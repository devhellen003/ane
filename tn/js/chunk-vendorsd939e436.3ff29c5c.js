(window["webpackJsonp"] = window["webpackJsonp"] || []).push([
    ["chunk-vendors~d939e436"], {
        "00dc": function(t, e, r) {
            (function(t) {
                var n = r("58a2a"),
                    i = r("c24d"),
                    s = r("561d");

                function a(e) {
                    var r = new t(i[e].prime, "hex"),
                        n = new t(i[e].gen, "hex");
                    return new s(r, n)
                }
                var o = {
                    binary: !0,
                    hex: !0,
                    base64: !0
                };

                function u(e, r, i, a) {
                    return t.isBuffer(r) || void 0 === o[r] ? u(e, "binary", r, i) : (r = r || "binary", a = a || "binary", i = i || new t([2]), t.isBuffer(i) || (i = new t(i, a)), "number" === typeof e ? new s(n(e, i), i, !0) : (t.isBuffer(e) || (e = new t(e, r)), new s(e, i, !0)))
                }
                e.DiffieHellmanGroup = e.createDiffieHellmanGroup = e.getDiffieHellman = a, e.createDiffieHellman = e.DiffieHellman = u
            }).call(this, r("b639").Buffer)
        },
        "0184": function(t, e, r) {
            "use strict";
            var n = r("da3e");

            function i(t) {
                this.options = t, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0
            }
            t.exports = i, i.prototype._init = function() {}, i.prototype.update = function(t) {
                return 0 === t.length ? [] : "decrypt" === this.type ? this._updateDecrypt(t) : this._updateEncrypt(t)
            }, i.prototype._buffer = function(t, e) {
                for (var r = Math.min(this.buffer.length - this.bufferOff, t.length - e), n = 0; n < r; n++) this.buffer[this.bufferOff + n] = t[e + n];
                return this.bufferOff += r, r
            }, i.prototype._flushBuffer = function(t, e) {
                return this._update(this.buffer, 0, t, e), this.bufferOff = 0, this.blockSize
            }, i.prototype._updateEncrypt = function(t) {
                var e = 0,
                    r = 0,
                    n = (this.bufferOff + t.length) / this.blockSize | 0,
                    i = new Array(n * this.blockSize);
                0 !== this.bufferOff && (e += this._buffer(t, e), this.bufferOff === this.buffer.length && (r += this._flushBuffer(i, r)));
                for (var s = t.length - (t.length - e) % this.blockSize; e < s; e += this.blockSize) this._update(t, e, i, r), r += this.blockSize;
                for (; e < t.length; e++, this.bufferOff++) this.buffer[this.bufferOff] = t[e];
                return i
            }, i.prototype._updateDecrypt = function(t) {
                for (var e = 0, r = 0, n = Math.ceil((this.bufferOff + t.length) / this.blockSize) - 1, i = new Array(n * this.blockSize); n > 0; n--) e += this._buffer(t, e), r += this._flushBuffer(i, r);
                return e += this._buffer(t, e), i
            }, i.prototype.final = function(t) {
                var e, r;
                return t && (e = this.update(t)), r = "encrypt" === this.type ? this._finalEncrypt() : this._finalDecrypt(), e ? e.concat(r) : r
            }, i.prototype._pad = function(t, e) {
                if (0 === e) return !1;
                while (e < t.length) t[e++] = 0;
                return !0
            }, i.prototype._finalEncrypt = function() {
                if (!this._pad(this.buffer, this.bufferOff)) return [];
                var t = new Array(this.blockSize);
                return this._update(this.buffer, 0, t, 0), t
            }, i.prototype._unpad = function(t) {
                return t
            }, i.prototype._finalDecrypt = function() {
                n.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
                var t = new Array(this.blockSize);
                return this._flushBuffer(t, 0), this._unpad(t)
            }
        },
        "030a": function(t, e, r) {
            (function(t) {
                (function(t, e) {
                    "use strict";

                    function n(t, e) {
                        if (!t) throw new Error(e || "Assertion failed")
                    }

                    function i(t, e) {
                        t.super_ = e;
                        var r = function() {};
                        r.prototype = e.prototype, t.prototype = new r, t.prototype.constructor = t
                    }

                    function s(t, e, r) {
                        if (s.isBN(t)) return t;
                        this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== t && ("le" !== e && "be" !== e || (r = e, e = 10), this._init(t || 0, e || 10, r || "be"))
                    }
                    var a;
                    "object" === typeof t ? t.exports = s : e.BN = s, s.BN = s, s.wordSize = 26;
                    try {
                        a = "undefined" !== typeof window && "undefined" !== typeof window.Buffer ? window.Buffer : r(14).Buffer
                    } catch (k) {}

                    function o(t, e) {
                        var r = t.charCodeAt(e);
                        return r >= 65 && r <= 70 ? r - 55 : r >= 97 && r <= 102 ? r - 87 : r - 48 & 15
                    }

                    function u(t, e, r) {
                        var n = o(t, r);
                        return r - 1 >= e && (n |= o(t, r - 1) << 4), n
                    }

                    function h(t, e, r, n) {
                        for (var i = 0, s = Math.min(t.length, r), a = e; a < s; a++) {
                            var o = t.charCodeAt(a) - 48;
                            i *= n, i += o >= 49 ? o - 49 + 10 : o >= 17 ? o - 17 + 10 : o
                        }
                        return i
                    }
                    s.isBN = function(t) {
                        return t instanceof s || null !== t && "object" === typeof t && t.constructor.wordSize === s.wordSize && Array.isArray(t.words)
                    }, s.max = function(t, e) {
                        return t.cmp(e) > 0 ? t : e
                    }, s.min = function(t, e) {
                        return t.cmp(e) < 0 ? t : e
                    }, s.prototype._init = function(t, e, r) {
                        if ("number" === typeof t) return this._initNumber(t, e, r);
                        if ("object" === typeof t) return this._initArray(t, e, r);
                        "hex" === e && (e = 16), n(e === (0 | e) && e >= 2 && e <= 36), t = t.toString().replace(/\s+/g, "");
                        var i = 0;
                        "-" === t[0] && (i++, this.negative = 1), i < t.length && (16 === e ? this._parseHex(t, i, r) : (this._parseBase(t, e, i), "le" === r && this._initArray(this.toArray(), e, r)))
                    }, s.prototype._initNumber = function(t, e, r) {
                        t < 0 && (this.negative = 1, t = -t), t < 67108864 ? (this.words = [67108863 & t], this.length = 1) : t < 4503599627370496 ? (this.words = [67108863 & t, t / 67108864 & 67108863], this.length = 2) : (n(t < 9007199254740992), this.words = [67108863 & t, t / 67108864 & 67108863, 1], this.length = 3), "le" === r && this._initArray(this.toArray(), e, r)
                    }, s.prototype._initArray = function(t, e, r) {
                        if (n("number" === typeof t.length), t.length <= 0) return this.words = [0], this.length = 1, this;
                        this.length = Math.ceil(t.length / 3), this.words = new Array(this.length);
                        for (var i = 0; i < this.length; i++) this.words[i] = 0;
                        var s, a, o = 0;
                        if ("be" === r)
                            for (i = t.length - 1, s = 0; i >= 0; i -= 3) a = t[i] | t[i - 1] << 8 | t[i - 2] << 16, this.words[s] |= a << o & 67108863, this.words[s + 1] = a >>> 26 - o & 67108863, o += 24, o >= 26 && (o -= 26, s++);
                        else if ("le" === r)
                            for (i = 0, s = 0; i < t.length; i += 3) a = t[i] | t[i + 1] << 8 | t[i + 2] << 16, this.words[s] |= a << o & 67108863, this.words[s + 1] = a >>> 26 - o & 67108863, o += 24, o >= 26 && (o -= 26, s++);
                        return this.strip()
                    }, s.prototype._parseHex = function(t, e, r) {
                        this.length = Math.ceil((t.length - e) / 6), this.words = new Array(this.length);
                        for (var n = 0; n < this.length; n++) this.words[n] = 0;
                        var i, s = 0,
                            a = 0;
                        if ("be" === r)
                            for (n = t.length - 1; n >= e; n -= 2) i = u(t, e, n) << s, this.words[a] |= 67108863 & i, s >= 18 ? (s -= 18, a += 1, this.words[a] |= i >>> 26) : s += 8;
                        else {
                            var o = t.length - e;
                            for (n = o % 2 === 0 ? e + 1 : e; n < t.length; n += 2) i = u(t, e, n) << s, this.words[a] |= 67108863 & i, s >= 18 ? (s -= 18, a += 1, this.words[a] |= i >>> 26) : s += 8
                        }
                        this.strip()
                    }, s.prototype._parseBase = function(t, e, r) {
                        this.words = [0], this.length = 1;
                        for (var n = 0, i = 1; i <= 67108863; i *= e) n++;
                        n--, i = i / e | 0;
                        for (var s = t.length - r, a = s % n, o = Math.min(s, s - a) + r, u = 0, f = r; f < o; f += n) u = h(t, f, f + n, e), this.imuln(i), this.words[0] + u < 67108864 ? this.words[0] += u : this._iaddn(u);
                        if (0 !== a) {
                            var c = 1;
                            for (u = h(t, f, t.length, e), f = 0; f < a; f++) c *= e;
                            this.imuln(c), this.words[0] + u < 67108864 ? this.words[0] += u : this._iaddn(u)
                        }
                        this.strip()
                    }, s.prototype.copy = function(t) {
                        t.words = new Array(this.length);
                        for (var e = 0; e < this.length; e++) t.words[e] = this.words[e];
                        t.length = this.length, t.negative = this.negative, t.red = this.red
                    }, s.prototype.clone = function() {
                        var t = new s(null);
                        return this.copy(t), t
                    }, s.prototype._expand = function(t) {
                        while (this.length < t) this.words[this.length++] = 0;
                        return this
                    }, s.prototype.strip = function() {
                        while (this.length > 1 && 0 === this.words[this.length - 1]) this.length--;
                        return this._normSign()
                    }, s.prototype._normSign = function() {
                        return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this
                    }, s.prototype.inspect = function() {
                        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
                    };
                    var f = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
                        c = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
                        l = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];

                    function d(t) {
                        for (var e = new Array(t.bitLength()), r = 0; r < e.length; r++) {
                            var n = r / 26 | 0,
                                i = r % 26;
                            e[r] = (t.words[n] & 1 << i) >>> i
                        }
                        return e
                    }

                    function p(t, e, r) {
                        r.negative = e.negative ^ t.negative;
                        var n = t.length + e.length | 0;
                        r.length = n, n = n - 1 | 0;
                        var i = 0 | t.words[0],
                            s = 0 | e.words[0],
                            a = i * s,
                            o = 67108863 & a,
                            u = a / 67108864 | 0;
                        r.words[0] = o;
                        for (var h = 1; h < n; h++) {
                            for (var f = u >>> 26, c = 67108863 & u, l = Math.min(h, e.length - 1), d = Math.max(0, h - t.length + 1); d <= l; d++) {
                                var p = h - d | 0;
                                i = 0 | t.words[p], s = 0 | e.words[d], a = i * s + c, f += a / 67108864 | 0, c = 67108863 & a
                            }
                            r.words[h] = 0 | c, u = 0 | f
                        }
                        return 0 !== u ? r.words[h] = 0 | u : r.length--, r.strip()
                    }
                    s.prototype.toString = function(t, e) {
                        var r;
                        if (t = t || 10, e = 0 | e || 1, 16 === t || "hex" === t) {
                            r = "";
                            for (var i = 0, s = 0, a = 0; a < this.length; a++) {
                                var o = this.words[a],
                                    u = (16777215 & (o << i | s)).toString(16);
                                s = o >>> 24 - i & 16777215, r = 0 !== s || a !== this.length - 1 ? f[6 - u.length] + u + r : u + r, i += 2, i >= 26 && (i -= 26, a--)
                            }
                            0 !== s && (r = s.toString(16) + r);
                            while (r.length % e !== 0) r = "0" + r;
                            return 0 !== this.negative && (r = "-" + r), r
                        }
                        if (t === (0 | t) && t >= 2 && t <= 36) {
                            var h = c[t],
                                d = l[t];
                            r = "";
                            var p = this.clone();
                            p.negative = 0;
                            while (!p.isZero()) {
                                var m = p.modn(d).toString(t);
                                p = p.idivn(d), r = p.isZero() ? m + r : f[h - m.length] + m + r
                            }
                            this.isZero() && (r = "0" + r);
                            while (r.length % e !== 0) r = "0" + r;
                            return 0 !== this.negative && (r = "-" + r), r
                        }
                        n(!1, "Base should be between 2 and 36")
                    }, s.prototype.toNumber = function() {
                        var t = this.words[0];
                        return 2 === this.length ? t += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? t += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), 0 !== this.negative ? -t : t
                    }, s.prototype.toJSON = function() {
                        return this.toString(16)
                    }, s.prototype.toBuffer = function(t, e) {
                        return n("undefined" !== typeof a), this.toArrayLike(a, t, e)
                    }, s.prototype.toArray = function(t, e) {
                        return this.toArrayLike(Array, t, e)
                    }, s.prototype.toArrayLike = function(t, e, r) {
                        var i = this.byteLength(),
                            s = r || Math.max(1, i);
                        n(i <= s, "byte array longer than desired length"), n(s > 0, "Requested array length <= 0"), this.strip();
                        var a, o, u = "le" === e,
                            h = new t(s),
                            f = this.clone();
                        if (u) {
                            for (o = 0; !f.isZero(); o++) a = f.andln(255), f.iushrn(8), h[o] = a;
                            for (; o < s; o++) h[o] = 0
                        } else {
                            for (o = 0; o < s - i; o++) h[o] = 0;
                            for (o = 0; !f.isZero(); o++) a = f.andln(255), f.iushrn(8), h[s - o - 1] = a
                        }
                        return h
                    }, Math.clz32 ? s.prototype._countBits = function(t) {
                        return 32 - Math.clz32(t)
                    } : s.prototype._countBits = function(t) {
                        var e = t,
                            r = 0;
                        return e >= 4096 && (r += 13, e >>>= 13), e >= 64 && (r += 7, e >>>= 7), e >= 8 && (r += 4, e >>>= 4), e >= 2 && (r += 2, e >>>= 2), r + e
                    }, s.prototype._zeroBits = function(t) {
                        if (0 === t) return 26;
                        var e = t,
                            r = 0;
                        return 0 === (8191 & e) && (r += 13, e >>>= 13), 0 === (127 & e) && (r += 7, e >>>= 7), 0 === (15 & e) && (r += 4, e >>>= 4), 0 === (3 & e) && (r += 2, e >>>= 2), 0 === (1 & e) && r++, r
                    }, s.prototype.bitLength = function() {
                        var t = this.words[this.length - 1],
                            e = this._countBits(t);
                        return 26 * (this.length - 1) + e
                    }, s.prototype.zeroBits = function() {
                        if (this.isZero()) return 0;
                        for (var t = 0, e = 0; e < this.length; e++) {
                            var r = this._zeroBits(this.words[e]);
                            if (t += r, 26 !== r) break
                        }
                        return t
                    }, s.prototype.byteLength = function() {
                        return Math.ceil(this.bitLength() / 8)
                    }, s.prototype.toTwos = function(t) {
                        return 0 !== this.negative ? this.abs().inotn(t).iaddn(1) : this.clone()
                    }, s.prototype.fromTwos = function(t) {
                        return this.testn(t - 1) ? this.notn(t).iaddn(1).ineg() : this.clone()
                    }, s.prototype.isNeg = function() {
                        return 0 !== this.negative
                    }, s.prototype.neg = function() {
                        return this.clone().ineg()
                    }, s.prototype.ineg = function() {
                        return this.isZero() || (this.negative ^= 1), this
                    }, s.prototype.iuor = function(t) {
                        while (this.length < t.length) this.words[this.length++] = 0;
                        for (var e = 0; e < t.length; e++) this.words[e] = this.words[e] | t.words[e];
                        return this.strip()
                    }, s.prototype.ior = function(t) {
                        return n(0 === (this.negative | t.negative)), this.iuor(t)
                    }, s.prototype.or = function(t) {
                        return this.length > t.length ? this.clone().ior(t) : t.clone().ior(this)
                    }, s.prototype.uor = function(t) {
                        return this.length > t.length ? this.clone().iuor(t) : t.clone().iuor(this)
                    }, s.prototype.iuand = function(t) {
                        var e;
                        e = this.length > t.length ? t : this;
                        for (var r = 0; r < e.length; r++) this.words[r] = this.words[r] & t.words[r];
                        return this.length = e.length, this.strip()
                    }, s.prototype.iand = function(t) {
                        return n(0 === (this.negative | t.negative)), this.iuand(t)
                    }, s.prototype.and = function(t) {
                        return this.length > t.length ? this.clone().iand(t) : t.clone().iand(this)
                    }, s.prototype.uand = function(t) {
                        return this.length > t.length ? this.clone().iuand(t) : t.clone().iuand(this)
                    }, s.prototype.iuxor = function(t) {
                        var e, r;
                        this.length > t.length ? (e = this, r = t) : (e = t, r = this);
                        for (var n = 0; n < r.length; n++) this.words[n] = e.words[n] ^ r.words[n];
                        if (this !== e)
                            for (; n < e.length; n++) this.words[n] = e.words[n];
                        return this.length = e.length, this.strip()
                    }, s.prototype.ixor = function(t) {
                        return n(0 === (this.negative | t.negative)), this.iuxor(t)
                    }, s.prototype.xor = function(t) {
                        return this.length > t.length ? this.clone().ixor(t) : t.clone().ixor(this)
                    }, s.prototype.uxor = function(t) {
                        return this.length > t.length ? this.clone().iuxor(t) : t.clone().iuxor(this)
                    }, s.prototype.inotn = function(t) {
                        n("number" === typeof t && t >= 0);
                        var e = 0 | Math.ceil(t / 26),
                            r = t % 26;
                        this._expand(e), r > 0 && e--;
                        for (var i = 0; i < e; i++) this.words[i] = 67108863 & ~this.words[i];
                        return r > 0 && (this.words[i] = ~this.words[i] & 67108863 >> 26 - r), this.strip()
                    }, s.prototype.notn = function(t) {
                        return this.clone().inotn(t)
                    }, s.prototype.setn = function(t, e) {
                        n("number" === typeof t && t >= 0);
                        var r = t / 26 | 0,
                            i = t % 26;
                        return this._expand(r + 1), this.words[r] = e ? this.words[r] | 1 << i : this.words[r] & ~(1 << i), this.strip()
                    }, s.prototype.iadd = function(t) {
                        var e, r, n;
                        if (0 !== this.negative && 0 === t.negative) return this.negative = 0, e = this.isub(t), this.negative ^= 1, this._normSign();
                        if (0 === this.negative && 0 !== t.negative) return t.negative = 0, e = this.isub(t), t.negative = 1, e._normSign();
                        this.length > t.length ? (r = this, n = t) : (r = t, n = this);
                        for (var i = 0, s = 0; s < n.length; s++) e = (0 | r.words[s]) + (0 | n.words[s]) + i, this.words[s] = 67108863 & e, i = e >>> 26;
                        for (; 0 !== i && s < r.length; s++) e = (0 | r.words[s]) + i, this.words[s] = 67108863 & e, i = e >>> 26;
                        if (this.length = r.length, 0 !== i) this.words[this.length] = i, this.length++;
                        else if (r !== this)
                            for (; s < r.length; s++) this.words[s] = r.words[s];
                        return this
                    }, s.prototype.add = function(t) {
                        var e;
                        return 0 !== t.negative && 0 === this.negative ? (t.negative = 0, e = this.sub(t), t.negative ^= 1, e) : 0 === t.negative && 0 !== this.negative ? (this.negative = 0, e = t.sub(this), this.negative = 1, e) : this.length > t.length ? this.clone().iadd(t) : t.clone().iadd(this)
                    }, s.prototype.isub = function(t) {
                        if (0 !== t.negative) {
                            t.negative = 0;
                            var e = this.iadd(t);
                            return t.negative = 1, e._normSign()
                        }
                        if (0 !== this.negative) return this.negative = 0, this.iadd(t), this.negative = 1, this._normSign();
                        var r, n, i = this.cmp(t);
                        if (0 === i) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
                        i > 0 ? (r = this, n = t) : (r = t, n = this);
                        for (var s = 0, a = 0; a < n.length; a++) e = (0 | r.words[a]) - (0 | n.words[a]) + s, s = e >> 26, this.words[a] = 67108863 & e;
                        for (; 0 !== s && a < r.length; a++) e = (0 | r.words[a]) + s, s = e >> 26, this.words[a] = 67108863 & e;
                        if (0 === s && a < r.length && r !== this)
                            for (; a < r.length; a++) this.words[a] = r.words[a];
                        return this.length = Math.max(this.length, a), r !== this && (this.negative = 1), this.strip()
                    }, s.prototype.sub = function(t) {
                        return this.clone().isub(t)
                    };
                    var m = function(t, e, r) {
                        var n, i, s, a = t.words,
                            o = e.words,
                            u = r.words,
                            h = 0,
                            f = 0 | a[0],
                            c = 8191 & f,
                            l = f >>> 13,
                            d = 0 | a[1],
                            p = 8191 & d,
                            m = d >>> 13,
                            b = 0 | a[2],
                            g = 8191 & b,
                            y = b >>> 13,
                            v = 0 | a[3],
                            w = 8191 & v,
                            _ = v >>> 13,
                            M = 0 | a[4],
                            A = 8191 & M,
                            S = M >>> 13,
                            x = 0 | a[5],
                            E = 8191 & x,
                            k = x >>> 13,
                            R = 0 | a[6],
                            O = 8191 & R,
                            I = R >>> 13,
                            P = 0 | a[7],
                            T = 8191 & P,
                            N = P >>> 13,
                            j = 0 | a[8],
                            C = 8191 & j,
                            z = j >>> 13,
                            D = 0 | a[9],
                            L = 8191 & D,
                            F = D >>> 13,
                            B = 0 | o[0],
                            $ = 8191 & B,
                            U = B >>> 13,
                            q = 0 | o[1],
                            K = 8191 & q,
                            V = q >>> 13,
                            W = 0 | o[2],
                            Z = 8191 & W,
                            H = W >>> 13,
                            G = 0 | o[3],
                            J = 8191 & G,
                            X = G >>> 13,
                            Y = 0 | o[4],
                            Q = 8191 & Y,
                            tt = Y >>> 13,
                            et = 0 | o[5],
                            rt = 8191 & et,
                            nt = et >>> 13,
                            it = 0 | o[6],
                            st = 8191 & it,
                            at = it >>> 13,
                            ot = 0 | o[7],
                            ut = 8191 & ot,
                            ht = ot >>> 13,
                            ft = 0 | o[8],
                            ct = 8191 & ft,
                            lt = ft >>> 13,
                            dt = 0 | o[9],
                            pt = 8191 & dt,
                            mt = dt >>> 13;
                        r.negative = t.negative ^ e.negative, r.length = 19, n = Math.imul(c, $), i = Math.imul(c, U), i = i + Math.imul(l, $) | 0, s = Math.imul(l, U);
                        var bt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, n = Math.imul(p, $), i = Math.imul(p, U), i = i + Math.imul(m, $) | 0, s = Math.imul(m, U), n = n + Math.imul(c, K) | 0, i = i + Math.imul(c, V) | 0, i = i + Math.imul(l, K) | 0, s = s + Math.imul(l, V) | 0;
                        var gt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (gt >>> 26) | 0, gt &= 67108863, n = Math.imul(g, $), i = Math.imul(g, U), i = i + Math.imul(y, $) | 0, s = Math.imul(y, U), n = n + Math.imul(p, K) | 0, i = i + Math.imul(p, V) | 0, i = i + Math.imul(m, K) | 0, s = s + Math.imul(m, V) | 0, n = n + Math.imul(c, Z) | 0, i = i + Math.imul(c, H) | 0, i = i + Math.imul(l, Z) | 0, s = s + Math.imul(l, H) | 0;
                        var yt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, n = Math.imul(w, $), i = Math.imul(w, U), i = i + Math.imul(_, $) | 0, s = Math.imul(_, U), n = n + Math.imul(g, K) | 0, i = i + Math.imul(g, V) | 0, i = i + Math.imul(y, K) | 0, s = s + Math.imul(y, V) | 0, n = n + Math.imul(p, Z) | 0, i = i + Math.imul(p, H) | 0, i = i + Math.imul(m, Z) | 0, s = s + Math.imul(m, H) | 0, n = n + Math.imul(c, J) | 0, i = i + Math.imul(c, X) | 0, i = i + Math.imul(l, J) | 0, s = s + Math.imul(l, X) | 0;
                        var vt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, n = Math.imul(A, $), i = Math.imul(A, U), i = i + Math.imul(S, $) | 0, s = Math.imul(S, U), n = n + Math.imul(w, K) | 0, i = i + Math.imul(w, V) | 0, i = i + Math.imul(_, K) | 0, s = s + Math.imul(_, V) | 0, n = n + Math.imul(g, Z) | 0, i = i + Math.imul(g, H) | 0, i = i + Math.imul(y, Z) | 0, s = s + Math.imul(y, H) | 0, n = n + Math.imul(p, J) | 0, i = i + Math.imul(p, X) | 0, i = i + Math.imul(m, J) | 0, s = s + Math.imul(m, X) | 0, n = n + Math.imul(c, Q) | 0, i = i + Math.imul(c, tt) | 0, i = i + Math.imul(l, Q) | 0, s = s + Math.imul(l, tt) | 0;
                        var wt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, n = Math.imul(E, $), i = Math.imul(E, U), i = i + Math.imul(k, $) | 0, s = Math.imul(k, U), n = n + Math.imul(A, K) | 0, i = i + Math.imul(A, V) | 0, i = i + Math.imul(S, K) | 0, s = s + Math.imul(S, V) | 0, n = n + Math.imul(w, Z) | 0, i = i + Math.imul(w, H) | 0, i = i + Math.imul(_, Z) | 0, s = s + Math.imul(_, H) | 0, n = n + Math.imul(g, J) | 0, i = i + Math.imul(g, X) | 0, i = i + Math.imul(y, J) | 0, s = s + Math.imul(y, X) | 0, n = n + Math.imul(p, Q) | 0, i = i + Math.imul(p, tt) | 0, i = i + Math.imul(m, Q) | 0, s = s + Math.imul(m, tt) | 0, n = n + Math.imul(c, rt) | 0, i = i + Math.imul(c, nt) | 0, i = i + Math.imul(l, rt) | 0, s = s + Math.imul(l, nt) | 0;
                        var _t = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, n = Math.imul(O, $), i = Math.imul(O, U), i = i + Math.imul(I, $) | 0, s = Math.imul(I, U), n = n + Math.imul(E, K) | 0, i = i + Math.imul(E, V) | 0, i = i + Math.imul(k, K) | 0, s = s + Math.imul(k, V) | 0, n = n + Math.imul(A, Z) | 0, i = i + Math.imul(A, H) | 0, i = i + Math.imul(S, Z) | 0, s = s + Math.imul(S, H) | 0, n = n + Math.imul(w, J) | 0, i = i + Math.imul(w, X) | 0, i = i + Math.imul(_, J) | 0, s = s + Math.imul(_, X) | 0, n = n + Math.imul(g, Q) | 0, i = i + Math.imul(g, tt) | 0, i = i + Math.imul(y, Q) | 0, s = s + Math.imul(y, tt) | 0, n = n + Math.imul(p, rt) | 0, i = i + Math.imul(p, nt) | 0, i = i + Math.imul(m, rt) | 0, s = s + Math.imul(m, nt) | 0, n = n + Math.imul(c, st) | 0, i = i + Math.imul(c, at) | 0, i = i + Math.imul(l, st) | 0, s = s + Math.imul(l, at) | 0;
                        var Mt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, n = Math.imul(T, $), i = Math.imul(T, U), i = i + Math.imul(N, $) | 0, s = Math.imul(N, U), n = n + Math.imul(O, K) | 0, i = i + Math.imul(O, V) | 0, i = i + Math.imul(I, K) | 0, s = s + Math.imul(I, V) | 0, n = n + Math.imul(E, Z) | 0, i = i + Math.imul(E, H) | 0, i = i + Math.imul(k, Z) | 0, s = s + Math.imul(k, H) | 0, n = n + Math.imul(A, J) | 0, i = i + Math.imul(A, X) | 0, i = i + Math.imul(S, J) | 0, s = s + Math.imul(S, X) | 0, n = n + Math.imul(w, Q) | 0, i = i + Math.imul(w, tt) | 0, i = i + Math.imul(_, Q) | 0, s = s + Math.imul(_, tt) | 0, n = n + Math.imul(g, rt) | 0, i = i + Math.imul(g, nt) | 0, i = i + Math.imul(y, rt) | 0, s = s + Math.imul(y, nt) | 0, n = n + Math.imul(p, st) | 0, i = i + Math.imul(p, at) | 0, i = i + Math.imul(m, st) | 0, s = s + Math.imul(m, at) | 0, n = n + Math.imul(c, ut) | 0, i = i + Math.imul(c, ht) | 0, i = i + Math.imul(l, ut) | 0, s = s + Math.imul(l, ht) | 0;
                        var At = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, n = Math.imul(C, $), i = Math.imul(C, U), i = i + Math.imul(z, $) | 0, s = Math.imul(z, U), n = n + Math.imul(T, K) | 0, i = i + Math.imul(T, V) | 0, i = i + Math.imul(N, K) | 0, s = s + Math.imul(N, V) | 0, n = n + Math.imul(O, Z) | 0, i = i + Math.imul(O, H) | 0, i = i + Math.imul(I, Z) | 0, s = s + Math.imul(I, H) | 0, n = n + Math.imul(E, J) | 0, i = i + Math.imul(E, X) | 0, i = i + Math.imul(k, J) | 0, s = s + Math.imul(k, X) | 0, n = n + Math.imul(A, Q) | 0, i = i + Math.imul(A, tt) | 0, i = i + Math.imul(S, Q) | 0, s = s + Math.imul(S, tt) | 0, n = n + Math.imul(w, rt) | 0, i = i + Math.imul(w, nt) | 0, i = i + Math.imul(_, rt) | 0, s = s + Math.imul(_, nt) | 0, n = n + Math.imul(g, st) | 0, i = i + Math.imul(g, at) | 0, i = i + Math.imul(y, st) | 0, s = s + Math.imul(y, at) | 0, n = n + Math.imul(p, ut) | 0, i = i + Math.imul(p, ht) | 0, i = i + Math.imul(m, ut) | 0, s = s + Math.imul(m, ht) | 0, n = n + Math.imul(c, ct) | 0, i = i + Math.imul(c, lt) | 0, i = i + Math.imul(l, ct) | 0, s = s + Math.imul(l, lt) | 0;
                        var St = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, n = Math.imul(L, $), i = Math.imul(L, U), i = i + Math.imul(F, $) | 0, s = Math.imul(F, U), n = n + Math.imul(C, K) | 0, i = i + Math.imul(C, V) | 0, i = i + Math.imul(z, K) | 0, s = s + Math.imul(z, V) | 0, n = n + Math.imul(T, Z) | 0, i = i + Math.imul(T, H) | 0, i = i + Math.imul(N, Z) | 0, s = s + Math.imul(N, H) | 0, n = n + Math.imul(O, J) | 0, i = i + Math.imul(O, X) | 0, i = i + Math.imul(I, J) | 0, s = s + Math.imul(I, X) | 0, n = n + Math.imul(E, Q) | 0, i = i + Math.imul(E, tt) | 0, i = i + Math.imul(k, Q) | 0, s = s + Math.imul(k, tt) | 0, n = n + Math.imul(A, rt) | 0, i = i + Math.imul(A, nt) | 0, i = i + Math.imul(S, rt) | 0, s = s + Math.imul(S, nt) | 0, n = n + Math.imul(w, st) | 0, i = i + Math.imul(w, at) | 0, i = i + Math.imul(_, st) | 0, s = s + Math.imul(_, at) | 0, n = n + Math.imul(g, ut) | 0, i = i + Math.imul(g, ht) | 0, i = i + Math.imul(y, ut) | 0, s = s + Math.imul(y, ht) | 0, n = n + Math.imul(p, ct) | 0, i = i + Math.imul(p, lt) | 0, i = i + Math.imul(m, ct) | 0, s = s + Math.imul(m, lt) | 0, n = n + Math.imul(c, pt) | 0, i = i + Math.imul(c, mt) | 0, i = i + Math.imul(l, pt) | 0, s = s + Math.imul(l, mt) | 0;
                        var xt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, n = Math.imul(L, K), i = Math.imul(L, V), i = i + Math.imul(F, K) | 0, s = Math.imul(F, V), n = n + Math.imul(C, Z) | 0, i = i + Math.imul(C, H) | 0, i = i + Math.imul(z, Z) | 0, s = s + Math.imul(z, H) | 0, n = n + Math.imul(T, J) | 0, i = i + Math.imul(T, X) | 0, i = i + Math.imul(N, J) | 0, s = s + Math.imul(N, X) | 0, n = n + Math.imul(O, Q) | 0, i = i + Math.imul(O, tt) | 0, i = i + Math.imul(I, Q) | 0, s = s + Math.imul(I, tt) | 0, n = n + Math.imul(E, rt) | 0, i = i + Math.imul(E, nt) | 0, i = i + Math.imul(k, rt) | 0, s = s + Math.imul(k, nt) | 0, n = n + Math.imul(A, st) | 0, i = i + Math.imul(A, at) | 0, i = i + Math.imul(S, st) | 0, s = s + Math.imul(S, at) | 0, n = n + Math.imul(w, ut) | 0, i = i + Math.imul(w, ht) | 0, i = i + Math.imul(_, ut) | 0, s = s + Math.imul(_, ht) | 0, n = n + Math.imul(g, ct) | 0, i = i + Math.imul(g, lt) | 0, i = i + Math.imul(y, ct) | 0, s = s + Math.imul(y, lt) | 0, n = n + Math.imul(p, pt) | 0, i = i + Math.imul(p, mt) | 0, i = i + Math.imul(m, pt) | 0, s = s + Math.imul(m, mt) | 0;
                        var Et = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, n = Math.imul(L, Z), i = Math.imul(L, H), i = i + Math.imul(F, Z) | 0, s = Math.imul(F, H), n = n + Math.imul(C, J) | 0, i = i + Math.imul(C, X) | 0, i = i + Math.imul(z, J) | 0, s = s + Math.imul(z, X) | 0, n = n + Math.imul(T, Q) | 0, i = i + Math.imul(T, tt) | 0, i = i + Math.imul(N, Q) | 0, s = s + Math.imul(N, tt) | 0, n = n + Math.imul(O, rt) | 0, i = i + Math.imul(O, nt) | 0, i = i + Math.imul(I, rt) | 0, s = s + Math.imul(I, nt) | 0, n = n + Math.imul(E, st) | 0, i = i + Math.imul(E, at) | 0, i = i + Math.imul(k, st) | 0, s = s + Math.imul(k, at) | 0, n = n + Math.imul(A, ut) | 0, i = i + Math.imul(A, ht) | 0, i = i + Math.imul(S, ut) | 0, s = s + Math.imul(S, ht) | 0, n = n + Math.imul(w, ct) | 0, i = i + Math.imul(w, lt) | 0, i = i + Math.imul(_, ct) | 0, s = s + Math.imul(_, lt) | 0, n = n + Math.imul(g, pt) | 0, i = i + Math.imul(g, mt) | 0, i = i + Math.imul(y, pt) | 0, s = s + Math.imul(y, mt) | 0;
                        var kt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, n = Math.imul(L, J), i = Math.imul(L, X), i = i + Math.imul(F, J) | 0, s = Math.imul(F, X), n = n + Math.imul(C, Q) | 0, i = i + Math.imul(C, tt) | 0, i = i + Math.imul(z, Q) | 0, s = s + Math.imul(z, tt) | 0, n = n + Math.imul(T, rt) | 0, i = i + Math.imul(T, nt) | 0, i = i + Math.imul(N, rt) | 0, s = s + Math.imul(N, nt) | 0, n = n + Math.imul(O, st) | 0, i = i + Math.imul(O, at) | 0, i = i + Math.imul(I, st) | 0, s = s + Math.imul(I, at) | 0, n = n + Math.imul(E, ut) | 0, i = i + Math.imul(E, ht) | 0, i = i + Math.imul(k, ut) | 0, s = s + Math.imul(k, ht) | 0, n = n + Math.imul(A, ct) | 0, i = i + Math.imul(A, lt) | 0, i = i + Math.imul(S, ct) | 0, s = s + Math.imul(S, lt) | 0, n = n + Math.imul(w, pt) | 0, i = i + Math.imul(w, mt) | 0, i = i + Math.imul(_, pt) | 0, s = s + Math.imul(_, mt) | 0;
                        var Rt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, n = Math.imul(L, Q), i = Math.imul(L, tt), i = i + Math.imul(F, Q) | 0, s = Math.imul(F, tt), n = n + Math.imul(C, rt) | 0, i = i + Math.imul(C, nt) | 0, i = i + Math.imul(z, rt) | 0, s = s + Math.imul(z, nt) | 0, n = n + Math.imul(T, st) | 0, i = i + Math.imul(T, at) | 0, i = i + Math.imul(N, st) | 0, s = s + Math.imul(N, at) | 0, n = n + Math.imul(O, ut) | 0, i = i + Math.imul(O, ht) | 0, i = i + Math.imul(I, ut) | 0, s = s + Math.imul(I, ht) | 0, n = n + Math.imul(E, ct) | 0, i = i + Math.imul(E, lt) | 0, i = i + Math.imul(k, ct) | 0, s = s + Math.imul(k, lt) | 0, n = n + Math.imul(A, pt) | 0, i = i + Math.imul(A, mt) | 0, i = i + Math.imul(S, pt) | 0, s = s + Math.imul(S, mt) | 0;
                        var Ot = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, n = Math.imul(L, rt), i = Math.imul(L, nt), i = i + Math.imul(F, rt) | 0, s = Math.imul(F, nt), n = n + Math.imul(C, st) | 0, i = i + Math.imul(C, at) | 0, i = i + Math.imul(z, st) | 0, s = s + Math.imul(z, at) | 0, n = n + Math.imul(T, ut) | 0, i = i + Math.imul(T, ht) | 0, i = i + Math.imul(N, ut) | 0, s = s + Math.imul(N, ht) | 0, n = n + Math.imul(O, ct) | 0, i = i + Math.imul(O, lt) | 0, i = i + Math.imul(I, ct) | 0, s = s + Math.imul(I, lt) | 0, n = n + Math.imul(E, pt) | 0, i = i + Math.imul(E, mt) | 0, i = i + Math.imul(k, pt) | 0, s = s + Math.imul(k, mt) | 0;
                        var It = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, n = Math.imul(L, st), i = Math.imul(L, at), i = i + Math.imul(F, st) | 0, s = Math.imul(F, at), n = n + Math.imul(C, ut) | 0, i = i + Math.imul(C, ht) | 0, i = i + Math.imul(z, ut) | 0, s = s + Math.imul(z, ht) | 0, n = n + Math.imul(T, ct) | 0, i = i + Math.imul(T, lt) | 0, i = i + Math.imul(N, ct) | 0, s = s + Math.imul(N, lt) | 0, n = n + Math.imul(O, pt) | 0, i = i + Math.imul(O, mt) | 0, i = i + Math.imul(I, pt) | 0, s = s + Math.imul(I, mt) | 0;
                        var Pt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, n = Math.imul(L, ut), i = Math.imul(L, ht), i = i + Math.imul(F, ut) | 0, s = Math.imul(F, ht), n = n + Math.imul(C, ct) | 0, i = i + Math.imul(C, lt) | 0, i = i + Math.imul(z, ct) | 0, s = s + Math.imul(z, lt) | 0, n = n + Math.imul(T, pt) | 0, i = i + Math.imul(T, mt) | 0, i = i + Math.imul(N, pt) | 0, s = s + Math.imul(N, mt) | 0;
                        var Tt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, n = Math.imul(L, ct), i = Math.imul(L, lt), i = i + Math.imul(F, ct) | 0, s = Math.imul(F, lt), n = n + Math.imul(C, pt) | 0, i = i + Math.imul(C, mt) | 0, i = i + Math.imul(z, pt) | 0, s = s + Math.imul(z, mt) | 0;
                        var Nt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, n = Math.imul(L, pt), i = Math.imul(L, mt), i = i + Math.imul(F, pt) | 0, s = Math.imul(F, mt);
                        var jt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        return h = (s + (i >>> 13) | 0) + (jt >>> 26) | 0, jt &= 67108863, u[0] = bt, u[1] = gt, u[2] = yt, u[3] = vt, u[4] = wt, u[5] = _t, u[6] = Mt, u[7] = At, u[8] = St, u[9] = xt, u[10] = Et, u[11] = kt, u[12] = Rt, u[13] = Ot, u[14] = It, u[15] = Pt, u[16] = Tt, u[17] = Nt, u[18] = jt, 0 !== h && (u[19] = h, r.length++), r
                    };

                    function b(t, e, r) {
                        r.negative = e.negative ^ t.negative, r.length = t.length + e.length;
                        for (var n = 0, i = 0, s = 0; s < r.length - 1; s++) {
                            var a = i;
                            i = 0;
                            for (var o = 67108863 & n, u = Math.min(s, e.length - 1), h = Math.max(0, s - t.length + 1); h <= u; h++) {
                                var f = s - h,
                                    c = 0 | t.words[f],
                                    l = 0 | e.words[h],
                                    d = c * l,
                                    p = 67108863 & d;
                                a = a + (d / 67108864 | 0) | 0, p = p + o | 0, o = 67108863 & p, a = a + (p >>> 26) | 0, i += a >>> 26, a &= 67108863
                            }
                            r.words[s] = o, n = a, a = i
                        }
                        return 0 !== n ? r.words[s] = n : r.length--, r.strip()
                    }

                    function g(t, e, r) {
                        var n = new y;
                        return n.mulp(t, e, r)
                    }

                    function y(t, e) {
                        this.x = t, this.y = e
                    }
                    Math.imul || (m = p), s.prototype.mulTo = function(t, e) {
                        var r, n = this.length + t.length;
                        return r = 10 === this.length && 10 === t.length ? m(this, t, e) : n < 63 ? p(this, t, e) : n < 1024 ? b(this, t, e) : g(this, t, e), r
                    }, y.prototype.makeRBT = function(t) {
                        for (var e = new Array(t), r = s.prototype._countBits(t) - 1, n = 0; n < t; n++) e[n] = this.revBin(n, r, t);
                        return e
                    }, y.prototype.revBin = function(t, e, r) {
                        if (0 === t || t === r - 1) return t;
                        for (var n = 0, i = 0; i < e; i++) n |= (1 & t) << e - i - 1, t >>= 1;
                        return n
                    }, y.prototype.permute = function(t, e, r, n, i, s) {
                        for (var a = 0; a < s; a++) n[a] = e[t[a]], i[a] = r[t[a]]
                    }, y.prototype.transform = function(t, e, r, n, i, s) {
                        this.permute(s, t, e, r, n, i);
                        for (var a = 1; a < i; a <<= 1)
                            for (var o = a << 1, u = Math.cos(2 * Math.PI / o), h = Math.sin(2 * Math.PI / o), f = 0; f < i; f += o)
                                for (var c = u, l = h, d = 0; d < a; d++) {
                                    var p = r[f + d],
                                        m = n[f + d],
                                        b = r[f + d + a],
                                        g = n[f + d + a],
                                        y = c * b - l * g;
                                    g = c * g + l * b, b = y, r[f + d] = p + b, n[f + d] = m + g, r[f + d + a] = p - b, n[f + d + a] = m - g, d !== o && (y = u * c - h * l, l = u * l + h * c, c = y)
                                }
                    }, y.prototype.guessLen13b = function(t, e) {
                        var r = 1 | Math.max(e, t),
                            n = 1 & r,
                            i = 0;
                        for (r = r / 2 | 0; r; r >>>= 1) i++;
                        return 1 << i + 1 + n
                    }, y.prototype.conjugate = function(t, e, r) {
                        if (!(r <= 1))
                            for (var n = 0; n < r / 2; n++) {
                                var i = t[n];
                                t[n] = t[r - n - 1], t[r - n - 1] = i, i = e[n], e[n] = -e[r - n - 1], e[r - n - 1] = -i
                            }
                    }, y.prototype.normalize13b = function(t, e) {
                        for (var r = 0, n = 0; n < e / 2; n++) {
                            var i = 8192 * Math.round(t[2 * n + 1] / e) + Math.round(t[2 * n] / e) + r;
                            t[n] = 67108863 & i, r = i < 67108864 ? 0 : i / 67108864 | 0
                        }
                        return t
                    }, y.prototype.convert13b = function(t, e, r, i) {
                        for (var s = 0, a = 0; a < e; a++) s += 0 | t[a], r[2 * a] = 8191 & s, s >>>= 13, r[2 * a + 1] = 8191 & s, s >>>= 13;
                        for (a = 2 * e; a < i; ++a) r[a] = 0;
                        n(0 === s), n(0 === (-8192 & s))
                    }, y.prototype.stub = function(t) {
                        for (var e = new Array(t), r = 0; r < t; r++) e[r] = 0;
                        return e
                    }, y.prototype.mulp = function(t, e, r) {
                        var n = 2 * this.guessLen13b(t.length, e.length),
                            i = this.makeRBT(n),
                            s = this.stub(n),
                            a = new Array(n),
                            o = new Array(n),
                            u = new Array(n),
                            h = new Array(n),
                            f = new Array(n),
                            c = new Array(n),
                            l = r.words;
                        l.length = n, this.convert13b(t.words, t.length, a, n), this.convert13b(e.words, e.length, h, n), this.transform(a, s, o, u, n, i), this.transform(h, s, f, c, n, i);
                        for (var d = 0; d < n; d++) {
                            var p = o[d] * f[d] - u[d] * c[d];
                            u[d] = o[d] * c[d] + u[d] * f[d], o[d] = p
                        }
                        return this.conjugate(o, u, n), this.transform(o, u, l, s, n, i), this.conjugate(l, s, n), this.normalize13b(l, n), r.negative = t.negative ^ e.negative, r.length = t.length + e.length, r.strip()
                    }, s.prototype.mul = function(t) {
                        var e = new s(null);
                        return e.words = new Array(this.length + t.length), this.mulTo(t, e)
                    }, s.prototype.mulf = function(t) {
                        var e = new s(null);
                        return e.words = new Array(this.length + t.length), g(this, t, e)
                    }, s.prototype.imul = function(t) {
                        return this.clone().mulTo(t, this)
                    }, s.prototype.imuln = function(t) {
                        n("number" === typeof t), n(t < 67108864);
                        for (var e = 0, r = 0; r < this.length; r++) {
                            var i = (0 | this.words[r]) * t,
                                s = (67108863 & i) + (67108863 & e);
                            e >>= 26, e += i / 67108864 | 0, e += s >>> 26, this.words[r] = 67108863 & s
                        }
                        return 0 !== e && (this.words[r] = e, this.length++), this
                    }, s.prototype.muln = function(t) {
                        return this.clone().imuln(t)
                    }, s.prototype.sqr = function() {
                        return this.mul(this)
                    }, s.prototype.isqr = function() {
                        return this.imul(this.clone())
                    }, s.prototype.pow = function(t) {
                        var e = d(t);
                        if (0 === e.length) return new s(1);
                        for (var r = this, n = 0; n < e.length; n++, r = r.sqr())
                            if (0 !== e[n]) break;
                        if (++n < e.length)
                            for (var i = r.sqr(); n < e.length; n++, i = i.sqr()) 0 !== e[n] && (r = r.mul(i));
                        return r
                    }, s.prototype.iushln = function(t) {
                        n("number" === typeof t && t >= 0);
                        var e, r = t % 26,
                            i = (t - r) / 26,
                            s = 67108863 >>> 26 - r << 26 - r;
                        if (0 !== r) {
                            var a = 0;
                            for (e = 0; e < this.length; e++) {
                                var o = this.words[e] & s,
                                    u = (0 | this.words[e]) - o << r;
                                this.words[e] = u | a, a = o >>> 26 - r
                            }
                            a && (this.words[e] = a, this.length++)
                        }
                        if (0 !== i) {
                            for (e = this.length - 1; e >= 0; e--) this.words[e + i] = this.words[e];
                            for (e = 0; e < i; e++) this.words[e] = 0;
                            this.length += i
                        }
                        return this.strip()
                    }, s.prototype.ishln = function(t) {
                        return n(0 === this.negative), this.iushln(t)
                    }, s.prototype.iushrn = function(t, e, r) {
                        var i;
                        n("number" === typeof t && t >= 0), i = e ? (e - e % 26) / 26 : 0;
                        var s = t % 26,
                            a = Math.min((t - s) / 26, this.length),
                            o = 67108863 ^ 67108863 >>> s << s,
                            u = r;
                        if (i -= a, i = Math.max(0, i), u) {
                            for (var h = 0; h < a; h++) u.words[h] = this.words[h];
                            u.length = a
                        }
                        if (0 === a);
                        else if (this.length > a)
                            for (this.length -= a, h = 0; h < this.length; h++) this.words[h] = this.words[h + a];
                        else this.words[0] = 0, this.length = 1;
                        var f = 0;
                        for (h = this.length - 1; h >= 0 && (0 !== f || h >= i); h--) {
                            var c = 0 | this.words[h];
                            this.words[h] = f << 26 - s | c >>> s, f = c & o
                        }
                        return u && 0 !== f && (u.words[u.length++] = f), 0 === this.length && (this.words[0] = 0, this.length = 1), this.strip()
                    }, s.prototype.ishrn = function(t, e, r) {
                        return n(0 === this.negative), this.iushrn(t, e, r)
                    }, s.prototype.shln = function(t) {
                        return this.clone().ishln(t)
                    }, s.prototype.ushln = function(t) {
                        return this.clone().iushln(t)
                    }, s.prototype.shrn = function(t) {
                        return this.clone().ishrn(t)
                    }, s.prototype.ushrn = function(t) {
                        return this.clone().iushrn(t)
                    }, s.prototype.testn = function(t) {
                        n("number" === typeof t && t >= 0);
                        var e = t % 26,
                            r = (t - e) / 26,
                            i = 1 << e;
                        if (this.length <= r) return !1;
                        var s = this.words[r];
                        return !!(s & i)
                    }, s.prototype.imaskn = function(t) {
                        n("number" === typeof t && t >= 0);
                        var e = t % 26,
                            r = (t - e) / 26;
                        if (n(0 === this.negative, "imaskn works only with positive numbers"), this.length <= r) return this;
                        if (0 !== e && r++, this.length = Math.min(r, this.length), 0 !== e) {
                            var i = 67108863 ^ 67108863 >>> e << e;
                            this.words[this.length - 1] &= i
                        }
                        return this.strip()
                    }, s.prototype.maskn = function(t) {
                        return this.clone().imaskn(t)
                    }, s.prototype.iaddn = function(t) {
                        return n("number" === typeof t), n(t < 67108864), t < 0 ? this.isubn(-t) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) < t ? (this.words[0] = t - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(t), this.negative = 1, this) : this._iaddn(t)
                    }, s.prototype._iaddn = function(t) {
                        this.words[0] += t;
                        for (var e = 0; e < this.length && this.words[e] >= 67108864; e++) this.words[e] -= 67108864, e === this.length - 1 ? this.words[e + 1] = 1 : this.words[e + 1]++;
                        return this.length = Math.max(this.length, e + 1), this
                    }, s.prototype.isubn = function(t) {
                        if (n("number" === typeof t), n(t < 67108864), t < 0) return this.iaddn(-t);
                        if (0 !== this.negative) return this.negative = 0, this.iaddn(t), this.negative = 1, this;
                        if (this.words[0] -= t, 1 === this.length && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
                        else
                            for (var e = 0; e < this.length && this.words[e] < 0; e++) this.words[e] += 67108864, this.words[e + 1] -= 1;
                        return this.strip()
                    }, s.prototype.addn = function(t) {
                        return this.clone().iaddn(t)
                    }, s.prototype.subn = function(t) {
                        return this.clone().isubn(t)
                    }, s.prototype.iabs = function() {
                        return this.negative = 0, this
                    }, s.prototype.abs = function() {
                        return this.clone().iabs()
                    }, s.prototype._ishlnsubmul = function(t, e, r) {
                        var i, s, a = t.length + r;
                        this._expand(a);
                        var o = 0;
                        for (i = 0; i < t.length; i++) {
                            s = (0 | this.words[i + r]) + o;
                            var u = (0 | t.words[i]) * e;
                            s -= 67108863 & u, o = (s >> 26) - (u / 67108864 | 0), this.words[i + r] = 67108863 & s
                        }
                        for (; i < this.length - r; i++) s = (0 | this.words[i + r]) + o, o = s >> 26, this.words[i + r] = 67108863 & s;
                        if (0 === o) return this.strip();
                        for (n(-1 === o), o = 0, i = 0; i < this.length; i++) s = -(0 | this.words[i]) + o, o = s >> 26, this.words[i] = 67108863 & s;
                        return this.negative = 1, this.strip()
                    }, s.prototype._wordDiv = function(t, e) {
                        var r = this.length - t.length,
                            n = this.clone(),
                            i = t,
                            a = 0 | i.words[i.length - 1],
                            o = this._countBits(a);
                        r = 26 - o, 0 !== r && (i = i.ushln(r), n.iushln(r), a = 0 | i.words[i.length - 1]);
                        var u, h = n.length - i.length;
                        if ("mod" !== e) {
                            u = new s(null), u.length = h + 1, u.words = new Array(u.length);
                            for (var f = 0; f < u.length; f++) u.words[f] = 0
                        }
                        var c = n.clone()._ishlnsubmul(i, 1, h);
                        0 === c.negative && (n = c, u && (u.words[h] = 1));
                        for (var l = h - 1; l >= 0; l--) {
                            var d = 67108864 * (0 | n.words[i.length + l]) + (0 | n.words[i.length + l - 1]);
                            d = Math.min(d / a | 0, 67108863), n._ishlnsubmul(i, d, l);
                            while (0 !== n.negative) d--, n.negative = 0, n._ishlnsubmul(i, 1, l), n.isZero() || (n.negative ^= 1);
                            u && (u.words[l] = d)
                        }
                        return u && u.strip(), n.strip(), "div" !== e && 0 !== r && n.iushrn(r), {
                            div: u || null,
                            mod: n
                        }
                    }, s.prototype.divmod = function(t, e, r) {
                        return n(!t.isZero()), this.isZero() ? {
                            div: new s(0),
                            mod: new s(0)
                        } : 0 !== this.negative && 0 === t.negative ? (o = this.neg().divmod(t, e), "mod" !== e && (i = o.div.neg()), "div" !== e && (a = o.mod.neg(), r && 0 !== a.negative && a.iadd(t)), {
                            div: i,
                            mod: a
                        }) : 0 === this.negative && 0 !== t.negative ? (o = this.divmod(t.neg(), e), "mod" !== e && (i = o.div.neg()), {
                            div: i,
                            mod: o.mod
                        }) : 0 !== (this.negative & t.negative) ? (o = this.neg().divmod(t.neg(), e), "div" !== e && (a = o.mod.neg(), r && 0 !== a.negative && a.isub(t)), {
                            div: o.div,
                            mod: a
                        }) : t.length > this.length || this.cmp(t) < 0 ? {
                            div: new s(0),
                            mod: this
                        } : 1 === t.length ? "div" === e ? {
                            div: this.divn(t.words[0]),
                            mod: null
                        } : "mod" === e ? {
                            div: null,
                            mod: new s(this.modn(t.words[0]))
                        } : {
                            div: this.divn(t.words[0]),
                            mod: new s(this.modn(t.words[0]))
                        } : this._wordDiv(t, e);
                        var i, a, o
                    }, s.prototype.div = function(t) {
                        return this.divmod(t, "div", !1).div
                    }, s.prototype.mod = function(t) {
                        return this.divmod(t, "mod", !1).mod
                    }, s.prototype.umod = function(t) {
                        return this.divmod(t, "mod", !0).mod
                    }, s.prototype.divRound = function(t) {
                        var e = this.divmod(t);
                        if (e.mod.isZero()) return e.div;
                        var r = 0 !== e.div.negative ? e.mod.isub(t) : e.mod,
                            n = t.ushrn(1),
                            i = t.andln(1),
                            s = r.cmp(n);
                        return s < 0 || 1 === i && 0 === s ? e.div : 0 !== e.div.negative ? e.div.isubn(1) : e.div.iaddn(1)
                    }, s.prototype.modn = function(t) {
                        n(t <= 67108863);
                        for (var e = (1 << 26) % t, r = 0, i = this.length - 1; i >= 0; i--) r = (e * r + (0 | this.words[i])) % t;
                        return r
                    }, s.prototype.idivn = function(t) {
                        n(t <= 67108863);
                        for (var e = 0, r = this.length - 1; r >= 0; r--) {
                            var i = (0 | this.words[r]) + 67108864 * e;
                            this.words[r] = i / t | 0, e = i % t
                        }
                        return this.strip()
                    }, s.prototype.divn = function(t) {
                        return this.clone().idivn(t)
                    }, s.prototype.egcd = function(t) {
                        n(0 === t.negative), n(!t.isZero());
                        var e = this,
                            r = t.clone();
                        e = 0 !== e.negative ? e.umod(t) : e.clone();
                        var i = new s(1),
                            a = new s(0),
                            o = new s(0),
                            u = new s(1),
                            h = 0;
                        while (e.isEven() && r.isEven()) e.iushrn(1), r.iushrn(1), ++h;
                        var f = r.clone(),
                            c = e.clone();
                        while (!e.isZero()) {
                            for (var l = 0, d = 1; 0 === (e.words[0] & d) && l < 26; ++l, d <<= 1);
                            if (l > 0) {
                                e.iushrn(l);
                                while (l-- > 0)(i.isOdd() || a.isOdd()) && (i.iadd(f), a.isub(c)), i.iushrn(1), a.iushrn(1)
                            }
                            for (var p = 0, m = 1; 0 === (r.words[0] & m) && p < 26; ++p, m <<= 1);
                            if (p > 0) {
                                r.iushrn(p);
                                while (p-- > 0)(o.isOdd() || u.isOdd()) && (o.iadd(f), u.isub(c)), o.iushrn(1), u.iushrn(1)
                            }
                            e.cmp(r) >= 0 ? (e.isub(r), i.isub(o), a.isub(u)) : (r.isub(e), o.isub(i), u.isub(a))
                        }
                        return {
                            a: o,
                            b: u,
                            gcd: r.iushln(h)
                        }
                    }, s.prototype._invmp = function(t) {
                        n(0 === t.negative), n(!t.isZero());
                        var e = this,
                            r = t.clone();
                        e = 0 !== e.negative ? e.umod(t) : e.clone();
                        var i, a = new s(1),
                            o = new s(0),
                            u = r.clone();
                        while (e.cmpn(1) > 0 && r.cmpn(1) > 0) {
                            for (var h = 0, f = 1; 0 === (e.words[0] & f) && h < 26; ++h, f <<= 1);
                            if (h > 0) {
                                e.iushrn(h);
                                while (h-- > 0) a.isOdd() && a.iadd(u), a.iushrn(1)
                            }
                            for (var c = 0, l = 1; 0 === (r.words[0] & l) && c < 26; ++c, l <<= 1);
                            if (c > 0) {
                                r.iushrn(c);
                                while (c-- > 0) o.isOdd() && o.iadd(u), o.iushrn(1)
                            }
                            e.cmp(r) >= 0 ? (e.isub(r), a.isub(o)) : (r.isub(e), o.isub(a))
                        }
                        return i = 0 === e.cmpn(1) ? a : o, i.cmpn(0) < 0 && i.iadd(t), i
                    }, s.prototype.gcd = function(t) {
                        if (this.isZero()) return t.abs();
                        if (t.isZero()) return this.abs();
                        var e = this.clone(),
                            r = t.clone();
                        e.negative = 0, r.negative = 0;
                        for (var n = 0; e.isEven() && r.isEven(); n++) e.iushrn(1), r.iushrn(1);
                        do {
                            while (e.isEven()) e.iushrn(1);
                            while (r.isEven()) r.iushrn(1);
                            var i = e.cmp(r);
                            if (i < 0) {
                                var s = e;
                                e = r, r = s
                            } else if (0 === i || 0 === r.cmpn(1)) break;
                            e.isub(r)
                        } while (1);
                        return r.iushln(n)
                    }, s.prototype.invm = function(t) {
                        return this.egcd(t).a.umod(t)
                    }, s.prototype.isEven = function() {
                        return 0 === (1 & this.words[0])
                    }, s.prototype.isOdd = function() {
                        return 1 === (1 & this.words[0])
                    }, s.prototype.andln = function(t) {
                        return this.words[0] & t
                    }, s.prototype.bincn = function(t) {
                        n("number" === typeof t);
                        var e = t % 26,
                            r = (t - e) / 26,
                            i = 1 << e;
                        if (this.length <= r) return this._expand(r + 1), this.words[r] |= i, this;
                        for (var s = i, a = r; 0 !== s && a < this.length; a++) {
                            var o = 0 | this.words[a];
                            o += s, s = o >>> 26, o &= 67108863, this.words[a] = o
                        }
                        return 0 !== s && (this.words[a] = s, this.length++), this
                    }, s.prototype.isZero = function() {
                        return 1 === this.length && 0 === this.words[0]
                    }, s.prototype.cmpn = function(t) {
                        var e, r = t < 0;
                        if (0 !== this.negative && !r) return -1;
                        if (0 === this.negative && r) return 1;
                        if (this.strip(), this.length > 1) e = 1;
                        else {
                            r && (t = -t), n(t <= 67108863, "Number is too big");
                            var i = 0 | this.words[0];
                            e = i === t ? 0 : i < t ? -1 : 1
                        }
                        return 0 !== this.negative ? 0 | -e : e
                    }, s.prototype.cmp = function(t) {
                        if (0 !== this.negative && 0 === t.negative) return -1;
                        if (0 === this.negative && 0 !== t.negative) return 1;
                        var e = this.ucmp(t);
                        return 0 !== this.negative ? 0 | -e : e
                    }, s.prototype.ucmp = function(t) {
                        if (this.length > t.length) return 1;
                        if (this.length < t.length) return -1;
                        for (var e = 0, r = this.length - 1; r >= 0; r--) {
                            var n = 0 | this.words[r],
                                i = 0 | t.words[r];
                            if (n !== i) {
                                n < i ? e = -1 : n > i && (e = 1);
                                break
                            }
                        }
                        return e
                    }, s.prototype.gtn = function(t) {
                        return 1 === this.cmpn(t)
                    }, s.prototype.gt = function(t) {
                        return 1 === this.cmp(t)
                    }, s.prototype.gten = function(t) {
                        return this.cmpn(t) >= 0
                    }, s.prototype.gte = function(t) {
                        return this.cmp(t) >= 0
                    }, s.prototype.ltn = function(t) {
                        return -1 === this.cmpn(t)
                    }, s.prototype.lt = function(t) {
                        return -1 === this.cmp(t)
                    }, s.prototype.lten = function(t) {
                        return this.cmpn(t) <= 0
                    }, s.prototype.lte = function(t) {
                        return this.cmp(t) <= 0
                    }, s.prototype.eqn = function(t) {
                        return 0 === this.cmpn(t)
                    }, s.prototype.eq = function(t) {
                        return 0 === this.cmp(t)
                    }, s.red = function(t) {
                        return new x(t)
                    }, s.prototype.toRed = function(t) {
                        return n(!this.red, "Already a number in reduction context"), n(0 === this.negative, "red works only with positives"), t.convertTo(this)._forceRed(t)
                    }, s.prototype.fromRed = function() {
                        return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
                    }, s.prototype._forceRed = function(t) {
                        return this.red = t, this
                    }, s.prototype.forceRed = function(t) {
                        return n(!this.red, "Already a number in reduction context"), this._forceRed(t)
                    }, s.prototype.redAdd = function(t) {
                        return n(this.red, "redAdd works only with red numbers"), this.red.add(this, t)
                    }, s.prototype.redIAdd = function(t) {
                        return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, t)
                    }, s.prototype.redSub = function(t) {
                        return n(this.red, "redSub works only with red numbers"), this.red.sub(this, t)
                    }, s.prototype.redISub = function(t) {
                        return n(this.red, "redISub works only with red numbers"), this.red.isub(this, t)
                    }, s.prototype.redShl = function(t) {
                        return n(this.red, "redShl works only with red numbers"), this.red.shl(this, t)
                    }, s.prototype.redMul = function(t) {
                        return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, t), this.red.mul(this, t)
                    }, s.prototype.redIMul = function(t) {
                        return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, t), this.red.imul(this, t)
                    }, s.prototype.redSqr = function() {
                        return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
                    }, s.prototype.redISqr = function() {
                        return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
                    }, s.prototype.redSqrt = function() {
                        return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
                    }, s.prototype.redInvm = function() {
                        return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
                    }, s.prototype.redNeg = function() {
                        return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
                    }, s.prototype.redPow = function(t) {
                        return n(this.red && !t.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, t)
                    };
                    var v = {
                        k256: null,
                        p224: null,
                        p192: null,
                        p25519: null
                    };

                    function w(t, e) {
                        this.name = t, this.p = new s(e, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
                    }

                    function _() {
                        w.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
                    }

                    function M() {
                        w.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
                    }

                    function A() {
                        w.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
                    }

                    function S() {
                        w.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
                    }

                    function x(t) {
                        if ("string" === typeof t) {
                            var e = s._prime(t);
                            this.m = e.p, this.prime = e
                        } else n(t.gtn(1), "modulus must be greater than 1"), this.m = t, this.prime = null
                    }

                    function E(t) {
                        x.call(this, t), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
                    }
                    w.prototype._tmp = function() {
                        var t = new s(null);
                        return t.words = new Array(Math.ceil(this.n / 13)), t
                    }, w.prototype.ireduce = function(t) {
                        var e, r = t;
                        do {
                            this.split(r, this.tmp), r = this.imulK(r), r = r.iadd(this.tmp), e = r.bitLength()
                        } while (e > this.n);
                        var n = e < this.n ? -1 : r.ucmp(this.p);
                        return 0 === n ? (r.words[0] = 0, r.length = 1) : n > 0 ? r.isub(this.p) : void 0 !== r.strip ? r.strip() : r._strip(), r
                    }, w.prototype.split = function(t, e) {
                        t.iushrn(this.n, 0, e)
                    }, w.prototype.imulK = function(t) {
                        return t.imul(this.k)
                    }, i(_, w), _.prototype.split = function(t, e) {
                        for (var r = 4194303, n = Math.min(t.length, 9), i = 0; i < n; i++) e.words[i] = t.words[i];
                        if (e.length = n, t.length <= 9) return t.words[0] = 0, void(t.length = 1);
                        var s = t.words[9];
                        for (e.words[e.length++] = s & r, i = 10; i < t.length; i++) {
                            var a = 0 | t.words[i];
                            t.words[i - 10] = (a & r) << 4 | s >>> 22, s = a
                        }
                        s >>>= 22, t.words[i - 10] = s, 0 === s && t.length > 10 ? t.length -= 10 : t.length -= 9
                    }, _.prototype.imulK = function(t) {
                        t.words[t.length] = 0, t.words[t.length + 1] = 0, t.length += 2;
                        for (var e = 0, r = 0; r < t.length; r++) {
                            var n = 0 | t.words[r];
                            e += 977 * n, t.words[r] = 67108863 & e, e = 64 * n + (e / 67108864 | 0)
                        }
                        return 0 === t.words[t.length - 1] && (t.length--, 0 === t.words[t.length - 1] && t.length--), t
                    }, i(M, w), i(A, w), i(S, w), S.prototype.imulK = function(t) {
                        for (var e = 0, r = 0; r < t.length; r++) {
                            var n = 19 * (0 | t.words[r]) + e,
                                i = 67108863 & n;
                            n >>>= 26, t.words[r] = i, e = n
                        }
                        return 0 !== e && (t.words[t.length++] = e), t
                    }, s._prime = function(t) {
                        if (v[t]) return v[t];
                        var e;
                        if ("k256" === t) e = new _;
                        else if ("p224" === t) e = new M;
                        else if ("p192" === t) e = new A;
                        else {
                            if ("p25519" !== t) throw new Error("Unknown prime " + t);
                            e = new S
                        }
                        return v[t] = e, e
                    }, x.prototype._verify1 = function(t) {
                        n(0 === t.negative, "red works only with positives"), n(t.red, "red works only with red numbers")
                    }, x.prototype._verify2 = function(t, e) {
                        n(0 === (t.negative | e.negative), "red works only with positives"), n(t.red && t.red === e.red, "red works only with red numbers")
                    }, x.prototype.imod = function(t) {
                        return this.prime ? this.prime.ireduce(t)._forceRed(this) : t.umod(this.m)._forceRed(this)
                    }, x.prototype.neg = function(t) {
                        return t.isZero() ? t.clone() : this.m.sub(t)._forceRed(this)
                    }, x.prototype.add = function(t, e) {
                        this._verify2(t, e);
                        var r = t.add(e);
                        return r.cmp(this.m) >= 0 && r.isub(this.m), r._forceRed(this)
                    }, x.prototype.iadd = function(t, e) {
                        this._verify2(t, e);
                        var r = t.iadd(e);
                        return r.cmp(this.m) >= 0 && r.isub(this.m), r
                    }, x.prototype.sub = function(t, e) {
                        this._verify2(t, e);
                        var r = t.sub(e);
                        return r.cmpn(0) < 0 && r.iadd(this.m), r._forceRed(this)
                    }, x.prototype.isub = function(t, e) {
                        this._verify2(t, e);
                        var r = t.isub(e);
                        return r.cmpn(0) < 0 && r.iadd(this.m), r
                    }, x.prototype.shl = function(t, e) {
                        return this._verify1(t), this.imod(t.ushln(e))
                    }, x.prototype.imul = function(t, e) {
                        return this._verify2(t, e), this.imod(t.imul(e))
                    }, x.prototype.mul = function(t, e) {
                        return this._verify2(t, e), this.imod(t.mul(e))
                    }, x.prototype.isqr = function(t) {
                        return this.imul(t, t.clone())
                    }, x.prototype.sqr = function(t) {
                        return this.mul(t, t)
                    }, x.prototype.sqrt = function(t) {
                        if (t.isZero()) return t.clone();
                        var e = this.m.andln(3);
                        if (n(e % 2 === 1), 3 === e) {
                            var r = this.m.add(new s(1)).iushrn(2);
                            return this.pow(t, r)
                        }
                        var i = this.m.subn(1),
                            a = 0;
                        while (!i.isZero() && 0 === i.andln(1)) a++, i.iushrn(1);
                        n(!i.isZero());
                        var o = new s(1).toRed(this),
                            u = o.redNeg(),
                            h = this.m.subn(1).iushrn(1),
                            f = this.m.bitLength();
                        f = new s(2 * f * f).toRed(this);
                        while (0 !== this.pow(f, h).cmp(u)) f.redIAdd(u);
                        var c = this.pow(f, i),
                            l = this.pow(t, i.addn(1).iushrn(1)),
                            d = this.pow(t, i),
                            p = a;
                        while (0 !== d.cmp(o)) {
                            for (var m = d, b = 0; 0 !== m.cmp(o); b++) m = m.redSqr();
                            n(b < p);
                            var g = this.pow(c, new s(1).iushln(p - b - 1));
                            l = l.redMul(g), c = g.redSqr(), d = d.redMul(c), p = b
                        }
                        return l
                    }, x.prototype.invm = function(t) {
                        var e = t._invmp(this.m);
                        return 0 !== e.negative ? (e.negative = 0, this.imod(e).redNeg()) : this.imod(e)
                    }, x.prototype.pow = function(t, e) {
                        if (e.isZero()) return new s(1).toRed(this);
                        if (0 === e.cmpn(1)) return t.clone();
                        var r = 4,
                            n = new Array(1 << r);
                        n[0] = new s(1).toRed(this), n[1] = t;
                        for (var i = 2; i < n.length; i++) n[i] = this.mul(n[i - 1], t);
                        var a = n[0],
                            o = 0,
                            u = 0,
                            h = e.bitLength() % 26;
                        for (0 === h && (h = 26), i = e.length - 1; i >= 0; i--) {
                            for (var f = e.words[i], c = h - 1; c >= 0; c--) {
                                var l = f >> c & 1;
                                a !== n[0] && (a = this.sqr(a)), 0 !== l || 0 !== o ? (o <<= 1, o |= l, u++, (u === r || 0 === i && 0 === c) && (a = this.mul(a, n[o]), u = 0, o = 0)) : u = 0
                            }
                            h = 26
                        }
                        return a
                    }, x.prototype.convertTo = function(t) {
                        var e = t.umod(this.m);
                        return e === t ? e.clone() : e
                    }, x.prototype.convertFrom = function(t) {
                        var e = t.clone();
                        return e.red = null, e
                    }, s.mont = function(t) {
                        return new E(t)
                    }, i(E, x), E.prototype.convertTo = function(t) {
                        return this.imod(t.ushln(this.shift))
                    }, E.prototype.convertFrom = function(t) {
                        var e = this.imod(t.mul(this.rinv));
                        return e.red = null, e
                    }, E.prototype.imul = function(t, e) {
                        if (t.isZero() || e.isZero()) return t.words[0] = 0, t.length = 1, t;
                        var r = t.imul(e),
                            n = r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                            i = r.isub(n).iushrn(this.shift),
                            s = i;
                        return i.cmp(this.m) >= 0 ? s = i.isub(this.m) : i.cmpn(0) < 0 && (s = i.iadd(this.m)), s._forceRed(this)
                    }, E.prototype.mul = function(t, e) {
                        if (t.isZero() || e.isZero()) return new s(0)._forceRed(this);
                        var r = t.mul(e),
                            n = r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                            i = r.isub(n).iushrn(this.shift),
                            a = i;
                        return i.cmp(this.m) >= 0 ? a = i.isub(this.m) : i.cmpn(0) < 0 && (a = i.iadd(this.m)), a._forceRed(this)
                    }, E.prototype.invm = function(t) {
                        var e = this.imod(t._invmp(this.m).mul(this.r2));
                        return e._forceRed(this)
                    }
                })(t, this)
            }).call(this, r("62e4")(t))
        },
        "0632": function(t, e, r) {
            /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
            var n = r("b639"),
                i = n.Buffer;

            function s(t, e) {
                for (var r in t) e[r] = t[r]
            }

            function a(t, e, r) {
                return i(t, e, r)
            }
            i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? t.exports = n : (s(n, e), e.Buffer = a), a.prototype = Object.create(i.prototype), s(i, a), a.from = function(t, e, r) {
                if ("number" === typeof t) throw new TypeError("Argument must not be a number");
                return i(t, e, r)
            }, a.alloc = function(t, e, r) {
                if ("number" !== typeof t) throw new TypeError("Argument must be a number");
                var n = i(t);
                return void 0 !== e ? "string" === typeof r ? n.fill(e, r) : n.fill(e) : n.fill(0), n
            }, a.allocUnsafe = function(t) {
                if ("number" !== typeof t) throw new TypeError("Argument must be a number");
                return i(t)
            }, a.allocUnsafeSlow = function(t) {
                if ("number" !== typeof t) throw new TypeError("Argument must be a number");
                return n.SlowBuffer(t)
            }
        },
        "07f2": function(t, e, r) {
            "use strict";
            var n = r("c3c0"),
                i = r("6eed");

            function s() {
                if (!(this instanceof s)) return new s;
                i.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]
            }
            n.inherits(s, i), t.exports = s, s.blockSize = 512, s.outSize = 224, s.hmacStrength = 192, s.padLength = 64, s.prototype._digest = function(t) {
                return "hex" === t ? n.toHex32(this.h.slice(0, 7), "big") : n.split32(this.h.slice(0, 7), "big")
            }
        },
        "0926": function(t, e, r) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.Serialize = e.RpcError = e.RpcInterfaces = e.Numeric = e.JsonRpc = e.ApiInterfaces = e.Api = void 0;
            var n = r("a795");
            Object.defineProperty(e, "Api", {
                enumerable: !0,
                get: function() {
                    return n.Api
                }
            });
            var i = r("9b67");
            e.ApiInterfaces = i;
            var s = r("b927");
            Object.defineProperty(e, "JsonRpc", {
                enumerable: !0,
                get: function() {
                    return s.JsonRpc
                }
            });
            var a = r("8cb0");
            e.Numeric = a;
            var o = r("9367");
            e.RpcInterfaces = o;
            var u = r("32b6");
            Object.defineProperty(e, "RpcError", {
                enumerable: !0,
                get: function() {
                    return u.RpcError
                }
            });
            var h = r("9392");
            e.Serialize = h
        },
        "09dc": function(t, e, r) {
            "use strict";
            t.exports = f;
            var n = r("9d8a").codes,
                i = n.ERR_METHOD_NOT_IMPLEMENTED,
                s = n.ERR_MULTIPLE_CALLBACK,
                a = n.ERR_TRANSFORM_ALREADY_TRANSFORMING,
                o = n.ERR_TRANSFORM_WITH_LENGTH_0,
                u = r("e666");

            function h(t, e) {
                var r = this._transformState;
                r.transforming = !1;
                var n = r.writecb;
                if (null === n) return this.emit("error", new s);
                r.writechunk = null, r.writecb = null, null != e && this.push(e), n(t);
                var i = this._readableState;
                i.reading = !1, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark)
            }

            function f(t) {
                if (!(this instanceof f)) return new f(t);
                u.call(this, t), this._transformState = {
                    afterTransform: h.bind(this),
                    needTransform: !1,
                    transforming: !1,
                    writecb: null,
                    writechunk: null,
                    writeencoding: null
                }, this._readableState.needReadable = !0, this._readableState.sync = !1, t && ("function" === typeof t.transform && (this._transform = t.transform), "function" === typeof t.flush && (this._flush = t.flush)), this.on("prefinish", c)
            }

            function c() {
                var t = this;
                "function" !== typeof this._flush || this._readableState.destroyed ? l(this, null, null) : this._flush((function(e, r) {
                    l(t, e, r)
                }))
            }

            function l(t, e, r) {
                if (e) return t.emit("error", e);
                if (null != r && t.push(r), t._writableState.length) throw new o;
                if (t._transformState.transforming) throw new a;
                return t.push(null)
            }
            r("3fb5")(f, u), f.prototype.push = function(t, e) {
                return this._transformState.needTransform = !1, u.prototype.push.call(this, t, e)
            }, f.prototype._transform = function(t, e, r) {
                r(new i("_transform()"))
            }, f.prototype._write = function(t, e, r) {
                var n = this._transformState;
                if (n.writecb = r, n.writechunk = t, n.writeencoding = e, !n.transforming) {
                    var i = this._readableState;
                    (n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark)
                }
            }, f.prototype._read = function(t) {
                var e = this._transformState;
                null === e.writechunk || e.transforming ? e.needTransform = !0 : (e.transforming = !0, this._transform(e.writechunk, e.writeencoding, e.afterTransform))
            }, f.prototype._destroy = function(t, e) {
                u.prototype._destroy.call(this, t, (function(t) {
                    e(t)
                }))
            }
        },
        "0ae3": function(t, e, r) {
            "use strict";
            t.exports = i;
            var n = r("09dc");

            function i(t) {
                if (!(this instanceof i)) return new i(t);
                n.call(this, t)
            }
            r("3fb5")(i, n), i.prototype._transform = function(t, e, r) {
                r(null, t)
            }
        },
        "0cbb": function(t, e, r) {
            "use strict";
            var n, i = e,
                s = r("7d92"),
                a = r("4136"),
                o = r("f3a3"),
                u = o.assert;

            function h(t) {
                "short" === t.type ? this.curve = new a.short(t) : "edwards" === t.type ? this.curve = new a.edwards(t) : this.curve = new a.mont(t), this.g = this.curve.g, this.n = this.curve.n, this.hash = t.hash, u(this.g.validate(), "Invalid curve"), u(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O")
            }

            function f(t, e) {
                Object.defineProperty(i, t, {
                    configurable: !0,
                    enumerable: !0,
                    get: function() {
                        var r = new h(e);
                        return Object.defineProperty(i, t, {
                            configurable: !0,
                            enumerable: !0,
                            value: r
                        }), r
                    }
                })
            }
            i.PresetCurve = h, f("p192", {
                type: "short",
                prime: "p192",
                p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
                a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
                b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
                n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
                hash: s.sha256,
                gRed: !1,
                g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]
            }), f("p224", {
                type: "short",
                prime: "p224",
                p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
                a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
                b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
                n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
                hash: s.sha256,
                gRed: !1,
                g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]
            }), f("p256", {
                type: "short",
                prime: null,
                p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
                a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
                b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
                n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
                hash: s.sha256,
                gRed: !1,
                g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]
            }), f("p384", {
                type: "short",
                prime: null,
                p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
                a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
                b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
                n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
                hash: s.sha384,
                gRed: !1,
                g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]
            }), f("p521", {
                type: "short",
                prime: null,
                p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
                a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
                b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
                n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
                hash: s.sha512,
                gRed: !1,
                g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]
            }), f("curve25519", {
                type: "mont",
                prime: "p25519",
                p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
                a: "76d06",
                b: "1",
                n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
                hash: s.sha256,
                gRed: !1,
                g: ["9"]
            }), f("ed25519", {
                type: "edwards",
                prime: "p25519",
                p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
                a: "-1",
                c: "1",
                d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
                n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
                hash: s.sha256,
                gRed: !1,
                g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"]
            });
            try {
                n = r("409b")
            } catch (c) {
                n = void 0
            }
            f("secp256k1", {
                type: "short",
                prime: "k256",
                p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
                a: "0",
                b: "7",
                n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
                h: "1",
                hash: s.sha256,
                beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
                lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
                basis: [{
                    a: "3086d221a7d46bcde86c90e49284eb15",
                    b: "-e4437ed6010e88286f547fa90abfe4c3"
                }, {
                    a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
                    b: "3086d221a7d46bcde86c90e49284eb15"
                }],
                gRed: !1,
                g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", n]
            })
        },
        "0da4": function(t, e, r) {
            "use strict";
            var n = r("da3e"),
                i = r("3fb5"),
                s = {};

            function a(t) {
                n.equal(t.length, 8, "Invalid IV length"), this.iv = new Array(8);
                for (var e = 0; e < this.iv.length; e++) this.iv[e] = t[e]
            }

            function o(t) {
                function e(e) {
                    t.call(this, e), this._cbcInit()
                }
                i(e, t);
                for (var r = Object.keys(s), n = 0; n < r.length; n++) {
                    var a = r[n];
                    e.prototype[a] = s[a]
                }
                return e.create = function(t) {
                    return new e(t)
                }, e
            }
            e.instantiate = o, s._cbcInit = function() {
                var t = new a(this.options.iv);
                this._cbcState = t
            }, s._update = function(t, e, r, n) {
                var i = this._cbcState,
                    s = this.constructor.super_.prototype,
                    a = i.iv;
                if ("encrypt" === this.type) {
                    for (var o = 0; o < this.blockSize; o++) a[o] ^= t[e + o];
                    s._update.call(this, a, 0, r, n);
                    for (o = 0; o < this.blockSize; o++) a[o] = r[n + o]
                } else {
                    s._update.call(this, t, e, r, n);
                    for (o = 0; o < this.blockSize; o++) r[n + o] ^= a[o];
                    for (o = 0; o < this.blockSize; o++) a[o] = t[e + o]
                }
            }
        },
        "0e4c": function(t, e, r) {
            "use strict";
            (function(t) {
                r.d(e, "a", (function() {
                    return K
                }));
                var n = r("030a"),
                    i = r.n(n),
                    s = r("7d92"),
                    a = r.n(s);
                "undefined" !== typeof globalThis ? globalThis : "undefined" !== typeof window ? window : "undefined" !== typeof t || "undefined" !== typeof self && self;

                function o(t, e, r) {
                    return r = {
                        path: e,
                        exports: {},
                        require: function(t, e) {
                            return u(t, void 0 === e || null === e ? r.path : e)
                        }
                    }, t(r, r.exports), r.exports
                }

                function u() {
                    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")
                }
                var h = f;

                function f(t, e) {
                    if (!t) throw new Error(e || "Assertion failed")
                }
                f.equal = function(t, e, r) {
                    if (t != e) throw new Error(r || "Assertion failed: " + t + " != " + e)
                };
                var c = o((function(t, e) {
                        var r = e;

                        function n(t, e) {
                            if (Array.isArray(t)) return t.slice();
                            if (!t) return [];
                            var r = [];
                            if ("string" !== typeof t) {
                                for (var n = 0; n < t.length; n++) r[n] = 0 | t[n];
                                return r
                            }
                            if ("hex" === e) {
                                t = t.replace(/[^a-z0-9]+/gi, ""), t.length % 2 !== 0 && (t = "0" + t);
                                for (n = 0; n < t.length; n += 2) r.push(parseInt(t[n] + t[n + 1], 16))
                            } else
                                for (n = 0; n < t.length; n++) {
                                    var i = t.charCodeAt(n),
                                        s = i >> 8,
                                        a = 255 & i;
                                    s ? r.push(s, a) : r.push(a)
                                }
                            return r
                        }

                        function i(t) {
                            return 1 === t.length ? "0" + t : t
                        }

                        function s(t) {
                            for (var e = "", r = 0; r < t.length; r++) e += i(t[r].toString(16));
                            return e
                        }
                        r.toArray = n, r.zero2 = i, r.toHex = s, r.encode = function(t, e) {
                            return "hex" === e ? s(t) : t
                        }
                    })),
                    l = o((function(t, e) {
                        var r = e;

                        function n(t, e, r) {
                            var n = new Array(Math.max(t.bitLength(), r) + 1);
                            n.fill(0);
                            for (var i = 1 << e + 1, s = t.clone(), a = 0; a < n.length; a++) {
                                var o, u = s.andln(i - 1);
                                s.isOdd() ? (o = u > (i >> 1) - 1 ? (i >> 1) - u : u, s.isubn(o)) : o = 0, n[a] = o, s.iushrn(1)
                            }
                            return n
                        }

                        function s(t, e) {
                            var r = [
                                [],
                                []
                            ];
                            t = t.clone(), e = e.clone();
                            var n, i = 0,
                                s = 0;
                            while (t.cmpn(-i) > 0 || e.cmpn(-s) > 0) {
                                var a, o, u = t.andln(3) + i & 3,
                                    h = e.andln(3) + s & 3;
                                3 === u && (u = -1), 3 === h && (h = -1), 0 === (1 & u) ? a = 0 : (n = t.andln(7) + i & 7, a = 3 !== n && 5 !== n || 2 !== h ? u : -u), r[0].push(a), 0 === (1 & h) ? o = 0 : (n = e.andln(7) + s & 7, o = 3 !== n && 5 !== n || 2 !== u ? h : -h), r[1].push(o), 2 * i === a + 1 && (i = 1 - i), 2 * s === o + 1 && (s = 1 - s), t.iushrn(1), e.iushrn(1)
                            }
                            return r
                        }

                        function a(t, e, r) {
                            var n = "_" + e;
                            t.prototype[e] = function() {
                                return void 0 !== this[n] ? this[n] : this[n] = r.call(this)
                            }
                        }

                        function o(t) {
                            return "string" === typeof t ? r.toArray(t, "hex") : t
                        }

                        function u(t) {
                            return new i.a(t, "hex", "le")
                        }
                        r.assert = h, r.toArray = c.toArray, r.zero2 = c.zero2, r.toHex = c.toHex, r.encode = c.encode, r.getNAF = n, r.getJSF = s, r.cachedProperty = a, r.parseBytes = o, r.intFromLE = u
                    })),
                    d = l.getNAF,
                    p = l.getJSF,
                    m = l.assert;

                function b(t, e) {
                    this.type = t, this.p = new i.a(e.p, 16), this.red = e.prime ? i.a.red(e.prime) : i.a.mont(this.p), this.zero = new i.a(0).toRed(this.red), this.one = new i.a(1).toRed(this.red), this.two = new i.a(2).toRed(this.red), this.n = e.n && new i.a(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
                    var r = this.n && this.p.div(this.n);
                    !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red))
                }
                var g = b;

                function y(t, e) {
                    this.curve = t, this.type = e, this.precomputed = null
                }
                b.prototype.point = function() {
                    throw new Error("Not implemented")
                }, b.prototype.validate = function() {
                    throw new Error("Not implemented")
                }, b.prototype._fixedNafMul = function(t, e) {
                    m(t.precomputed);
                    var r = t._getDoubles(),
                        n = d(e, 1, this._bitLength),
                        i = (1 << r.step + 1) - (r.step % 2 === 0 ? 2 : 1);
                    i /= 3;
                    var s, a, o = [];
                    for (s = 0; s < n.length; s += r.step) {
                        a = 0;
                        for (var u = s + r.step - 1; u >= s; u--) a = (a << 1) + n[u];
                        o.push(a)
                    }
                    for (var h = this.jpoint(null, null, null), f = this.jpoint(null, null, null), c = i; c > 0; c--) {
                        for (s = 0; s < o.length; s++) a = o[s], a === c ? f = f.mixedAdd(r.points[s]) : a === -c && (f = f.mixedAdd(r.points[s].neg()));
                        h = h.add(f)
                    }
                    return h.toP()
                }, b.prototype._wnafMul = function(t, e) {
                    var r = 4,
                        n = t._getNAFPoints(r);
                    r = n.wnd;
                    for (var i = n.points, s = d(e, r, this._bitLength), a = this.jpoint(null, null, null), o = s.length - 1; o >= 0; o--) {
                        for (var u = 0; o >= 0 && 0 === s[o]; o--) u++;
                        if (o >= 0 && u++, a = a.dblp(u), o < 0) break;
                        var h = s[o];
                        m(0 !== h), a = "affine" === t.type ? h > 0 ? a.mixedAdd(i[h - 1 >> 1]) : a.mixedAdd(i[-h - 1 >> 1].neg()) : h > 0 ? a.add(i[h - 1 >> 1]) : a.add(i[-h - 1 >> 1].neg())
                    }
                    return "affine" === t.type ? a.toP() : a
                }, b.prototype._wnafMulAdd = function(t, e, r, n, i) {
                    var s, a, o, u = this._wnafT1,
                        h = this._wnafT2,
                        f = this._wnafT3,
                        c = 0;
                    for (s = 0; s < n; s++) {
                        o = e[s];
                        var l = o._getNAFPoints(t);
                        u[s] = l.wnd, h[s] = l.points
                    }
                    for (s = n - 1; s >= 1; s -= 2) {
                        var m = s - 1,
                            b = s;
                        if (1 === u[m] && 1 === u[b]) {
                            var g = [e[m], null, null, e[b]];
                            0 === e[m].y.cmp(e[b].y) ? (g[1] = e[m].add(e[b]), g[2] = e[m].toJ().mixedAdd(e[b].neg())) : 0 === e[m].y.cmp(e[b].y.redNeg()) ? (g[1] = e[m].toJ().mixedAdd(e[b]), g[2] = e[m].add(e[b].neg())) : (g[1] = e[m].toJ().mixedAdd(e[b]), g[2] = e[m].toJ().mixedAdd(e[b].neg()));
                            var y = [-3, -1, -5, -7, 0, 7, 5, 1, 3],
                                v = p(r[m], r[b]);
                            for (c = Math.max(v[0].length, c), f[m] = new Array(c), f[b] = new Array(c), a = 0; a < c; a++) {
                                var w = 0 | v[0][a],
                                    _ = 0 | v[1][a];
                                f[m][a] = y[3 * (w + 1) + (_ + 1)], f[b][a] = 0, h[m] = g
                            }
                        } else f[m] = d(r[m], u[m], this._bitLength), f[b] = d(r[b], u[b], this._bitLength), c = Math.max(f[m].length, c), c = Math.max(f[b].length, c)
                    }
                    var M = this.jpoint(null, null, null),
                        A = this._wnafT4;
                    for (s = c; s >= 0; s--) {
                        var S = 0;
                        while (s >= 0) {
                            var x = !0;
                            for (a = 0; a < n; a++) A[a] = 0 | f[a][s], 0 !== A[a] && (x = !1);
                            if (!x) break;
                            S++, s--
                        }
                        if (s >= 0 && S++, M = M.dblp(S), s < 0) break;
                        for (a = 0; a < n; a++) {
                            var E = A[a];
                            0 !== E && (E > 0 ? o = h[a][E - 1 >> 1] : E < 0 && (o = h[a][-E - 1 >> 1].neg()), M = "affine" === o.type ? M.mixedAdd(o) : M.add(o))
                        }
                    }
                    for (s = 0; s < n; s++) h[s] = null;
                    return i ? M : M.toP()
                }, b.BasePoint = y, y.prototype.eq = function() {
                    throw new Error("Not implemented")
                }, y.prototype.validate = function() {
                    return this.curve.validate(this)
                }, b.prototype.decodePoint = function(t, e) {
                    t = l.toArray(t, e);
                    var r = this.p.byteLength();
                    if ((4 === t[0] || 6 === t[0] || 7 === t[0]) && t.length - 1 === 2 * r) {
                        6 === t[0] ? m(t[t.length - 1] % 2 === 0) : 7 === t[0] && m(t[t.length - 1] % 2 === 1);
                        var n = this.point(t.slice(1, 1 + r), t.slice(1 + r, 1 + 2 * r));
                        return n
                    }
                    if ((2 === t[0] || 3 === t[0]) && t.length - 1 === r) return this.pointFromX(t.slice(1, 1 + r), 3 === t[0]);
                    throw new Error("Unknown point format")
                }, y.prototype.encodeCompressed = function(t) {
                    return this.encode(t, !0)
                }, y.prototype._encode = function(t) {
                    var e = this.curve.p.byteLength(),
                        r = this.getX().toArray("be", e);
                    return t ? [this.getY().isEven() ? 2 : 3].concat(r) : [4].concat(r, this.getY().toArray("be", e))
                }, y.prototype.encode = function(t, e) {
                    return l.encode(this._encode(e), t)
                }, y.prototype.precompute = function(t) {
                    if (this.precomputed) return this;
                    var e = {
                        doubles: null,
                        naf: null,
                        beta: null
                    };
                    return e.naf = this._getNAFPoints(8), e.doubles = this._getDoubles(4, t), e.beta = this._getBeta(), this.precomputed = e, this
                }, y.prototype._hasDoubles = function(t) {
                    if (!this.precomputed) return !1;
                    var e = this.precomputed.doubles;
                    return !!e && e.points.length >= Math.ceil((t.bitLength() + 1) / e.step)
                }, y.prototype._getDoubles = function(t, e) {
                    if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
                    for (var r = [this], n = this, i = 0; i < e; i += t) {
                        for (var s = 0; s < t; s++) n = n.dbl();
                        r.push(n)
                    }
                    return {
                        step: t,
                        points: r
                    }
                }, y.prototype._getNAFPoints = function(t) {
                    if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
                    for (var e = [this], r = (1 << t) - 1, n = 1 === r ? null : this.dbl(), i = 1; i < r; i++) e[i] = e[i - 1].add(n);
                    return {
                        wnd: t,
                        points: e
                    }
                }, y.prototype._getBeta = function() {
                    return null
                }, y.prototype.dblp = function(t) {
                    for (var e = this, r = 0; r < t; r++) e = e.dbl();
                    return e
                };
                var v = o((function(t) {
                        "function" === typeof Object.create ? t.exports = function(t, e) {
                            e && (t.super_ = e, t.prototype = Object.create(e.prototype, {
                                constructor: {
                                    value: t,
                                    enumerable: !1,
                                    writable: !0,
                                    configurable: !0
                                }
                            }))
                        } : t.exports = function(t, e) {
                            if (e) {
                                t.super_ = e;
                                var r = function() {};
                                r.prototype = e.prototype, t.prototype = new r, t.prototype.constructor = t
                            }
                        }
                    })),
                    w = l.assert;

                function _(t) {
                    g.call(this, "short", t), this.a = new i.a(t.a, 16).toRed(this.red), this.b = new i.a(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = 0 === this.a.fromRed().cmpn(0), this.threeA = 0 === this.a.fromRed().sub(this.p).cmpn(-3), this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4)
                }
                v(_, g);
                var M = _;

                function A(t, e, r, n) {
                    g.BasePoint.call(this, t, "affine"), null === e && null === r ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new i.a(e, 16), this.y = new i.a(r, 16), n && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1)
                }

                function S(t, e, r, n) {
                    g.BasePoint.call(this, t, "jacobian"), null === e && null === r && null === n ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new i.a(0)) : (this.x = new i.a(e, 16), this.y = new i.a(r, 16), this.z = new i.a(n, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one
                }
                _.prototype._getEndomorphism = function(t) {
                    if (this.zeroA && this.g && this.n && 1 === this.p.modn(3)) {
                        var e, r, n;
                        if (t.beta) e = new i.a(t.beta, 16).toRed(this.red);
                        else {
                            var s = this._getEndoRoots(this.p);
                            e = s[0].cmp(s[1]) < 0 ? s[0] : s[1], e = e.toRed(this.red)
                        }
                        if (t.lambda) r = new i.a(t.lambda, 16);
                        else {
                            var a = this._getEndoRoots(this.n);
                            0 === this.g.mul(a[0]).x.cmp(this.g.x.redMul(e)) ? r = a[0] : (r = a[1], w(0 === this.g.mul(r).x.cmp(this.g.x.redMul(e))))
                        }
                        return n = t.basis ? t.basis.map((function(t) {
                            return {
                                a: new i.a(t.a, 16),
                                b: new i.a(t.b, 16)
                            }
                        })) : this._getEndoBasis(r), {
                            beta: e,
                            lambda: r,
                            basis: n
                        }
                    }
                }, _.prototype._getEndoRoots = function(t) {
                    var e = t === this.p ? this.red : i.a.mont(t),
                        r = new i.a(2).toRed(e).redInvm(),
                        n = r.redNeg(),
                        s = new i.a(3).toRed(e).redNeg().redSqrt().redMul(r),
                        a = n.redAdd(s).fromRed(),
                        o = n.redSub(s).fromRed();
                    return [a, o]
                }, _.prototype._getEndoBasis = function(t) {
                    var e, r, n, s, a, o, u, h, f, c = this.n.ushrn(Math.floor(this.n.bitLength() / 2)),
                        l = t,
                        d = this.n.clone(),
                        p = new i.a(1),
                        m = new i.a(0),
                        b = new i.a(0),
                        g = new i.a(1),
                        y = 0;
                    while (0 !== l.cmpn(0)) {
                        var v = d.div(l);
                        h = d.sub(v.mul(l)), f = b.sub(v.mul(p));
                        var w = g.sub(v.mul(m));
                        if (!n && h.cmp(c) < 0) e = u.neg(), r = p, n = h.neg(), s = f;
                        else if (n && 2 === ++y) break;
                        u = h, d = l, l = h, b = p, p = f, g = m, m = w
                    }
                    a = h.neg(), o = f;
                    var _ = n.sqr().add(s.sqr()),
                        M = a.sqr().add(o.sqr());
                    return M.cmp(_) >= 0 && (a = e, o = r), n.negative && (n = n.neg(), s = s.neg()), a.negative && (a = a.neg(), o = o.neg()), [{
                        a: n,
                        b: s
                    }, {
                        a: a,
                        b: o
                    }]
                }, _.prototype._endoSplit = function(t) {
                    var e = this.endo.basis,
                        r = e[0],
                        n = e[1],
                        i = n.b.mul(t).divRound(this.n),
                        s = r.b.neg().mul(t).divRound(this.n),
                        a = i.mul(r.a),
                        o = s.mul(n.a),
                        u = i.mul(r.b),
                        h = s.mul(n.b),
                        f = t.sub(a).sub(o),
                        c = u.add(h).neg();
                    return {
                        k1: f,
                        k2: c
                    }
                }, _.prototype.pointFromX = function(t, e) {
                    t = new i.a(t, 16), t.red || (t = t.toRed(this.red));
                    var r = t.redSqr().redMul(t).redIAdd(t.redMul(this.a)).redIAdd(this.b),
                        n = r.redSqrt();
                    if (0 !== n.redSqr().redSub(r).cmp(this.zero)) throw new Error("invalid point");
                    var s = n.fromRed().isOdd();
                    return (e && !s || !e && s) && (n = n.redNeg()), this.point(t, n)
                }, _.prototype.validate = function(t) {
                    if (t.inf) return !0;
                    var e = t.x,
                        r = t.y,
                        n = this.a.redMul(e),
                        i = e.redSqr().redMul(e).redIAdd(n).redIAdd(this.b);
                    return 0 === r.redSqr().redISub(i).cmpn(0)
                }, _.prototype._endoWnafMulAdd = function(t, e, r) {
                    for (var n = this._endoWnafT1, i = this._endoWnafT2, s = 0; s < t.length; s++) {
                        var a = this._endoSplit(e[s]),
                            o = t[s],
                            u = o._getBeta();
                        a.k1.negative && (a.k1.ineg(), o = o.neg(!0)), a.k2.negative && (a.k2.ineg(), u = u.neg(!0)), n[2 * s] = o, n[2 * s + 1] = u, i[2 * s] = a.k1, i[2 * s + 1] = a.k2
                    }
                    for (var h = this._wnafMulAdd(1, n, i, 2 * s, r), f = 0; f < 2 * s; f++) n[f] = null, i[f] = null;
                    return h
                }, v(A, g.BasePoint), _.prototype.point = function(t, e, r) {
                    return new A(this, t, e, r)
                }, _.prototype.pointFromJSON = function(t, e) {
                    return A.fromJSON(this, t, e)
                }, A.prototype._getBeta = function() {
                    if (this.curve.endo) {
                        var t = this.precomputed;
                        if (t && t.beta) return t.beta;
                        var e = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
                        if (t) {
                            var r = this.curve,
                                n = function(t) {
                                    return r.point(t.x.redMul(r.endo.beta), t.y)
                                };
                            t.beta = e, e.precomputed = {
                                beta: null,
                                naf: t.naf && {
                                    wnd: t.naf.wnd,
                                    points: t.naf.points.map(n)
                                },
                                doubles: t.doubles && {
                                    step: t.doubles.step,
                                    points: t.doubles.points.map(n)
                                }
                            }
                        }
                        return e
                    }
                }, A.prototype.toJSON = function() {
                    return this.precomputed ? [this.x, this.y, this.precomputed && {
                        doubles: this.precomputed.doubles && {
                            step: this.precomputed.doubles.step,
                            points: this.precomputed.doubles.points.slice(1)
                        },
                        naf: this.precomputed.naf && {
                            wnd: this.precomputed.naf.wnd,
                            points: this.precomputed.naf.points.slice(1)
                        }
                    }] : [this.x, this.y]
                }, A.fromJSON = function(t, e, r) {
                    "string" === typeof e && (e = JSON.parse(e));
                    var n = t.point(e[0], e[1], r);
                    if (!e[2]) return n;

                    function i(e) {
                        return t.point(e[0], e[1], r)
                    }
                    var s = e[2];
                    return n.precomputed = {
                        beta: null,
                        doubles: s.doubles && {
                            step: s.doubles.step,
                            points: [n].concat(s.doubles.points.map(i))
                        },
                        naf: s.naf && {
                            wnd: s.naf.wnd,
                            points: [n].concat(s.naf.points.map(i))
                        }
                    }, n
                }, A.prototype.inspect = function() {
                    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">"
                }, A.prototype.isInfinity = function() {
                    return this.inf
                }, A.prototype.add = function(t) {
                    if (this.inf) return t;
                    if (t.inf) return this;
                    if (this.eq(t)) return this.dbl();
                    if (this.neg().eq(t)) return this.curve.point(null, null);
                    if (0 === this.x.cmp(t.x)) return this.curve.point(null, null);
                    var e = this.y.redSub(t.y);
                    0 !== e.cmpn(0) && (e = e.redMul(this.x.redSub(t.x).redInvm()));
                    var r = e.redSqr().redISub(this.x).redISub(t.x),
                        n = e.redMul(this.x.redSub(r)).redISub(this.y);
                    return this.curve.point(r, n)
                }, A.prototype.dbl = function() {
                    if (this.inf) return this;
                    var t = this.y.redAdd(this.y);
                    if (0 === t.cmpn(0)) return this.curve.point(null, null);
                    var e = this.curve.a,
                        r = this.x.redSqr(),
                        n = t.redInvm(),
                        i = r.redAdd(r).redIAdd(r).redIAdd(e).redMul(n),
                        s = i.redSqr().redISub(this.x.redAdd(this.x)),
                        a = i.redMul(this.x.redSub(s)).redISub(this.y);
                    return this.curve.point(s, a)
                }, A.prototype.getX = function() {
                    return this.x.fromRed()
                }, A.prototype.getY = function() {
                    return this.y.fromRed()
                }, A.prototype.mul = function(t) {
                    return t = new i.a(t, 16), this.isInfinity() ? this : this._hasDoubles(t) ? this.curve._fixedNafMul(this, t) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [t]) : this.curve._wnafMul(this, t)
                }, A.prototype.mulAdd = function(t, e, r) {
                    var n = [this, e],
                        i = [t, r];
                    return this.curve.endo ? this.curve._endoWnafMulAdd(n, i) : this.curve._wnafMulAdd(1, n, i, 2)
                }, A.prototype.jmulAdd = function(t, e, r) {
                    var n = [this, e],
                        i = [t, r];
                    return this.curve.endo ? this.curve._endoWnafMulAdd(n, i, !0) : this.curve._wnafMulAdd(1, n, i, 2, !0)
                }, A.prototype.eq = function(t) {
                    return this === t || this.inf === t.inf && (this.inf || 0 === this.x.cmp(t.x) && 0 === this.y.cmp(t.y))
                }, A.prototype.neg = function(t) {
                    if (this.inf) return this;
                    var e = this.curve.point(this.x, this.y.redNeg());
                    if (t && this.precomputed) {
                        var r = this.precomputed,
                            n = function(t) {
                                return t.neg()
                            };
                        e.precomputed = {
                            naf: r.naf && {
                                wnd: r.naf.wnd,
                                points: r.naf.points.map(n)
                            },
                            doubles: r.doubles && {
                                step: r.doubles.step,
                                points: r.doubles.points.map(n)
                            }
                        }
                    }
                    return e
                }, A.prototype.toJ = function() {
                    if (this.inf) return this.curve.jpoint(null, null, null);
                    var t = this.curve.jpoint(this.x, this.y, this.curve.one);
                    return t
                }, v(S, g.BasePoint), _.prototype.jpoint = function(t, e, r) {
                    return new S(this, t, e, r)
                }, S.prototype.toP = function() {
                    if (this.isInfinity()) return this.curve.point(null, null);
                    var t = this.z.redInvm(),
                        e = t.redSqr(),
                        r = this.x.redMul(e),
                        n = this.y.redMul(e).redMul(t);
                    return this.curve.point(r, n)
                }, S.prototype.neg = function() {
                    return this.curve.jpoint(this.x, this.y.redNeg(), this.z)
                }, S.prototype.add = function(t) {
                    if (this.isInfinity()) return t;
                    if (t.isInfinity()) return this;
                    var e = t.z.redSqr(),
                        r = this.z.redSqr(),
                        n = this.x.redMul(e),
                        i = t.x.redMul(r),
                        s = this.y.redMul(e.redMul(t.z)),
                        a = t.y.redMul(r.redMul(this.z)),
                        o = n.redSub(i),
                        u = s.redSub(a);
                    if (0 === o.cmpn(0)) return 0 !== u.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
                    var h = o.redSqr(),
                        f = h.redMul(o),
                        c = n.redMul(h),
                        l = u.redSqr().redIAdd(f).redISub(c).redISub(c),
                        d = u.redMul(c.redISub(l)).redISub(s.redMul(f)),
                        p = this.z.redMul(t.z).redMul(o);
                    return this.curve.jpoint(l, d, p)
                }, S.prototype.mixedAdd = function(t) {
                    if (this.isInfinity()) return t.toJ();
                    if (t.isInfinity()) return this;
                    var e = this.z.redSqr(),
                        r = this.x,
                        n = t.x.redMul(e),
                        i = this.y,
                        s = t.y.redMul(e).redMul(this.z),
                        a = r.redSub(n),
                        o = i.redSub(s);
                    if (0 === a.cmpn(0)) return 0 !== o.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
                    var u = a.redSqr(),
                        h = u.redMul(a),
                        f = r.redMul(u),
                        c = o.redSqr().redIAdd(h).redISub(f).redISub(f),
                        l = o.redMul(f.redISub(c)).redISub(i.redMul(h)),
                        d = this.z.redMul(a);
                    return this.curve.jpoint(c, l, d)
                }, S.prototype.dblp = function(t) {
                    if (0 === t) return this;
                    if (this.isInfinity()) return this;
                    if (!t) return this.dbl();
                    var e;
                    if (this.curve.zeroA || this.curve.threeA) {
                        var r = this;
                        for (e = 0; e < t; e++) r = r.dbl();
                        return r
                    }
                    var n = this.curve.a,
                        i = this.curve.tinv,
                        s = this.x,
                        a = this.y,
                        o = this.z,
                        u = o.redSqr().redSqr(),
                        h = a.redAdd(a);
                    for (e = 0; e < t; e++) {
                        var f = s.redSqr(),
                            c = h.redSqr(),
                            l = c.redSqr(),
                            d = f.redAdd(f).redIAdd(f).redIAdd(n.redMul(u)),
                            p = s.redMul(c),
                            m = d.redSqr().redISub(p.redAdd(p)),
                            b = p.redISub(m),
                            g = d.redMul(b);
                        g = g.redIAdd(g).redISub(l);
                        var y = h.redMul(o);
                        e + 1 < t && (u = u.redMul(l)), s = m, o = y, h = g
                    }
                    return this.curve.jpoint(s, h.redMul(i), o)
                }, S.prototype.dbl = function() {
                    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl()
                }, S.prototype._zeroDbl = function() {
                    var t, e, r;
                    if (this.zOne) {
                        var n = this.x.redSqr(),
                            i = this.y.redSqr(),
                            s = i.redSqr(),
                            a = this.x.redAdd(i).redSqr().redISub(n).redISub(s);
                        a = a.redIAdd(a);
                        var o = n.redAdd(n).redIAdd(n),
                            u = o.redSqr().redISub(a).redISub(a),
                            h = s.redIAdd(s);
                        h = h.redIAdd(h), h = h.redIAdd(h), t = u, e = o.redMul(a.redISub(u)).redISub(h), r = this.y.redAdd(this.y)
                    } else {
                        var f = this.x.redSqr(),
                            c = this.y.redSqr(),
                            l = c.redSqr(),
                            d = this.x.redAdd(c).redSqr().redISub(f).redISub(l);
                        d = d.redIAdd(d);
                        var p = f.redAdd(f).redIAdd(f),
                            m = p.redSqr(),
                            b = l.redIAdd(l);
                        b = b.redIAdd(b), b = b.redIAdd(b), t = m.redISub(d).redISub(d), e = p.redMul(d.redISub(t)).redISub(b), r = this.y.redMul(this.z), r = r.redIAdd(r)
                    }
                    return this.curve.jpoint(t, e, r)
                }, S.prototype._threeDbl = function() {
                    var t, e, r;
                    if (this.zOne) {
                        var n = this.x.redSqr(),
                            i = this.y.redSqr(),
                            s = i.redSqr(),
                            a = this.x.redAdd(i).redSqr().redISub(n).redISub(s);
                        a = a.redIAdd(a);
                        var o = n.redAdd(n).redIAdd(n).redIAdd(this.curve.a),
                            u = o.redSqr().redISub(a).redISub(a);
                        t = u;
                        var h = s.redIAdd(s);
                        h = h.redIAdd(h), h = h.redIAdd(h), e = o.redMul(a.redISub(u)).redISub(h), r = this.y.redAdd(this.y)
                    } else {
                        var f = this.z.redSqr(),
                            c = this.y.redSqr(),
                            l = this.x.redMul(c),
                            d = this.x.redSub(f).redMul(this.x.redAdd(f));
                        d = d.redAdd(d).redIAdd(d);
                        var p = l.redIAdd(l);
                        p = p.redIAdd(p);
                        var m = p.redAdd(p);
                        t = d.redSqr().redISub(m), r = this.y.redAdd(this.z).redSqr().redISub(c).redISub(f);
                        var b = c.redSqr();
                        b = b.redIAdd(b), b = b.redIAdd(b), b = b.redIAdd(b), e = d.redMul(p.redISub(t)).redISub(b)
                    }
                    return this.curve.jpoint(t, e, r)
                }, S.prototype._dbl = function() {
                    var t = this.curve.a,
                        e = this.x,
                        r = this.y,
                        n = this.z,
                        i = n.redSqr().redSqr(),
                        s = e.redSqr(),
                        a = r.redSqr(),
                        o = s.redAdd(s).redIAdd(s).redIAdd(t.redMul(i)),
                        u = e.redAdd(e);
                    u = u.redIAdd(u);
                    var h = u.redMul(a),
                        f = o.redSqr().redISub(h.redAdd(h)),
                        c = h.redISub(f),
                        l = a.redSqr();
                    l = l.redIAdd(l), l = l.redIAdd(l), l = l.redIAdd(l);
                    var d = o.redMul(c).redISub(l),
                        p = r.redAdd(r).redMul(n);
                    return this.curve.jpoint(f, d, p)
                }, S.prototype.trpl = function() {
                    if (!this.curve.zeroA) return this.dbl().add(this);
                    var t = this.x.redSqr(),
                        e = this.y.redSqr(),
                        r = this.z.redSqr(),
                        n = e.redSqr(),
                        i = t.redAdd(t).redIAdd(t),
                        s = i.redSqr(),
                        a = this.x.redAdd(e).redSqr().redISub(t).redISub(n);
                    a = a.redIAdd(a), a = a.redAdd(a).redIAdd(a), a = a.redISub(s);
                    var o = a.redSqr(),
                        u = n.redIAdd(n);
                    u = u.redIAdd(u), u = u.redIAdd(u), u = u.redIAdd(u);
                    var h = i.redIAdd(a).redSqr().redISub(s).redISub(o).redISub(u),
                        f = e.redMul(h);
                    f = f.redIAdd(f), f = f.redIAdd(f);
                    var c = this.x.redMul(o).redISub(f);
                    c = c.redIAdd(c), c = c.redIAdd(c);
                    var l = this.y.redMul(h.redMul(u.redISub(h)).redISub(a.redMul(o)));
                    l = l.redIAdd(l), l = l.redIAdd(l), l = l.redIAdd(l);
                    var d = this.z.redAdd(a).redSqr().redISub(r).redISub(o);
                    return this.curve.jpoint(c, l, d)
                }, S.prototype.mul = function(t, e) {
                    return t = new i.a(t, e), this.curve._wnafMul(this, t)
                }, S.prototype.eq = function(t) {
                    if ("affine" === t.type) return this.eq(t.toJ());
                    if (this === t) return !0;
                    var e = this.z.redSqr(),
                        r = t.z.redSqr();
                    if (0 !== this.x.redMul(r).redISub(t.x.redMul(e)).cmpn(0)) return !1;
                    var n = e.redMul(this.z),
                        i = r.redMul(t.z);
                    return 0 === this.y.redMul(i).redISub(t.y.redMul(n)).cmpn(0)
                }, S.prototype.eqXToP = function(t) {
                    var e = this.z.redSqr(),
                        r = t.toRed(this.curve.red).redMul(e);
                    if (0 === this.x.cmp(r)) return !0;
                    for (var n = t.clone(), i = this.curve.redN.redMul(e);;) {
                        if (n.iadd(this.curve.n), n.cmp(this.curve.p) >= 0) return !1;
                        if (r.redIAdd(i), 0 === this.x.cmp(r)) return !0
                    }
                }, S.prototype.inspect = function() {
                    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">"
                }, S.prototype.isInfinity = function() {
                    return 0 === this.z.cmpn(0)
                };
                var x = o((function(t, e) {
                        var r = e;
                        r.base = g, r.short = M, r.mont = null, r.edwards = null
                    })),
                    E = o((function(t, e) {
                        var r, n = e,
                            i = l.assert;

                        function s(t) {
                            "short" === t.type ? this.curve = new x.short(t) : "edwards" === t.type ? this.curve = new x.edwards(t) : this.curve = new x.mont(t), this.g = this.curve.g, this.n = this.curve.n, this.hash = t.hash, i(this.g.validate(), "Invalid curve"), i(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O")
                        }

                        function o(t, e) {
                            Object.defineProperty(n, t, {
                                configurable: !0,
                                enumerable: !0,
                                get: function() {
                                    var r = new s(e);
                                    return Object.defineProperty(n, t, {
                                        configurable: !0,
                                        enumerable: !0,
                                        value: r
                                    }), r
                                }
                            })
                        }
                        n.PresetCurve = s, o("p192", {
                            type: "short",
                            prime: "p192",
                            p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
                            a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
                            b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
                            n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
                            hash: a.a.sha256,
                            gRed: !1,
                            g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]
                        }), o("p224", {
                            type: "short",
                            prime: "p224",
                            p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
                            a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
                            b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
                            n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
                            hash: a.a.sha256,
                            gRed: !1,
                            g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]
                        }), o("p256", {
                            type: "short",
                            prime: null,
                            p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
                            a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
                            b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
                            n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
                            hash: a.a.sha256,
                            gRed: !1,
                            g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]
                        }), o("p384", {
                            type: "short",
                            prime: null,
                            p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
                            a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
                            b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
                            n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
                            hash: a.a.sha384,
                            gRed: !1,
                            g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]
                        }), o("p521", {
                            type: "short",
                            prime: null,
                            p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
                            a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
                            b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
                            n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
                            hash: a.a.sha512,
                            gRed: !1,
                            g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]
                        }), o("curve25519", {
                            type: "mont",
                            prime: "p25519",
                            p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
                            a: "76d06",
                            b: "1",
                            n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
                            hash: a.a.sha256,
                            gRed: !1,
                            g: ["9"]
                        }), o("ed25519", {
                            type: "edwards",
                            prime: "p25519",
                            p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
                            a: "-1",
                            c: "1",
                            d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
                            n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
                            hash: a.a.sha256,
                            gRed: !1,
                            g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"]
                        });
                        try {
                            r = null.crash()
                        } catch (u) {
                            r = void 0
                        }
                        o("secp256k1", {
                            type: "short",
                            prime: "k256",
                            p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
                            a: "0",
                            b: "7",
                            n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
                            h: "1",
                            hash: a.a.sha256,
                            beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
                            lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
                            basis: [{
                                a: "3086d221a7d46bcde86c90e49284eb15",
                                b: "-e4437ed6010e88286f547fa90abfe4c3"
                            }, {
                                a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
                                b: "3086d221a7d46bcde86c90e49284eb15"
                            }],
                            gRed: !1,
                            g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", r]
                        })
                    }));

                function k(t) {
                    if (!(this instanceof k)) return new k(t);
                    this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
                    var e = c.toArray(t.entropy, t.entropyEnc || "hex"),
                        r = c.toArray(t.nonce, t.nonceEnc || "hex"),
                        n = c.toArray(t.pers, t.persEnc || "hex");
                    h(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, r, n)
                }
                var R = k;
                k.prototype._init = function(t, e, r) {
                    var n = t.concat(e).concat(r);
                    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
                    for (var i = 0; i < this.V.length; i++) this.K[i] = 0, this.V[i] = 1;
                    this._update(n), this._reseed = 1, this.reseedInterval = 281474976710656
                }, k.prototype._hmac = function() {
                    return new a.a.hmac(this.hash, this.K)
                }, k.prototype._update = function(t) {
                    var e = this._hmac().update(this.V).update([0]);
                    t && (e = e.update(t)), this.K = e.digest(), this.V = this._hmac().update(this.V).digest(), t && (this.K = this._hmac().update(this.V).update([1]).update(t).digest(), this.V = this._hmac().update(this.V).digest())
                }, k.prototype.reseed = function(t, e, r, n) {
                    "string" !== typeof e && (n = r, r = e, e = null), t = c.toArray(t, e), r = c.toArray(r, n), h(t.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(t.concat(r || [])), this._reseed = 1
                }, k.prototype.generate = function(t, e, r, n) {
                    if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
                    "string" !== typeof e && (n = r, r = e, e = null), r && (r = c.toArray(r, n || "hex"), this._update(r));
                    var i = [];
                    while (i.length < t) this.V = this._hmac().update(this.V).digest(), i = i.concat(this.V);
                    var s = i.slice(0, t);
                    return this._update(r), this._reseed++, c.encode(s, e)
                };
                var O = l.assert;

                function I(t, e) {
                    this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc)
                }
                var P = I;
                I.fromPublic = function(t, e, r) {
                    return e instanceof I ? e : new I(t, {
                        pub: e,
                        pubEnc: r
                    })
                }, I.fromPrivate = function(t, e, r) {
                    return e instanceof I ? e : new I(t, {
                        priv: e,
                        privEnc: r
                    })
                }, I.prototype.validate = function() {
                    var t = this.getPublic();
                    return t.isInfinity() ? {
                        result: !1,
                        reason: "Invalid public key"
                    } : t.validate() ? t.mul(this.ec.curve.n).isInfinity() ? {
                        result: !0,
                        reason: null
                    } : {
                        result: !1,
                        reason: "Public key * N != O"
                    } : {
                        result: !1,
                        reason: "Public key is not a point"
                    }
                }, I.prototype.getPublic = function(t, e) {
                    return "string" === typeof t && (e = t, t = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), e ? this.pub.encode(e, t) : this.pub
                }, I.prototype.getPrivate = function(t) {
                    return "hex" === t ? this.priv.toString(16, 2) : this.priv
                }, I.prototype._importPrivate = function(t, e) {
                    this.priv = new i.a(t, e || 16), this.priv = this.priv.umod(this.ec.curve.n)
                }, I.prototype._importPublic = function(t, e) {
                    if (t.x || t.y) return "mont" === this.ec.curve.type ? O(t.x, "Need x coordinate") : "short" !== this.ec.curve.type && "edwards" !== this.ec.curve.type || O(t.x && t.y, "Need both x and y coordinate"), void(this.pub = this.ec.curve.point(t.x, t.y));
                    this.pub = this.ec.curve.decodePoint(t, e)
                }, I.prototype.derive = function(t) {
                    return t.validate() || O(t.validate(), "public point not validated"), t.mul(this.priv).getX()
                }, I.prototype.sign = function(t, e, r) {
                    return this.ec.sign(t, this, e, r)
                }, I.prototype.verify = function(t, e) {
                    return this.ec.verify(t, e, this)
                }, I.prototype.inspect = function() {
                    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >"
                };
                var T = l.assert;

                function N(t, e) {
                    if (t instanceof N) return t;
                    this._importDER(t, e) || (T(t.r && t.s, "Signature without r or s"), this.r = new i.a(t.r, 16), this.s = new i.a(t.s, 16), void 0 === t.recoveryParam ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam)
                }
                var j = N;

                function C() {
                    this.place = 0
                }

                function z(t, e) {
                    var r = t[e.place++];
                    if (!(128 & r)) return r;
                    var n = 15 & r;
                    if (0 === n || n > 4) return !1;
                    for (var i = 0, s = 0, a = e.place; s < n; s++, a++) i <<= 8, i |= t[a], i >>>= 0;
                    return !(i <= 127) && (e.place = a, i)
                }

                function D(t) {
                    var e = 0,
                        r = t.length - 1;
                    while (!t[e] && !(128 & t[e + 1]) && e < r) e++;
                    return 0 === e ? t : t.slice(e)
                }

                function L(t, e) {
                    if (e < 128) t.push(e);
                    else {
                        var r = 1 + (Math.log(e) / Math.LN2 >>> 3);
                        t.push(128 | r);
                        while (--r) t.push(e >>> (r << 3) & 255);
                        t.push(e)
                    }
                }
                N.prototype._importDER = function(t, e) {
                    t = l.toArray(t, e);
                    var r = new C;
                    if (48 !== t[r.place++]) return !1;
                    var n = z(t, r);
                    if (!1 === n) return !1;
                    if (n + r.place !== t.length) return !1;
                    if (2 !== t[r.place++]) return !1;
                    var s = z(t, r);
                    if (!1 === s) return !1;
                    var a = t.slice(r.place, s + r.place);
                    if (r.place += s, 2 !== t[r.place++]) return !1;
                    var o = z(t, r);
                    if (!1 === o) return !1;
                    if (t.length !== o + r.place) return !1;
                    var u = t.slice(r.place, o + r.place);
                    if (0 === a[0]) {
                        if (!(128 & a[1])) return !1;
                        a = a.slice(1)
                    }
                    if (0 === u[0]) {
                        if (!(128 & u[1])) return !1;
                        u = u.slice(1)
                    }
                    return this.r = new i.a(a), this.s = new i.a(u), this.recoveryParam = null, !0
                }, N.prototype.toDER = function(t) {
                    var e = this.r.toArray(),
                        r = this.s.toArray();
                    128 & e[0] && (e = [0].concat(e)), 128 & r[0] && (r = [0].concat(r)), e = D(e), r = D(r);
                    while (!r[0] && !(128 & r[1])) r = r.slice(1);
                    var n = [2];
                    L(n, e.length), n = n.concat(e), n.push(2), L(n, r.length);
                    var i = n.concat(r),
                        s = [48];
                    return L(s, i.length), s = s.concat(i), l.encode(s, t)
                };
                var F = function() {
                        throw new Error("unsupported")
                    },
                    B = l.assert;

                function $(t) {
                    if (!(this instanceof $)) return new $(t);
                    "string" === typeof t && (B(Object.prototype.hasOwnProperty.call(E, t), "Unknown curve " + t), t = E[t]), t instanceof E.PresetCurve && (t = {
                        curve: t
                    }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash
                }
                var U = $;
                $.prototype.keyPair = function(t) {
                    return new P(this, t)
                }, $.prototype.keyFromPrivate = function(t, e) {
                    return P.fromPrivate(this, t, e)
                }, $.prototype.keyFromPublic = function(t, e) {
                    return P.fromPublic(this, t, e)
                }, $.prototype.genKeyPair = function(t) {
                    t || (t = {});
                    for (var e = new R({
                            hash: this.hash,
                            pers: t.pers,
                            persEnc: t.persEnc || "utf8",
                            entropy: t.entropy || F(this.hash.hmacStrength),
                            entropyEnc: t.entropy && t.entropyEnc || "utf8",
                            nonce: this.n.toArray()
                        }), r = this.n.byteLength(), n = this.n.sub(new i.a(2));;) {
                        var s = new i.a(e.generate(r));
                        if (!(s.cmp(n) > 0)) return s.iaddn(1), this.keyFromPrivate(s)
                    }
                }, $.prototype._truncateToN = function(t, e) {
                    var r = 8 * t.byteLength() - this.n.bitLength();
                    return r > 0 && (t = t.ushrn(r)), !e && t.cmp(this.n) >= 0 ? t.sub(this.n) : t
                }, $.prototype.sign = function(t, e, r, n) {
                    "object" === typeof r && (n = r, r = null), n || (n = {}), e = this.keyFromPrivate(e, r), t = this._truncateToN(new i.a(t, 16));
                    for (var s = this.n.byteLength(), a = e.getPrivate().toArray("be", s), o = t.toArray("be", s), u = new R({
                            hash: this.hash,
                            entropy: a,
                            nonce: o,
                            pers: n.pers,
                            persEnc: n.persEnc || "utf8"
                        }), h = this.n.sub(new i.a(1)), f = 0;; f++) {
                        var c = n.k ? n.k(f) : new i.a(u.generate(this.n.byteLength()));
                        if (c = this._truncateToN(c, !0), !(c.cmpn(1) <= 0 || c.cmp(h) >= 0)) {
                            var l = this.g.mul(c);
                            if (!l.isInfinity()) {
                                var d = l.getX(),
                                    p = d.umod(this.n);
                                if (0 !== p.cmpn(0)) {
                                    var m = c.invm(this.n).mul(p.mul(e.getPrivate()).iadd(t));
                                    if (m = m.umod(this.n), 0 !== m.cmpn(0)) {
                                        var b = (l.getY().isOdd() ? 1 : 0) | (0 !== d.cmp(p) ? 2 : 0);
                                        return n.canonical && m.cmp(this.nh) > 0 && (m = this.n.sub(m), b ^= 1), new j({
                                            r: p,
                                            s: m,
                                            recoveryParam: b
                                        })
                                    }
                                }
                            }
                        }
                    }
                }, $.prototype.verify = function(t, e, r, n) {
                    t = this._truncateToN(new i.a(t, 16)), r = this.keyFromPublic(r, n), e = new j(e, "hex");
                    var s = e.r,
                        a = e.s;
                    if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0) return !1;
                    if (a.cmpn(1) < 0 || a.cmp(this.n) >= 0) return !1;
                    var o, u = a.invm(this.n),
                        h = u.mul(t).umod(this.n),
                        f = u.mul(s).umod(this.n);
                    return this.curve._maxwellTrick ? (o = this.g.jmulAdd(h, r.getPublic(), f), !o.isInfinity() && o.eqXToP(s)) : (o = this.g.mulAdd(h, r.getPublic(), f), !o.isInfinity() && 0 === o.getX().umod(this.n).cmp(s))
                }, $.prototype.recoverPubKey = function(t, e, r, n) {
                    B((3 & r) === r, "The recovery param is more than two bits"), e = new j(e, n);
                    var s = this.n,
                        a = new i.a(t),
                        o = e.r,
                        u = e.s,
                        h = 1 & r,
                        f = r >> 1;
                    if (o.cmp(this.curve.p.umod(this.curve.n)) >= 0 && f) throw new Error("Unable to find sencond key candinate");
                    o = f ? this.curve.pointFromX(o.add(this.curve.n), h) : this.curve.pointFromX(o, h);
                    var c = e.r.invm(s),
                        l = s.sub(a).mul(c).umod(s),
                        d = u.mul(c).umod(s);
                    return this.g.mulAdd(l, o, d)
                }, $.prototype.getKeyRecoveryParam = function(t, e, r, n) {
                    if (e = new j(e, n), null !== e.recoveryParam) return e.recoveryParam;
                    for (var i = 0; i < 4; i++) {
                        var s;
                        try {
                            s = this.recoverPubKey(t, e, i)
                        } catch (t) {
                            continue
                        }
                        if (s.eq(r)) return i
                    }
                    throw new Error("Unable to find valid recovery factor")
                };
                var q = o((function(t, e) {
                        var r = e;
                        r.version = {
                            version: "6.5.4"
                        }.version, r.utils = l, r.rand = function() {
                            throw new Error("unsupported")
                        }, r.curve = x, r.curves = E, r.ec = U, r.eddsa = null
                    })),
                    K = q.ec
            }).call(this, r("c8ba"))
        },
        "13e2": function(t, e, r) {
            "use strict";
            var n = r("c3c0"),
                i = r("edc9"),
                s = r("aa56"),
                a = n.rotl32,
                o = n.sum32,
                u = n.sum32_5,
                h = s.ft_1,
                f = i.BlockHash,
                c = [1518500249, 1859775393, 2400959708, 3395469782];

            function l() {
                if (!(this instanceof l)) return new l;
                f.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80)
            }
            n.inherits(l, f), t.exports = l, l.blockSize = 512, l.outSize = 160, l.hmacStrength = 80, l.padLength = 64, l.prototype._update = function(t, e) {
                for (var r = this.W, n = 0; n < 16; n++) r[n] = t[e + n];
                for (; n < r.length; n++) r[n] = a(r[n - 3] ^ r[n - 8] ^ r[n - 14] ^ r[n - 16], 1);
                var i = this.h[0],
                    s = this.h[1],
                    f = this.h[2],
                    l = this.h[3],
                    d = this.h[4];
                for (n = 0; n < r.length; n++) {
                    var p = ~~(n / 20),
                        m = u(a(i, 5), h(p, s, f, l), d, r[n], c[p]);
                    d = l, l = f, f = a(s, 30), s = i, i = m
                }
                this.h[0] = o(this.h[0], i), this.h[1] = o(this.h[1], s), this.h[2] = o(this.h[2], f), this.h[3] = o(this.h[3], l), this.h[4] = o(this.h[4], d)
            }, l.prototype._digest = function(t) {
                return "hex" === t ? n.toHex32(this.h, "big") : n.split32(this.h, "big")
            }
        },
        "14c5": function(t, e, r) {
            "use strict";
            r.r(e), r.d(e, "Deflate", (function() {
                return es
            })), r.d(e, "Inflate", (function() {
                return ss
            })), r.d(e, "constants", (function() {
                return hs
            })), r.d(e, "deflate", (function() {
                return rs
            })), r.d(e, "deflateRaw", (function() {
                return ns
            })), r.d(e, "gzip", (function() {
                return is
            })), r.d(e, "inflate", (function() {
                return as
            })), r.d(e, "inflateRaw", (function() {
                return os
            })), r.d(e, "ungzip", (function() {
                return us
            }));
            /*! pako 2.0.3 https://github.com/nodeca/pako @license (MIT AND Zlib) */
            const n = 4,
                i = 0,
                s = 1,
                a = 2;

            function o(t) {
                let e = t.length;
                while (--e >= 0) t[e] = 0
            }
            const u = 0,
                h = 1,
                f = 2,
                c = 3,
                l = 258,
                d = 29,
                p = 256,
                m = p + 1 + d,
                b = 30,
                g = 19,
                y = 2 * m + 1,
                v = 15,
                w = 16,
                _ = 7,
                M = 256,
                A = 16,
                S = 17,
                x = 18,
                E = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]),
                k = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]),
                R = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]),
                O = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
                I = 512,
                P = new Array(2 * (m + 2));
            o(P);
            const T = new Array(2 * b);
            o(T);
            const N = new Array(I);
            o(N);
            const j = new Array(l - c + 1);
            o(j);
            const C = new Array(d);
            o(C);
            const z = new Array(b);

            function D(t, e, r, n, i) {
                this.static_tree = t, this.extra_bits = e, this.extra_base = r, this.elems = n, this.max_length = i, this.has_stree = t && t.length
            }
            let L, F, B;

            function $(t, e) {
                this.dyn_tree = t, this.max_code = 0, this.stat_desc = e
            }
            o(z);
            const U = t => t < 256 ? N[t] : N[256 + (t >>> 7)],
                q = (t, e) => {
                    t.pending_buf[t.pending++] = 255 & e, t.pending_buf[t.pending++] = e >>> 8 & 255
                },
                K = (t, e, r) => {
                    t.bi_valid > w - r ? (t.bi_buf |= e << t.bi_valid & 65535, q(t, t.bi_buf), t.bi_buf = e >> w - t.bi_valid, t.bi_valid += r - w) : (t.bi_buf |= e << t.bi_valid & 65535, t.bi_valid += r)
                },
                V = (t, e, r) => {
                    K(t, r[2 * e], r[2 * e + 1])
                },
                W = (t, e) => {
                    let r = 0;
                    do {
                        r |= 1 & t, t >>>= 1, r <<= 1
                    } while (--e > 0);
                    return r >>> 1
                },
                Z = t => {
                    16 === t.bi_valid ? (q(t, t.bi_buf), t.bi_buf = 0, t.bi_valid = 0) : t.bi_valid >= 8 && (t.pending_buf[t.pending++] = 255 & t.bi_buf, t.bi_buf >>= 8, t.bi_valid -= 8)
                },
                H = (t, e) => {
                    const r = e.dyn_tree,
                        n = e.max_code,
                        i = e.stat_desc.static_tree,
                        s = e.stat_desc.has_stree,
                        a = e.stat_desc.extra_bits,
                        o = e.stat_desc.extra_base,
                        u = e.stat_desc.max_length;
                    let h, f, c, l, d, p, m = 0;
                    for (l = 0; l <= v; l++) t.bl_count[l] = 0;
                    for (r[2 * t.heap[t.heap_max] + 1] = 0, h = t.heap_max + 1; h < y; h++) f = t.heap[h], l = r[2 * r[2 * f + 1] + 1] + 1, l > u && (l = u, m++), r[2 * f + 1] = l, f > n || (t.bl_count[l]++, d = 0, f >= o && (d = a[f - o]), p = r[2 * f], t.opt_len += p * (l + d), s && (t.static_len += p * (i[2 * f + 1] + d)));
                    if (0 !== m) {
                        do {
                            l = u - 1;
                            while (0 === t.bl_count[l]) l--;
                            t.bl_count[l]--, t.bl_count[l + 1] += 2, t.bl_count[u]--, m -= 2
                        } while (m > 0);
                        for (l = u; 0 !== l; l--) {
                            f = t.bl_count[l];
                            while (0 !== f) c = t.heap[--h], c > n || (r[2 * c + 1] !== l && (t.opt_len += (l - r[2 * c + 1]) * r[2 * c], r[2 * c + 1] = l), f--)
                        }
                    }
                },
                G = (t, e, r) => {
                    const n = new Array(v + 1);
                    let i, s, a = 0;
                    for (i = 1; i <= v; i++) n[i] = a = a + r[i - 1] << 1;
                    for (s = 0; s <= e; s++) {
                        let e = t[2 * s + 1];
                        0 !== e && (t[2 * s] = W(n[e]++, e))
                    }
                },
                J = () => {
                    let t, e, r, n, i;
                    const s = new Array(v + 1);
                    for (r = 0, n = 0; n < d - 1; n++)
                        for (C[n] = r, t = 0; t < 1 << E[n]; t++) j[r++] = n;
                    for (j[r - 1] = n, i = 0, n = 0; n < 16; n++)
                        for (z[n] = i, t = 0; t < 1 << k[n]; t++) N[i++] = n;
                    for (i >>= 7; n < b; n++)
                        for (z[n] = i << 7, t = 0; t < 1 << k[n] - 7; t++) N[256 + i++] = n;
                    for (e = 0; e <= v; e++) s[e] = 0;
                    t = 0;
                    while (t <= 143) P[2 * t + 1] = 8, t++, s[8]++;
                    while (t <= 255) P[2 * t + 1] = 9, t++, s[9]++;
                    while (t <= 279) P[2 * t + 1] = 7, t++, s[7]++;
                    while (t <= 287) P[2 * t + 1] = 8, t++, s[8]++;
                    for (G(P, m + 1, s), t = 0; t < b; t++) T[2 * t + 1] = 5, T[2 * t] = W(t, 5);
                    L = new D(P, E, p + 1, m, v), F = new D(T, k, 0, b, v), B = new D(new Array(0), R, 0, g, _)
                },
                X = t => {
                    let e;
                    for (e = 0; e < m; e++) t.dyn_ltree[2 * e] = 0;
                    for (e = 0; e < b; e++) t.dyn_dtree[2 * e] = 0;
                    for (e = 0; e < g; e++) t.bl_tree[2 * e] = 0;
                    t.dyn_ltree[2 * M] = 1, t.opt_len = t.static_len = 0, t.last_lit = t.matches = 0
                },
                Y = t => {
                    t.bi_valid > 8 ? q(t, t.bi_buf) : t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf), t.bi_buf = 0, t.bi_valid = 0
                },
                Q = (t, e, r, n) => {
                    Y(t), n && (q(t, r), q(t, ~r)), t.pending_buf.set(t.window.subarray(e, e + r), t.pending), t.pending += r
                },
                tt = (t, e, r, n) => {
                    const i = 2 * e,
                        s = 2 * r;
                    return t[i] < t[s] || t[i] === t[s] && n[e] <= n[r]
                },
                et = (t, e, r) => {
                    const n = t.heap[r];
                    let i = r << 1;
                    while (i <= t.heap_len) {
                        if (i < t.heap_len && tt(e, t.heap[i + 1], t.heap[i], t.depth) && i++, tt(e, n, t.heap[i], t.depth)) break;
                        t.heap[r] = t.heap[i], r = i, i <<= 1
                    }
                    t.heap[r] = n
                },
                rt = (t, e, r) => {
                    let n, i, s, a, o = 0;
                    if (0 !== t.last_lit)
                        do {
                            n = t.pending_buf[t.d_buf + 2 * o] << 8 | t.pending_buf[t.d_buf + 2 * o + 1], i = t.pending_buf[t.l_buf + o], o++, 0 === n ? V(t, i, e) : (s = j[i], V(t, s + p + 1, e), a = E[s], 0 !== a && (i -= C[s], K(t, i, a)), n--, s = U(n), V(t, s, r), a = k[s], 0 !== a && (n -= z[s], K(t, n, a)))
                        } while (o < t.last_lit);
                    V(t, M, e)
                },
                nt = (t, e) => {
                    const r = e.dyn_tree,
                        n = e.stat_desc.static_tree,
                        i = e.stat_desc.has_stree,
                        s = e.stat_desc.elems;
                    let a, o, u, h = -1;
                    for (t.heap_len = 0, t.heap_max = y, a = 0; a < s; a++) 0 !== r[2 * a] ? (t.heap[++t.heap_len] = h = a, t.depth[a] = 0) : r[2 * a + 1] = 0;
                    while (t.heap_len < 2) u = t.heap[++t.heap_len] = h < 2 ? ++h : 0, r[2 * u] = 1, t.depth[u] = 0, t.opt_len--, i && (t.static_len -= n[2 * u + 1]);
                    for (e.max_code = h, a = t.heap_len >> 1; a >= 1; a--) et(t, r, a);
                    u = s;
                    do {
                        a = t.heap[1], t.heap[1] = t.heap[t.heap_len--], et(t, r, 1), o = t.heap[1], t.heap[--t.heap_max] = a, t.heap[--t.heap_max] = o, r[2 * u] = r[2 * a] + r[2 * o], t.depth[u] = (t.depth[a] >= t.depth[o] ? t.depth[a] : t.depth[o]) + 1, r[2 * a + 1] = r[2 * o + 1] = u, t.heap[1] = u++, et(t, r, 1)
                    } while (t.heap_len >= 2);
                    t.heap[--t.heap_max] = t.heap[1], H(t, e), G(r, h, t.bl_count)
                },
                it = (t, e, r) => {
                    let n, i, s = -1,
                        a = e[1],
                        o = 0,
                        u = 7,
                        h = 4;
                    for (0 === a && (u = 138, h = 3), e[2 * (r + 1) + 1] = 65535, n = 0; n <= r; n++) i = a, a = e[2 * (n + 1) + 1], ++o < u && i === a || (o < h ? t.bl_tree[2 * i] += o : 0 !== i ? (i !== s && t.bl_tree[2 * i]++, t.bl_tree[2 * A]++) : o <= 10 ? t.bl_tree[2 * S]++ : t.bl_tree[2 * x]++, o = 0, s = i, 0 === a ? (u = 138, h = 3) : i === a ? (u = 6, h = 3) : (u = 7, h = 4))
                },
                st = (t, e, r) => {
                    let n, i, s = -1,
                        a = e[1],
                        o = 0,
                        u = 7,
                        h = 4;
                    for (0 === a && (u = 138, h = 3), n = 0; n <= r; n++)
                        if (i = a, a = e[2 * (n + 1) + 1], !(++o < u && i === a)) {
                            if (o < h)
                                do {
                                    V(t, i, t.bl_tree)
                                } while (0 !== --o);
                            else 0 !== i ? (i !== s && (V(t, i, t.bl_tree), o--), V(t, A, t.bl_tree), K(t, o - 3, 2)) : o <= 10 ? (V(t, S, t.bl_tree), K(t, o - 3, 3)) : (V(t, x, t.bl_tree), K(t, o - 11, 7));
                            o = 0, s = i, 0 === a ? (u = 138, h = 3) : i === a ? (u = 6, h = 3) : (u = 7, h = 4)
                        }
                },
                at = t => {
                    let e;
                    for (it(t, t.dyn_ltree, t.l_desc.max_code), it(t, t.dyn_dtree, t.d_desc.max_code), nt(t, t.bl_desc), e = g - 1; e >= 3; e--)
                        if (0 !== t.bl_tree[2 * O[e] + 1]) break;
                    return t.opt_len += 3 * (e + 1) + 5 + 5 + 4, e
                },
                ot = (t, e, r, n) => {
                    let i;
                    for (K(t, e - 257, 5), K(t, r - 1, 5), K(t, n - 4, 4), i = 0; i < n; i++) K(t, t.bl_tree[2 * O[i] + 1], 3);
                    st(t, t.dyn_ltree, e - 1), st(t, t.dyn_dtree, r - 1)
                },
                ut = t => {
                    let e, r = 4093624447;
                    for (e = 0; e <= 31; e++, r >>>= 1)
                        if (1 & r && 0 !== t.dyn_ltree[2 * e]) return i;
                    if (0 !== t.dyn_ltree[18] || 0 !== t.dyn_ltree[20] || 0 !== t.dyn_ltree[26]) return s;
                    for (e = 32; e < p; e++)
                        if (0 !== t.dyn_ltree[2 * e]) return s;
                    return i
                };
            let ht = !1;
            const ft = t => {
                    ht || (J(), ht = !0), t.l_desc = new $(t.dyn_ltree, L), t.d_desc = new $(t.dyn_dtree, F), t.bl_desc = new $(t.bl_tree, B), t.bi_buf = 0, t.bi_valid = 0, X(t)
                },
                ct = (t, e, r, n) => {
                    K(t, (u << 1) + (n ? 1 : 0), 3), Q(t, e, r, !0)
                },
                lt = t => {
                    K(t, h << 1, 3), V(t, M, P), Z(t)
                },
                dt = (t, e, r, i) => {
                    let s, o, u = 0;
                    t.level > 0 ? (t.strm.data_type === a && (t.strm.data_type = ut(t)), nt(t, t.l_desc), nt(t, t.d_desc), u = at(t), s = t.opt_len + 3 + 7 >>> 3, o = t.static_len + 3 + 7 >>> 3, o <= s && (s = o)) : s = o = r + 5, r + 4 <= s && -1 !== e ? ct(t, e, r, i) : t.strategy === n || o === s ? (K(t, (h << 1) + (i ? 1 : 0), 3), rt(t, P, T)) : (K(t, (f << 1) + (i ? 1 : 0), 3), ot(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, u + 1), rt(t, t.dyn_ltree, t.dyn_dtree)), X(t), i && Y(t)
                },
                pt = (t, e, r) => (t.pending_buf[t.d_buf + 2 * t.last_lit] = e >>> 8 & 255, t.pending_buf[t.d_buf + 2 * t.last_lit + 1] = 255 & e, t.pending_buf[t.l_buf + t.last_lit] = 255 & r, t.last_lit++, 0 === e ? t.dyn_ltree[2 * r]++ : (t.matches++, e--, t.dyn_ltree[2 * (j[r] + p + 1)]++, t.dyn_dtree[2 * U(e)]++), t.last_lit === t.lit_bufsize - 1);
            var mt = ft,
                bt = ct,
                gt = dt,
                yt = pt,
                vt = lt,
                wt = {
                    _tr_init: mt,
                    _tr_stored_block: bt,
                    _tr_flush_block: gt,
                    _tr_tally: yt,
                    _tr_align: vt
                };
            const _t = (t, e, r, n) => {
                let i = 65535 & t | 0,
                    s = t >>> 16 & 65535 | 0,
                    a = 0;
                while (0 !== r) {
                    a = r > 2e3 ? 2e3 : r, r -= a;
                    do {
                        i = i + e[n++] | 0, s = s + i | 0
                    } while (--a);
                    i %= 65521, s %= 65521
                }
                return i | s << 16 | 0
            };
            var Mt = _t;
            const At = () => {
                    let t, e = [];
                    for (var r = 0; r < 256; r++) {
                        t = r;
                        for (var n = 0; n < 8; n++) t = 1 & t ? 3988292384 ^ t >>> 1 : t >>> 1;
                        e[r] = t
                    }
                    return e
                },
                St = new Uint32Array(At()),
                xt = (t, e, r, n) => {
                    const i = St,
                        s = n + r;
                    t ^= -1;
                    for (let a = n; a < s; a++) t = t >>> 8 ^ i[255 & (t ^ e[a])];
                    return -1 ^ t
                };
            var Et = xt,
                kt = {
                    2: "need dictionary",
                    1: "stream end",
                    0: "",
                    "-1": "file error",
                    "-2": "stream error",
                    "-3": "data error",
                    "-4": "insufficient memory",
                    "-5": "buffer error",
                    "-6": "incompatible version"
                },
                Rt = {
                    Z_NO_FLUSH: 0,
                    Z_PARTIAL_FLUSH: 1,
                    Z_SYNC_FLUSH: 2,
                    Z_FULL_FLUSH: 3,
                    Z_FINISH: 4,
                    Z_BLOCK: 5,
                    Z_TREES: 6,
                    Z_OK: 0,
                    Z_STREAM_END: 1,
                    Z_NEED_DICT: 2,
                    Z_ERRNO: -1,
                    Z_STREAM_ERROR: -2,
                    Z_DATA_ERROR: -3,
                    Z_MEM_ERROR: -4,
                    Z_BUF_ERROR: -5,
                    Z_NO_COMPRESSION: 0,
                    Z_BEST_SPEED: 1,
                    Z_BEST_COMPRESSION: 9,
                    Z_DEFAULT_COMPRESSION: -1,
                    Z_FILTERED: 1,
                    Z_HUFFMAN_ONLY: 2,
                    Z_RLE: 3,
                    Z_FIXED: 4,
                    Z_DEFAULT_STRATEGY: 0,
                    Z_BINARY: 0,
                    Z_TEXT: 1,
                    Z_UNKNOWN: 2,
                    Z_DEFLATED: 8
                };
            const {
                _tr_init: Ot,
                _tr_stored_block: It,
                _tr_flush_block: Pt,
                _tr_tally: Tt,
                _tr_align: Nt
            } = wt, {
                Z_NO_FLUSH: jt,
                Z_PARTIAL_FLUSH: Ct,
                Z_FULL_FLUSH: zt,
                Z_FINISH: Dt,
                Z_BLOCK: Lt,
                Z_OK: Ft,
                Z_STREAM_END: Bt,
                Z_STREAM_ERROR: $t,
                Z_DATA_ERROR: Ut,
                Z_BUF_ERROR: qt,
                Z_DEFAULT_COMPRESSION: Kt,
                Z_FILTERED: Vt,
                Z_HUFFMAN_ONLY: Wt,
                Z_RLE: Zt,
                Z_FIXED: Ht,
                Z_DEFAULT_STRATEGY: Gt,
                Z_UNKNOWN: Jt,
                Z_DEFLATED: Xt
            } = Rt, Yt = 9, Qt = 15, te = 8, ee = 29, re = 256, ne = re + 1 + ee, ie = 30, se = 19, ae = 2 * ne + 1, oe = 15, ue = 3, he = 258, fe = he + ue + 1, ce = 32, le = 42, de = 69, pe = 73, me = 91, be = 103, ge = 113, ye = 666, ve = 1, we = 2, _e = 3, Me = 4, Ae = 3, Se = (t, e) => (t.msg = kt[e], e), xe = t => (t << 1) - (t > 4 ? 9 : 0), Ee = t => {
                let e = t.length;
                while (--e >= 0) t[e] = 0
            };
            let ke = (t, e, r) => (e << t.hash_shift ^ r) & t.hash_mask,
                Re = ke;
            const Oe = t => {
                    const e = t.state;
                    let r = e.pending;
                    r > t.avail_out && (r = t.avail_out), 0 !== r && (t.output.set(e.pending_buf.subarray(e.pending_out, e.pending_out + r), t.next_out), t.next_out += r, e.pending_out += r, t.total_out += r, t.avail_out -= r, e.pending -= r, 0 === e.pending && (e.pending_out = 0))
                },
                Ie = (t, e) => {
                    Pt(t, t.block_start >= 0 ? t.block_start : -1, t.strstart - t.block_start, e), t.block_start = t.strstart, Oe(t.strm)
                },
                Pe = (t, e) => {
                    t.pending_buf[t.pending++] = e
                },
                Te = (t, e) => {
                    t.pending_buf[t.pending++] = e >>> 8 & 255, t.pending_buf[t.pending++] = 255 & e
                },
                Ne = (t, e, r, n) => {
                    let i = t.avail_in;
                    return i > n && (i = n), 0 === i ? 0 : (t.avail_in -= i, e.set(t.input.subarray(t.next_in, t.next_in + i), r), 1 === t.state.wrap ? t.adler = Mt(t.adler, e, i, r) : 2 === t.state.wrap && (t.adler = Et(t.adler, e, i, r)), t.next_in += i, t.total_in += i, i)
                },
                je = (t, e) => {
                    let r, n, i = t.max_chain_length,
                        s = t.strstart,
                        a = t.prev_length,
                        o = t.nice_match;
                    const u = t.strstart > t.w_size - fe ? t.strstart - (t.w_size - fe) : 0,
                        h = t.window,
                        f = t.w_mask,
                        c = t.prev,
                        l = t.strstart + he;
                    let d = h[s + a - 1],
                        p = h[s + a];
                    t.prev_length >= t.good_match && (i >>= 2), o > t.lookahead && (o = t.lookahead);
                    do {
                        if (r = e, h[r + a] === p && h[r + a - 1] === d && h[r] === h[s] && h[++r] === h[s + 1]) {
                            s += 2, r++;
                            do {} while (h[++s] === h[++r] && h[++s] === h[++r] && h[++s] === h[++r] && h[++s] === h[++r] && h[++s] === h[++r] && h[++s] === h[++r] && h[++s] === h[++r] && h[++s] === h[++r] && s < l);
                            if (n = he - (l - s), s = l - he, n > a) {
                                if (t.match_start = e, a = n, n >= o) break;
                                d = h[s + a - 1], p = h[s + a]
                            }
                        }
                    } while ((e = c[e & f]) > u && 0 !== --i);
                    return a <= t.lookahead ? a : t.lookahead
                },
                Ce = t => {
                    const e = t.w_size;
                    let r, n, i, s, a;
                    do {
                        if (s = t.window_size - t.lookahead - t.strstart, t.strstart >= e + (e - fe)) {
                            t.window.set(t.window.subarray(e, e + e), 0), t.match_start -= e, t.strstart -= e, t.block_start -= e, n = t.hash_size, r = n;
                            do {
                                i = t.head[--r], t.head[r] = i >= e ? i - e : 0
                            } while (--n);
                            n = e, r = n;
                            do {
                                i = t.prev[--r], t.prev[r] = i >= e ? i - e : 0
                            } while (--n);
                            s += e
                        }
                        if (0 === t.strm.avail_in) break;
                        if (n = Ne(t.strm, t.window, t.strstart + t.lookahead, s), t.lookahead += n, t.lookahead + t.insert >= ue) {
                            a = t.strstart - t.insert, t.ins_h = t.window[a], t.ins_h = Re(t, t.ins_h, t.window[a + 1]);
                            while (t.insert)
                                if (t.ins_h = Re(t, t.ins_h, t.window[a + ue - 1]), t.prev[a & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = a, a++, t.insert--, t.lookahead + t.insert < ue) break
                        }
                    } while (t.lookahead < fe && 0 !== t.strm.avail_in)
                },
                ze = (t, e) => {
                    let r = 65535;
                    for (r > t.pending_buf_size - 5 && (r = t.pending_buf_size - 5);;) {
                        if (t.lookahead <= 1) {
                            if (Ce(t), 0 === t.lookahead && e === jt) return ve;
                            if (0 === t.lookahead) break
                        }
                        t.strstart += t.lookahead, t.lookahead = 0;
                        const n = t.block_start + r;
                        if ((0 === t.strstart || t.strstart >= n) && (t.lookahead = t.strstart - n, t.strstart = n, Ie(t, !1), 0 === t.strm.avail_out)) return ve;
                        if (t.strstart - t.block_start >= t.w_size - fe && (Ie(t, !1), 0 === t.strm.avail_out)) return ve
                    }
                    return t.insert = 0, e === Dt ? (Ie(t, !0), 0 === t.strm.avail_out ? _e : Me) : (t.strstart > t.block_start && (Ie(t, !1), t.strm.avail_out), ve)
                },
                De = (t, e) => {
                    let r, n;
                    for (;;) {
                        if (t.lookahead < fe) {
                            if (Ce(t), t.lookahead < fe && e === jt) return ve;
                            if (0 === t.lookahead) break
                        }
                        if (r = 0, t.lookahead >= ue && (t.ins_h = Re(t, t.ins_h, t.window[t.strstart + ue - 1]), r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), 0 !== r && t.strstart - r <= t.w_size - fe && (t.match_length = je(t, r)), t.match_length >= ue)
                            if (n = Tt(t, t.strstart - t.match_start, t.match_length - ue), t.lookahead -= t.match_length, t.match_length <= t.max_lazy_match && t.lookahead >= ue) {
                                t.match_length--;
                                do {
                                    t.strstart++, t.ins_h = Re(t, t.ins_h, t.window[t.strstart + ue - 1]), r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart
                                } while (0 !== --t.match_length);
                                t.strstart++
                            } else t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = Re(t, t.ins_h, t.window[t.strstart + 1]);
                        else n = Tt(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++;
                        if (n && (Ie(t, !1), 0 === t.strm.avail_out)) return ve
                    }
                    return t.insert = t.strstart < ue - 1 ? t.strstart : ue - 1, e === Dt ? (Ie(t, !0), 0 === t.strm.avail_out ? _e : Me) : t.last_lit && (Ie(t, !1), 0 === t.strm.avail_out) ? ve : we
                },
                Le = (t, e) => {
                    let r, n, i;
                    for (;;) {
                        if (t.lookahead < fe) {
                            if (Ce(t), t.lookahead < fe && e === jt) return ve;
                            if (0 === t.lookahead) break
                        }
                        if (r = 0, t.lookahead >= ue && (t.ins_h = Re(t, t.ins_h, t.window[t.strstart + ue - 1]), r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = ue - 1, 0 !== r && t.prev_length < t.max_lazy_match && t.strstart - r <= t.w_size - fe && (t.match_length = je(t, r), t.match_length <= 5 && (t.strategy === Vt || t.match_length === ue && t.strstart - t.match_start > 4096) && (t.match_length = ue - 1)), t.prev_length >= ue && t.match_length <= t.prev_length) {
                            i = t.strstart + t.lookahead - ue, n = Tt(t, t.strstart - 1 - t.prev_match, t.prev_length - ue), t.lookahead -= t.prev_length - 1, t.prev_length -= 2;
                            do {
                                ++t.strstart <= i && (t.ins_h = Re(t, t.ins_h, t.window[t.strstart + ue - 1]), r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart)
                            } while (0 !== --t.prev_length);
                            if (t.match_available = 0, t.match_length = ue - 1, t.strstart++, n && (Ie(t, !1), 0 === t.strm.avail_out)) return ve
                        } else if (t.match_available) {
                            if (n = Tt(t, 0, t.window[t.strstart - 1]), n && Ie(t, !1), t.strstart++, t.lookahead--, 0 === t.strm.avail_out) return ve
                        } else t.match_available = 1, t.strstart++, t.lookahead--
                    }
                    return t.match_available && (n = Tt(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = t.strstart < ue - 1 ? t.strstart : ue - 1, e === Dt ? (Ie(t, !0), 0 === t.strm.avail_out ? _e : Me) : t.last_lit && (Ie(t, !1), 0 === t.strm.avail_out) ? ve : we
                },
                Fe = (t, e) => {
                    let r, n, i, s;
                    const a = t.window;
                    for (;;) {
                        if (t.lookahead <= he) {
                            if (Ce(t), t.lookahead <= he && e === jt) return ve;
                            if (0 === t.lookahead) break
                        }
                        if (t.match_length = 0, t.lookahead >= ue && t.strstart > 0 && (i = t.strstart - 1, n = a[i], n === a[++i] && n === a[++i] && n === a[++i])) {
                            s = t.strstart + he;
                            do {} while (n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && i < s);
                            t.match_length = he - (s - i), t.match_length > t.lookahead && (t.match_length = t.lookahead)
                        }
                        if (t.match_length >= ue ? (r = Tt(t, 1, t.match_length - ue), t.lookahead -= t.match_length, t.strstart += t.match_length, t.match_length = 0) : (r = Tt(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++), r && (Ie(t, !1), 0 === t.strm.avail_out)) return ve
                    }
                    return t.insert = 0, e === Dt ? (Ie(t, !0), 0 === t.strm.avail_out ? _e : Me) : t.last_lit && (Ie(t, !1), 0 === t.strm.avail_out) ? ve : we
                },
                Be = (t, e) => {
                    let r;
                    for (;;) {
                        if (0 === t.lookahead && (Ce(t), 0 === t.lookahead)) {
                            if (e === jt) return ve;
                            break
                        }
                        if (t.match_length = 0, r = Tt(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++, r && (Ie(t, !1), 0 === t.strm.avail_out)) return ve
                    }
                    return t.insert = 0, e === Dt ? (Ie(t, !0), 0 === t.strm.avail_out ? _e : Me) : t.last_lit && (Ie(t, !1), 0 === t.strm.avail_out) ? ve : we
                };

            function $e(t, e, r, n, i) {
                this.good_length = t, this.max_lazy = e, this.nice_length = r, this.max_chain = n, this.func = i
            }
            const Ue = [new $e(0, 0, 0, 0, ze), new $e(4, 4, 8, 4, De), new $e(4, 5, 16, 8, De), new $e(4, 6, 32, 32, De), new $e(4, 4, 16, 16, Le), new $e(8, 16, 32, 32, Le), new $e(8, 16, 128, 128, Le), new $e(8, 32, 128, 256, Le), new $e(32, 128, 258, 1024, Le), new $e(32, 258, 258, 4096, Le)],
                qe = t => {
                    t.window_size = 2 * t.w_size, Ee(t.head), t.max_lazy_match = Ue[t.level].max_lazy, t.good_match = Ue[t.level].good_length, t.nice_match = Ue[t.level].nice_length, t.max_chain_length = Ue[t.level].max_chain, t.strstart = 0, t.block_start = 0, t.lookahead = 0, t.insert = 0, t.match_length = t.prev_length = ue - 1, t.match_available = 0, t.ins_h = 0
                };

            function Ke() {
                this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Xt, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(2 * ae), this.dyn_dtree = new Uint16Array(2 * (2 * ie + 1)), this.bl_tree = new Uint16Array(2 * (2 * se + 1)), Ee(this.dyn_ltree), Ee(this.dyn_dtree), Ee(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(oe + 1), this.heap = new Uint16Array(2 * ne + 1), Ee(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * ne + 1), Ee(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0
            }
            const Ve = t => {
                    if (!t || !t.state) return Se(t, $t);
                    t.total_in = t.total_out = 0, t.data_type = Jt;
                    const e = t.state;
                    return e.pending = 0, e.pending_out = 0, e.wrap < 0 && (e.wrap = -e.wrap), e.status = e.wrap ? le : ge, t.adler = 2 === e.wrap ? 0 : 1, e.last_flush = jt, Ot(e), Ft
                },
                We = t => {
                    const e = Ve(t);
                    return e === Ft && qe(t.state), e
                },
                Ze = (t, e) => t && t.state ? 2 !== t.state.wrap ? $t : (t.state.gzhead = e, Ft) : $t,
                He = (t, e, r, n, i, s) => {
                    if (!t) return $t;
                    let a = 1;
                    if (e === Kt && (e = 6), n < 0 ? (a = 0, n = -n) : n > 15 && (a = 2, n -= 16), i < 1 || i > Yt || r !== Xt || n < 8 || n > 15 || e < 0 || e > 9 || s < 0 || s > Ht) return Se(t, $t);
                    8 === n && (n = 9);
                    const o = new Ke;
                    return t.state = o, o.strm = t, o.wrap = a, o.gzhead = null, o.w_bits = n, o.w_size = 1 << o.w_bits, o.w_mask = o.w_size - 1, o.hash_bits = i + 7, o.hash_size = 1 << o.hash_bits, o.hash_mask = o.hash_size - 1, o.hash_shift = ~~((o.hash_bits + ue - 1) / ue), o.window = new Uint8Array(2 * o.w_size), o.head = new Uint16Array(o.hash_size), o.prev = new Uint16Array(o.w_size), o.lit_bufsize = 1 << i + 6, o.pending_buf_size = 4 * o.lit_bufsize, o.pending_buf = new Uint8Array(o.pending_buf_size), o.d_buf = 1 * o.lit_bufsize, o.l_buf = 3 * o.lit_bufsize, o.level = e, o.strategy = s, o.method = r, We(t)
                },
                Ge = (t, e) => He(t, e, Xt, Qt, te, Gt),
                Je = (t, e) => {
                    let r, n;
                    if (!t || !t.state || e > Lt || e < 0) return t ? Se(t, $t) : $t;
                    const i = t.state;
                    if (!t.output || !t.input && 0 !== t.avail_in || i.status === ye && e !== Dt) return Se(t, 0 === t.avail_out ? qt : $t);
                    i.strm = t;
                    const s = i.last_flush;
                    if (i.last_flush = e, i.status === le)
                        if (2 === i.wrap) t.adler = 0, Pe(i, 31), Pe(i, 139), Pe(i, 8), i.gzhead ? (Pe(i, (i.gzhead.text ? 1 : 0) + (i.gzhead.hcrc ? 2 : 0) + (i.gzhead.extra ? 4 : 0) + (i.gzhead.name ? 8 : 0) + (i.gzhead.comment ? 16 : 0)), Pe(i, 255 & i.gzhead.time), Pe(i, i.gzhead.time >> 8 & 255), Pe(i, i.gzhead.time >> 16 & 255), Pe(i, i.gzhead.time >> 24 & 255), Pe(i, 9 === i.level ? 2 : i.strategy >= Wt || i.level < 2 ? 4 : 0), Pe(i, 255 & i.gzhead.os), i.gzhead.extra && i.gzhead.extra.length && (Pe(i, 255 & i.gzhead.extra.length), Pe(i, i.gzhead.extra.length >> 8 & 255)), i.gzhead.hcrc && (t.adler = Et(t.adler, i.pending_buf, i.pending, 0)), i.gzindex = 0, i.status = de) : (Pe(i, 0), Pe(i, 0), Pe(i, 0), Pe(i, 0), Pe(i, 0), Pe(i, 9 === i.level ? 2 : i.strategy >= Wt || i.level < 2 ? 4 : 0), Pe(i, Ae), i.status = ge);
                        else {
                            let e = Xt + (i.w_bits - 8 << 4) << 8,
                                r = -1;
                            r = i.strategy >= Wt || i.level < 2 ? 0 : i.level < 6 ? 1 : 6 === i.level ? 2 : 3, e |= r << 6, 0 !== i.strstart && (e |= ce), e += 31 - e % 31, i.status = ge, Te(i, e), 0 !== i.strstart && (Te(i, t.adler >>> 16), Te(i, 65535 & t.adler)), t.adler = 1
                        }
                    if (i.status === de)
                        if (i.gzhead.extra) {
                            r = i.pending;
                            while (i.gzindex < (65535 & i.gzhead.extra.length)) {
                                if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > r && (t.adler = Et(t.adler, i.pending_buf, i.pending - r, r)), Oe(t), r = i.pending, i.pending === i.pending_buf_size)) break;
                                Pe(i, 255 & i.gzhead.extra[i.gzindex]), i.gzindex++
                            }
                            i.gzhead.hcrc && i.pending > r && (t.adler = Et(t.adler, i.pending_buf, i.pending - r, r)), i.gzindex === i.gzhead.extra.length && (i.gzindex = 0, i.status = pe)
                        } else i.status = pe;
                    if (i.status === pe)
                        if (i.gzhead.name) {
                            r = i.pending;
                            do {
                                if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > r && (t.adler = Et(t.adler, i.pending_buf, i.pending - r, r)), Oe(t), r = i.pending, i.pending === i.pending_buf_size)) {
                                    n = 1;
                                    break
                                }
                                n = i.gzindex < i.gzhead.name.length ? 255 & i.gzhead.name.charCodeAt(i.gzindex++) : 0, Pe(i, n)
                            } while (0 !== n);
                            i.gzhead.hcrc && i.pending > r && (t.adler = Et(t.adler, i.pending_buf, i.pending - r, r)), 0 === n && (i.gzindex = 0, i.status = me)
                        } else i.status = me;
                    if (i.status === me)
                        if (i.gzhead.comment) {
                            r = i.pending;
                            do {
                                if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > r && (t.adler = Et(t.adler, i.pending_buf, i.pending - r, r)), Oe(t), r = i.pending, i.pending === i.pending_buf_size)) {
                                    n = 1;
                                    break
                                }
                                n = i.gzindex < i.gzhead.comment.length ? 255 & i.gzhead.comment.charCodeAt(i.gzindex++) : 0, Pe(i, n)
                            } while (0 !== n);
                            i.gzhead.hcrc && i.pending > r && (t.adler = Et(t.adler, i.pending_buf, i.pending - r, r)), 0 === n && (i.status = be)
                        } else i.status = be;
                    if (i.status === be && (i.gzhead.hcrc ? (i.pending + 2 > i.pending_buf_size && Oe(t), i.pending + 2 <= i.pending_buf_size && (Pe(i, 255 & t.adler), Pe(i, t.adler >> 8 & 255), t.adler = 0, i.status = ge)) : i.status = ge), 0 !== i.pending) {
                        if (Oe(t), 0 === t.avail_out) return i.last_flush = -1, Ft
                    } else if (0 === t.avail_in && xe(e) <= xe(s) && e !== Dt) return Se(t, qt);
                    if (i.status === ye && 0 !== t.avail_in) return Se(t, qt);
                    if (0 !== t.avail_in || 0 !== i.lookahead || e !== jt && i.status !== ye) {
                        let r = i.strategy === Wt ? Be(i, e) : i.strategy === Zt ? Fe(i, e) : Ue[i.level].func(i, e);
                        if (r !== _e && r !== Me || (i.status = ye), r === ve || r === _e) return 0 === t.avail_out && (i.last_flush = -1), Ft;
                        if (r === we && (e === Ct ? Nt(i) : e !== Lt && (It(i, 0, 0, !1), e === zt && (Ee(i.head), 0 === i.lookahead && (i.strstart = 0, i.block_start = 0, i.insert = 0))), Oe(t), 0 === t.avail_out)) return i.last_flush = -1, Ft
                    }
                    return e !== Dt ? Ft : i.wrap <= 0 ? Bt : (2 === i.wrap ? (Pe(i, 255 & t.adler), Pe(i, t.adler >> 8 & 255), Pe(i, t.adler >> 16 & 255), Pe(i, t.adler >> 24 & 255), Pe(i, 255 & t.total_in), Pe(i, t.total_in >> 8 & 255), Pe(i, t.total_in >> 16 & 255), Pe(i, t.total_in >> 24 & 255)) : (Te(i, t.adler >>> 16), Te(i, 65535 & t.adler)), Oe(t), i.wrap > 0 && (i.wrap = -i.wrap), 0 !== i.pending ? Ft : Bt)
                },
                Xe = t => {
                    if (!t || !t.state) return $t;
                    const e = t.state.status;
                    return e !== le && e !== de && e !== pe && e !== me && e !== be && e !== ge && e !== ye ? Se(t, $t) : (t.state = null, e === ge ? Se(t, Ut) : Ft)
                },
                Ye = (t, e) => {
                    let r = e.length;
                    if (!t || !t.state) return $t;
                    const n = t.state,
                        i = n.wrap;
                    if (2 === i || 1 === i && n.status !== le || n.lookahead) return $t;
                    if (1 === i && (t.adler = Mt(t.adler, e, r, 0)), n.wrap = 0, r >= n.w_size) {
                        0 === i && (Ee(n.head), n.strstart = 0, n.block_start = 0, n.insert = 0);
                        let t = new Uint8Array(n.w_size);
                        t.set(e.subarray(r - n.w_size, r), 0), e = t, r = n.w_size
                    }
                    const s = t.avail_in,
                        a = t.next_in,
                        o = t.input;
                    t.avail_in = r, t.next_in = 0, t.input = e, Ce(n);
                    while (n.lookahead >= ue) {
                        let t = n.strstart,
                            e = n.lookahead - (ue - 1);
                        do {
                            n.ins_h = Re(n, n.ins_h, n.window[t + ue - 1]), n.prev[t & n.w_mask] = n.head[n.ins_h], n.head[n.ins_h] = t, t++
                        } while (--e);
                        n.strstart = t, n.lookahead = ue - 1, Ce(n)
                    }
                    return n.strstart += n.lookahead, n.block_start = n.strstart, n.insert = n.lookahead, n.lookahead = 0, n.match_length = n.prev_length = ue - 1, n.match_available = 0, t.next_in = a, t.input = o, t.avail_in = s, n.wrap = i, Ft
                };
            var Qe = Ge,
                tr = He,
                er = We,
                rr = Ve,
                nr = Ze,
                ir = Je,
                sr = Xe,
                ar = Ye,
                or = "pako deflate (from Nodeca project)",
                ur = {
                    deflateInit: Qe,
                    deflateInit2: tr,
                    deflateReset: er,
                    deflateResetKeep: rr,
                    deflateSetHeader: nr,
                    deflate: ir,
                    deflateEnd: sr,
                    deflateSetDictionary: ar,
                    deflateInfo: or
                };
            const hr = (t, e) => Object.prototype.hasOwnProperty.call(t, e);
            var fr = function(t) {
                    const e = Array.prototype.slice.call(arguments, 1);
                    while (e.length) {
                        const r = e.shift();
                        if (r) {
                            if ("object" !== typeof r) throw new TypeError(r + "must be non-object");
                            for (const e in r) hr(r, e) && (t[e] = r[e])
                        }
                    }
                    return t
                },
                cr = t => {
                    let e = 0;
                    for (let n = 0, i = t.length; n < i; n++) e += t[n].length;
                    const r = new Uint8Array(e);
                    for (let n = 0, i = 0, s = t.length; n < s; n++) {
                        let e = t[n];
                        r.set(e, i), i += e.length
                    }
                    return r
                },
                lr = {
                    assign: fr,
                    flattenChunks: cr
                };
            let dr = !0;
            try {
                String.fromCharCode.apply(null, new Uint8Array(1))
            } catch (cs) {
                dr = !1
            }
            const pr = new Uint8Array(256);
            for (let ls = 0; ls < 256; ls++) pr[ls] = ls >= 252 ? 6 : ls >= 248 ? 5 : ls >= 240 ? 4 : ls >= 224 ? 3 : ls >= 192 ? 2 : 1;
            pr[254] = pr[254] = 1;
            var mr = t => {
                let e, r, n, i, s, a = t.length,
                    o = 0;
                for (i = 0; i < a; i++) r = t.charCodeAt(i), 55296 === (64512 & r) && i + 1 < a && (n = t.charCodeAt(i + 1), 56320 === (64512 & n) && (r = 65536 + (r - 55296 << 10) + (n - 56320), i++)), o += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4;
                for (e = new Uint8Array(o), s = 0, i = 0; s < o; i++) r = t.charCodeAt(i), 55296 === (64512 & r) && i + 1 < a && (n = t.charCodeAt(i + 1), 56320 === (64512 & n) && (r = 65536 + (r - 55296 << 10) + (n - 56320), i++)), r < 128 ? e[s++] = r : r < 2048 ? (e[s++] = 192 | r >>> 6, e[s++] = 128 | 63 & r) : r < 65536 ? (e[s++] = 224 | r >>> 12, e[s++] = 128 | r >>> 6 & 63, e[s++] = 128 | 63 & r) : (e[s++] = 240 | r >>> 18, e[s++] = 128 | r >>> 12 & 63, e[s++] = 128 | r >>> 6 & 63, e[s++] = 128 | 63 & r);
                return e
            };
            const br = (t, e) => {
                if (e < 65534 && t.subarray && dr) return String.fromCharCode.apply(null, t.length === e ? t : t.subarray(0, e));
                let r = "";
                for (let n = 0; n < e; n++) r += String.fromCharCode(t[n]);
                return r
            };
            var gr = (t, e) => {
                    let r, n;
                    const i = e || t.length,
                        s = new Array(2 * i);
                    for (n = 0, r = 0; r < i;) {
                        let e = t[r++];
                        if (e < 128) {
                            s[n++] = e;
                            continue
                        }
                        let a = pr[e];
                        if (a > 4) s[n++] = 65533, r += a - 1;
                        else {
                            e &= 2 === a ? 31 : 3 === a ? 15 : 7;
                            while (a > 1 && r < i) e = e << 6 | 63 & t[r++], a--;
                            a > 1 ? s[n++] = 65533 : e < 65536 ? s[n++] = e : (e -= 65536, s[n++] = 55296 | e >> 10 & 1023, s[n++] = 56320 | 1023 & e)
                        }
                    }
                    return br(s, n)
                },
                yr = (t, e) => {
                    e = e || t.length, e > t.length && (e = t.length);
                    let r = e - 1;
                    while (r >= 0 && 128 === (192 & t[r])) r--;
                    return r < 0 || 0 === r ? e : r + pr[t[r]] > e ? r : e
                },
                vr = {
                    string2buf: mr,
                    buf2string: gr,
                    utf8border: yr
                };

            function wr() {
                this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0
            }
            var _r = wr;
            const Mr = Object.prototype.toString,
                {
                    Z_NO_FLUSH: Ar,
                    Z_SYNC_FLUSH: Sr,
                    Z_FULL_FLUSH: xr,
                    Z_FINISH: Er,
                    Z_OK: kr,
                    Z_STREAM_END: Rr,
                    Z_DEFAULT_COMPRESSION: Or,
                    Z_DEFAULT_STRATEGY: Ir,
                    Z_DEFLATED: Pr
                } = Rt;

            function Tr(t) {
                this.options = lr.assign({
                    level: Or,
                    method: Pr,
                    chunkSize: 16384,
                    windowBits: 15,
                    memLevel: 8,
                    strategy: Ir
                }, t || {});
                let e = this.options;
                e.raw && e.windowBits > 0 ? e.windowBits = -e.windowBits : e.gzip && e.windowBits > 0 && e.windowBits < 16 && (e.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new _r, this.strm.avail_out = 0;
                let r = ur.deflateInit2(this.strm, e.level, e.method, e.windowBits, e.memLevel, e.strategy);
                if (r !== kr) throw new Error(kt[r]);
                if (e.header && ur.deflateSetHeader(this.strm, e.header), e.dictionary) {
                    let t;
                    if (t = "string" === typeof e.dictionary ? vr.string2buf(e.dictionary) : "[object ArrayBuffer]" === Mr.call(e.dictionary) ? new Uint8Array(e.dictionary) : e.dictionary, r = ur.deflateSetDictionary(this.strm, t), r !== kr) throw new Error(kt[r]);
                    this._dict_set = !0
                }
            }

            function Nr(t, e) {
                const r = new Tr(e);
                if (r.push(t, !0), r.err) throw r.msg || kt[r.err];
                return r.result
            }

            function jr(t, e) {
                return e = e || {}, e.raw = !0, Nr(t, e)
            }

            function Cr(t, e) {
                return e = e || {}, e.gzip = !0, Nr(t, e)
            }
            Tr.prototype.push = function(t, e) {
                const r = this.strm,
                    n = this.options.chunkSize;
                let i, s;
                if (this.ended) return !1;
                for (s = e === ~~e ? e : !0 === e ? Er : Ar, "string" === typeof t ? r.input = vr.string2buf(t) : "[object ArrayBuffer]" === Mr.call(t) ? r.input = new Uint8Array(t) : r.input = t, r.next_in = 0, r.avail_in = r.input.length;;)
                    if (0 === r.avail_out && (r.output = new Uint8Array(n), r.next_out = 0, r.avail_out = n), (s === Sr || s === xr) && r.avail_out <= 6) this.onData(r.output.subarray(0, r.next_out)), r.avail_out = 0;
                    else {
                        if (i = ur.deflate(r, s), i === Rr) return r.next_out > 0 && this.onData(r.output.subarray(0, r.next_out)), i = ur.deflateEnd(this.strm), this.onEnd(i), this.ended = !0, i === kr;
                        if (0 !== r.avail_out) {
                            if (s > 0 && r.next_out > 0) this.onData(r.output.subarray(0, r.next_out)), r.avail_out = 0;
                            else if (0 === r.avail_in) break
                        } else this.onData(r.output)
                    }
                return !0
            }, Tr.prototype.onData = function(t) {
                this.chunks.push(t)
            }, Tr.prototype.onEnd = function(t) {
                t === kr && (this.result = lr.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg
            };
            var zr = Tr,
                Dr = Nr,
                Lr = jr,
                Fr = Cr,
                Br = Rt,
                $r = {
                    Deflate: zr,
                    deflate: Dr,
                    deflateRaw: Lr,
                    gzip: Fr,
                    constants: Br
                };
            const Ur = 30,
                qr = 12;
            var Kr = function(t, e) {
                let r, n, i, s, a, o, u, h, f, c, l, d, p, m, b, g, y, v, w, _, M, A, S, x;
                const E = t.state;
                r = t.next_in, S = t.input, n = r + (t.avail_in - 5), i = t.next_out, x = t.output, s = i - (e - t.avail_out), a = i + (t.avail_out - 257), o = E.dmax, u = E.wsize, h = E.whave, f = E.wnext, c = E.window, l = E.hold, d = E.bits, p = E.lencode, m = E.distcode, b = (1 << E.lenbits) - 1, g = (1 << E.distbits) - 1;
                t: do {
                    d < 15 && (l += S[r++] << d, d += 8, l += S[r++] << d, d += 8), y = p[l & b];
                    e: for (;;) {
                        if (v = y >>> 24, l >>>= v, d -= v, v = y >>> 16 & 255, 0 === v) x[i++] = 65535 & y;
                        else {
                            if (!(16 & v)) {
                                if (0 === (64 & v)) {
                                    y = p[(65535 & y) + (l & (1 << v) - 1)];
                                    continue e
                                }
                                if (32 & v) {
                                    E.mode = qr;
                                    break t
                                }
                                t.msg = "invalid literal/length code", E.mode = Ur;
                                break t
                            }
                            w = 65535 & y, v &= 15, v && (d < v && (l += S[r++] << d, d += 8), w += l & (1 << v) - 1, l >>>= v, d -= v), d < 15 && (l += S[r++] << d, d += 8, l += S[r++] << d, d += 8), y = m[l & g];
                            r: for (;;) {
                                if (v = y >>> 24, l >>>= v, d -= v, v = y >>> 16 & 255, !(16 & v)) {
                                    if (0 === (64 & v)) {
                                        y = m[(65535 & y) + (l & (1 << v) - 1)];
                                        continue r
                                    }
                                    t.msg = "invalid distance code", E.mode = Ur;
                                    break t
                                }
                                if (_ = 65535 & y, v &= 15, d < v && (l += S[r++] << d, d += 8, d < v && (l += S[r++] << d, d += 8)), _ += l & (1 << v) - 1, _ > o) {
                                    t.msg = "invalid distance too far back", E.mode = Ur;
                                    break t
                                }
                                if (l >>>= v, d -= v, v = i - s, _ > v) {
                                    if (v = _ - v, v > h && E.sane) {
                                        t.msg = "invalid distance too far back", E.mode = Ur;
                                        break t
                                    }
                                    if (M = 0, A = c, 0 === f) {
                                        if (M += u - v, v < w) {
                                            w -= v;
                                            do {
                                                x[i++] = c[M++]
                                            } while (--v);
                                            M = i - _, A = x
                                        }
                                    } else if (f < v) {
                                        if (M += u + f - v, v -= f, v < w) {
                                            w -= v;
                                            do {
                                                x[i++] = c[M++]
                                            } while (--v);
                                            if (M = 0, f < w) {
                                                v = f, w -= v;
                                                do {
                                                    x[i++] = c[M++]
                                                } while (--v);
                                                M = i - _, A = x
                                            }
                                        }
                                    } else if (M += f - v, v < w) {
                                        w -= v;
                                        do {
                                            x[i++] = c[M++]
                                        } while (--v);
                                        M = i - _, A = x
                                    }
                                    while (w > 2) x[i++] = A[M++], x[i++] = A[M++], x[i++] = A[M++], w -= 3;
                                    w && (x[i++] = A[M++], w > 1 && (x[i++] = A[M++]))
                                } else {
                                    M = i - _;
                                    do {
                                        x[i++] = x[M++], x[i++] = x[M++], x[i++] = x[M++], w -= 3
                                    } while (w > 2);
                                    w && (x[i++] = x[M++], w > 1 && (x[i++] = x[M++]))
                                }
                                break
                            }
                        }
                        break
                    }
                } while (r < n && i < a);
                w = d >> 3, r -= w, d -= w << 3, l &= (1 << d) - 1, t.next_in = r, t.next_out = i, t.avail_in = r < n ? n - r + 5 : 5 - (r - n), t.avail_out = i < a ? a - i + 257 : 257 - (i - a), E.hold = l, E.bits = d
            };
            const Vr = 15,
                Wr = 852,
                Zr = 592,
                Hr = 0,
                Gr = 1,
                Jr = 2,
                Xr = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]),
                Yr = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]),
                Qr = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]),
                tn = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]),
                en = (t, e, r, n, i, s, a, o) => {
                    const u = o.bits;
                    let h, f, c, l, d, p, m = 0,
                        b = 0,
                        g = 0,
                        y = 0,
                        v = 0,
                        w = 0,
                        _ = 0,
                        M = 0,
                        A = 0,
                        S = 0,
                        x = null,
                        E = 0;
                    const k = new Uint16Array(Vr + 1),
                        R = new Uint16Array(Vr + 1);
                    let O, I, P, T = null,
                        N = 0;
                    for (m = 0; m <= Vr; m++) k[m] = 0;
                    for (b = 0; b < n; b++) k[e[r + b]]++;
                    for (v = u, y = Vr; y >= 1; y--)
                        if (0 !== k[y]) break;
                    if (v > y && (v = y), 0 === y) return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
                    for (g = 1; g < y; g++)
                        if (0 !== k[g]) break;
                    for (v < g && (v = g), M = 1, m = 1; m <= Vr; m++)
                        if (M <<= 1, M -= k[m], M < 0) return -1;
                    if (M > 0 && (t === Hr || 1 !== y)) return -1;
                    for (R[1] = 0, m = 1; m < Vr; m++) R[m + 1] = R[m] + k[m];
                    for (b = 0; b < n; b++) 0 !== e[r + b] && (a[R[e[r + b]]++] = b);
                    if (t === Hr ? (x = T = a, p = 19) : t === Gr ? (x = Xr, E -= 257, T = Yr, N -= 257, p = 256) : (x = Qr, T = tn, p = -1), S = 0, b = 0, m = g, d = s, w = v, _ = 0, c = -1, A = 1 << v, l = A - 1, t === Gr && A > Wr || t === Jr && A > Zr) return 1;
                    for (;;) {
                        O = m - _, a[b] < p ? (I = 0, P = a[b]) : a[b] > p ? (I = T[N + a[b]], P = x[E + a[b]]) : (I = 96, P = 0), h = 1 << m - _, f = 1 << w, g = f;
                        do {
                            f -= h, i[d + (S >> _) + f] = O << 24 | I << 16 | P | 0
                        } while (0 !== f);
                        h = 1 << m - 1;
                        while (S & h) h >>= 1;
                        if (0 !== h ? (S &= h - 1, S += h) : S = 0, b++, 0 === --k[m]) {
                            if (m === y) break;
                            m = e[r + a[b]]
                        }
                        if (m > v && (S & l) !== c) {
                            0 === _ && (_ = v), d += g, w = m - _, M = 1 << w;
                            while (w + _ < y) {
                                if (M -= k[w + _], M <= 0) break;
                                w++, M <<= 1
                            }
                            if (A += 1 << w, t === Gr && A > Wr || t === Jr && A > Zr) return 1;
                            c = S & l, i[c] = v << 24 | w << 16 | d - s | 0
                        }
                    }
                    return 0 !== S && (i[d + S] = m - _ << 24 | 64 << 16 | 0), o.bits = v, 0
                };
            var rn = en;
            const nn = 0,
                sn = 1,
                an = 2,
                {
                    Z_FINISH: on,
                    Z_BLOCK: un,
                    Z_TREES: hn,
                    Z_OK: fn,
                    Z_STREAM_END: cn,
                    Z_NEED_DICT: ln,
                    Z_STREAM_ERROR: dn,
                    Z_DATA_ERROR: pn,
                    Z_MEM_ERROR: mn,
                    Z_BUF_ERROR: bn,
                    Z_DEFLATED: gn
                } = Rt,
                yn = 1,
                vn = 2,
                wn = 3,
                _n = 4,
                Mn = 5,
                An = 6,
                Sn = 7,
                xn = 8,
                En = 9,
                kn = 10,
                Rn = 11,
                On = 12,
                In = 13,
                Pn = 14,
                Tn = 15,
                Nn = 16,
                jn = 17,
                Cn = 18,
                zn = 19,
                Dn = 20,
                Ln = 21,
                Fn = 22,
                Bn = 23,
                $n = 24,
                Un = 25,
                qn = 26,
                Kn = 27,
                Vn = 28,
                Wn = 29,
                Zn = 30,
                Hn = 31,
                Gn = 32,
                Jn = 852,
                Xn = 592,
                Yn = 15,
                Qn = Yn,
                ti = t => (t >>> 24 & 255) + (t >>> 8 & 65280) + ((65280 & t) << 8) + ((255 & t) << 24);

            function ei() {
                this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0
            }
            const ri = t => {
                    if (!t || !t.state) return dn;
                    const e = t.state;
                    return t.total_in = t.total_out = e.total = 0, t.msg = "", e.wrap && (t.adler = 1 & e.wrap), e.mode = yn, e.last = 0, e.havedict = 0, e.dmax = 32768, e.head = null, e.hold = 0, e.bits = 0, e.lencode = e.lendyn = new Int32Array(Jn), e.distcode = e.distdyn = new Int32Array(Xn), e.sane = 1, e.back = -1, fn
                },
                ni = t => {
                    if (!t || !t.state) return dn;
                    const e = t.state;
                    return e.wsize = 0, e.whave = 0, e.wnext = 0, ri(t)
                },
                ii = (t, e) => {
                    let r;
                    if (!t || !t.state) return dn;
                    const n = t.state;
                    return e < 0 ? (r = 0, e = -e) : (r = 1 + (e >> 4), e < 48 && (e &= 15)), e && (e < 8 || e > 15) ? dn : (null !== n.window && n.wbits !== e && (n.window = null), n.wrap = r, n.wbits = e, ni(t))
                },
                si = (t, e) => {
                    if (!t) return dn;
                    const r = new ei;
                    t.state = r, r.window = null;
                    const n = ii(t, e);
                    return n !== fn && (t.state = null), n
                },
                ai = t => si(t, Qn);
            let oi, ui, hi = !0;
            const fi = t => {
                    if (hi) {
                        oi = new Int32Array(512), ui = new Int32Array(32);
                        let e = 0;
                        while (e < 144) t.lens[e++] = 8;
                        while (e < 256) t.lens[e++] = 9;
                        while (e < 280) t.lens[e++] = 7;
                        while (e < 288) t.lens[e++] = 8;
                        rn(sn, t.lens, 0, 288, oi, 0, t.work, {
                            bits: 9
                        }), e = 0;
                        while (e < 32) t.lens[e++] = 5;
                        rn(an, t.lens, 0, 32, ui, 0, t.work, {
                            bits: 5
                        }), hi = !1
                    }
                    t.lencode = oi, t.lenbits = 9, t.distcode = ui, t.distbits = 5
                },
                ci = (t, e, r, n) => {
                    let i;
                    const s = t.state;
                    return null === s.window && (s.wsize = 1 << s.wbits, s.wnext = 0, s.whave = 0, s.window = new Uint8Array(s.wsize)), n >= s.wsize ? (s.window.set(e.subarray(r - s.wsize, r), 0), s.wnext = 0, s.whave = s.wsize) : (i = s.wsize - s.wnext, i > n && (i = n), s.window.set(e.subarray(r - n, r - n + i), s.wnext), n -= i, n ? (s.window.set(e.subarray(r - n, r), 0), s.wnext = n, s.whave = s.wsize) : (s.wnext += i, s.wnext === s.wsize && (s.wnext = 0), s.whave < s.wsize && (s.whave += i))), 0
                },
                li = (t, e) => {
                    let r, n, i, s, a, o, u, h, f, c, l, d, p, m, b, g, y, v, w, _, M, A, S = 0;
                    const x = new Uint8Array(4);
                    let E, k;
                    const R = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
                    if (!t || !t.state || !t.output || !t.input && 0 !== t.avail_in) return dn;
                    r = t.state, r.mode === On && (r.mode = In), a = t.next_out, i = t.output, u = t.avail_out, s = t.next_in, n = t.input, o = t.avail_in, h = r.hold, f = r.bits, c = o, l = u, A = fn;
                    t: for (;;) switch (r.mode) {
                        case yn:
                            if (0 === r.wrap) {
                                r.mode = In;
                                break
                            }
                            while (f < 16) {
                                if (0 === o) break t;
                                o--, h += n[s++] << f, f += 8
                            }
                            if (2 & r.wrap && 35615 === h) {
                                r.check = 0, x[0] = 255 & h, x[1] = h >>> 8 & 255, r.check = Et(r.check, x, 2, 0), h = 0, f = 0, r.mode = vn;
                                break
                            }
                            if (r.flags = 0, r.head && (r.head.done = !1), !(1 & r.wrap) || (((255 & h) << 8) + (h >> 8)) % 31) {
                                t.msg = "incorrect header check", r.mode = Zn;
                                break
                            }
                            if ((15 & h) !== gn) {
                                t.msg = "unknown compression method", r.mode = Zn;
                                break
                            }
                            if (h >>>= 4, f -= 4, M = 8 + (15 & h), 0 === r.wbits) r.wbits = M;
                            else if (M > r.wbits) {
                                t.msg = "invalid window size", r.mode = Zn;
                                break
                            }
                            r.dmax = 1 << r.wbits, t.adler = r.check = 1, r.mode = 512 & h ? kn : On, h = 0, f = 0;
                            break;
                        case vn:
                            while (f < 16) {
                                if (0 === o) break t;
                                o--, h += n[s++] << f, f += 8
                            }
                            if (r.flags = h, (255 & r.flags) !== gn) {
                                t.msg = "unknown compression method", r.mode = Zn;
                                break
                            }
                            if (57344 & r.flags) {
                                t.msg = "unknown header flags set", r.mode = Zn;
                                break
                            }
                            r.head && (r.head.text = h >> 8 & 1), 512 & r.flags && (x[0] = 255 & h, x[1] = h >>> 8 & 255, r.check = Et(r.check, x, 2, 0)), h = 0, f = 0, r.mode = wn;
                        case wn:
                            while (f < 32) {
                                if (0 === o) break t;
                                o--, h += n[s++] << f, f += 8
                            }
                            r.head && (r.head.time = h), 512 & r.flags && (x[0] = 255 & h, x[1] = h >>> 8 & 255, x[2] = h >>> 16 & 255, x[3] = h >>> 24 & 255, r.check = Et(r.check, x, 4, 0)), h = 0, f = 0, r.mode = _n;
                        case _n:
                            while (f < 16) {
                                if (0 === o) break t;
                                o--, h += n[s++] << f, f += 8
                            }
                            r.head && (r.head.xflags = 255 & h, r.head.os = h >> 8), 512 & r.flags && (x[0] = 255 & h, x[1] = h >>> 8 & 255, r.check = Et(r.check, x, 2, 0)), h = 0, f = 0, r.mode = Mn;
                        case Mn:
                            if (1024 & r.flags) {
                                while (f < 16) {
                                    if (0 === o) break t;
                                    o--, h += n[s++] << f, f += 8
                                }
                                r.length = h, r.head && (r.head.extra_len = h), 512 & r.flags && (x[0] = 255 & h, x[1] = h >>> 8 & 255, r.check = Et(r.check, x, 2, 0)), h = 0, f = 0
                            } else r.head && (r.head.extra = null);
                            r.mode = An;
                        case An:
                            if (1024 & r.flags && (d = r.length, d > o && (d = o), d && (r.head && (M = r.head.extra_len - r.length, r.head.extra || (r.head.extra = new Uint8Array(r.head.extra_len)), r.head.extra.set(n.subarray(s, s + d), M)), 512 & r.flags && (r.check = Et(r.check, n, d, s)), o -= d, s += d, r.length -= d), r.length)) break t;
                            r.length = 0, r.mode = Sn;
                        case Sn:
                            if (2048 & r.flags) {
                                if (0 === o) break t;
                                d = 0;
                                do {
                                    M = n[s + d++], r.head && M && r.length < 65536 && (r.head.name += String.fromCharCode(M))
                                } while (M && d < o);
                                if (512 & r.flags && (r.check = Et(r.check, n, d, s)), o -= d, s += d, M) break t
                            } else r.head && (r.head.name = null);
                            r.length = 0, r.mode = xn;
                        case xn:
                            if (4096 & r.flags) {
                                if (0 === o) break t;
                                d = 0;
                                do {
                                    M = n[s + d++], r.head && M && r.length < 65536 && (r.head.comment += String.fromCharCode(M))
                                } while (M && d < o);
                                if (512 & r.flags && (r.check = Et(r.check, n, d, s)), o -= d, s += d, M) break t
                            } else r.head && (r.head.comment = null);
                            r.mode = En;
                        case En:
                            if (512 & r.flags) {
                                while (f < 16) {
                                    if (0 === o) break t;
                                    o--, h += n[s++] << f, f += 8
                                }
                                if (h !== (65535 & r.check)) {
                                    t.msg = "header crc mismatch", r.mode = Zn;
                                    break
                                }
                                h = 0, f = 0
                            }
                            r.head && (r.head.hcrc = r.flags >> 9 & 1, r.head.done = !0), t.adler = r.check = 0, r.mode = On;
                            break;
                        case kn:
                            while (f < 32) {
                                if (0 === o) break t;
                                o--, h += n[s++] << f, f += 8
                            }
                            t.adler = r.check = ti(h), h = 0, f = 0, r.mode = Rn;
                        case Rn:
                            if (0 === r.havedict) return t.next_out = a, t.avail_out = u, t.next_in = s, t.avail_in = o, r.hold = h, r.bits = f, ln;
                            t.adler = r.check = 1, r.mode = On;
                        case On:
                            if (e === un || e === hn) break t;
                        case In:
                            if (r.last) {
                                h >>>= 7 & f, f -= 7 & f, r.mode = Kn;
                                break
                            }
                            while (f < 3) {
                                if (0 === o) break t;
                                o--, h += n[s++] << f, f += 8
                            }
                            switch (r.last = 1 & h, h >>>= 1, f -= 1, 3 & h) {
                                case 0:
                                    r.mode = Pn;
                                    break;
                                case 1:
                                    if (fi(r), r.mode = Dn, e === hn) {
                                        h >>>= 2, f -= 2;
                                        break t
                                    }
                                    break;
                                case 2:
                                    r.mode = jn;
                                    break;
                                case 3:
                                    t.msg = "invalid block type", r.mode = Zn
                            }
                            h >>>= 2, f -= 2;
                            break;
                        case Pn:
                            h >>>= 7 & f, f -= 7 & f;
                            while (f < 32) {
                                if (0 === o) break t;
                                o--, h += n[s++] << f, f += 8
                            }
                            if ((65535 & h) !== (h >>> 16 ^ 65535)) {
                                t.msg = "invalid stored block lengths", r.mode = Zn;
                                break
                            }
                            if (r.length = 65535 & h, h = 0, f = 0, r.mode = Tn, e === hn) break t;
                        case Tn:
                            r.mode = Nn;
                        case Nn:
                            if (d = r.length, d) {
                                if (d > o && (d = o), d > u && (d = u), 0 === d) break t;
                                i.set(n.subarray(s, s + d), a), o -= d, s += d, u -= d, a += d, r.length -= d;
                                break
                            }
                            r.mode = On;
                            break;
                        case jn:
                            while (f < 14) {
                                if (0 === o) break t;
                                o--, h += n[s++] << f, f += 8
                            }
                            if (r.nlen = 257 + (31 & h), h >>>= 5, f -= 5, r.ndist = 1 + (31 & h), h >>>= 5, f -= 5, r.ncode = 4 + (15 & h), h >>>= 4, f -= 4, r.nlen > 286 || r.ndist > 30) {
                                t.msg = "too many length or distance symbols", r.mode = Zn;
                                break
                            }
                            r.have = 0, r.mode = Cn;
                        case Cn:
                            while (r.have < r.ncode) {
                                while (f < 3) {
                                    if (0 === o) break t;
                                    o--, h += n[s++] << f, f += 8
                                }
                                r.lens[R[r.have++]] = 7 & h, h >>>= 3, f -= 3
                            }
                            while (r.have < 19) r.lens[R[r.have++]] = 0;
                            if (r.lencode = r.lendyn, r.lenbits = 7, E = {
                                    bits: r.lenbits
                                }, A = rn(nn, r.lens, 0, 19, r.lencode, 0, r.work, E), r.lenbits = E.bits, A) {
                                t.msg = "invalid code lengths set", r.mode = Zn;
                                break
                            }
                            r.have = 0, r.mode = zn;
                        case zn:
                            while (r.have < r.nlen + r.ndist) {
                                for (;;) {
                                    if (S = r.lencode[h & (1 << r.lenbits) - 1], b = S >>> 24, g = S >>> 16 & 255, y = 65535 & S, b <= f) break;
                                    if (0 === o) break t;
                                    o--, h += n[s++] << f, f += 8
                                }
                                if (y < 16) h >>>= b, f -= b, r.lens[r.have++] = y;
                                else {
                                    if (16 === y) {
                                        k = b + 2;
                                        while (f < k) {
                                            if (0 === o) break t;
                                            o--, h += n[s++] << f, f += 8
                                        }
                                        if (h >>>= b, f -= b, 0 === r.have) {
                                            t.msg = "invalid bit length repeat", r.mode = Zn;
                                            break
                                        }
                                        M = r.lens[r.have - 1], d = 3 + (3 & h), h >>>= 2, f -= 2
                                    } else if (17 === y) {
                                        k = b + 3;
                                        while (f < k) {
                                            if (0 === o) break t;
                                            o--, h += n[s++] << f, f += 8
                                        }
                                        h >>>= b, f -= b, M = 0, d = 3 + (7 & h), h >>>= 3, f -= 3
                                    } else {
                                        k = b + 7;
                                        while (f < k) {
                                            if (0 === o) break t;
                                            o--, h += n[s++] << f, f += 8
                                        }
                                        h >>>= b, f -= b, M = 0, d = 11 + (127 & h), h >>>= 7, f -= 7
                                    }
                                    if (r.have + d > r.nlen + r.ndist) {
                                        t.msg = "invalid bit length repeat", r.mode = Zn;
                                        break
                                    }
                                    while (d--) r.lens[r.have++] = M
                                }
                            }
                            if (r.mode === Zn) break;
                            if (0 === r.lens[256]) {
                                t.msg = "invalid code -- missing end-of-block", r.mode = Zn;
                                break
                            }
                            if (r.lenbits = 9, E = {
                                    bits: r.lenbits
                                }, A = rn(sn, r.lens, 0, r.nlen, r.lencode, 0, r.work, E), r.lenbits = E.bits, A) {
                                t.msg = "invalid literal/lengths set", r.mode = Zn;
                                break
                            }
                            if (r.distbits = 6, r.distcode = r.distdyn, E = {
                                    bits: r.distbits
                                }, A = rn(an, r.lens, r.nlen, r.ndist, r.distcode, 0, r.work, E), r.distbits = E.bits, A) {
                                t.msg = "invalid distances set", r.mode = Zn;
                                break
                            }
                            if (r.mode = Dn, e === hn) break t;
                        case Dn:
                            r.mode = Ln;
                        case Ln:
                            if (o >= 6 && u >= 258) {
                                t.next_out = a, t.avail_out = u, t.next_in = s, t.avail_in = o, r.hold = h, r.bits = f, Kr(t, l), a = t.next_out, i = t.output, u = t.avail_out, s = t.next_in, n = t.input, o = t.avail_in, h = r.hold, f = r.bits, r.mode === On && (r.back = -1);
                                break
                            }
                            for (r.back = 0;;) {
                                if (S = r.lencode[h & (1 << r.lenbits) - 1], b = S >>> 24, g = S >>> 16 & 255, y = 65535 & S, b <= f) break;
                                if (0 === o) break t;
                                o--, h += n[s++] << f, f += 8
                            }
                            if (g && 0 === (240 & g)) {
                                for (v = b, w = g, _ = y;;) {
                                    if (S = r.lencode[_ + ((h & (1 << v + w) - 1) >> v)], b = S >>> 24, g = S >>> 16 & 255, y = 65535 & S, v + b <= f) break;
                                    if (0 === o) break t;
                                    o--, h += n[s++] << f, f += 8
                                }
                                h >>>= v, f -= v, r.back += v
                            }
                            if (h >>>= b, f -= b, r.back += b, r.length = y, 0 === g) {
                                r.mode = qn;
                                break
                            }
                            if (32 & g) {
                                r.back = -1, r.mode = On;
                                break
                            }
                            if (64 & g) {
                                t.msg = "invalid literal/length code", r.mode = Zn;
                                break
                            }
                            r.extra = 15 & g, r.mode = Fn;
                        case Fn:
                            if (r.extra) {
                                k = r.extra;
                                while (f < k) {
                                    if (0 === o) break t;
                                    o--, h += n[s++] << f, f += 8
                                }
                                r.length += h & (1 << r.extra) - 1, h >>>= r.extra, f -= r.extra, r.back += r.extra
                            }
                            r.was = r.length, r.mode = Bn;
                        case Bn:
                            for (;;) {
                                if (S = r.distcode[h & (1 << r.distbits) - 1], b = S >>> 24, g = S >>> 16 & 255, y = 65535 & S, b <= f) break;
                                if (0 === o) break t;
                                o--, h += n[s++] << f, f += 8
                            }
                            if (0 === (240 & g)) {
                                for (v = b, w = g, _ = y;;) {
                                    if (S = r.distcode[_ + ((h & (1 << v + w) - 1) >> v)], b = S >>> 24, g = S >>> 16 & 255, y = 65535 & S, v + b <= f) break;
                                    if (0 === o) break t;
                                    o--, h += n[s++] << f, f += 8
                                }
                                h >>>= v, f -= v, r.back += v
                            }
                            if (h >>>= b, f -= b, r.back += b, 64 & g) {
                                t.msg = "invalid distance code", r.mode = Zn;
                                break
                            }
                            r.offset = y, r.extra = 15 & g, r.mode = $n;
                        case $n:
                            if (r.extra) {
                                k = r.extra;
                                while (f < k) {
                                    if (0 === o) break t;
                                    o--, h += n[s++] << f, f += 8
                                }
                                r.offset += h & (1 << r.extra) - 1, h >>>= r.extra, f -= r.extra, r.back += r.extra
                            }
                            if (r.offset > r.dmax) {
                                t.msg = "invalid distance too far back", r.mode = Zn;
                                break
                            }
                            r.mode = Un;
                        case Un:
                            if (0 === u) break t;
                            if (d = l - u, r.offset > d) {
                                if (d = r.offset - d, d > r.whave && r.sane) {
                                    t.msg = "invalid distance too far back", r.mode = Zn;
                                    break
                                }
                                d > r.wnext ? (d -= r.wnext, p = r.wsize - d) : p = r.wnext - d, d > r.length && (d = r.length), m = r.window
                            } else m = i, p = a - r.offset, d = r.length;
                            d > u && (d = u), u -= d, r.length -= d;
                            do {
                                i[a++] = m[p++]
                            } while (--d);
                            0 === r.length && (r.mode = Ln);
                            break;
                        case qn:
                            if (0 === u) break t;
                            i[a++] = r.length, u--, r.mode = Ln;
                            break;
                        case Kn:
                            if (r.wrap) {
                                while (f < 32) {
                                    if (0 === o) break t;
                                    o--, h |= n[s++] << f, f += 8
                                }
                                if (l -= u, t.total_out += l, r.total += l, l && (t.adler = r.check = r.flags ? Et(r.check, i, l, a - l) : Mt(r.check, i, l, a - l)), l = u, (r.flags ? h : ti(h)) !== r.check) {
                                    t.msg = "incorrect data check", r.mode = Zn;
                                    break
                                }
                                h = 0, f = 0
                            }
                            r.mode = Vn;
                        case Vn:
                            if (r.wrap && r.flags) {
                                while (f < 32) {
                                    if (0 === o) break t;
                                    o--, h += n[s++] << f, f += 8
                                }
                                if (h !== (4294967295 & r.total)) {
                                    t.msg = "incorrect length check", r.mode = Zn;
                                    break
                                }
                                h = 0, f = 0
                            }
                            r.mode = Wn;
                        case Wn:
                            A = cn;
                            break t;
                        case Zn:
                            A = pn;
                            break t;
                        case Hn:
                            return mn;
                        case Gn:
                        default:
                            return dn
                    }
                    return t.next_out = a, t.avail_out = u, t.next_in = s, t.avail_in = o, r.hold = h, r.bits = f, (r.wsize || l !== t.avail_out && r.mode < Zn && (r.mode < Kn || e !== on)) && ci(t, t.output, t.next_out, l - t.avail_out), c -= t.avail_in, l -= t.avail_out, t.total_in += c, t.total_out += l, r.total += l, r.wrap && l && (t.adler = r.check = r.flags ? Et(r.check, i, l, t.next_out - l) : Mt(r.check, i, l, t.next_out - l)), t.data_type = r.bits + (r.last ? 64 : 0) + (r.mode === On ? 128 : 0) + (r.mode === Dn || r.mode === Tn ? 256 : 0), (0 === c && 0 === l || e === on) && A === fn && (A = bn), A
                },
                di = t => {
                    if (!t || !t.state) return dn;
                    let e = t.state;
                    return e.window && (e.window = null), t.state = null, fn
                },
                pi = (t, e) => {
                    if (!t || !t.state) return dn;
                    const r = t.state;
                    return 0 === (2 & r.wrap) ? dn : (r.head = e, e.done = !1, fn)
                },
                mi = (t, e) => {
                    const r = e.length;
                    let n, i, s;
                    return t && t.state ? (n = t.state, 0 !== n.wrap && n.mode !== Rn ? dn : n.mode === Rn && (i = 1, i = Mt(i, e, r, 0), i !== n.check) ? pn : (s = ci(t, e, r, r), s ? (n.mode = Hn, mn) : (n.havedict = 1, fn))) : dn
                };
            var bi = ni,
                gi = ii,
                yi = ri,
                vi = ai,
                wi = si,
                _i = li,
                Mi = di,
                Ai = pi,
                Si = mi,
                xi = "pako inflate (from Nodeca project)",
                Ei = {
                    inflateReset: bi,
                    inflateReset2: gi,
                    inflateResetKeep: yi,
                    inflateInit: vi,
                    inflateInit2: wi,
                    inflate: _i,
                    inflateEnd: Mi,
                    inflateGetHeader: Ai,
                    inflateSetDictionary: Si,
                    inflateInfo: xi
                };

            function ki() {
                this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1
            }
            var Ri = ki;
            const Oi = Object.prototype.toString,
                {
                    Z_NO_FLUSH: Ii,
                    Z_FINISH: Pi,
                    Z_OK: Ti,
                    Z_STREAM_END: Ni,
                    Z_NEED_DICT: ji,
                    Z_STREAM_ERROR: Ci,
                    Z_DATA_ERROR: zi,
                    Z_MEM_ERROR: Di
                } = Rt;

            function Li(t) {
                this.options = lr.assign({
                    chunkSize: 65536,
                    windowBits: 15,
                    to: ""
                }, t || {});
                const e = this.options;
                e.raw && e.windowBits >= 0 && e.windowBits < 16 && (e.windowBits = -e.windowBits, 0 === e.windowBits && (e.windowBits = -15)), !(e.windowBits >= 0 && e.windowBits < 16) || t && t.windowBits || (e.windowBits += 32), e.windowBits > 15 && e.windowBits < 48 && 0 === (15 & e.windowBits) && (e.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new _r, this.strm.avail_out = 0;
                let r = Ei.inflateInit2(this.strm, e.windowBits);
                if (r !== Ti) throw new Error(kt[r]);
                if (this.header = new Ri, Ei.inflateGetHeader(this.strm, this.header), e.dictionary && ("string" === typeof e.dictionary ? e.dictionary = vr.string2buf(e.dictionary) : "[object ArrayBuffer]" === Oi.call(e.dictionary) && (e.dictionary = new Uint8Array(e.dictionary)), e.raw && (r = Ei.inflateSetDictionary(this.strm, e.dictionary), r !== Ti))) throw new Error(kt[r])
            }

            function Fi(t, e) {
                const r = new Li(e);
                if (r.push(t), r.err) throw r.msg || kt[r.err];
                return r.result
            }

            function Bi(t, e) {
                return e = e || {}, e.raw = !0, Fi(t, e)
            }
            Li.prototype.push = function(t, e) {
                const r = this.strm,
                    n = this.options.chunkSize,
                    i = this.options.dictionary;
                let s, a, o;
                if (this.ended) return !1;
                for (a = e === ~~e ? e : !0 === e ? Pi : Ii, "[object ArrayBuffer]" === Oi.call(t) ? r.input = new Uint8Array(t) : r.input = t, r.next_in = 0, r.avail_in = r.input.length;;) {
                    0 === r.avail_out && (r.output = new Uint8Array(n), r.next_out = 0, r.avail_out = n), s = Ei.inflate(r, a), s === ji && i && (s = Ei.inflateSetDictionary(r, i), s === Ti ? s = Ei.inflate(r, a) : s === zi && (s = ji));
                    while (r.avail_in > 0 && s === Ni && r.state.wrap > 0 && 0 !== t[r.next_in]) Ei.inflateReset(r), s = Ei.inflate(r, a);
                    switch (s) {
                        case Ci:
                        case zi:
                        case ji:
                        case Di:
                            return this.onEnd(s), this.ended = !0, !1
                    }
                    if (o = r.avail_out, r.next_out && (0 === r.avail_out || s === Ni))
                        if ("string" === this.options.to) {
                            let t = vr.utf8border(r.output, r.next_out),
                                e = r.next_out - t,
                                i = vr.buf2string(r.output, t);
                            r.next_out = e, r.avail_out = n - e, e && r.output.set(r.output.subarray(t, t + e), 0), this.onData(i)
                        } else this.onData(r.output.length === r.next_out ? r.output : r.output.subarray(0, r.next_out));
                    if (s !== Ti || 0 !== o) {
                        if (s === Ni) return s = Ei.inflateEnd(this.strm), this.onEnd(s), this.ended = !0, !0;
                        if (0 === r.avail_in) break
                    }
                }
                return !0
            }, Li.prototype.onData = function(t) {
                this.chunks.push(t)
            }, Li.prototype.onEnd = function(t) {
                t === Ti && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = lr.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg
            };
            var $i = Li,
                Ui = Fi,
                qi = Bi,
                Ki = Fi,
                Vi = Rt,
                Wi = {
                    Inflate: $i,
                    inflate: Ui,
                    inflateRaw: qi,
                    ungzip: Ki,
                    constants: Vi
                };
            const {
                Deflate: Zi,
                deflate: Hi,
                deflateRaw: Gi,
                gzip: Ji
            } = $r, {
                Inflate: Xi,
                inflate: Yi,
                inflateRaw: Qi,
                ungzip: ts
            } = Wi;
            var es = Zi,
                rs = Hi,
                ns = Gi,
                is = Ji,
                ss = Xi,
                as = Yi,
                os = Qi,
                us = ts,
                hs = Rt,
                fs = {
                    Deflate: es,
                    deflate: rs,
                    deflateRaw: ns,
                    gzip: is,
                    Inflate: ss,
                    inflate: as,
                    inflateRaw: os,
                    ungzip: us,
                    constants: hs
                };
            e["default"] = fs
        },
        1545: function(t, e, r) {
            "use strict";
            e.utils = r("5ee7"), e.Cipher = r("0184"), e.DES = r("4e2b"), e.CBC = r("0da4"), e.EDE = r("1fec")
        },
        1553: function(t, e) {
            t.exports = function(t) {
                return (e, ...r) => function(t, ...e) {
                    return new Promise((r, n) => {
                        t(...e, (t, e) => {
                            t ? n(t) : r(e)
                        })
                    })
                }(e.bind(t), ...r)
            }
        },
        1555: function(t, e, r) {
            e.UINT32 = r("f8a0"), e.UINT64 = r("fdbb")
        },
        1781: function(t, e, r) {
            var n = r("be09"),
                i = r(3);

            function s(t) {
                if (n.crypto && n.crypto.getRandomValues) return n.crypto.getRandomValues(t);
                if ("object" === typeof n.msCrypto && "function" === typeof n.msCrypto.getRandomValues) return n.msCrypto.getRandomValues(t);
                if (i.randomBytes) {
                    if (!(t instanceof Uint8Array)) throw new TypeError("expected Uint8Array");
                    if (t.length > 65536) {
                        var e = new Error;
                        throw e.code = 22, e.message = "Failed to execute 'getRandomValues' on 'Crypto': The ArrayBufferView's byte length (" + t.length + ") exceeds the number of bytes of entropy available via this API (65536).", e.name = "QuotaExceededError", e
                    }
                    var r = i.randomBytes(t.length);
                    return t.set(r), t
                }
                throw new Error("No secure random number generator available.")
            }
            t.exports = s
        },
        "19ea": function(t, e, r) {
            "use strict";
            (function(e, n) {
                function i(t) {
                    var e = this;
                    this.next = null, this.entry = null, this.finish = function() {
                        V(e, t)
                    }
                }
                var s;
                t.exports = R, R.WritableState = k;
                var a = {
                        deprecate: r("b7d1")
                    },
                    o = r("5bbb"),
                    u = r("b639").Buffer,
                    h = e.Uint8Array || function() {};

                function f(t) {
                    return u.from(t)
                }

                function c(t) {
                    return u.isBuffer(t) || t instanceof h
                }
                var l, d = r("493f"),
                    p = r("b9b5"),
                    m = p.getHighWaterMark,
                    b = r("9d8a").codes,
                    g = b.ERR_INVALID_ARG_TYPE,
                    y = b.ERR_METHOD_NOT_IMPLEMENTED,
                    v = b.ERR_MULTIPLE_CALLBACK,
                    w = b.ERR_STREAM_CANNOT_PIPE,
                    _ = b.ERR_STREAM_DESTROYED,
                    M = b.ERR_STREAM_NULL_VALUES,
                    A = b.ERR_STREAM_WRITE_AFTER_END,
                    S = b.ERR_UNKNOWN_ENCODING,
                    x = d.errorOrDestroy;

                function E() {}

                function k(t, e, n) {
                    s = s || r("e666"), t = t || {}, "boolean" !== typeof n && (n = e instanceof s), this.objectMode = !!t.objectMode, n && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = m(this, t, "writableHighWaterMark", n), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
                    var a = !1 === t.decodeStrings;
                    this.decodeStrings = !a, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(t) {
                        z(e, t)
                    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !1 !== t.emitClose, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new i(this)
                }

                function R(t) {
                    s = s || r("e666");
                    var e = this instanceof s;
                    if (!e && !l.call(R, this)) return new R(t);
                    this._writableState = new k(t, this, e), this.writable = !0, t && ("function" === typeof t.write && (this._write = t.write), "function" === typeof t.writev && (this._writev = t.writev), "function" === typeof t.destroy && (this._destroy = t.destroy), "function" === typeof t.final && (this._final = t.final)), o.call(this)
                }

                function O(t, e) {
                    var r = new A;
                    x(t, r), n.nextTick(e, r)
                }

                function I(t, e, r, i) {
                    var s;
                    return null === r ? s = new M : "string" === typeof r || e.objectMode || (s = new g("chunk", ["string", "Buffer"], r)), !s || (x(t, s), n.nextTick(i, s), !1)
                }

                function P(t, e, r) {
                    return t.objectMode || !1 === t.decodeStrings || "string" !== typeof e || (e = u.from(e, r)), e
                }

                function T(t, e, r, n, i, s) {
                    if (!r) {
                        var a = P(e, n, i);
                        n !== a && (r = !0, i = "buffer", n = a)
                    }
                    var o = e.objectMode ? 1 : n.length;
                    e.length += o;
                    var u = e.length < e.highWaterMark;
                    if (u || (e.needDrain = !0), e.writing || e.corked) {
                        var h = e.lastBufferedRequest;
                        e.lastBufferedRequest = {
                            chunk: n,
                            encoding: i,
                            isBuf: r,
                            callback: s,
                            next: null
                        }, h ? h.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1
                    } else N(t, e, !1, o, n, i, s);
                    return u
                }

                function N(t, e, r, n, i, s, a) {
                    e.writelen = n, e.writecb = a, e.writing = !0, e.sync = !0, e.destroyed ? e.onwrite(new _("write")) : r ? t._writev(i, e.onwrite) : t._write(i, s, e.onwrite), e.sync = !1
                }

                function j(t, e, r, i, s) {
                    --e.pendingcb, r ? (n.nextTick(s, i), n.nextTick(q, t, e), t._writableState.errorEmitted = !0, x(t, i)) : (s(i), t._writableState.errorEmitted = !0, x(t, i), q(t, e))
                }

                function C(t) {
                    t.writing = !1, t.writecb = null, t.length -= t.writelen, t.writelen = 0
                }

                function z(t, e) {
                    var r = t._writableState,
                        i = r.sync,
                        s = r.writecb;
                    if ("function" !== typeof s) throw new v;
                    if (C(r), e) j(t, r, i, e, s);
                    else {
                        var a = B(r) || t.destroyed;
                        a || r.corked || r.bufferProcessing || !r.bufferedRequest || F(t, r), i ? n.nextTick(D, t, r, a, s) : D(t, r, a, s)
                    }
                }

                function D(t, e, r, n) {
                    r || L(t, e), e.pendingcb--, n(), q(t, e)
                }

                function L(t, e) {
                    0 === e.length && e.needDrain && (e.needDrain = !1, t.emit("drain"))
                }

                function F(t, e) {
                    e.bufferProcessing = !0;
                    var r = e.bufferedRequest;
                    if (t._writev && r && r.next) {
                        var n = e.bufferedRequestCount,
                            s = new Array(n),
                            a = e.corkedRequestsFree;
                        a.entry = r;
                        var o = 0,
                            u = !0;
                        while (r) s[o] = r, r.isBuf || (u = !1), r = r.next, o += 1;
                        s.allBuffers = u, N(t, e, !0, e.length, s, "", a.finish), e.pendingcb++, e.lastBufferedRequest = null, a.next ? (e.corkedRequestsFree = a.next, a.next = null) : e.corkedRequestsFree = new i(e), e.bufferedRequestCount = 0
                    } else {
                        while (r) {
                            var h = r.chunk,
                                f = r.encoding,
                                c = r.callback,
                                l = e.objectMode ? 1 : h.length;
                            if (N(t, e, !1, l, h, f, c), r = r.next, e.bufferedRequestCount--, e.writing) break
                        }
                        null === r && (e.lastBufferedRequest = null)
                    }
                    e.bufferedRequest = r, e.bufferProcessing = !1
                }

                function B(t) {
                    return t.ending && 0 === t.length && null === t.bufferedRequest && !t.finished && !t.writing
                }

                function $(t, e) {
                    t._final((function(r) {
                        e.pendingcb--, r && x(t, r), e.prefinished = !0, t.emit("prefinish"), q(t, e)
                    }))
                }

                function U(t, e) {
                    e.prefinished || e.finalCalled || ("function" !== typeof t._final || e.destroyed ? (e.prefinished = !0, t.emit("prefinish")) : (e.pendingcb++, e.finalCalled = !0, n.nextTick($, t, e)))
                }

                function q(t, e) {
                    var r = B(e);
                    if (r && (U(t, e), 0 === e.pendingcb && (e.finished = !0, t.emit("finish"), e.autoDestroy))) {
                        var n = t._readableState;
                        (!n || n.autoDestroy && n.endEmitted) && t.destroy()
                    }
                    return r
                }

                function K(t, e, r) {
                    e.ending = !0, q(t, e), r && (e.finished ? n.nextTick(r) : t.once("finish", r)), e.ended = !0, t.writable = !1
                }

                function V(t, e, r) {
                    var n = t.entry;
                    t.entry = null;
                    while (n) {
                        var i = n.callback;
                        e.pendingcb--, i(r), n = n.next
                    }
                    e.corkedRequestsFree.next = t
                }
                r("3fb5")(R, o), k.prototype.getBuffer = function() {
                        var t = this.bufferedRequest,
                            e = [];
                        while (t) e.push(t), t = t.next;
                        return e
                    },
                    function() {
                        try {
                            Object.defineProperty(k.prototype, "buffer", {
                                get: a.deprecate((function() {
                                    return this.getBuffer()
                                }), "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
                            })
                        } catch (t) {}
                    }(), "function" === typeof Symbol && Symbol.hasInstance && "function" === typeof Function.prototype[Symbol.hasInstance] ? (l = Function.prototype[Symbol.hasInstance], Object.defineProperty(R, Symbol.hasInstance, {
                        value: function(t) {
                            return !!l.call(this, t) || this === R && (t && t._writableState instanceof k)
                        }
                    })) : l = function(t) {
                        return t instanceof this
                    }, R.prototype.pipe = function() {
                        x(this, new w)
                    }, R.prototype.write = function(t, e, r) {
                        var n = this._writableState,
                            i = !1,
                            s = !n.objectMode && c(t);
                        return s && !u.isBuffer(t) && (t = f(t)), "function" === typeof e && (r = e, e = null), s ? e = "buffer" : e || (e = n.defaultEncoding), "function" !== typeof r && (r = E), n.ending ? O(this, r) : (s || I(this, n, t, r)) && (n.pendingcb++, i = T(this, n, s, t, e, r)), i
                    }, R.prototype.cork = function() {
                        this._writableState.corked++
                    }, R.prototype.uncork = function() {
                        var t = this._writableState;
                        t.corked && (t.corked--, t.writing || t.corked || t.bufferProcessing || !t.bufferedRequest || F(this, t))
                    }, R.prototype.setDefaultEncoding = function(t) {
                        if ("string" === typeof t && (t = t.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((t + "").toLowerCase()) > -1)) throw new S(t);
                        return this._writableState.defaultEncoding = t, this
                    }, Object.defineProperty(R.prototype, "writableBuffer", {
                        enumerable: !1,
                        get: function() {
                            return this._writableState && this._writableState.getBuffer()
                        }
                    }), Object.defineProperty(R.prototype, "writableHighWaterMark", {
                        enumerable: !1,
                        get: function() {
                            return this._writableState.highWaterMark
                        }
                    }), R.prototype._write = function(t, e, r) {
                        r(new y("_write()"))
                    }, R.prototype._writev = null, R.prototype.end = function(t, e, r) {
                        var n = this._writableState;
                        return "function" === typeof t ? (r = t, t = null, e = null) : "function" === typeof e && (r = e, e = null), null !== t && void 0 !== t && this.write(t, e), n.corked && (n.corked = 1, this.uncork()), n.ending || K(this, n, r), this
                    }, Object.defineProperty(R.prototype, "writableLength", {
                        enumerable: !1,
                        get: function() {
                            return this._writableState.length
                        }
                    }), Object.defineProperty(R.prototype, "destroyed", {
                        enumerable: !1,
                        get: function() {
                            return void 0 !== this._writableState && this._writableState.destroyed
                        },
                        set: function(t) {
                            this._writableState && (this._writableState.destroyed = t)
                        }
                    }), R.prototype.destroy = d.destroy, R.prototype._undestroy = d.undestroy, R.prototype._destroy = function(t, e) {
                        e(t)
                    }
            }).call(this, r("c8ba"), r("4362"))
        },
        "1fec": function(t, e, r) {
            "use strict";
            var n = r("da3e"),
                i = r("3fb5"),
                s = r("0184"),
                a = r("4e2b");

            function o(t, e) {
                n.equal(e.length, 24, "Invalid key length");
                var r = e.slice(0, 8),
                    i = e.slice(8, 16),
                    s = e.slice(16, 24);
                this.ciphers = "encrypt" === t ? [a.create({
                    type: "encrypt",
                    key: r
                }), a.create({
                    type: "decrypt",
                    key: i
                }), a.create({
                    type: "encrypt",
                    key: s
                })] : [a.create({
                    type: "decrypt",
                    key: s
                }), a.create({
                    type: "encrypt",
                    key: i
                }), a.create({
                    type: "decrypt",
                    key: r
                })]
            }

            function u(t) {
                s.call(this, t);
                var e = new o(this.type, this.options.key);
                this._edeState = e
            }
            i(u, s), t.exports = u, u.create = function(t) {
                return new u(t)
            }, u.prototype._update = function(t, e, r, n) {
                var i = this._edeState;
                i.ciphers[0]._update(t, e, r, n), i.ciphers[1]._update(r, n, r, n), i.ciphers[2]._update(r, n, r, n)
            }, u.prototype._pad = a.prototype._pad, u.prototype._unpad = a.prototype._unpad
        },
        2137: function(t, e, r) {
            "use strict";
            var n = r("c3c0"),
                i = r("da3e");

            function s(t, e, r) {
                if (!(this instanceof s)) return new s(t, e, r);
                this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(n.toArray(e, r))
            }
            t.exports = s, s.prototype._init = function(t) {
                t.length > this.blockSize && (t = (new this.Hash).update(t).digest()), i(t.length <= this.blockSize);
                for (var e = t.length; e < this.blockSize; e++) t.push(0);
                for (e = 0; e < t.length; e++) t[e] ^= 54;
                for (this.inner = (new this.Hash).update(t), e = 0; e < t.length; e++) t[e] ^= 106;
                this.outer = (new this.Hash).update(t)
            }, s.prototype.update = function(t, e) {
                return this.inner.update(t, e), this
            }, s.prototype.digest = function(t) {
                return this.outer.update(this.inner.digest()), this.outer.digest(t)
            }
        },
        2801: function(t) {
            t.exports = JSON.parse('{"name":"elliptic","version":"6.5.4","description":"EC cryptography","main":"lib/elliptic.js","files":["lib"],"scripts":{"lint":"eslint lib test","lint:fix":"npm run lint -- --fix","unit":"istanbul test _mocha --reporter=spec test/index.js","test":"npm run lint && npm run unit","version":"grunt dist && git add dist/"},"repository":{"type":"git","url":"git@github.com:indutny/elliptic"},"keywords":["EC","Elliptic","curve","Cryptography"],"author":"Fedor Indutny <fedor@indutny.com>","license":"MIT","bugs":{"url":"https://github.com/indutny/elliptic/issues"},"homepage":"https://github.com/indutny/elliptic","devDependencies":{"brfs":"^2.0.2","coveralls":"^3.1.0","eslint":"^7.6.0","grunt":"^1.2.1","grunt-browserify":"^5.3.0","grunt-cli":"^1.3.2","grunt-contrib-connect":"^3.0.0","grunt-contrib-copy":"^1.0.0","grunt-contrib-uglify":"^5.0.0","grunt-mocha-istanbul":"^5.0.2","grunt-saucelabs":"^9.0.1","istanbul":"^0.4.5","mocha":"^8.0.1"},"dependencies":{"bn.js":"^4.11.9","brorand":"^1.1.0","hash.js":"^1.0.0","hmac-drbg":"^1.0.1","inherits":"^2.0.4","minimalistic-assert":"^1.0.1","minimalistic-crypto-utils":"^1.0.1"}}')
        },
        "32b6": function(t, e, r) {
            "use strict";
            var n = this && this.__extends || function() {
                var t = function(e, r) {
                    return t = Object.setPrototypeOf || {
                        __proto__: []
                    }
                    instanceof Array && function(t, e) {
                        t.__proto__ = e
                    } || function(t, e) {
                        for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r])
                    }, t(e, r)
                };
                return function(e, r) {
                    if ("function" !== typeof r && null !== r) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");

                    function n() {
                        this.constructor = e
                    }
                    t(e, r), e.prototype = null === r ? Object.create(r) : (n.prototype = r.prototype, new n)
                }
            }();
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.RpcError = void 0;
            var i = function(t) {
                function e(r) {
                    var n = this;
                    return n = r.error && r.error.details && r.error.details.length && r.error.details[0].message ? t.call(this, r.error.details[0].message) || this : r.processed && r.processed.except && r.processed.except.message ? t.call(this, r.processed.except.message) || this : t.call(this, r.message) || this, Object.setPrototypeOf(n, e.prototype), n.json = r, n
                }
                return n(e, t), e
            }(Error);
            e.RpcError = i
        },
        3300: function(t, e, r) {
            "use strict";
            var n = r("f3a3"),
                i = r("80af"),
                s = r("3fb5"),
                a = r("ea53"),
                o = n.assert;

            function u(t) {
                a.call(this, "short", t), this.a = new i(t.a, 16).toRed(this.red), this.b = new i(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = 0 === this.a.fromRed().cmpn(0), this.threeA = 0 === this.a.fromRed().sub(this.p).cmpn(-3), this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4)
            }

            function h(t, e, r, n) {
                a.BasePoint.call(this, t, "affine"), null === e && null === r ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new i(e, 16), this.y = new i(r, 16), n && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1)
            }

            function f(t, e, r, n) {
                a.BasePoint.call(this, t, "jacobian"), null === e && null === r && null === n ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new i(0)) : (this.x = new i(e, 16), this.y = new i(r, 16), this.z = new i(n, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one
            }
            s(u, a), t.exports = u, u.prototype._getEndomorphism = function(t) {
                if (this.zeroA && this.g && this.n && 1 === this.p.modn(3)) {
                    var e, r, n;
                    if (t.beta) e = new i(t.beta, 16).toRed(this.red);
                    else {
                        var s = this._getEndoRoots(this.p);
                        e = s[0].cmp(s[1]) < 0 ? s[0] : s[1], e = e.toRed(this.red)
                    }
                    if (t.lambda) r = new i(t.lambda, 16);
                    else {
                        var a = this._getEndoRoots(this.n);
                        0 === this.g.mul(a[0]).x.cmp(this.g.x.redMul(e)) ? r = a[0] : (r = a[1], o(0 === this.g.mul(r).x.cmp(this.g.x.redMul(e))))
                    }
                    return n = t.basis ? t.basis.map((function(t) {
                        return {
                            a: new i(t.a, 16),
                            b: new i(t.b, 16)
                        }
                    })) : this._getEndoBasis(r), {
                        beta: e,
                        lambda: r,
                        basis: n
                    }
                }
            }, u.prototype._getEndoRoots = function(t) {
                var e = t === this.p ? this.red : i.mont(t),
                    r = new i(2).toRed(e).redInvm(),
                    n = r.redNeg(),
                    s = new i(3).toRed(e).redNeg().redSqrt().redMul(r),
                    a = n.redAdd(s).fromRed(),
                    o = n.redSub(s).fromRed();
                return [a, o]
            }, u.prototype._getEndoBasis = function(t) {
                var e, r, n, s, a, o, u, h, f, c = this.n.ushrn(Math.floor(this.n.bitLength() / 2)),
                    l = t,
                    d = this.n.clone(),
                    p = new i(1),
                    m = new i(0),
                    b = new i(0),
                    g = new i(1),
                    y = 0;
                while (0 !== l.cmpn(0)) {
                    var v = d.div(l);
                    h = d.sub(v.mul(l)), f = b.sub(v.mul(p));
                    var w = g.sub(v.mul(m));
                    if (!n && h.cmp(c) < 0) e = u.neg(), r = p, n = h.neg(), s = f;
                    else if (n && 2 === ++y) break;
                    u = h, d = l, l = h, b = p, p = f, g = m, m = w
                }
                a = h.neg(), o = f;
                var _ = n.sqr().add(s.sqr()),
                    M = a.sqr().add(o.sqr());
                return M.cmp(_) >= 0 && (a = e, o = r), n.negative && (n = n.neg(), s = s.neg()), a.negative && (a = a.neg(), o = o.neg()), [{
                    a: n,
                    b: s
                }, {
                    a: a,
                    b: o
                }]
            }, u.prototype._endoSplit = function(t) {
                var e = this.endo.basis,
                    r = e[0],
                    n = e[1],
                    i = n.b.mul(t).divRound(this.n),
                    s = r.b.neg().mul(t).divRound(this.n),
                    a = i.mul(r.a),
                    o = s.mul(n.a),
                    u = i.mul(r.b),
                    h = s.mul(n.b),
                    f = t.sub(a).sub(o),
                    c = u.add(h).neg();
                return {
                    k1: f,
                    k2: c
                }
            }, u.prototype.pointFromX = function(t, e) {
                t = new i(t, 16), t.red || (t = t.toRed(this.red));
                var r = t.redSqr().redMul(t).redIAdd(t.redMul(this.a)).redIAdd(this.b),
                    n = r.redSqrt();
                if (0 !== n.redSqr().redSub(r).cmp(this.zero)) throw new Error("invalid point");
                var s = n.fromRed().isOdd();
                return (e && !s || !e && s) && (n = n.redNeg()), this.point(t, n)
            }, u.prototype.validate = function(t) {
                if (t.inf) return !0;
                var e = t.x,
                    r = t.y,
                    n = this.a.redMul(e),
                    i = e.redSqr().redMul(e).redIAdd(n).redIAdd(this.b);
                return 0 === r.redSqr().redISub(i).cmpn(0)
            }, u.prototype._endoWnafMulAdd = function(t, e, r) {
                for (var n = this._endoWnafT1, i = this._endoWnafT2, s = 0; s < t.length; s++) {
                    var a = this._endoSplit(e[s]),
                        o = t[s],
                        u = o._getBeta();
                    a.k1.negative && (a.k1.ineg(), o = o.neg(!0)), a.k2.negative && (a.k2.ineg(), u = u.neg(!0)), n[2 * s] = o, n[2 * s + 1] = u, i[2 * s] = a.k1, i[2 * s + 1] = a.k2
                }
                for (var h = this._wnafMulAdd(1, n, i, 2 * s, r), f = 0; f < 2 * s; f++) n[f] = null, i[f] = null;
                return h
            }, s(h, a.BasePoint), u.prototype.point = function(t, e, r) {
                return new h(this, t, e, r)
            }, u.prototype.pointFromJSON = function(t, e) {
                return h.fromJSON(this, t, e)
            }, h.prototype._getBeta = function() {
                if (this.curve.endo) {
                    var t = this.precomputed;
                    if (t && t.beta) return t.beta;
                    var e = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
                    if (t) {
                        var r = this.curve,
                            n = function(t) {
                                return r.point(t.x.redMul(r.endo.beta), t.y)
                            };
                        t.beta = e, e.precomputed = {
                            beta: null,
                            naf: t.naf && {
                                wnd: t.naf.wnd,
                                points: t.naf.points.map(n)
                            },
                            doubles: t.doubles && {
                                step: t.doubles.step,
                                points: t.doubles.points.map(n)
                            }
                        }
                    }
                    return e
                }
            }, h.prototype.toJSON = function() {
                return this.precomputed ? [this.x, this.y, this.precomputed && {
                    doubles: this.precomputed.doubles && {
                        step: this.precomputed.doubles.step,
                        points: this.precomputed.doubles.points.slice(1)
                    },
                    naf: this.precomputed.naf && {
                        wnd: this.precomputed.naf.wnd,
                        points: this.precomputed.naf.points.slice(1)
                    }
                }] : [this.x, this.y]
            }, h.fromJSON = function(t, e, r) {
                "string" === typeof e && (e = JSON.parse(e));
                var n = t.point(e[0], e[1], r);
                if (!e[2]) return n;

                function i(e) {
                    return t.point(e[0], e[1], r)
                }
                var s = e[2];
                return n.precomputed = {
                    beta: null,
                    doubles: s.doubles && {
                        step: s.doubles.step,
                        points: [n].concat(s.doubles.points.map(i))
                    },
                    naf: s.naf && {
                        wnd: s.naf.wnd,
                        points: [n].concat(s.naf.points.map(i))
                    }
                }, n
            }, h.prototype.inspect = function() {
                return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">"
            }, h.prototype.isInfinity = function() {
                return this.inf
            }, h.prototype.add = function(t) {
                if (this.inf) return t;
                if (t.inf) return this;
                if (this.eq(t)) return this.dbl();
                if (this.neg().eq(t)) return this.curve.point(null, null);
                if (0 === this.x.cmp(t.x)) return this.curve.point(null, null);
                var e = this.y.redSub(t.y);
                0 !== e.cmpn(0) && (e = e.redMul(this.x.redSub(t.x).redInvm()));
                var r = e.redSqr().redISub(this.x).redISub(t.x),
                    n = e.redMul(this.x.redSub(r)).redISub(this.y);
                return this.curve.point(r, n)
            }, h.prototype.dbl = function() {
                if (this.inf) return this;
                var t = this.y.redAdd(this.y);
                if (0 === t.cmpn(0)) return this.curve.point(null, null);
                var e = this.curve.a,
                    r = this.x.redSqr(),
                    n = t.redInvm(),
                    i = r.redAdd(r).redIAdd(r).redIAdd(e).redMul(n),
                    s = i.redSqr().redISub(this.x.redAdd(this.x)),
                    a = i.redMul(this.x.redSub(s)).redISub(this.y);
                return this.curve.point(s, a)
            }, h.prototype.getX = function() {
                return this.x.fromRed()
            }, h.prototype.getY = function() {
                return this.y.fromRed()
            }, h.prototype.mul = function(t) {
                return t = new i(t, 16), this.isInfinity() ? this : this._hasDoubles(t) ? this.curve._fixedNafMul(this, t) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [t]) : this.curve._wnafMul(this, t)
            }, h.prototype.mulAdd = function(t, e, r) {
                var n = [this, e],
                    i = [t, r];
                return this.curve.endo ? this.curve._endoWnafMulAdd(n, i) : this.curve._wnafMulAdd(1, n, i, 2)
            }, h.prototype.jmulAdd = function(t, e, r) {
                var n = [this, e],
                    i = [t, r];
                return this.curve.endo ? this.curve._endoWnafMulAdd(n, i, !0) : this.curve._wnafMulAdd(1, n, i, 2, !0)
            }, h.prototype.eq = function(t) {
                return this === t || this.inf === t.inf && (this.inf || 0 === this.x.cmp(t.x) && 0 === this.y.cmp(t.y))
            }, h.prototype.neg = function(t) {
                if (this.inf) return this;
                var e = this.curve.point(this.x, this.y.redNeg());
                if (t && this.precomputed) {
                    var r = this.precomputed,
                        n = function(t) {
                            return t.neg()
                        };
                    e.precomputed = {
                        naf: r.naf && {
                            wnd: r.naf.wnd,
                            points: r.naf.points.map(n)
                        },
                        doubles: r.doubles && {
                            step: r.doubles.step,
                            points: r.doubles.points.map(n)
                        }
                    }
                }
                return e
            }, h.prototype.toJ = function() {
                if (this.inf) return this.curve.jpoint(null, null, null);
                var t = this.curve.jpoint(this.x, this.y, this.curve.one);
                return t
            }, s(f, a.BasePoint), u.prototype.jpoint = function(t, e, r) {
                return new f(this, t, e, r)
            }, f.prototype.toP = function() {
                if (this.isInfinity()) return this.curve.point(null, null);
                var t = this.z.redInvm(),
                    e = t.redSqr(),
                    r = this.x.redMul(e),
                    n = this.y.redMul(e).redMul(t);
                return this.curve.point(r, n)
            }, f.prototype.neg = function() {
                return this.curve.jpoint(this.x, this.y.redNeg(), this.z)
            }, f.prototype.add = function(t) {
                if (this.isInfinity()) return t;
                if (t.isInfinity()) return this;
                var e = t.z.redSqr(),
                    r = this.z.redSqr(),
                    n = this.x.redMul(e),
                    i = t.x.redMul(r),
                    s = this.y.redMul(e.redMul(t.z)),
                    a = t.y.redMul(r.redMul(this.z)),
                    o = n.redSub(i),
                    u = s.redSub(a);
                if (0 === o.cmpn(0)) return 0 !== u.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
                var h = o.redSqr(),
                    f = h.redMul(o),
                    c = n.redMul(h),
                    l = u.redSqr().redIAdd(f).redISub(c).redISub(c),
                    d = u.redMul(c.redISub(l)).redISub(s.redMul(f)),
                    p = this.z.redMul(t.z).redMul(o);
                return this.curve.jpoint(l, d, p)
            }, f.prototype.mixedAdd = function(t) {
                if (this.isInfinity()) return t.toJ();
                if (t.isInfinity()) return this;
                var e = this.z.redSqr(),
                    r = this.x,
                    n = t.x.redMul(e),
                    i = this.y,
                    s = t.y.redMul(e).redMul(this.z),
                    a = r.redSub(n),
                    o = i.redSub(s);
                if (0 === a.cmpn(0)) return 0 !== o.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
                var u = a.redSqr(),
                    h = u.redMul(a),
                    f = r.redMul(u),
                    c = o.redSqr().redIAdd(h).redISub(f).redISub(f),
                    l = o.redMul(f.redISub(c)).redISub(i.redMul(h)),
                    d = this.z.redMul(a);
                return this.curve.jpoint(c, l, d)
            }, f.prototype.dblp = function(t) {
                if (0 === t) return this;
                if (this.isInfinity()) return this;
                if (!t) return this.dbl();
                var e;
                if (this.curve.zeroA || this.curve.threeA) {
                    var r = this;
                    for (e = 0; e < t; e++) r = r.dbl();
                    return r
                }
                var n = this.curve.a,
                    i = this.curve.tinv,
                    s = this.x,
                    a = this.y,
                    o = this.z,
                    u = o.redSqr().redSqr(),
                    h = a.redAdd(a);
                for (e = 0; e < t; e++) {
                    var f = s.redSqr(),
                        c = h.redSqr(),
                        l = c.redSqr(),
                        d = f.redAdd(f).redIAdd(f).redIAdd(n.redMul(u)),
                        p = s.redMul(c),
                        m = d.redSqr().redISub(p.redAdd(p)),
                        b = p.redISub(m),
                        g = d.redMul(b);
                    g = g.redIAdd(g).redISub(l);
                    var y = h.redMul(o);
                    e + 1 < t && (u = u.redMul(l)), s = m, o = y, h = g
                }
                return this.curve.jpoint(s, h.redMul(i), o)
            }, f.prototype.dbl = function() {
                return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl()
            }, f.prototype._zeroDbl = function() {
                var t, e, r;
                if (this.zOne) {
                    var n = this.x.redSqr(),
                        i = this.y.redSqr(),
                        s = i.redSqr(),
                        a = this.x.redAdd(i).redSqr().redISub(n).redISub(s);
                    a = a.redIAdd(a);
                    var o = n.redAdd(n).redIAdd(n),
                        u = o.redSqr().redISub(a).redISub(a),
                        h = s.redIAdd(s);
                    h = h.redIAdd(h), h = h.redIAdd(h), t = u, e = o.redMul(a.redISub(u)).redISub(h), r = this.y.redAdd(this.y)
                } else {
                    var f = this.x.redSqr(),
                        c = this.y.redSqr(),
                        l = c.redSqr(),
                        d = this.x.redAdd(c).redSqr().redISub(f).redISub(l);
                    d = d.redIAdd(d);
                    var p = f.redAdd(f).redIAdd(f),
                        m = p.redSqr(),
                        b = l.redIAdd(l);
                    b = b.redIAdd(b), b = b.redIAdd(b), t = m.redISub(d).redISub(d), e = p.redMul(d.redISub(t)).redISub(b), r = this.y.redMul(this.z), r = r.redIAdd(r)
                }
                return this.curve.jpoint(t, e, r)
            }, f.prototype._threeDbl = function() {
                var t, e, r;
                if (this.zOne) {
                    var n = this.x.redSqr(),
                        i = this.y.redSqr(),
                        s = i.redSqr(),
                        a = this.x.redAdd(i).redSqr().redISub(n).redISub(s);
                    a = a.redIAdd(a);
                    var o = n.redAdd(n).redIAdd(n).redIAdd(this.curve.a),
                        u = o.redSqr().redISub(a).redISub(a);
                    t = u;
                    var h = s.redIAdd(s);
                    h = h.redIAdd(h), h = h.redIAdd(h), e = o.redMul(a.redISub(u)).redISub(h), r = this.y.redAdd(this.y)
                } else {
                    var f = this.z.redSqr(),
                        c = this.y.redSqr(),
                        l = this.x.redMul(c),
                        d = this.x.redSub(f).redMul(this.x.redAdd(f));
                    d = d.redAdd(d).redIAdd(d);
                    var p = l.redIAdd(l);
                    p = p.redIAdd(p);
                    var m = p.redAdd(p);
                    t = d.redSqr().redISub(m), r = this.y.redAdd(this.z).redSqr().redISub(c).redISub(f);
                    var b = c.redSqr();
                    b = b.redIAdd(b), b = b.redIAdd(b), b = b.redIAdd(b), e = d.redMul(p.redISub(t)).redISub(b)
                }
                return this.curve.jpoint(t, e, r)
            }, f.prototype._dbl = function() {
                var t = this.curve.a,
                    e = this.x,
                    r = this.y,
                    n = this.z,
                    i = n.redSqr().redSqr(),
                    s = e.redSqr(),
                    a = r.redSqr(),
                    o = s.redAdd(s).redIAdd(s).redIAdd(t.redMul(i)),
                    u = e.redAdd(e);
                u = u.redIAdd(u);
                var h = u.redMul(a),
                    f = o.redSqr().redISub(h.redAdd(h)),
                    c = h.redISub(f),
                    l = a.redSqr();
                l = l.redIAdd(l), l = l.redIAdd(l), l = l.redIAdd(l);
                var d = o.redMul(c).redISub(l),
                    p = r.redAdd(r).redMul(n);
                return this.curve.jpoint(f, d, p)
            }, f.prototype.trpl = function() {
                if (!this.curve.zeroA) return this.dbl().add(this);
                var t = this.x.redSqr(),
                    e = this.y.redSqr(),
                    r = this.z.redSqr(),
                    n = e.redSqr(),
                    i = t.redAdd(t).redIAdd(t),
                    s = i.redSqr(),
                    a = this.x.redAdd(e).redSqr().redISub(t).redISub(n);
                a = a.redIAdd(a), a = a.redAdd(a).redIAdd(a), a = a.redISub(s);
                var o = a.redSqr(),
                    u = n.redIAdd(n);
                u = u.redIAdd(u), u = u.redIAdd(u), u = u.redIAdd(u);
                var h = i.redIAdd(a).redSqr().redISub(s).redISub(o).redISub(u),
                    f = e.redMul(h);
                f = f.redIAdd(f), f = f.redIAdd(f);
                var c = this.x.redMul(o).redISub(f);
                c = c.redIAdd(c), c = c.redIAdd(c);
                var l = this.y.redMul(h.redMul(u.redISub(h)).redISub(a.redMul(o)));
                l = l.redIAdd(l), l = l.redIAdd(l), l = l.redIAdd(l);
                var d = this.z.redAdd(a).redSqr().redISub(r).redISub(o);
                return this.curve.jpoint(c, l, d)
            }, f.prototype.mul = function(t, e) {
                return t = new i(t, e), this.curve._wnafMul(this, t)
            }, f.prototype.eq = function(t) {
                if ("affine" === t.type) return this.eq(t.toJ());
                if (this === t) return !0;
                var e = this.z.redSqr(),
                    r = t.z.redSqr();
                if (0 !== this.x.redMul(r).redISub(t.x.redMul(e)).cmpn(0)) return !1;
                var n = e.redMul(this.z),
                    i = r.redMul(t.z);
                return 0 === this.y.redMul(i).redISub(t.y.redMul(n)).cmpn(0)
            }, f.prototype.eqXToP = function(t) {
                var e = this.z.redSqr(),
                    r = t.toRed(this.curve.red).redMul(e);
                if (0 === this.x.cmp(r)) return !0;
                for (var n = t.clone(), i = this.curve.redN.redMul(e);;) {
                    if (n.iadd(this.curve.n), n.cmp(this.curve.p) >= 0) return !1;
                    if (r.redIAdd(i), 0 === this.x.cmp(r)) return !0
                }
            }, f.prototype.inspect = function() {
                return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">"
            }, f.prototype.isInfinity = function() {
                return 0 === this.z.cmpn(0)
            }
        },
        3337: function(t, e, r) {
            "use strict";
            var n = e;
            n.version = r("2801").version, n.utils = r("f3a3"), n.rand = r("fdac"), n.curve = r("4136"), n.curves = r("0cbb"), n.ec = r("b9a8"), n.eddsa = r("945d")
        },
        "334a": function(t, e, r) {
            e = t.exports = r("4250"), e.Stream = e, e.Readable = e, e.Writable = r("19ea"), e.Duplex = r("e666"), e.Transform = r("09dc"), e.PassThrough = r("0ae3"), e.finished = r("ee93"), e.pipeline = r("fbd5")
        },
        "380f": function(t, e, r) {
            "use strict";
            var n = r("f3a3"),
                i = n.assert,
                s = n.parseBytes,
                a = n.cachedProperty;

            function o(t, e) {
                this.eddsa = t, this._secret = s(e.secret), t.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = s(e.pub)
            }
            o.fromPublic = function(t, e) {
                return e instanceof o ? e : new o(t, {
                    pub: e
                })
            }, o.fromSecret = function(t, e) {
                return e instanceof o ? e : new o(t, {
                    secret: e
                })
            }, o.prototype.secret = function() {
                return this._secret
            }, a(o, "pubBytes", (function() {
                return this.eddsa.encodePoint(this.pub())
            })), a(o, "pub", (function() {
                return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv())
            })), a(o, "privBytes", (function() {
                var t = this.eddsa,
                    e = this.hash(),
                    r = t.encodingLength - 1,
                    n = e.slice(0, t.encodingLength);
                return n[0] &= 248, n[r] &= 127, n[r] |= 64, n
            })), a(o, "priv", (function() {
                return this.eddsa.decodeInt(this.privBytes())
            })), a(o, "hash", (function() {
                return this.eddsa.hash().update(this.secret()).digest()
            })), a(o, "messagePrefix", (function() {
                return this.hash().slice(this.eddsa.encodingLength)
            })), o.prototype.sign = function(t) {
                return i(this._secret, "KeyPair can only verify"), this.eddsa.sign(t, this)
            }, o.prototype.verify = function(t, e) {
                return this.eddsa.verify(t, e, this)
            }, o.prototype.getSecret = function(t) {
                return i(this._secret, "KeyPair is public only"), n.encode(this.secret(), t)
            }, o.prototype.getPublic = function(t) {
                return n.encode(this.pubBytes(), t)
            }, t.exports = o
        },
        "3daf": function(t, e, r) {
            "use strict";
            var n = r("f3a3"),
                i = r("80af"),
                s = r("3fb5"),
                a = r("ea53"),
                o = n.assert;

            function u(t) {
                this.twisted = 1 !== (0 | t.a), this.mOneA = this.twisted && -1 === (0 | t.a), this.extended = this.mOneA, a.call(this, "edwards", t), this.a = new i(t.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new i(t.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new i(t.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), o(!this.twisted || 0 === this.c.fromRed().cmpn(1)), this.oneC = 1 === (0 | t.c)
            }

            function h(t, e, r, n, s) {
                a.BasePoint.call(this, t, "projective"), null === e && null === r && null === n ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new i(e, 16), this.y = new i(r, 16), this.z = n ? new i(n, 16) : this.curve.one, this.t = s && new i(s, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))))
            }
            s(u, a), t.exports = u, u.prototype._mulA = function(t) {
                return this.mOneA ? t.redNeg() : this.a.redMul(t)
            }, u.prototype._mulC = function(t) {
                return this.oneC ? t : this.c.redMul(t)
            }, u.prototype.jpoint = function(t, e, r, n) {
                return this.point(t, e, r, n)
            }, u.prototype.pointFromX = function(t, e) {
                t = new i(t, 16), t.red || (t = t.toRed(this.red));
                var r = t.redSqr(),
                    n = this.c2.redSub(this.a.redMul(r)),
                    s = this.one.redSub(this.c2.redMul(this.d).redMul(r)),
                    a = n.redMul(s.redInvm()),
                    o = a.redSqrt();
                if (0 !== o.redSqr().redSub(a).cmp(this.zero)) throw new Error("invalid point");
                var u = o.fromRed().isOdd();
                return (e && !u || !e && u) && (o = o.redNeg()), this.point(t, o)
            }, u.prototype.pointFromY = function(t, e) {
                t = new i(t, 16), t.red || (t = t.toRed(this.red));
                var r = t.redSqr(),
                    n = r.redSub(this.c2),
                    s = r.redMul(this.d).redMul(this.c2).redSub(this.a),
                    a = n.redMul(s.redInvm());
                if (0 === a.cmp(this.zero)) {
                    if (e) throw new Error("invalid point");
                    return this.point(this.zero, t)
                }
                var o = a.redSqrt();
                if (0 !== o.redSqr().redSub(a).cmp(this.zero)) throw new Error("invalid point");
                return o.fromRed().isOdd() !== e && (o = o.redNeg()), this.point(o, t)
            }, u.prototype.validate = function(t) {
                if (t.isInfinity()) return !0;
                t.normalize();
                var e = t.x.redSqr(),
                    r = t.y.redSqr(),
                    n = e.redMul(this.a).redAdd(r),
                    i = this.c2.redMul(this.one.redAdd(this.d.redMul(e).redMul(r)));
                return 0 === n.cmp(i)
            }, s(h, a.BasePoint), u.prototype.pointFromJSON = function(t) {
                return h.fromJSON(this, t)
            }, u.prototype.point = function(t, e, r, n) {
                return new h(this, t, e, r, n)
            }, h.fromJSON = function(t, e) {
                return new h(t, e[0], e[1], e[2])
            }, h.prototype.inspect = function() {
                return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">"
            }, h.prototype.isInfinity = function() {
                return 0 === this.x.cmpn(0) && (0 === this.y.cmp(this.z) || this.zOne && 0 === this.y.cmp(this.curve.c))
            }, h.prototype._extDbl = function() {
                var t = this.x.redSqr(),
                    e = this.y.redSqr(),
                    r = this.z.redSqr();
                r = r.redIAdd(r);
                var n = this.curve._mulA(t),
                    i = this.x.redAdd(this.y).redSqr().redISub(t).redISub(e),
                    s = n.redAdd(e),
                    a = s.redSub(r),
                    o = n.redSub(e),
                    u = i.redMul(a),
                    h = s.redMul(o),
                    f = i.redMul(o),
                    c = a.redMul(s);
                return this.curve.point(u, h, c, f)
            }, h.prototype._projDbl = function() {
                var t, e, r, n, i, s, a = this.x.redAdd(this.y).redSqr(),
                    o = this.x.redSqr(),
                    u = this.y.redSqr();
                if (this.curve.twisted) {
                    n = this.curve._mulA(o);
                    var h = n.redAdd(u);
                    this.zOne ? (t = a.redSub(o).redSub(u).redMul(h.redSub(this.curve.two)), e = h.redMul(n.redSub(u)), r = h.redSqr().redSub(h).redSub(h)) : (i = this.z.redSqr(), s = h.redSub(i).redISub(i), t = a.redSub(o).redISub(u).redMul(s), e = h.redMul(n.redSub(u)), r = h.redMul(s))
                } else n = o.redAdd(u), i = this.curve._mulC(this.z).redSqr(), s = n.redSub(i).redSub(i), t = this.curve._mulC(a.redISub(n)).redMul(s), e = this.curve._mulC(n).redMul(o.redISub(u)), r = n.redMul(s);
                return this.curve.point(t, e, r)
            }, h.prototype.dbl = function() {
                return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl()
            }, h.prototype._extAdd = function(t) {
                var e = this.y.redSub(this.x).redMul(t.y.redSub(t.x)),
                    r = this.y.redAdd(this.x).redMul(t.y.redAdd(t.x)),
                    n = this.t.redMul(this.curve.dd).redMul(t.t),
                    i = this.z.redMul(t.z.redAdd(t.z)),
                    s = r.redSub(e),
                    a = i.redSub(n),
                    o = i.redAdd(n),
                    u = r.redAdd(e),
                    h = s.redMul(a),
                    f = o.redMul(u),
                    c = s.redMul(u),
                    l = a.redMul(o);
                return this.curve.point(h, f, l, c)
            }, h.prototype._projAdd = function(t) {
                var e, r, n = this.z.redMul(t.z),
                    i = n.redSqr(),
                    s = this.x.redMul(t.x),
                    a = this.y.redMul(t.y),
                    o = this.curve.d.redMul(s).redMul(a),
                    u = i.redSub(o),
                    h = i.redAdd(o),
                    f = this.x.redAdd(this.y).redMul(t.x.redAdd(t.y)).redISub(s).redISub(a),
                    c = n.redMul(u).redMul(f);
                return this.curve.twisted ? (e = n.redMul(h).redMul(a.redSub(this.curve._mulA(s))), r = u.redMul(h)) : (e = n.redMul(h).redMul(a.redSub(s)), r = this.curve._mulC(u).redMul(h)), this.curve.point(c, e, r)
            }, h.prototype.add = function(t) {
                return this.isInfinity() ? t : t.isInfinity() ? this : this.curve.extended ? this._extAdd(t) : this._projAdd(t)
            }, h.prototype.mul = function(t) {
                return this._hasDoubles(t) ? this.curve._fixedNafMul(this, t) : this.curve._wnafMul(this, t)
            }, h.prototype.mulAdd = function(t, e, r) {
                return this.curve._wnafMulAdd(1, [this, e], [t, r], 2, !1)
            }, h.prototype.jmulAdd = function(t, e, r) {
                return this.curve._wnafMulAdd(1, [this, e], [t, r], 2, !0)
            }, h.prototype.normalize = function() {
                if (this.zOne) return this;
                var t = this.z.redInvm();
                return this.x = this.x.redMul(t), this.y = this.y.redMul(t), this.t && (this.t = this.t.redMul(t)), this.z = this.curve.one, this.zOne = !0, this
            }, h.prototype.neg = function() {
                return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg())
            }, h.prototype.getX = function() {
                return this.normalize(), this.x.fromRed()
            }, h.prototype.getY = function() {
                return this.normalize(), this.y.fromRed()
            }, h.prototype.eq = function(t) {
                return this === t || 0 === this.getX().cmp(t.getX()) && 0 === this.getY().cmp(t.getY())
            }, h.prototype.eqXToP = function(t) {
                var e = t.toRed(this.curve.red).redMul(this.z);
                if (0 === this.x.cmp(e)) return !0;
                for (var r = t.clone(), n = this.curve.redN.redMul(this.z);;) {
                    if (r.iadd(this.curve.n), r.cmp(this.curve.p) >= 0) return !1;
                    if (e.redIAdd(n), 0 === this.x.cmp(e)) return !0
                }
            }, h.prototype.toP = h.prototype.normalize, h.prototype.mixedAdd = h.prototype.add
        },
        "3fb5": function(t, e) {
            "function" === typeof Object.create ? t.exports = function(t, e) {
                e && (t.super_ = e, t.prototype = Object.create(e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }))
            } : t.exports = function(t, e) {
                if (e) {
                    t.super_ = e;
                    var r = function() {};
                    r.prototype = e.prototype, t.prototype = new r, t.prototype.constructor = t
                }
            }
        },
        "3fe3": function(t, e, r) {
            (function(e) {
                var r = null;
                "undefined" !== typeof WebSocket ? r = WebSocket : "undefined" !== typeof MozWebSocket ? r = MozWebSocket : "undefined" !== typeof e ? r = e.WebSocket || e.MozWebSocket : "undefined" !== typeof window ? r = window.WebSocket || window.MozWebSocket : "undefined" !== typeof self && (r = self.WebSocket || self.MozWebSocket), t.exports = r
            }).call(this, r("c8ba"))
        },
        "409b": function(t, e) {
            t.exports = {
                doubles: {
                    step: 4,
                    points: [
                        ["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"],
                        ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"],
                        ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"],
                        ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"],
                        ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"],
                        ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"],
                        ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"],
                        ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"],
                        ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"],
                        ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"],
                        ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"],
                        ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"],
                        ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"],
                        ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"],
                        ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"],
                        ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"],
                        ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"],
                        ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"],
                        ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"],
                        ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"],
                        ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"],
                        ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"],
                        ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"],
                        ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"],
                        ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"],
                        ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"],
                        ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"],
                        ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"],
                        ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"],
                        ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"],
                        ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"],
                        ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"],
                        ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"],
                        ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"],
                        ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"],
                        ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"],
                        ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"],
                        ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"],
                        ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"],
                        ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"],
                        ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"],
                        ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"],
                        ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"],
                        ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"],
                        ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"],
                        ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"],
                        ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"],
                        ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"],
                        ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"],
                        ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"],
                        ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"],
                        ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"],
                        ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"],
                        ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"],
                        ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"],
                        ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"],
                        ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"],
                        ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"],
                        ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"],
                        ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"],
                        ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"],
                        ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"],
                        ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"],
                        ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"],
                        ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]
                    ]
                },
                naf: {
                    wnd: 7,
                    points: [
                        ["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"],
                        ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"],
                        ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"],
                        ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"],
                        ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"],
                        ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"],
                        ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"],
                        ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"],
                        ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"],
                        ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"],
                        ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"],
                        ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"],
                        ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"],
                        ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"],
                        ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"],
                        ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"],
                        ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"],
                        ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"],
                        ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"],
                        ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"],
                        ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"],
                        ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"],
                        ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"],
                        ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"],
                        ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"],
                        ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"],
                        ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"],
                        ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"],
                        ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"],
                        ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"],
                        ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"],
                        ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"],
                        ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"],
                        ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"],
                        ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"],
                        ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"],
                        ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"],
                        ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"],
                        ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"],
                        ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"],
                        ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"],
                        ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"],
                        ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"],
                        ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"],
                        ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"],
                        ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"],
                        ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"],
                        ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"],
                        ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"],
                        ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"],
                        ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"],
                        ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"],
                        ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"],
                        ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"],
                        ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"],
                        ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"],
                        ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"],
                        ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"],
                        ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"],
                        ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"],
                        ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"],
                        ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"],
                        ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"],
                        ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"],
                        ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"],
                        ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"],
                        ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"],
                        ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"],
                        ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"],
                        ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"],
                        ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"],
                        ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"],
                        ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"],
                        ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"],
                        ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"],
                        ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"],
                        ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"],
                        ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"],
                        ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"],
                        ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"],
                        ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"],
                        ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"],
                        ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"],
                        ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"],
                        ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"],
                        ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"],
                        ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"],
                        ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"],
                        ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"],
                        ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"],
                        ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"],
                        ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"],
                        ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"],
                        ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"],
                        ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"],
                        ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"],
                        ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"],
                        ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"],
                        ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"],
                        ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"],
                        ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"],
                        ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"],
                        ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"],
                        ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"],
                        ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"],
                        ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"],
                        ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"],
                        ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"],
                        ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"],
                        ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"],
                        ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"],
                        ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"],
                        ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"],
                        ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"],
                        ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"],
                        ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"],
                        ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"],
                        ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"],
                        ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"],
                        ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"],
                        ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"],
                        ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"],
                        ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"],
                        ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"],
                        ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"],
                        ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"],
                        ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]
                    ]
                }
            }
        },
        "40a1": function(t, e, r) {
            "use strict";
            var n = function() {
                    function t(t, e) {
                        var r = [],
                            n = !0,
                            i = !1,
                            s = void 0;
                        try {
                            for (var a, o = t[Symbol.iterator](); !(n = (a = o.next()).done); n = !0)
                                if (r.push(a.value), e && r.length === e) break
                        } catch (u) {
                            i = !0, s = u
                        } finally {
                            try {
                                !n && o["return"] && o["return"]()
                            } finally {
                                if (i) throw s
                            }
                        }
                        return r
                    }
                    return function(e, r) {
                        if (Array.isArray(e)) return e;
                        if (Symbol.iterator in Object(e)) return t(e, r);
                        throw new TypeError("Invalid attempt to destructure non-iterable instance")
                    }
                }(),
                i = function() {
                    function t(t, e) {
                        for (var r = 0; r < e.length; r++) {
                            var n = e[r];
                            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                        }
                    }
                    return function(e, r, n) {
                        return r && t(e.prototype, r), n && t(e, n), e
                    }
                }();

            function s(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }
            var a = function() {
                function t() {
                    s(this, t)
                }
                return i(t, null, [{
                    key: "get_n_pad_bytes",
                    value: function(t) {
                        return 64 - (t + 8 & 63)
                    }
                }, {
                    key: "pad",
                    value: function(e) {
                        var r = e.byteLength,
                            i = t.get_n_pad_bytes(r),
                            s = function(t, e) {
                                return [Math.floor(t / e), t % e]
                            },
                            a = s(r, 536870912).map((function(t, e) {
                                return e ? 8 * t : t
                            })),
                            o = n(a, 2),
                            u = o[0],
                            h = o[1],
                            f = new Uint8Array(r + i + 8);
                        f.set(new Uint8Array(e), 0);
                        var c = new DataView(f.buffer);
                        return c.setUint8(r, 128), c.setUint32(r + i, h, !0), c.setUint32(r + i + 4, u, !0), f.buffer
                    }
                }, {
                    key: "f",
                    value: function(t, e, r, n) {
                        return 0 <= t && t <= 15 ? e ^ r ^ n : 16 <= t && t <= 31 ? e & r | ~e & n : 32 <= t && t <= 47 ? (e | ~r) ^ n : 48 <= t && t <= 63 ? e & n | r & ~n : 64 <= t && t <= 79 ? e ^ (r | ~n) : void 0
                    }
                }, {
                    key: "K",
                    value: function(t) {
                        return 0 <= t && t <= 15 ? 0 : 16 <= t && t <= 31 ? 1518500249 : 32 <= t && t <= 47 ? 1859775393 : 48 <= t && t <= 63 ? 2400959708 : 64 <= t && t <= 79 ? 2840853838 : void 0
                    }
                }, {
                    key: "KP",
                    value: function(t) {
                        return 0 <= t && t <= 15 ? 1352829926 : 16 <= t && t <= 31 ? 1548603684 : 32 <= t && t <= 47 ? 1836072691 : 48 <= t && t <= 63 ? 2053994217 : 64 <= t && t <= 79 ? 0 : void 0
                    }
                }, {
                    key: "add_modulo32",
                    value: function() {
                        return 0 | Array.from(arguments).reduce((function(t, e) {
                            return t + e
                        }), 0)
                    }
                }, {
                    key: "rol32",
                    value: function(t, e) {
                        return t << e | t >>> 32 - e
                    }
                }, {
                    key: "hash",
                    value: function(e) {
                        for (var r = t.pad(e), n = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], i = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], s = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], a = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], o = 4, u = 64, h = r.byteLength / u, f = new Array(h).fill(void 0).map((function(t, e) {
                                return function(t) {
                                    return new DataView(r, e * u, u).getUint32(t * o, !0)
                                }
                            })), c = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], l = 0; l < h; ++l) {
                            for (var d = c[0], p = c[1], m = c[2], b = c[3], g = c[4], y = d, v = p, w = m, _ = b, M = g, A = 0; A < 80; ++A) {
                                var S = t.add_modulo32(t.rol32(t.add_modulo32(d, t.f(A, p, m, b), f[l](n[A]), t.K(A)), s[A]), g);
                                d = g, g = b, b = t.rol32(m, 10), m = p, p = S, S = t.add_modulo32(t.rol32(t.add_modulo32(y, t.f(79 - A, v, w, _), f[l](i[A]), t.KP(A)), a[A]), M), y = M, M = _, _ = t.rol32(w, 10), w = v, v = S
                            }
                            var x = t.add_modulo32(c[1], m, _);
                            c[1] = t.add_modulo32(c[2], b, M), c[2] = t.add_modulo32(c[3], g, y), c[3] = t.add_modulo32(c[4], d, v), c[4] = t.add_modulo32(c[0], p, w), c[0] = x
                        }
                        var E = new ArrayBuffer(20),
                            k = new DataView(E);
                        return c.forEach((function(t, e) {
                            return k.setUint32(4 * e, t, !0)
                        })), E
                    }
                }]), t
            }();
            t.exports = {
                RIPEMD160: a
            }
        },
        4136: function(t, e, r) {
            "use strict";
            var n = e;
            n.base = r("ea53"), n.short = r("3300"), n.mont = r("676f"), n.edwards = r("3daf")
        },
        4186: function(t, e, r) {
            "use strict";
            (function(e) {
                var n;

                function i(t, e, r) {
                    return e in t ? Object.defineProperty(t, e, {
                        value: r,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : t[e] = r, t
                }
                var s = r("ee93"),
                    a = Symbol("lastResolve"),
                    o = Symbol("lastReject"),
                    u = Symbol("error"),
                    h = Symbol("ended"),
                    f = Symbol("lastPromise"),
                    c = Symbol("handlePromise"),
                    l = Symbol("stream");

                function d(t, e) {
                    return {
                        value: t,
                        done: e
                    }
                }

                function p(t) {
                    var e = t[a];
                    if (null !== e) {
                        var r = t[l].read();
                        null !== r && (t[f] = null, t[a] = null, t[o] = null, e(d(r, !1)))
                    }
                }

                function m(t) {
                    e.nextTick(p, t)
                }

                function b(t, e) {
                    return function(r, n) {
                        t.then((function() {
                            e[h] ? r(d(void 0, !0)) : e[c](r, n)
                        }), n)
                    }
                }
                var g = Object.getPrototypeOf((function() {})),
                    y = Object.setPrototypeOf((n = {
                        get stream() {
                            return this[l]
                        },
                        next: function() {
                            var t = this,
                                r = this[u];
                            if (null !== r) return Promise.reject(r);
                            if (this[h]) return Promise.resolve(d(void 0, !0));
                            if (this[l].destroyed) return new Promise((function(r, n) {
                                e.nextTick((function() {
                                    t[u] ? n(t[u]) : r(d(void 0, !0))
                                }))
                            }));
                            var n, i = this[f];
                            if (i) n = new Promise(b(i, this));
                            else {
                                var s = this[l].read();
                                if (null !== s) return Promise.resolve(d(s, !1));
                                n = new Promise(this[c])
                            }
                            return this[f] = n, n
                        }
                    }, i(n, Symbol.asyncIterator, (function() {
                        return this
                    })), i(n, "return", (function() {
                        var t = this;
                        return new Promise((function(e, r) {
                            t[l].destroy(null, (function(t) {
                                t ? r(t) : e(d(void 0, !0))
                            }))
                        }))
                    })), n), g),
                    v = function(t) {
                        var e, r = Object.create(y, (e = {}, i(e, l, {
                            value: t,
                            writable: !0
                        }), i(e, a, {
                            value: null,
                            writable: !0
                        }), i(e, o, {
                            value: null,
                            writable: !0
                        }), i(e, u, {
                            value: null,
                            writable: !0
                        }), i(e, h, {
                            value: t._readableState.endEmitted,
                            writable: !0
                        }), i(e, c, {
                            value: function(t, e) {
                                var n = r[l].read();
                                n ? (r[f] = null, r[a] = null, r[o] = null, t(d(n, !1))) : (r[a] = t, r[o] = e)
                            },
                            writable: !0
                        }), e));
                        return r[f] = null, s(t, (function(t) {
                            if (t && "ERR_STREAM_PREMATURE_CLOSE" !== t.code) {
                                var e = r[o];
                                return null !== e && (r[f] = null, r[a] = null, r[o] = null, e(t)), void(r[u] = t)
                            }
                            var n = r[a];
                            null !== n && (r[f] = null, r[a] = null, r[o] = null, n(d(void 0, !0))), r[h] = !0
                        })), t.on("readable", m.bind(null, r)), r
                    };
                t.exports = v
            }).call(this, r("4362"))
        },
        4250: function(t, e, r) {
            "use strict";
            (function(e, n) {
                var i;
                t.exports = O, O.ReadableState = R;
                r("faa1").EventEmitter;
                var s = function(t, e) {
                        return t.listeners(e).length
                    },
                    a = r("5bbb"),
                    o = r("b639").Buffer,
                    u = e.Uint8Array || function() {};

                function h(t) {
                    return o.from(t)
                }

                function f(t) {
                    return o.isBuffer(t) || t instanceof u
                }
                var c, l = r(4);
                c = l && l.debuglog ? l.debuglog("stream") : function() {};
                var d, p, m, b = r("96a5"),
                    g = r("493f"),
                    y = r("b9b5"),
                    v = y.getHighWaterMark,
                    w = r("9d8a").codes,
                    _ = w.ERR_INVALID_ARG_TYPE,
                    M = w.ERR_STREAM_PUSH_AFTER_EOF,
                    A = w.ERR_METHOD_NOT_IMPLEMENTED,
                    S = w.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
                r("3fb5")(O, a);
                var x = g.errorOrDestroy,
                    E = ["error", "close", "destroy", "pause", "resume"];

                function k(t, e, r) {
                    if ("function" === typeof t.prependListener) return t.prependListener(e, r);
                    t._events && t._events[e] ? Array.isArray(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]] : t.on(e, r)
                }

                function R(t, e, n) {
                    i = i || r("e666"), t = t || {}, "boolean" !== typeof n && (n = e instanceof i), this.objectMode = !!t.objectMode, n && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = v(this, t, "readableHighWaterMark", n), this.buffer = new b, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = !1 !== t.emitClose, this.autoDestroy = !!t.autoDestroy, this.destroyed = !1, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, t.encoding && (d || (d = r("7d72").StringDecoder), this.decoder = new d(t.encoding), this.encoding = t.encoding)
                }

                function O(t) {
                    if (i = i || r("e666"), !(this instanceof O)) return new O(t);
                    var e = this instanceof i;
                    this._readableState = new R(t, this, e), this.readable = !0, t && ("function" === typeof t.read && (this._read = t.read), "function" === typeof t.destroy && (this._destroy = t.destroy)), a.call(this)
                }

                function I(t, e, r, n, i) {
                    c("readableAddChunk", e);
                    var s, a = t._readableState;
                    if (null === e) a.reading = !1, z(t, a);
                    else if (i || (s = T(a, e)), s) x(t, s);
                    else if (a.objectMode || e && e.length > 0)
                        if ("string" === typeof e || a.objectMode || Object.getPrototypeOf(e) === o.prototype || (e = h(e)), n) a.endEmitted ? x(t, new S) : P(t, a, e, !0);
                        else if (a.ended) x(t, new M);
                    else {
                        if (a.destroyed) return !1;
                        a.reading = !1, a.decoder && !r ? (e = a.decoder.write(e), a.objectMode || 0 !== e.length ? P(t, a, e, !1) : F(t, a)) : P(t, a, e, !1)
                    } else n || (a.reading = !1, F(t, a));
                    return !a.ended && (a.length < a.highWaterMark || 0 === a.length)
                }

                function P(t, e, r, n) {
                    e.flowing && 0 === e.length && !e.sync ? (e.awaitDrain = 0, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, n ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && D(t)), F(t, e)
                }

                function T(t, e) {
                    var r;
                    return f(e) || "string" === typeof e || void 0 === e || t.objectMode || (r = new _("chunk", ["string", "Buffer", "Uint8Array"], e)), r
                }
                Object.defineProperty(O.prototype, "destroyed", {
                    enumerable: !1,
                    get: function() {
                        return void 0 !== this._readableState && this._readableState.destroyed
                    },
                    set: function(t) {
                        this._readableState && (this._readableState.destroyed = t)
                    }
                }), O.prototype.destroy = g.destroy, O.prototype._undestroy = g.undestroy, O.prototype._destroy = function(t, e) {
                    e(t)
                }, O.prototype.push = function(t, e) {
                    var r, n = this._readableState;
                    return n.objectMode ? r = !0 : "string" === typeof t && (e = e || n.defaultEncoding, e !== n.encoding && (t = o.from(t, e), e = ""), r = !0), I(this, t, e, !1, r)
                }, O.prototype.unshift = function(t) {
                    return I(this, t, null, !0, !1)
                }, O.prototype.isPaused = function() {
                    return !1 === this._readableState.flowing
                }, O.prototype.setEncoding = function(t) {
                    d || (d = r("7d72").StringDecoder);
                    var e = new d(t);
                    this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
                    var n = this._readableState.buffer.head,
                        i = "";
                    while (null !== n) i += e.write(n.data), n = n.next;
                    return this._readableState.buffer.clear(), "" !== i && this._readableState.buffer.push(i), this._readableState.length = i.length, this
                };
                var N = 1073741824;

                function j(t) {
                    return t >= N ? t = N : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t
                }

                function C(t, e) {
                    return t <= 0 || 0 === e.length && e.ended ? 0 : e.objectMode ? 1 : t !== t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = j(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = !0, 0))
                }

                function z(t, e) {
                    if (c("onEofChunk"), !e.ended) {
                        if (e.decoder) {
                            var r = e.decoder.end();
                            r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length)
                        }
                        e.ended = !0, e.sync ? D(t) : (e.needReadable = !1, e.emittedReadable || (e.emittedReadable = !0, L(t)))
                    }
                }

                function D(t) {
                    var e = t._readableState;
                    c("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = !1, e.emittedReadable || (c("emitReadable", e.flowing), e.emittedReadable = !0, n.nextTick(L, t))
                }

                function L(t) {
                    var e = t._readableState;
                    c("emitReadable_", e.destroyed, e.length, e.ended), e.destroyed || !e.length && !e.ended || (t.emit("readable"), e.emittedReadable = !1), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, W(t)
                }

                function F(t, e) {
                    e.readingMore || (e.readingMore = !0, n.nextTick(B, t, e))
                }

                function B(t, e) {
                    while (!e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && 0 === e.length)) {
                        var r = e.length;
                        if (c("maybeReadMore read 0"), t.read(0), r === e.length) break
                    }
                    e.readingMore = !1
                }

                function $(t) {
                    return function() {
                        var e = t._readableState;
                        c("pipeOnDrain", e.awaitDrain), e.awaitDrain && e.awaitDrain--, 0 === e.awaitDrain && s(t, "data") && (e.flowing = !0, W(t))
                    }
                }

                function U(t) {
                    var e = t._readableState;
                    e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && !e.paused ? e.flowing = !0 : t.listenerCount("data") > 0 && t.resume()
                }

                function q(t) {
                    c("readable nexttick read 0"), t.read(0)
                }

                function K(t, e) {
                    e.resumeScheduled || (e.resumeScheduled = !0, n.nextTick(V, t, e))
                }

                function V(t, e) {
                    c("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = !1, t.emit("resume"), W(t), e.flowing && !e.reading && t.read(0)
                }

                function W(t) {
                    var e = t._readableState;
                    c("flow", e.flowing);
                    while (e.flowing && null !== t.read());
                }

                function Z(t, e) {
                    return 0 === e.length ? null : (e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (r = e.decoder ? e.buffer.join("") : 1 === e.buffer.length ? e.buffer.first() : e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r);
                    var r
                }

                function H(t) {
                    var e = t._readableState;
                    c("endReadable", e.endEmitted), e.endEmitted || (e.ended = !0, n.nextTick(G, e, t))
                }

                function G(t, e) {
                    if (c("endReadableNT", t.endEmitted, t.length), !t.endEmitted && 0 === t.length && (t.endEmitted = !0, e.readable = !1, e.emit("end"), t.autoDestroy)) {
                        var r = e._writableState;
                        (!r || r.autoDestroy && r.finished) && e.destroy()
                    }
                }

                function J(t, e) {
                    for (var r = 0, n = t.length; r < n; r++)
                        if (t[r] === e) return r;
                    return -1
                }
                O.prototype.read = function(t) {
                    c("read", t), t = parseInt(t, 10);
                    var e = this._readableState,
                        r = t;
                    if (0 !== t && (e.emittedReadable = !1), 0 === t && e.needReadable && ((0 !== e.highWaterMark ? e.length >= e.highWaterMark : e.length > 0) || e.ended)) return c("read: emitReadable", e.length, e.ended), 0 === e.length && e.ended ? H(this) : D(this), null;
                    if (t = C(t, e), 0 === t && e.ended) return 0 === e.length && H(this), null;
                    var n, i = e.needReadable;
                    return c("need readable", i), (0 === e.length || e.length - t < e.highWaterMark) && (i = !0, c("length less than watermark", i)), e.ended || e.reading ? (i = !1, c("reading or ended", i)) : i && (c("do read"), e.reading = !0, e.sync = !0, 0 === e.length && (e.needReadable = !0), this._read(e.highWaterMark), e.sync = !1, e.reading || (t = C(r, e))), n = t > 0 ? Z(t, e) : null, null === n ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.awaitDrain = 0), 0 === e.length && (e.ended || (e.needReadable = !0), r !== t && e.ended && H(this)), null !== n && this.emit("data", n), n
                }, O.prototype._read = function(t) {
                    x(this, new A("_read()"))
                }, O.prototype.pipe = function(t, e) {
                    var r = this,
                        i = this._readableState;
                    switch (i.pipesCount) {
                        case 0:
                            i.pipes = t;
                            break;
                        case 1:
                            i.pipes = [i.pipes, t];
                            break;
                        default:
                            i.pipes.push(t);
                            break
                    }
                    i.pipesCount += 1, c("pipe count=%d opts=%j", i.pipesCount, e);
                    var a = (!e || !1 !== e.end) && t !== n.stdout && t !== n.stderr,
                        o = a ? h : y;

                    function u(t, e) {
                        c("onunpipe"), t === r && e && !1 === e.hasUnpiped && (e.hasUnpiped = !0, d())
                    }

                    function h() {
                        c("onend"), t.end()
                    }
                    i.endEmitted ? n.nextTick(o) : r.once("end", o), t.on("unpipe", u);
                    var f = $(r);
                    t.on("drain", f);
                    var l = !1;

                    function d() {
                        c("cleanup"), t.removeListener("close", b), t.removeListener("finish", g), t.removeListener("drain", f), t.removeListener("error", m), t.removeListener("unpipe", u), r.removeListener("end", h), r.removeListener("end", y), r.removeListener("data", p), l = !0, !i.awaitDrain || t._writableState && !t._writableState.needDrain || f()
                    }

                    function p(e) {
                        c("ondata");
                        var n = t.write(e);
                        c("dest.write", n), !1 === n && ((1 === i.pipesCount && i.pipes === t || i.pipesCount > 1 && -1 !== J(i.pipes, t)) && !l && (c("false write response, pause", i.awaitDrain), i.awaitDrain++), r.pause())
                    }

                    function m(e) {
                        c("onerror", e), y(), t.removeListener("error", m), 0 === s(t, "error") && x(t, e)
                    }

                    function b() {
                        t.removeListener("finish", g), y()
                    }

                    function g() {
                        c("onfinish"), t.removeListener("close", b), y()
                    }

                    function y() {
                        c("unpipe"), r.unpipe(t)
                    }
                    return r.on("data", p), k(t, "error", m), t.once("close", b), t.once("finish", g), t.emit("pipe", r), i.flowing || (c("pipe resume"), r.resume()), t
                }, O.prototype.unpipe = function(t) {
                    var e = this._readableState,
                        r = {
                            hasUnpiped: !1
                        };
                    if (0 === e.pipesCount) return this;
                    if (1 === e.pipesCount) return t && t !== e.pipes || (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = !1, t && t.emit("unpipe", this, r)), this;
                    if (!t) {
                        var n = e.pipes,
                            i = e.pipesCount;
                        e.pipes = null, e.pipesCount = 0, e.flowing = !1;
                        for (var s = 0; s < i; s++) n[s].emit("unpipe", this, {
                            hasUnpiped: !1
                        });
                        return this
                    }
                    var a = J(e.pipes, t);
                    return -1 === a || (e.pipes.splice(a, 1), e.pipesCount -= 1, 1 === e.pipesCount && (e.pipes = e.pipes[0]), t.emit("unpipe", this, r)), this
                }, O.prototype.on = function(t, e) {
                    var r = a.prototype.on.call(this, t, e),
                        i = this._readableState;
                    return "data" === t ? (i.readableListening = this.listenerCount("readable") > 0, !1 !== i.flowing && this.resume()) : "readable" === t && (i.endEmitted || i.readableListening || (i.readableListening = i.needReadable = !0, i.flowing = !1, i.emittedReadable = !1, c("on readable", i.length, i.reading), i.length ? D(this) : i.reading || n.nextTick(q, this))), r
                }, O.prototype.addListener = O.prototype.on, O.prototype.removeListener = function(t, e) {
                    var r = a.prototype.removeListener.call(this, t, e);
                    return "readable" === t && n.nextTick(U, this), r
                }, O.prototype.removeAllListeners = function(t) {
                    var e = a.prototype.removeAllListeners.apply(this, arguments);
                    return "readable" !== t && void 0 !== t || n.nextTick(U, this), e
                }, O.prototype.resume = function() {
                    var t = this._readableState;
                    return t.flowing || (c("resume"), t.flowing = !t.readableListening, K(this, t)), t.paused = !1, this
                }, O.prototype.pause = function() {
                    return c("call pause flowing=%j", this._readableState.flowing), !1 !== this._readableState.flowing && (c("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this
                }, O.prototype.wrap = function(t) {
                    var e = this,
                        r = this._readableState,
                        n = !1;
                    for (var i in t.on("end", (function() {
                            if (c("wrapped end"), r.decoder && !r.ended) {
                                var t = r.decoder.end();
                                t && t.length && e.push(t)
                            }
                            e.push(null)
                        })), t.on("data", (function(i) {
                            if (c("wrapped data"), r.decoder && (i = r.decoder.write(i)), (!r.objectMode || null !== i && void 0 !== i) && (r.objectMode || i && i.length)) {
                                var s = e.push(i);
                                s || (n = !0, t.pause())
                            }
                        })), t) void 0 === this[i] && "function" === typeof t[i] && (this[i] = function(e) {
                        return function() {
                            return t[e].apply(t, arguments)
                        }
                    }(i));
                    for (var s = 0; s < E.length; s++) t.on(E[s], this.emit.bind(this, E[s]));
                    return this._read = function(e) {
                        c("wrapped _read", e), n && (n = !1, t.resume())
                    }, this
                }, "function" === typeof Symbol && (O.prototype[Symbol.asyncIterator] = function() {
                    return void 0 === p && (p = r("4186")), p(this)
                }), Object.defineProperty(O.prototype, "readableHighWaterMark", {
                    enumerable: !1,
                    get: function() {
                        return this._readableState.highWaterMark
                    }
                }), Object.defineProperty(O.prototype, "readableBuffer", {
                    enumerable: !1,
                    get: function() {
                        return this._readableState && this._readableState.buffer
                    }
                }), Object.defineProperty(O.prototype, "readableFlowing", {
                    enumerable: !1,
                    get: function() {
                        return this._readableState.flowing
                    },
                    set: function(t) {
                        this._readableState && (this._readableState.flowing = t)
                    }
                }), O._fromList = Z, Object.defineProperty(O.prototype, "readableLength", {
                    enumerable: !1,
                    get: function() {
                        return this._readableState.length
                    }
                }), "function" === typeof Symbol && (O.from = function(t, e) {
                    return void 0 === m && (m = r("919c")), m(O, t, e)
                })
            }).call(this, r("c8ba"), r("4362"))
        },
        "44a3": function(t, e, r) {
            "use strict";
            var n = r("80af"),
                i = r("f3a3"),
                s = i.assert,
                a = i.cachedProperty,
                o = i.parseBytes;

            function u(t, e) {
                this.eddsa = t, "object" !== typeof e && (e = o(e)), Array.isArray(e) && (e = {
                    R: e.slice(0, t.encodingLength),
                    S: e.slice(t.encodingLength)
                }), s(e.R && e.S, "Signature without R or S"), t.isPoint(e.R) && (this._R = e.R), e.S instanceof n && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded
            }
            a(u, "S", (function() {
                return this.eddsa.decodeInt(this.Sencoded())
            })), a(u, "R", (function() {
                return this.eddsa.decodePoint(this.Rencoded())
            })), a(u, "Rencoded", (function() {
                return this.eddsa.encodePoint(this.R())
            })), a(u, "Sencoded", (function() {
                return this.eddsa.encodeInt(this.S())
            })), u.prototype.toBytes = function() {
                return this.Rencoded().concat(this.Sencoded())
            }, u.prototype.toHex = function() {
                return i.encode(this.toBytes(), "hex").toUpperCase()
            }, t.exports = u
        },
        "48e6": function(t, e, r) {
            (function(t) {
                (function(t, e) {
                    "use strict";

                    function n(t, e) {
                        if (!t) throw new Error(e || "Assertion failed")
                    }

                    function i(t, e) {
                        t.super_ = e;
                        var r = function() {};
                        r.prototype = e.prototype, t.prototype = new r, t.prototype.constructor = t
                    }

                    function s(t, e, r) {
                        if (s.isBN(t)) return t;
                        this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== t && ("le" !== e && "be" !== e || (r = e, e = 10), this._init(t || 0, e || 10, r || "be"))
                    }
                    var a;
                    "object" === typeof t ? t.exports = s : e.BN = s, s.BN = s, s.wordSize = 26;
                    try {
                        a = r(23).Buffer
                    } catch (E) {}

                    function o(t, e, r) {
                        for (var n = 0, i = Math.min(t.length, r), s = e; s < i; s++) {
                            var a = t.charCodeAt(s) - 48;
                            n <<= 4, n |= a >= 49 && a <= 54 ? a - 49 + 10 : a >= 17 && a <= 22 ? a - 17 + 10 : 15 & a
                        }
                        return n
                    }

                    function u(t, e, r, n) {
                        for (var i = 0, s = Math.min(t.length, r), a = e; a < s; a++) {
                            var o = t.charCodeAt(a) - 48;
                            i *= n, i += o >= 49 ? o - 49 + 10 : o >= 17 ? o - 17 + 10 : o
                        }
                        return i
                    }
                    s.isBN = function(t) {
                        return t instanceof s || null !== t && "object" === typeof t && t.constructor.wordSize === s.wordSize && Array.isArray(t.words)
                    }, s.max = function(t, e) {
                        return t.cmp(e) > 0 ? t : e
                    }, s.min = function(t, e) {
                        return t.cmp(e) < 0 ? t : e
                    }, s.prototype._init = function(t, e, r) {
                        if ("number" === typeof t) return this._initNumber(t, e, r);
                        if ("object" === typeof t) return this._initArray(t, e, r);
                        "hex" === e && (e = 16), n(e === (0 | e) && e >= 2 && e <= 36), t = t.toString().replace(/\s+/g, "");
                        var i = 0;
                        "-" === t[0] && i++, 16 === e ? this._parseHex(t, i) : this._parseBase(t, e, i), "-" === t[0] && (this.negative = 1), this.strip(), "le" === r && this._initArray(this.toArray(), e, r)
                    }, s.prototype._initNumber = function(t, e, r) {
                        t < 0 && (this.negative = 1, t = -t), t < 67108864 ? (this.words = [67108863 & t], this.length = 1) : t < 4503599627370496 ? (this.words = [67108863 & t, t / 67108864 & 67108863], this.length = 2) : (n(t < 9007199254740992), this.words = [67108863 & t, t / 67108864 & 67108863, 1], this.length = 3), "le" === r && this._initArray(this.toArray(), e, r)
                    }, s.prototype._initArray = function(t, e, r) {
                        if (n("number" === typeof t.length), t.length <= 0) return this.words = [0], this.length = 1, this;
                        this.length = Math.ceil(t.length / 3), this.words = new Array(this.length);
                        for (var i = 0; i < this.length; i++) this.words[i] = 0;
                        var s, a, o = 0;
                        if ("be" === r)
                            for (i = t.length - 1, s = 0; i >= 0; i -= 3) a = t[i] | t[i - 1] << 8 | t[i - 2] << 16, this.words[s] |= a << o & 67108863, this.words[s + 1] = a >>> 26 - o & 67108863, o += 24, o >= 26 && (o -= 26, s++);
                        else if ("le" === r)
                            for (i = 0, s = 0; i < t.length; i += 3) a = t[i] | t[i + 1] << 8 | t[i + 2] << 16, this.words[s] |= a << o & 67108863, this.words[s + 1] = a >>> 26 - o & 67108863, o += 24, o >= 26 && (o -= 26, s++);
                        return this.strip()
                    }, s.prototype._parseHex = function(t, e) {
                        this.length = Math.ceil((t.length - e) / 6), this.words = new Array(this.length);
                        for (var r = 0; r < this.length; r++) this.words[r] = 0;
                        var n, i, s = 0;
                        for (r = t.length - 6, n = 0; r >= e; r -= 6) i = o(t, r, r + 6), this.words[n] |= i << s & 67108863, this.words[n + 1] |= i >>> 26 - s & 4194303, s += 24, s >= 26 && (s -= 26, n++);
                        r + 6 !== e && (i = o(t, e, r + 6), this.words[n] |= i << s & 67108863, this.words[n + 1] |= i >>> 26 - s & 4194303), this.strip()
                    }, s.prototype._parseBase = function(t, e, r) {
                        this.words = [0], this.length = 1;
                        for (var n = 0, i = 1; i <= 67108863; i *= e) n++;
                        n--, i = i / e | 0;
                        for (var s = t.length - r, a = s % n, o = Math.min(s, s - a) + r, h = 0, f = r; f < o; f += n) h = u(t, f, f + n, e), this.imuln(i), this.words[0] + h < 67108864 ? this.words[0] += h : this._iaddn(h);
                        if (0 !== a) {
                            var c = 1;
                            for (h = u(t, f, t.length, e), f = 0; f < a; f++) c *= e;
                            this.imuln(c), this.words[0] + h < 67108864 ? this.words[0] += h : this._iaddn(h)
                        }
                    }, s.prototype.copy = function(t) {
                        t.words = new Array(this.length);
                        for (var e = 0; e < this.length; e++) t.words[e] = this.words[e];
                        t.length = this.length, t.negative = this.negative, t.red = this.red
                    }, s.prototype.clone = function() {
                        var t = new s(null);
                        return this.copy(t), t
                    }, s.prototype._expand = function(t) {
                        while (this.length < t) this.words[this.length++] = 0;
                        return this
                    }, s.prototype.strip = function() {
                        while (this.length > 1 && 0 === this.words[this.length - 1]) this.length--;
                        return this._normSign()
                    }, s.prototype._normSign = function() {
                        return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this
                    }, s.prototype.inspect = function() {
                        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
                    };
                    var h = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
                        f = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
                        c = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];

                    function l(t) {
                        for (var e = new Array(t.bitLength()), r = 0; r < e.length; r++) {
                            var n = r / 26 | 0,
                                i = r % 26;
                            e[r] = (t.words[n] & 1 << i) >>> i
                        }
                        return e
                    }

                    function d(t, e, r) {
                        r.negative = e.negative ^ t.negative;
                        var n = t.length + e.length | 0;
                        r.length = n, n = n - 1 | 0;
                        var i = 0 | t.words[0],
                            s = 0 | e.words[0],
                            a = i * s,
                            o = 67108863 & a,
                            u = a / 67108864 | 0;
                        r.words[0] = o;
                        for (var h = 1; h < n; h++) {
                            for (var f = u >>> 26, c = 67108863 & u, l = Math.min(h, e.length - 1), d = Math.max(0, h - t.length + 1); d <= l; d++) {
                                var p = h - d | 0;
                                i = 0 | t.words[p], s = 0 | e.words[d], a = i * s + c, f += a / 67108864 | 0, c = 67108863 & a
                            }
                            r.words[h] = 0 | c, u = 0 | f
                        }
                        return 0 !== u ? r.words[h] = 0 | u : r.length--, r.strip()
                    }
                    s.prototype.toString = function(t, e) {
                        var r;
                        if (t = t || 10, e = 0 | e || 1, 16 === t || "hex" === t) {
                            r = "";
                            for (var i = 0, s = 0, a = 0; a < this.length; a++) {
                                var o = this.words[a],
                                    u = (16777215 & (o << i | s)).toString(16);
                                s = o >>> 24 - i & 16777215, r = 0 !== s || a !== this.length - 1 ? h[6 - u.length] + u + r : u + r, i += 2, i >= 26 && (i -= 26, a--)
                            }
                            0 !== s && (r = s.toString(16) + r);
                            while (r.length % e !== 0) r = "0" + r;
                            return 0 !== this.negative && (r = "-" + r), r
                        }
                        if (t === (0 | t) && t >= 2 && t <= 36) {
                            var l = f[t],
                                d = c[t];
                            r = "";
                            var p = this.clone();
                            p.negative = 0;
                            while (!p.isZero()) {
                                var m = p.modn(d).toString(t);
                                p = p.idivn(d), r = p.isZero() ? m + r : h[l - m.length] + m + r
                            }
                            this.isZero() && (r = "0" + r);
                            while (r.length % e !== 0) r = "0" + r;
                            return 0 !== this.negative && (r = "-" + r), r
                        }
                        n(!1, "Base should be between 2 and 36")
                    }, s.prototype.toNumber = function() {
                        var t = this.words[0];
                        return 2 === this.length ? t += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? t += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), 0 !== this.negative ? -t : t
                    }, s.prototype.toJSON = function() {
                        return this.toString(16)
                    }, s.prototype.toBuffer = function(t, e) {
                        return n("undefined" !== typeof a), this.toArrayLike(a, t, e)
                    }, s.prototype.toArray = function(t, e) {
                        return this.toArrayLike(Array, t, e)
                    }, s.prototype.toArrayLike = function(t, e, r) {
                        var i = this.byteLength(),
                            s = r || Math.max(1, i);
                        n(i <= s, "byte array longer than desired length"), n(s > 0, "Requested array length <= 0"), this.strip();
                        var a, o, u = "le" === e,
                            h = new t(s),
                            f = this.clone();
                        if (u) {
                            for (o = 0; !f.isZero(); o++) a = f.andln(255), f.iushrn(8), h[o] = a;
                            for (; o < s; o++) h[o] = 0
                        } else {
                            for (o = 0; o < s - i; o++) h[o] = 0;
                            for (o = 0; !f.isZero(); o++) a = f.andln(255), f.iushrn(8), h[s - o - 1] = a
                        }
                        return h
                    }, Math.clz32 ? s.prototype._countBits = function(t) {
                        return 32 - Math.clz32(t)
                    } : s.prototype._countBits = function(t) {
                        var e = t,
                            r = 0;
                        return e >= 4096 && (r += 13, e >>>= 13), e >= 64 && (r += 7, e >>>= 7), e >= 8 && (r += 4, e >>>= 4), e >= 2 && (r += 2, e >>>= 2), r + e
                    }, s.prototype._zeroBits = function(t) {
                        if (0 === t) return 26;
                        var e = t,
                            r = 0;
                        return 0 === (8191 & e) && (r += 13, e >>>= 13), 0 === (127 & e) && (r += 7, e >>>= 7), 0 === (15 & e) && (r += 4, e >>>= 4), 0 === (3 & e) && (r += 2, e >>>= 2), 0 === (1 & e) && r++, r
                    }, s.prototype.bitLength = function() {
                        var t = this.words[this.length - 1],
                            e = this._countBits(t);
                        return 26 * (this.length - 1) + e
                    }, s.prototype.zeroBits = function() {
                        if (this.isZero()) return 0;
                        for (var t = 0, e = 0; e < this.length; e++) {
                            var r = this._zeroBits(this.words[e]);
                            if (t += r, 26 !== r) break
                        }
                        return t
                    }, s.prototype.byteLength = function() {
                        return Math.ceil(this.bitLength() / 8)
                    }, s.prototype.toTwos = function(t) {
                        return 0 !== this.negative ? this.abs().inotn(t).iaddn(1) : this.clone()
                    }, s.prototype.fromTwos = function(t) {
                        return this.testn(t - 1) ? this.notn(t).iaddn(1).ineg() : this.clone()
                    }, s.prototype.isNeg = function() {
                        return 0 !== this.negative
                    }, s.prototype.neg = function() {
                        return this.clone().ineg()
                    }, s.prototype.ineg = function() {
                        return this.isZero() || (this.negative ^= 1), this
                    }, s.prototype.iuor = function(t) {
                        while (this.length < t.length) this.words[this.length++] = 0;
                        for (var e = 0; e < t.length; e++) this.words[e] = this.words[e] | t.words[e];
                        return this.strip()
                    }, s.prototype.ior = function(t) {
                        return n(0 === (this.negative | t.negative)), this.iuor(t)
                    }, s.prototype.or = function(t) {
                        return this.length > t.length ? this.clone().ior(t) : t.clone().ior(this)
                    }, s.prototype.uor = function(t) {
                        return this.length > t.length ? this.clone().iuor(t) : t.clone().iuor(this)
                    }, s.prototype.iuand = function(t) {
                        var e;
                        e = this.length > t.length ? t : this;
                        for (var r = 0; r < e.length; r++) this.words[r] = this.words[r] & t.words[r];
                        return this.length = e.length, this.strip()
                    }, s.prototype.iand = function(t) {
                        return n(0 === (this.negative | t.negative)), this.iuand(t)
                    }, s.prototype.and = function(t) {
                        return this.length > t.length ? this.clone().iand(t) : t.clone().iand(this)
                    }, s.prototype.uand = function(t) {
                        return this.length > t.length ? this.clone().iuand(t) : t.clone().iuand(this)
                    }, s.prototype.iuxor = function(t) {
                        var e, r;
                        this.length > t.length ? (e = this, r = t) : (e = t, r = this);
                        for (var n = 0; n < r.length; n++) this.words[n] = e.words[n] ^ r.words[n];
                        if (this !== e)
                            for (; n < e.length; n++) this.words[n] = e.words[n];
                        return this.length = e.length, this.strip()
                    }, s.prototype.ixor = function(t) {
                        return n(0 === (this.negative | t.negative)), this.iuxor(t)
                    }, s.prototype.xor = function(t) {
                        return this.length > t.length ? this.clone().ixor(t) : t.clone().ixor(this)
                    }, s.prototype.uxor = function(t) {
                        return this.length > t.length ? this.clone().iuxor(t) : t.clone().iuxor(this)
                    }, s.prototype.inotn = function(t) {
                        n("number" === typeof t && t >= 0);
                        var e = 0 | Math.ceil(t / 26),
                            r = t % 26;
                        this._expand(e), r > 0 && e--;
                        for (var i = 0; i < e; i++) this.words[i] = 67108863 & ~this.words[i];
                        return r > 0 && (this.words[i] = ~this.words[i] & 67108863 >> 26 - r), this.strip()
                    }, s.prototype.notn = function(t) {
                        return this.clone().inotn(t)
                    }, s.prototype.setn = function(t, e) {
                        n("number" === typeof t && t >= 0);
                        var r = t / 26 | 0,
                            i = t % 26;
                        return this._expand(r + 1), this.words[r] = e ? this.words[r] | 1 << i : this.words[r] & ~(1 << i), this.strip()
                    }, s.prototype.iadd = function(t) {
                        var e, r, n;
                        if (0 !== this.negative && 0 === t.negative) return this.negative = 0, e = this.isub(t), this.negative ^= 1, this._normSign();
                        if (0 === this.negative && 0 !== t.negative) return t.negative = 0, e = this.isub(t), t.negative = 1, e._normSign();
                        this.length > t.length ? (r = this, n = t) : (r = t, n = this);
                        for (var i = 0, s = 0; s < n.length; s++) e = (0 | r.words[s]) + (0 | n.words[s]) + i, this.words[s] = 67108863 & e, i = e >>> 26;
                        for (; 0 !== i && s < r.length; s++) e = (0 | r.words[s]) + i, this.words[s] = 67108863 & e, i = e >>> 26;
                        if (this.length = r.length, 0 !== i) this.words[this.length] = i, this.length++;
                        else if (r !== this)
                            for (; s < r.length; s++) this.words[s] = r.words[s];
                        return this
                    }, s.prototype.add = function(t) {
                        var e;
                        return 0 !== t.negative && 0 === this.negative ? (t.negative = 0, e = this.sub(t), t.negative ^= 1, e) : 0 === t.negative && 0 !== this.negative ? (this.negative = 0, e = t.sub(this), this.negative = 1, e) : this.length > t.length ? this.clone().iadd(t) : t.clone().iadd(this)
                    }, s.prototype.isub = function(t) {
                        if (0 !== t.negative) {
                            t.negative = 0;
                            var e = this.iadd(t);
                            return t.negative = 1, e._normSign()
                        }
                        if (0 !== this.negative) return this.negative = 0, this.iadd(t), this.negative = 1, this._normSign();
                        var r, n, i = this.cmp(t);
                        if (0 === i) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
                        i > 0 ? (r = this, n = t) : (r = t, n = this);
                        for (var s = 0, a = 0; a < n.length; a++) e = (0 | r.words[a]) - (0 | n.words[a]) + s, s = e >> 26, this.words[a] = 67108863 & e;
                        for (; 0 !== s && a < r.length; a++) e = (0 | r.words[a]) + s, s = e >> 26, this.words[a] = 67108863 & e;
                        if (0 === s && a < r.length && r !== this)
                            for (; a < r.length; a++) this.words[a] = r.words[a];
                        return this.length = Math.max(this.length, a), r !== this && (this.negative = 1), this.strip()
                    }, s.prototype.sub = function(t) {
                        return this.clone().isub(t)
                    };
                    var p = function(t, e, r) {
                        var n, i, s, a = t.words,
                            o = e.words,
                            u = r.words,
                            h = 0,
                            f = 0 | a[0],
                            c = 8191 & f,
                            l = f >>> 13,
                            d = 0 | a[1],
                            p = 8191 & d,
                            m = d >>> 13,
                            b = 0 | a[2],
                            g = 8191 & b,
                            y = b >>> 13,
                            v = 0 | a[3],
                            w = 8191 & v,
                            _ = v >>> 13,
                            M = 0 | a[4],
                            A = 8191 & M,
                            S = M >>> 13,
                            x = 0 | a[5],
                            E = 8191 & x,
                            k = x >>> 13,
                            R = 0 | a[6],
                            O = 8191 & R,
                            I = R >>> 13,
                            P = 0 | a[7],
                            T = 8191 & P,
                            N = P >>> 13,
                            j = 0 | a[8],
                            C = 8191 & j,
                            z = j >>> 13,
                            D = 0 | a[9],
                            L = 8191 & D,
                            F = D >>> 13,
                            B = 0 | o[0],
                            $ = 8191 & B,
                            U = B >>> 13,
                            q = 0 | o[1],
                            K = 8191 & q,
                            V = q >>> 13,
                            W = 0 | o[2],
                            Z = 8191 & W,
                            H = W >>> 13,
                            G = 0 | o[3],
                            J = 8191 & G,
                            X = G >>> 13,
                            Y = 0 | o[4],
                            Q = 8191 & Y,
                            tt = Y >>> 13,
                            et = 0 | o[5],
                            rt = 8191 & et,
                            nt = et >>> 13,
                            it = 0 | o[6],
                            st = 8191 & it,
                            at = it >>> 13,
                            ot = 0 | o[7],
                            ut = 8191 & ot,
                            ht = ot >>> 13,
                            ft = 0 | o[8],
                            ct = 8191 & ft,
                            lt = ft >>> 13,
                            dt = 0 | o[9],
                            pt = 8191 & dt,
                            mt = dt >>> 13;
                        r.negative = t.negative ^ e.negative, r.length = 19, n = Math.imul(c, $), i = Math.imul(c, U), i = i + Math.imul(l, $) | 0, s = Math.imul(l, U);
                        var bt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, n = Math.imul(p, $), i = Math.imul(p, U), i = i + Math.imul(m, $) | 0, s = Math.imul(m, U), n = n + Math.imul(c, K) | 0, i = i + Math.imul(c, V) | 0, i = i + Math.imul(l, K) | 0, s = s + Math.imul(l, V) | 0;
                        var gt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (gt >>> 26) | 0, gt &= 67108863, n = Math.imul(g, $), i = Math.imul(g, U), i = i + Math.imul(y, $) | 0, s = Math.imul(y, U), n = n + Math.imul(p, K) | 0, i = i + Math.imul(p, V) | 0, i = i + Math.imul(m, K) | 0, s = s + Math.imul(m, V) | 0, n = n + Math.imul(c, Z) | 0, i = i + Math.imul(c, H) | 0, i = i + Math.imul(l, Z) | 0, s = s + Math.imul(l, H) | 0;
                        var yt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, n = Math.imul(w, $), i = Math.imul(w, U), i = i + Math.imul(_, $) | 0, s = Math.imul(_, U), n = n + Math.imul(g, K) | 0, i = i + Math.imul(g, V) | 0, i = i + Math.imul(y, K) | 0, s = s + Math.imul(y, V) | 0, n = n + Math.imul(p, Z) | 0, i = i + Math.imul(p, H) | 0, i = i + Math.imul(m, Z) | 0, s = s + Math.imul(m, H) | 0, n = n + Math.imul(c, J) | 0, i = i + Math.imul(c, X) | 0, i = i + Math.imul(l, J) | 0, s = s + Math.imul(l, X) | 0;
                        var vt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, n = Math.imul(A, $), i = Math.imul(A, U), i = i + Math.imul(S, $) | 0, s = Math.imul(S, U), n = n + Math.imul(w, K) | 0, i = i + Math.imul(w, V) | 0, i = i + Math.imul(_, K) | 0, s = s + Math.imul(_, V) | 0, n = n + Math.imul(g, Z) | 0, i = i + Math.imul(g, H) | 0, i = i + Math.imul(y, Z) | 0, s = s + Math.imul(y, H) | 0, n = n + Math.imul(p, J) | 0, i = i + Math.imul(p, X) | 0, i = i + Math.imul(m, J) | 0, s = s + Math.imul(m, X) | 0, n = n + Math.imul(c, Q) | 0, i = i + Math.imul(c, tt) | 0, i = i + Math.imul(l, Q) | 0, s = s + Math.imul(l, tt) | 0;
                        var wt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, n = Math.imul(E, $), i = Math.imul(E, U), i = i + Math.imul(k, $) | 0, s = Math.imul(k, U), n = n + Math.imul(A, K) | 0, i = i + Math.imul(A, V) | 0, i = i + Math.imul(S, K) | 0, s = s + Math.imul(S, V) | 0, n = n + Math.imul(w, Z) | 0, i = i + Math.imul(w, H) | 0, i = i + Math.imul(_, Z) | 0, s = s + Math.imul(_, H) | 0, n = n + Math.imul(g, J) | 0, i = i + Math.imul(g, X) | 0, i = i + Math.imul(y, J) | 0, s = s + Math.imul(y, X) | 0, n = n + Math.imul(p, Q) | 0, i = i + Math.imul(p, tt) | 0, i = i + Math.imul(m, Q) | 0, s = s + Math.imul(m, tt) | 0, n = n + Math.imul(c, rt) | 0, i = i + Math.imul(c, nt) | 0, i = i + Math.imul(l, rt) | 0, s = s + Math.imul(l, nt) | 0;
                        var _t = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, n = Math.imul(O, $), i = Math.imul(O, U), i = i + Math.imul(I, $) | 0, s = Math.imul(I, U), n = n + Math.imul(E, K) | 0, i = i + Math.imul(E, V) | 0, i = i + Math.imul(k, K) | 0, s = s + Math.imul(k, V) | 0, n = n + Math.imul(A, Z) | 0, i = i + Math.imul(A, H) | 0, i = i + Math.imul(S, Z) | 0, s = s + Math.imul(S, H) | 0, n = n + Math.imul(w, J) | 0, i = i + Math.imul(w, X) | 0, i = i + Math.imul(_, J) | 0, s = s + Math.imul(_, X) | 0, n = n + Math.imul(g, Q) | 0, i = i + Math.imul(g, tt) | 0, i = i + Math.imul(y, Q) | 0, s = s + Math.imul(y, tt) | 0, n = n + Math.imul(p, rt) | 0, i = i + Math.imul(p, nt) | 0, i = i + Math.imul(m, rt) | 0, s = s + Math.imul(m, nt) | 0, n = n + Math.imul(c, st) | 0, i = i + Math.imul(c, at) | 0, i = i + Math.imul(l, st) | 0, s = s + Math.imul(l, at) | 0;
                        var Mt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, n = Math.imul(T, $), i = Math.imul(T, U), i = i + Math.imul(N, $) | 0, s = Math.imul(N, U), n = n + Math.imul(O, K) | 0, i = i + Math.imul(O, V) | 0, i = i + Math.imul(I, K) | 0, s = s + Math.imul(I, V) | 0, n = n + Math.imul(E, Z) | 0, i = i + Math.imul(E, H) | 0, i = i + Math.imul(k, Z) | 0, s = s + Math.imul(k, H) | 0, n = n + Math.imul(A, J) | 0, i = i + Math.imul(A, X) | 0, i = i + Math.imul(S, J) | 0, s = s + Math.imul(S, X) | 0, n = n + Math.imul(w, Q) | 0, i = i + Math.imul(w, tt) | 0, i = i + Math.imul(_, Q) | 0, s = s + Math.imul(_, tt) | 0, n = n + Math.imul(g, rt) | 0, i = i + Math.imul(g, nt) | 0, i = i + Math.imul(y, rt) | 0, s = s + Math.imul(y, nt) | 0, n = n + Math.imul(p, st) | 0, i = i + Math.imul(p, at) | 0, i = i + Math.imul(m, st) | 0, s = s + Math.imul(m, at) | 0, n = n + Math.imul(c, ut) | 0, i = i + Math.imul(c, ht) | 0, i = i + Math.imul(l, ut) | 0, s = s + Math.imul(l, ht) | 0;
                        var At = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, n = Math.imul(C, $), i = Math.imul(C, U), i = i + Math.imul(z, $) | 0, s = Math.imul(z, U), n = n + Math.imul(T, K) | 0, i = i + Math.imul(T, V) | 0, i = i + Math.imul(N, K) | 0, s = s + Math.imul(N, V) | 0, n = n + Math.imul(O, Z) | 0, i = i + Math.imul(O, H) | 0, i = i + Math.imul(I, Z) | 0, s = s + Math.imul(I, H) | 0, n = n + Math.imul(E, J) | 0, i = i + Math.imul(E, X) | 0, i = i + Math.imul(k, J) | 0, s = s + Math.imul(k, X) | 0, n = n + Math.imul(A, Q) | 0, i = i + Math.imul(A, tt) | 0, i = i + Math.imul(S, Q) | 0, s = s + Math.imul(S, tt) | 0, n = n + Math.imul(w, rt) | 0, i = i + Math.imul(w, nt) | 0, i = i + Math.imul(_, rt) | 0, s = s + Math.imul(_, nt) | 0, n = n + Math.imul(g, st) | 0, i = i + Math.imul(g, at) | 0, i = i + Math.imul(y, st) | 0, s = s + Math.imul(y, at) | 0, n = n + Math.imul(p, ut) | 0, i = i + Math.imul(p, ht) | 0, i = i + Math.imul(m, ut) | 0, s = s + Math.imul(m, ht) | 0, n = n + Math.imul(c, ct) | 0, i = i + Math.imul(c, lt) | 0, i = i + Math.imul(l, ct) | 0, s = s + Math.imul(l, lt) | 0;
                        var St = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, n = Math.imul(L, $), i = Math.imul(L, U), i = i + Math.imul(F, $) | 0, s = Math.imul(F, U), n = n + Math.imul(C, K) | 0, i = i + Math.imul(C, V) | 0, i = i + Math.imul(z, K) | 0, s = s + Math.imul(z, V) | 0, n = n + Math.imul(T, Z) | 0, i = i + Math.imul(T, H) | 0, i = i + Math.imul(N, Z) | 0, s = s + Math.imul(N, H) | 0, n = n + Math.imul(O, J) | 0, i = i + Math.imul(O, X) | 0, i = i + Math.imul(I, J) | 0, s = s + Math.imul(I, X) | 0, n = n + Math.imul(E, Q) | 0, i = i + Math.imul(E, tt) | 0, i = i + Math.imul(k, Q) | 0, s = s + Math.imul(k, tt) | 0, n = n + Math.imul(A, rt) | 0, i = i + Math.imul(A, nt) | 0, i = i + Math.imul(S, rt) | 0, s = s + Math.imul(S, nt) | 0, n = n + Math.imul(w, st) | 0, i = i + Math.imul(w, at) | 0, i = i + Math.imul(_, st) | 0, s = s + Math.imul(_, at) | 0, n = n + Math.imul(g, ut) | 0, i = i + Math.imul(g, ht) | 0, i = i + Math.imul(y, ut) | 0, s = s + Math.imul(y, ht) | 0, n = n + Math.imul(p, ct) | 0, i = i + Math.imul(p, lt) | 0, i = i + Math.imul(m, ct) | 0, s = s + Math.imul(m, lt) | 0, n = n + Math.imul(c, pt) | 0, i = i + Math.imul(c, mt) | 0, i = i + Math.imul(l, pt) | 0, s = s + Math.imul(l, mt) | 0;
                        var xt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, n = Math.imul(L, K), i = Math.imul(L, V), i = i + Math.imul(F, K) | 0, s = Math.imul(F, V), n = n + Math.imul(C, Z) | 0, i = i + Math.imul(C, H) | 0, i = i + Math.imul(z, Z) | 0, s = s + Math.imul(z, H) | 0, n = n + Math.imul(T, J) | 0, i = i + Math.imul(T, X) | 0, i = i + Math.imul(N, J) | 0, s = s + Math.imul(N, X) | 0, n = n + Math.imul(O, Q) | 0, i = i + Math.imul(O, tt) | 0, i = i + Math.imul(I, Q) | 0, s = s + Math.imul(I, tt) | 0, n = n + Math.imul(E, rt) | 0, i = i + Math.imul(E, nt) | 0, i = i + Math.imul(k, rt) | 0, s = s + Math.imul(k, nt) | 0, n = n + Math.imul(A, st) | 0, i = i + Math.imul(A, at) | 0, i = i + Math.imul(S, st) | 0, s = s + Math.imul(S, at) | 0, n = n + Math.imul(w, ut) | 0, i = i + Math.imul(w, ht) | 0, i = i + Math.imul(_, ut) | 0, s = s + Math.imul(_, ht) | 0, n = n + Math.imul(g, ct) | 0, i = i + Math.imul(g, lt) | 0, i = i + Math.imul(y, ct) | 0, s = s + Math.imul(y, lt) | 0, n = n + Math.imul(p, pt) | 0, i = i + Math.imul(p, mt) | 0, i = i + Math.imul(m, pt) | 0, s = s + Math.imul(m, mt) | 0;
                        var Et = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, n = Math.imul(L, Z), i = Math.imul(L, H), i = i + Math.imul(F, Z) | 0, s = Math.imul(F, H), n = n + Math.imul(C, J) | 0, i = i + Math.imul(C, X) | 0, i = i + Math.imul(z, J) | 0, s = s + Math.imul(z, X) | 0, n = n + Math.imul(T, Q) | 0, i = i + Math.imul(T, tt) | 0, i = i + Math.imul(N, Q) | 0, s = s + Math.imul(N, tt) | 0, n = n + Math.imul(O, rt) | 0, i = i + Math.imul(O, nt) | 0, i = i + Math.imul(I, rt) | 0, s = s + Math.imul(I, nt) | 0, n = n + Math.imul(E, st) | 0, i = i + Math.imul(E, at) | 0, i = i + Math.imul(k, st) | 0, s = s + Math.imul(k, at) | 0, n = n + Math.imul(A, ut) | 0, i = i + Math.imul(A, ht) | 0, i = i + Math.imul(S, ut) | 0, s = s + Math.imul(S, ht) | 0, n = n + Math.imul(w, ct) | 0, i = i + Math.imul(w, lt) | 0, i = i + Math.imul(_, ct) | 0, s = s + Math.imul(_, lt) | 0, n = n + Math.imul(g, pt) | 0, i = i + Math.imul(g, mt) | 0, i = i + Math.imul(y, pt) | 0, s = s + Math.imul(y, mt) | 0;
                        var kt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, n = Math.imul(L, J), i = Math.imul(L, X), i = i + Math.imul(F, J) | 0, s = Math.imul(F, X), n = n + Math.imul(C, Q) | 0, i = i + Math.imul(C, tt) | 0, i = i + Math.imul(z, Q) | 0, s = s + Math.imul(z, tt) | 0, n = n + Math.imul(T, rt) | 0, i = i + Math.imul(T, nt) | 0, i = i + Math.imul(N, rt) | 0, s = s + Math.imul(N, nt) | 0, n = n + Math.imul(O, st) | 0, i = i + Math.imul(O, at) | 0, i = i + Math.imul(I, st) | 0, s = s + Math.imul(I, at) | 0, n = n + Math.imul(E, ut) | 0, i = i + Math.imul(E, ht) | 0, i = i + Math.imul(k, ut) | 0, s = s + Math.imul(k, ht) | 0, n = n + Math.imul(A, ct) | 0, i = i + Math.imul(A, lt) | 0, i = i + Math.imul(S, ct) | 0, s = s + Math.imul(S, lt) | 0, n = n + Math.imul(w, pt) | 0, i = i + Math.imul(w, mt) | 0, i = i + Math.imul(_, pt) | 0, s = s + Math.imul(_, mt) | 0;
                        var Rt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, n = Math.imul(L, Q), i = Math.imul(L, tt), i = i + Math.imul(F, Q) | 0, s = Math.imul(F, tt), n = n + Math.imul(C, rt) | 0, i = i + Math.imul(C, nt) | 0, i = i + Math.imul(z, rt) | 0, s = s + Math.imul(z, nt) | 0, n = n + Math.imul(T, st) | 0, i = i + Math.imul(T, at) | 0, i = i + Math.imul(N, st) | 0, s = s + Math.imul(N, at) | 0, n = n + Math.imul(O, ut) | 0, i = i + Math.imul(O, ht) | 0, i = i + Math.imul(I, ut) | 0, s = s + Math.imul(I, ht) | 0, n = n + Math.imul(E, ct) | 0, i = i + Math.imul(E, lt) | 0, i = i + Math.imul(k, ct) | 0, s = s + Math.imul(k, lt) | 0, n = n + Math.imul(A, pt) | 0, i = i + Math.imul(A, mt) | 0, i = i + Math.imul(S, pt) | 0, s = s + Math.imul(S, mt) | 0;
                        var Ot = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, n = Math.imul(L, rt), i = Math.imul(L, nt), i = i + Math.imul(F, rt) | 0, s = Math.imul(F, nt), n = n + Math.imul(C, st) | 0, i = i + Math.imul(C, at) | 0, i = i + Math.imul(z, st) | 0, s = s + Math.imul(z, at) | 0, n = n + Math.imul(T, ut) | 0, i = i + Math.imul(T, ht) | 0, i = i + Math.imul(N, ut) | 0, s = s + Math.imul(N, ht) | 0, n = n + Math.imul(O, ct) | 0, i = i + Math.imul(O, lt) | 0, i = i + Math.imul(I, ct) | 0, s = s + Math.imul(I, lt) | 0, n = n + Math.imul(E, pt) | 0, i = i + Math.imul(E, mt) | 0, i = i + Math.imul(k, pt) | 0, s = s + Math.imul(k, mt) | 0;
                        var It = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, n = Math.imul(L, st), i = Math.imul(L, at), i = i + Math.imul(F, st) | 0, s = Math.imul(F, at), n = n + Math.imul(C, ut) | 0, i = i + Math.imul(C, ht) | 0, i = i + Math.imul(z, ut) | 0, s = s + Math.imul(z, ht) | 0, n = n + Math.imul(T, ct) | 0, i = i + Math.imul(T, lt) | 0, i = i + Math.imul(N, ct) | 0, s = s + Math.imul(N, lt) | 0, n = n + Math.imul(O, pt) | 0, i = i + Math.imul(O, mt) | 0, i = i + Math.imul(I, pt) | 0, s = s + Math.imul(I, mt) | 0;
                        var Pt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, n = Math.imul(L, ut), i = Math.imul(L, ht), i = i + Math.imul(F, ut) | 0, s = Math.imul(F, ht), n = n + Math.imul(C, ct) | 0, i = i + Math.imul(C, lt) | 0, i = i + Math.imul(z, ct) | 0, s = s + Math.imul(z, lt) | 0, n = n + Math.imul(T, pt) | 0, i = i + Math.imul(T, mt) | 0, i = i + Math.imul(N, pt) | 0, s = s + Math.imul(N, mt) | 0;
                        var Tt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, n = Math.imul(L, ct), i = Math.imul(L, lt), i = i + Math.imul(F, ct) | 0, s = Math.imul(F, lt), n = n + Math.imul(C, pt) | 0, i = i + Math.imul(C, mt) | 0, i = i + Math.imul(z, pt) | 0, s = s + Math.imul(z, mt) | 0;
                        var Nt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, n = Math.imul(L, pt), i = Math.imul(L, mt), i = i + Math.imul(F, pt) | 0, s = Math.imul(F, mt);
                        var jt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        return h = (s + (i >>> 13) | 0) + (jt >>> 26) | 0, jt &= 67108863, u[0] = bt, u[1] = gt, u[2] = yt, u[3] = vt, u[4] = wt, u[5] = _t, u[6] = Mt, u[7] = At, u[8] = St, u[9] = xt, u[10] = Et, u[11] = kt, u[12] = Rt, u[13] = Ot, u[14] = It, u[15] = Pt, u[16] = Tt, u[17] = Nt, u[18] = jt, 0 !== h && (u[19] = h, r.length++), r
                    };

                    function m(t, e, r) {
                        r.negative = e.negative ^ t.negative, r.length = t.length + e.length;
                        for (var n = 0, i = 0, s = 0; s < r.length - 1; s++) {
                            var a = i;
                            i = 0;
                            for (var o = 67108863 & n, u = Math.min(s, e.length - 1), h = Math.max(0, s - t.length + 1); h <= u; h++) {
                                var f = s - h,
                                    c = 0 | t.words[f],
                                    l = 0 | e.words[h],
                                    d = c * l,
                                    p = 67108863 & d;
                                a = a + (d / 67108864 | 0) | 0, p = p + o | 0, o = 67108863 & p, a = a + (p >>> 26) | 0, i += a >>> 26, a &= 67108863
                            }
                            r.words[s] = o, n = a, a = i
                        }
                        return 0 !== n ? r.words[s] = n : r.length--, r.strip()
                    }

                    function b(t, e, r) {
                        var n = new g;
                        return n.mulp(t, e, r)
                    }

                    function g(t, e) {
                        this.x = t, this.y = e
                    }
                    Math.imul || (p = d), s.prototype.mulTo = function(t, e) {
                        var r, n = this.length + t.length;
                        return r = 10 === this.length && 10 === t.length ? p(this, t, e) : n < 63 ? d(this, t, e) : n < 1024 ? m(this, t, e) : b(this, t, e), r
                    }, g.prototype.makeRBT = function(t) {
                        for (var e = new Array(t), r = s.prototype._countBits(t) - 1, n = 0; n < t; n++) e[n] = this.revBin(n, r, t);
                        return e
                    }, g.prototype.revBin = function(t, e, r) {
                        if (0 === t || t === r - 1) return t;
                        for (var n = 0, i = 0; i < e; i++) n |= (1 & t) << e - i - 1, t >>= 1;
                        return n
                    }, g.prototype.permute = function(t, e, r, n, i, s) {
                        for (var a = 0; a < s; a++) n[a] = e[t[a]], i[a] = r[t[a]]
                    }, g.prototype.transform = function(t, e, r, n, i, s) {
                        this.permute(s, t, e, r, n, i);
                        for (var a = 1; a < i; a <<= 1)
                            for (var o = a << 1, u = Math.cos(2 * Math.PI / o), h = Math.sin(2 * Math.PI / o), f = 0; f < i; f += o)
                                for (var c = u, l = h, d = 0; d < a; d++) {
                                    var p = r[f + d],
                                        m = n[f + d],
                                        b = r[f + d + a],
                                        g = n[f + d + a],
                                        y = c * b - l * g;
                                    g = c * g + l * b, b = y, r[f + d] = p + b, n[f + d] = m + g, r[f + d + a] = p - b, n[f + d + a] = m - g, d !== o && (y = u * c - h * l, l = u * l + h * c, c = y)
                                }
                    }, g.prototype.guessLen13b = function(t, e) {
                        var r = 1 | Math.max(e, t),
                            n = 1 & r,
                            i = 0;
                        for (r = r / 2 | 0; r; r >>>= 1) i++;
                        return 1 << i + 1 + n
                    }, g.prototype.conjugate = function(t, e, r) {
                        if (!(r <= 1))
                            for (var n = 0; n < r / 2; n++) {
                                var i = t[n];
                                t[n] = t[r - n - 1], t[r - n - 1] = i, i = e[n], e[n] = -e[r - n - 1], e[r - n - 1] = -i
                            }
                    }, g.prototype.normalize13b = function(t, e) {
                        for (var r = 0, n = 0; n < e / 2; n++) {
                            var i = 8192 * Math.round(t[2 * n + 1] / e) + Math.round(t[2 * n] / e) + r;
                            t[n] = 67108863 & i, r = i < 67108864 ? 0 : i / 67108864 | 0
                        }
                        return t
                    }, g.prototype.convert13b = function(t, e, r, i) {
                        for (var s = 0, a = 0; a < e; a++) s += 0 | t[a], r[2 * a] = 8191 & s, s >>>= 13, r[2 * a + 1] = 8191 & s, s >>>= 13;
                        for (a = 2 * e; a < i; ++a) r[a] = 0;
                        n(0 === s), n(0 === (-8192 & s))
                    }, g.prototype.stub = function(t) {
                        for (var e = new Array(t), r = 0; r < t; r++) e[r] = 0;
                        return e
                    }, g.prototype.mulp = function(t, e, r) {
                        var n = 2 * this.guessLen13b(t.length, e.length),
                            i = this.makeRBT(n),
                            s = this.stub(n),
                            a = new Array(n),
                            o = new Array(n),
                            u = new Array(n),
                            h = new Array(n),
                            f = new Array(n),
                            c = new Array(n),
                            l = r.words;
                        l.length = n, this.convert13b(t.words, t.length, a, n), this.convert13b(e.words, e.length, h, n), this.transform(a, s, o, u, n, i), this.transform(h, s, f, c, n, i);
                        for (var d = 0; d < n; d++) {
                            var p = o[d] * f[d] - u[d] * c[d];
                            u[d] = o[d] * c[d] + u[d] * f[d], o[d] = p
                        }
                        return this.conjugate(o, u, n), this.transform(o, u, l, s, n, i), this.conjugate(l, s, n), this.normalize13b(l, n), r.negative = t.negative ^ e.negative, r.length = t.length + e.length, r.strip()
                    }, s.prototype.mul = function(t) {
                        var e = new s(null);
                        return e.words = new Array(this.length + t.length), this.mulTo(t, e)
                    }, s.prototype.mulf = function(t) {
                        var e = new s(null);
                        return e.words = new Array(this.length + t.length), b(this, t, e)
                    }, s.prototype.imul = function(t) {
                        return this.clone().mulTo(t, this)
                    }, s.prototype.imuln = function(t) {
                        n("number" === typeof t), n(t < 67108864);
                        for (var e = 0, r = 0; r < this.length; r++) {
                            var i = (0 | this.words[r]) * t,
                                s = (67108863 & i) + (67108863 & e);
                            e >>= 26, e += i / 67108864 | 0, e += s >>> 26, this.words[r] = 67108863 & s
                        }
                        return 0 !== e && (this.words[r] = e, this.length++), this
                    }, s.prototype.muln = function(t) {
                        return this.clone().imuln(t)
                    }, s.prototype.sqr = function() {
                        return this.mul(this)
                    }, s.prototype.isqr = function() {
                        return this.imul(this.clone())
                    }, s.prototype.pow = function(t) {
                        var e = l(t);
                        if (0 === e.length) return new s(1);
                        for (var r = this, n = 0; n < e.length; n++, r = r.sqr())
                            if (0 !== e[n]) break;
                        if (++n < e.length)
                            for (var i = r.sqr(); n < e.length; n++, i = i.sqr()) 0 !== e[n] && (r = r.mul(i));
                        return r
                    }, s.prototype.iushln = function(t) {
                        n("number" === typeof t && t >= 0);
                        var e, r = t % 26,
                            i = (t - r) / 26,
                            s = 67108863 >>> 26 - r << 26 - r;
                        if (0 !== r) {
                            var a = 0;
                            for (e = 0; e < this.length; e++) {
                                var o = this.words[e] & s,
                                    u = (0 | this.words[e]) - o << r;
                                this.words[e] = u | a, a = o >>> 26 - r
                            }
                            a && (this.words[e] = a, this.length++)
                        }
                        if (0 !== i) {
                            for (e = this.length - 1; e >= 0; e--) this.words[e + i] = this.words[e];
                            for (e = 0; e < i; e++) this.words[e] = 0;
                            this.length += i
                        }
                        return this.strip()
                    }, s.prototype.ishln = function(t) {
                        return n(0 === this.negative), this.iushln(t)
                    }, s.prototype.iushrn = function(t, e, r) {
                        var i;
                        n("number" === typeof t && t >= 0), i = e ? (e - e % 26) / 26 : 0;
                        var s = t % 26,
                            a = Math.min((t - s) / 26, this.length),
                            o = 67108863 ^ 67108863 >>> s << s,
                            u = r;
                        if (i -= a, i = Math.max(0, i), u) {
                            for (var h = 0; h < a; h++) u.words[h] = this.words[h];
                            u.length = a
                        }
                        if (0 === a);
                        else if (this.length > a)
                            for (this.length -= a, h = 0; h < this.length; h++) this.words[h] = this.words[h + a];
                        else this.words[0] = 0, this.length = 1;
                        var f = 0;
                        for (h = this.length - 1; h >= 0 && (0 !== f || h >= i); h--) {
                            var c = 0 | this.words[h];
                            this.words[h] = f << 26 - s | c >>> s, f = c & o
                        }
                        return u && 0 !== f && (u.words[u.length++] = f), 0 === this.length && (this.words[0] = 0, this.length = 1), this.strip()
                    }, s.prototype.ishrn = function(t, e, r) {
                        return n(0 === this.negative), this.iushrn(t, e, r)
                    }, s.prototype.shln = function(t) {
                        return this.clone().ishln(t)
                    }, s.prototype.ushln = function(t) {
                        return this.clone().iushln(t)
                    }, s.prototype.shrn = function(t) {
                        return this.clone().ishrn(t)
                    }, s.prototype.ushrn = function(t) {
                        return this.clone().iushrn(t)
                    }, s.prototype.testn = function(t) {
                        n("number" === typeof t && t >= 0);
                        var e = t % 26,
                            r = (t - e) / 26,
                            i = 1 << e;
                        if (this.length <= r) return !1;
                        var s = this.words[r];
                        return !!(s & i)
                    }, s.prototype.imaskn = function(t) {
                        n("number" === typeof t && t >= 0);
                        var e = t % 26,
                            r = (t - e) / 26;
                        if (n(0 === this.negative, "imaskn works only with positive numbers"), this.length <= r) return this;
                        if (0 !== e && r++, this.length = Math.min(r, this.length), 0 !== e) {
                            var i = 67108863 ^ 67108863 >>> e << e;
                            this.words[this.length - 1] &= i
                        }
                        return this.strip()
                    }, s.prototype.maskn = function(t) {
                        return this.clone().imaskn(t)
                    }, s.prototype.iaddn = function(t) {
                        return n("number" === typeof t), n(t < 67108864), t < 0 ? this.isubn(-t) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) < t ? (this.words[0] = t - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(t), this.negative = 1, this) : this._iaddn(t)
                    }, s.prototype._iaddn = function(t) {
                        this.words[0] += t;
                        for (var e = 0; e < this.length && this.words[e] >= 67108864; e++) this.words[e] -= 67108864, e === this.length - 1 ? this.words[e + 1] = 1 : this.words[e + 1]++;
                        return this.length = Math.max(this.length, e + 1), this
                    }, s.prototype.isubn = function(t) {
                        if (n("number" === typeof t), n(t < 67108864), t < 0) return this.iaddn(-t);
                        if (0 !== this.negative) return this.negative = 0, this.iaddn(t), this.negative = 1, this;
                        if (this.words[0] -= t, 1 === this.length && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
                        else
                            for (var e = 0; e < this.length && this.words[e] < 0; e++) this.words[e] += 67108864, this.words[e + 1] -= 1;
                        return this.strip()
                    }, s.prototype.addn = function(t) {
                        return this.clone().iaddn(t)
                    }, s.prototype.subn = function(t) {
                        return this.clone().isubn(t)
                    }, s.prototype.iabs = function() {
                        return this.negative = 0, this
                    }, s.prototype.abs = function() {
                        return this.clone().iabs()
                    }, s.prototype._ishlnsubmul = function(t, e, r) {
                        var i, s, a = t.length + r;
                        this._expand(a);
                        var o = 0;
                        for (i = 0; i < t.length; i++) {
                            s = (0 | this.words[i + r]) + o;
                            var u = (0 | t.words[i]) * e;
                            s -= 67108863 & u, o = (s >> 26) - (u / 67108864 | 0), this.words[i + r] = 67108863 & s
                        }
                        for (; i < this.length - r; i++) s = (0 | this.words[i + r]) + o, o = s >> 26, this.words[i + r] = 67108863 & s;
                        if (0 === o) return this.strip();
                        for (n(-1 === o), o = 0, i = 0; i < this.length; i++) s = -(0 | this.words[i]) + o, o = s >> 26, this.words[i] = 67108863 & s;
                        return this.negative = 1, this.strip()
                    }, s.prototype._wordDiv = function(t, e) {
                        var r = this.length - t.length,
                            n = this.clone(),
                            i = t,
                            a = 0 | i.words[i.length - 1],
                            o = this._countBits(a);
                        r = 26 - o, 0 !== r && (i = i.ushln(r), n.iushln(r), a = 0 | i.words[i.length - 1]);
                        var u, h = n.length - i.length;
                        if ("mod" !== e) {
                            u = new s(null), u.length = h + 1, u.words = new Array(u.length);
                            for (var f = 0; f < u.length; f++) u.words[f] = 0
                        }
                        var c = n.clone()._ishlnsubmul(i, 1, h);
                        0 === c.negative && (n = c, u && (u.words[h] = 1));
                        for (var l = h - 1; l >= 0; l--) {
                            var d = 67108864 * (0 | n.words[i.length + l]) + (0 | n.words[i.length + l - 1]);
                            d = Math.min(d / a | 0, 67108863), n._ishlnsubmul(i, d, l);
                            while (0 !== n.negative) d--, n.negative = 0, n._ishlnsubmul(i, 1, l), n.isZero() || (n.negative ^= 1);
                            u && (u.words[l] = d)
                        }
                        return u && u.strip(), n.strip(), "div" !== e && 0 !== r && n.iushrn(r), {
                            div: u || null,
                            mod: n
                        }
                    }, s.prototype.divmod = function(t, e, r) {
                        return n(!t.isZero()), this.isZero() ? {
                            div: new s(0),
                            mod: new s(0)
                        } : 0 !== this.negative && 0 === t.negative ? (o = this.neg().divmod(t, e), "mod" !== e && (i = o.div.neg()), "div" !== e && (a = o.mod.neg(), r && 0 !== a.negative && a.iadd(t)), {
                            div: i,
                            mod: a
                        }) : 0 === this.negative && 0 !== t.negative ? (o = this.divmod(t.neg(), e), "mod" !== e && (i = o.div.neg()), {
                            div: i,
                            mod: o.mod
                        }) : 0 !== (this.negative & t.negative) ? (o = this.neg().divmod(t.neg(), e), "div" !== e && (a = o.mod.neg(), r && 0 !== a.negative && a.isub(t)), {
                            div: o.div,
                            mod: a
                        }) : t.length > this.length || this.cmp(t) < 0 ? {
                            div: new s(0),
                            mod: this
                        } : 1 === t.length ? "div" === e ? {
                            div: this.divn(t.words[0]),
                            mod: null
                        } : "mod" === e ? {
                            div: null,
                            mod: new s(this.modn(t.words[0]))
                        } : {
                            div: this.divn(t.words[0]),
                            mod: new s(this.modn(t.words[0]))
                        } : this._wordDiv(t, e);
                        var i, a, o
                    }, s.prototype.div = function(t) {
                        return this.divmod(t, "div", !1).div
                    }, s.prototype.mod = function(t) {
                        return this.divmod(t, "mod", !1).mod
                    }, s.prototype.umod = function(t) {
                        return this.divmod(t, "mod", !0).mod
                    }, s.prototype.divRound = function(t) {
                        var e = this.divmod(t);
                        if (e.mod.isZero()) return e.div;
                        var r = 0 !== e.div.negative ? e.mod.isub(t) : e.mod,
                            n = t.ushrn(1),
                            i = t.andln(1),
                            s = r.cmp(n);
                        return s < 0 || 1 === i && 0 === s ? e.div : 0 !== e.div.negative ? e.div.isubn(1) : e.div.iaddn(1)
                    }, s.prototype.modn = function(t) {
                        n(t <= 67108863);
                        for (var e = (1 << 26) % t, r = 0, i = this.length - 1; i >= 0; i--) r = (e * r + (0 | this.words[i])) % t;
                        return r
                    }, s.prototype.idivn = function(t) {
                        n(t <= 67108863);
                        for (var e = 0, r = this.length - 1; r >= 0; r--) {
                            var i = (0 | this.words[r]) + 67108864 * e;
                            this.words[r] = i / t | 0, e = i % t
                        }
                        return this.strip()
                    }, s.prototype.divn = function(t) {
                        return this.clone().idivn(t)
                    }, s.prototype.egcd = function(t) {
                        n(0 === t.negative), n(!t.isZero());
                        var e = this,
                            r = t.clone();
                        e = 0 !== e.negative ? e.umod(t) : e.clone();
                        var i = new s(1),
                            a = new s(0),
                            o = new s(0),
                            u = new s(1),
                            h = 0;
                        while (e.isEven() && r.isEven()) e.iushrn(1), r.iushrn(1), ++h;
                        var f = r.clone(),
                            c = e.clone();
                        while (!e.isZero()) {
                            for (var l = 0, d = 1; 0 === (e.words[0] & d) && l < 26; ++l, d <<= 1);
                            if (l > 0) {
                                e.iushrn(l);
                                while (l-- > 0)(i.isOdd() || a.isOdd()) && (i.iadd(f), a.isub(c)), i.iushrn(1), a.iushrn(1)
                            }
                            for (var p = 0, m = 1; 0 === (r.words[0] & m) && p < 26; ++p, m <<= 1);
                            if (p > 0) {
                                r.iushrn(p);
                                while (p-- > 0)(o.isOdd() || u.isOdd()) && (o.iadd(f), u.isub(c)), o.iushrn(1), u.iushrn(1)
                            }
                            e.cmp(r) >= 0 ? (e.isub(r), i.isub(o), a.isub(u)) : (r.isub(e), o.isub(i), u.isub(a))
                        }
                        return {
                            a: o,
                            b: u,
                            gcd: r.iushln(h)
                        }
                    }, s.prototype._invmp = function(t) {
                        n(0 === t.negative), n(!t.isZero());
                        var e = this,
                            r = t.clone();
                        e = 0 !== e.negative ? e.umod(t) : e.clone();
                        var i, a = new s(1),
                            o = new s(0),
                            u = r.clone();
                        while (e.cmpn(1) > 0 && r.cmpn(1) > 0) {
                            for (var h = 0, f = 1; 0 === (e.words[0] & f) && h < 26; ++h, f <<= 1);
                            if (h > 0) {
                                e.iushrn(h);
                                while (h-- > 0) a.isOdd() && a.iadd(u), a.iushrn(1)
                            }
                            for (var c = 0, l = 1; 0 === (r.words[0] & l) && c < 26; ++c, l <<= 1);
                            if (c > 0) {
                                r.iushrn(c);
                                while (c-- > 0) o.isOdd() && o.iadd(u), o.iushrn(1)
                            }
                            e.cmp(r) >= 0 ? (e.isub(r), a.isub(o)) : (r.isub(e), o.isub(a))
                        }
                        return i = 0 === e.cmpn(1) ? a : o, i.cmpn(0) < 0 && i.iadd(t), i
                    }, s.prototype.gcd = function(t) {
                        if (this.isZero()) return t.abs();
                        if (t.isZero()) return this.abs();
                        var e = this.clone(),
                            r = t.clone();
                        e.negative = 0, r.negative = 0;
                        for (var n = 0; e.isEven() && r.isEven(); n++) e.iushrn(1), r.iushrn(1);
                        do {
                            while (e.isEven()) e.iushrn(1);
                            while (r.isEven()) r.iushrn(1);
                            var i = e.cmp(r);
                            if (i < 0) {
                                var s = e;
                                e = r, r = s
                            } else if (0 === i || 0 === r.cmpn(1)) break;
                            e.isub(r)
                        } while (1);
                        return r.iushln(n)
                    }, s.prototype.invm = function(t) {
                        return this.egcd(t).a.umod(t)
                    }, s.prototype.isEven = function() {
                        return 0 === (1 & this.words[0])
                    }, s.prototype.isOdd = function() {
                        return 1 === (1 & this.words[0])
                    }, s.prototype.andln = function(t) {
                        return this.words[0] & t
                    }, s.prototype.bincn = function(t) {
                        n("number" === typeof t);
                        var e = t % 26,
                            r = (t - e) / 26,
                            i = 1 << e;
                        if (this.length <= r) return this._expand(r + 1), this.words[r] |= i, this;
                        for (var s = i, a = r; 0 !== s && a < this.length; a++) {
                            var o = 0 | this.words[a];
                            o += s, s = o >>> 26, o &= 67108863, this.words[a] = o
                        }
                        return 0 !== s && (this.words[a] = s, this.length++), this
                    }, s.prototype.isZero = function() {
                        return 1 === this.length && 0 === this.words[0]
                    }, s.prototype.cmpn = function(t) {
                        var e, r = t < 0;
                        if (0 !== this.negative && !r) return -1;
                        if (0 === this.negative && r) return 1;
                        if (this.strip(), this.length > 1) e = 1;
                        else {
                            r && (t = -t), n(t <= 67108863, "Number is too big");
                            var i = 0 | this.words[0];
                            e = i === t ? 0 : i < t ? -1 : 1
                        }
                        return 0 !== this.negative ? 0 | -e : e
                    }, s.prototype.cmp = function(t) {
                        if (0 !== this.negative && 0 === t.negative) return -1;
                        if (0 === this.negative && 0 !== t.negative) return 1;
                        var e = this.ucmp(t);
                        return 0 !== this.negative ? 0 | -e : e
                    }, s.prototype.ucmp = function(t) {
                        if (this.length > t.length) return 1;
                        if (this.length < t.length) return -1;
                        for (var e = 0, r = this.length - 1; r >= 0; r--) {
                            var n = 0 | this.words[r],
                                i = 0 | t.words[r];
                            if (n !== i) {
                                n < i ? e = -1 : n > i && (e = 1);
                                break
                            }
                        }
                        return e
                    }, s.prototype.gtn = function(t) {
                        return 1 === this.cmpn(t)
                    }, s.prototype.gt = function(t) {
                        return 1 === this.cmp(t)
                    }, s.prototype.gten = function(t) {
                        return this.cmpn(t) >= 0
                    }, s.prototype.gte = function(t) {
                        return this.cmp(t) >= 0
                    }, s.prototype.ltn = function(t) {
                        return -1 === this.cmpn(t)
                    }, s.prototype.lt = function(t) {
                        return -1 === this.cmp(t)
                    }, s.prototype.lten = function(t) {
                        return this.cmpn(t) <= 0
                    }, s.prototype.lte = function(t) {
                        return this.cmp(t) <= 0
                    }, s.prototype.eqn = function(t) {
                        return 0 === this.cmpn(t)
                    }, s.prototype.eq = function(t) {
                        return 0 === this.cmp(t)
                    }, s.red = function(t) {
                        return new S(t)
                    }, s.prototype.toRed = function(t) {
                        return n(!this.red, "Already a number in reduction context"), n(0 === this.negative, "red works only with positives"), t.convertTo(this)._forceRed(t)
                    }, s.prototype.fromRed = function() {
                        return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
                    }, s.prototype._forceRed = function(t) {
                        return this.red = t, this
                    }, s.prototype.forceRed = function(t) {
                        return n(!this.red, "Already a number in reduction context"), this._forceRed(t)
                    }, s.prototype.redAdd = function(t) {
                        return n(this.red, "redAdd works only with red numbers"), this.red.add(this, t)
                    }, s.prototype.redIAdd = function(t) {
                        return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, t)
                    }, s.prototype.redSub = function(t) {
                        return n(this.red, "redSub works only with red numbers"), this.red.sub(this, t)
                    }, s.prototype.redISub = function(t) {
                        return n(this.red, "redISub works only with red numbers"), this.red.isub(this, t)
                    }, s.prototype.redShl = function(t) {
                        return n(this.red, "redShl works only with red numbers"), this.red.shl(this, t)
                    }, s.prototype.redMul = function(t) {
                        return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, t), this.red.mul(this, t)
                    }, s.prototype.redIMul = function(t) {
                        return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, t), this.red.imul(this, t)
                    }, s.prototype.redSqr = function() {
                        return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
                    }, s.prototype.redISqr = function() {
                        return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
                    }, s.prototype.redSqrt = function() {
                        return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
                    }, s.prototype.redInvm = function() {
                        return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
                    }, s.prototype.redNeg = function() {
                        return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
                    }, s.prototype.redPow = function(t) {
                        return n(this.red && !t.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, t)
                    };
                    var y = {
                        k256: null,
                        p224: null,
                        p192: null,
                        p25519: null
                    };

                    function v(t, e) {
                        this.name = t, this.p = new s(e, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
                    }

                    function w() {
                        v.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
                    }

                    function _() {
                        v.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
                    }

                    function M() {
                        v.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
                    }

                    function A() {
                        v.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
                    }

                    function S(t) {
                        if ("string" === typeof t) {
                            var e = s._prime(t);
                            this.m = e.p, this.prime = e
                        } else n(t.gtn(1), "modulus must be greater than 1"), this.m = t, this.prime = null
                    }

                    function x(t) {
                        S.call(this, t), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
                    }
                    v.prototype._tmp = function() {
                        var t = new s(null);
                        return t.words = new Array(Math.ceil(this.n / 13)), t
                    }, v.prototype.ireduce = function(t) {
                        var e, r = t;
                        do {
                            this.split(r, this.tmp), r = this.imulK(r), r = r.iadd(this.tmp), e = r.bitLength()
                        } while (e > this.n);
                        var n = e < this.n ? -1 : r.ucmp(this.p);
                        return 0 === n ? (r.words[0] = 0, r.length = 1) : n > 0 ? r.isub(this.p) : void 0 !== r.strip ? r.strip() : r._strip(), r
                    }, v.prototype.split = function(t, e) {
                        t.iushrn(this.n, 0, e)
                    }, v.prototype.imulK = function(t) {
                        return t.imul(this.k)
                    }, i(w, v), w.prototype.split = function(t, e) {
                        for (var r = 4194303, n = Math.min(t.length, 9), i = 0; i < n; i++) e.words[i] = t.words[i];
                        if (e.length = n, t.length <= 9) return t.words[0] = 0, void(t.length = 1);
                        var s = t.words[9];
                        for (e.words[e.length++] = s & r, i = 10; i < t.length; i++) {
                            var a = 0 | t.words[i];
                            t.words[i - 10] = (a & r) << 4 | s >>> 22, s = a
                        }
                        s >>>= 22, t.words[i - 10] = s, 0 === s && t.length > 10 ? t.length -= 10 : t.length -= 9
                    }, w.prototype.imulK = function(t) {
                        t.words[t.length] = 0, t.words[t.length + 1] = 0, t.length += 2;
                        for (var e = 0, r = 0; r < t.length; r++) {
                            var n = 0 | t.words[r];
                            e += 977 * n, t.words[r] = 67108863 & e, e = 64 * n + (e / 67108864 | 0)
                        }
                        return 0 === t.words[t.length - 1] && (t.length--, 0 === t.words[t.length - 1] && t.length--), t
                    }, i(_, v), i(M, v), i(A, v), A.prototype.imulK = function(t) {
                        for (var e = 0, r = 0; r < t.length; r++) {
                            var n = 19 * (0 | t.words[r]) + e,
                                i = 67108863 & n;
                            n >>>= 26, t.words[r] = i, e = n
                        }
                        return 0 !== e && (t.words[t.length++] = e), t
                    }, s._prime = function(t) {
                        if (y[t]) return y[t];
                        var e;
                        if ("k256" === t) e = new w;
                        else if ("p224" === t) e = new _;
                        else if ("p192" === t) e = new M;
                        else {
                            if ("p25519" !== t) throw new Error("Unknown prime " + t);
                            e = new A
                        }
                        return y[t] = e, e
                    }, S.prototype._verify1 = function(t) {
                        n(0 === t.negative, "red works only with positives"), n(t.red, "red works only with red numbers")
                    }, S.prototype._verify2 = function(t, e) {
                        n(0 === (t.negative | e.negative), "red works only with positives"), n(t.red && t.red === e.red, "red works only with red numbers")
                    }, S.prototype.imod = function(t) {
                        return this.prime ? this.prime.ireduce(t)._forceRed(this) : t.umod(this.m)._forceRed(this)
                    }, S.prototype.neg = function(t) {
                        return t.isZero() ? t.clone() : this.m.sub(t)._forceRed(this)
                    }, S.prototype.add = function(t, e) {
                        this._verify2(t, e);
                        var r = t.add(e);
                        return r.cmp(this.m) >= 0 && r.isub(this.m), r._forceRed(this)
                    }, S.prototype.iadd = function(t, e) {
                        this._verify2(t, e);
                        var r = t.iadd(e);
                        return r.cmp(this.m) >= 0 && r.isub(this.m), r
                    }, S.prototype.sub = function(t, e) {
                        this._verify2(t, e);
                        var r = t.sub(e);
                        return r.cmpn(0) < 0 && r.iadd(this.m), r._forceRed(this)
                    }, S.prototype.isub = function(t, e) {
                        this._verify2(t, e);
                        var r = t.isub(e);
                        return r.cmpn(0) < 0 && r.iadd(this.m), r
                    }, S.prototype.shl = function(t, e) {
                        return this._verify1(t), this.imod(t.ushln(e))
                    }, S.prototype.imul = function(t, e) {
                        return this._verify2(t, e), this.imod(t.imul(e))
                    }, S.prototype.mul = function(t, e) {
                        return this._verify2(t, e), this.imod(t.mul(e))
                    }, S.prototype.isqr = function(t) {
                        return this.imul(t, t.clone())
                    }, S.prototype.sqr = function(t) {
                        return this.mul(t, t)
                    }, S.prototype.sqrt = function(t) {
                        if (t.isZero()) return t.clone();
                        var e = this.m.andln(3);
                        if (n(e % 2 === 1), 3 === e) {
                            var r = this.m.add(new s(1)).iushrn(2);
                            return this.pow(t, r)
                        }
                        var i = this.m.subn(1),
                            a = 0;
                        while (!i.isZero() && 0 === i.andln(1)) a++, i.iushrn(1);
                        n(!i.isZero());
                        var o = new s(1).toRed(this),
                            u = o.redNeg(),
                            h = this.m.subn(1).iushrn(1),
                            f = this.m.bitLength();
                        f = new s(2 * f * f).toRed(this);
                        while (0 !== this.pow(f, h).cmp(u)) f.redIAdd(u);
                        var c = this.pow(f, i),
                            l = this.pow(t, i.addn(1).iushrn(1)),
                            d = this.pow(t, i),
                            p = a;
                        while (0 !== d.cmp(o)) {
                            for (var m = d, b = 0; 0 !== m.cmp(o); b++) m = m.redSqr();
                            n(b < p);
                            var g = this.pow(c, new s(1).iushln(p - b - 1));
                            l = l.redMul(g), c = g.redSqr(), d = d.redMul(c), p = b
                        }
                        return l
                    }, S.prototype.invm = function(t) {
                        var e = t._invmp(this.m);
                        return 0 !== e.negative ? (e.negative = 0, this.imod(e).redNeg()) : this.imod(e)
                    }, S.prototype.pow = function(t, e) {
                        if (e.isZero()) return new s(1).toRed(this);
                        if (0 === e.cmpn(1)) return t.clone();
                        var r = 4,
                            n = new Array(1 << r);
                        n[0] = new s(1).toRed(this), n[1] = t;
                        for (var i = 2; i < n.length; i++) n[i] = this.mul(n[i - 1], t);
                        var a = n[0],
                            o = 0,
                            u = 0,
                            h = e.bitLength() % 26;
                        for (0 === h && (h = 26), i = e.length - 1; i >= 0; i--) {
                            for (var f = e.words[i], c = h - 1; c >= 0; c--) {
                                var l = f >> c & 1;
                                a !== n[0] && (a = this.sqr(a)), 0 !== l || 0 !== o ? (o <<= 1, o |= l, u++, (u === r || 0 === i && 0 === c) && (a = this.mul(a, n[o]), u = 0, o = 0)) : u = 0
                            }
                            h = 26
                        }
                        return a
                    }, S.prototype.convertTo = function(t) {
                        var e = t.umod(this.m);
                        return e === t ? e.clone() : e
                    }, S.prototype.convertFrom = function(t) {
                        var e = t.clone();
                        return e.red = null, e
                    }, s.mont = function(t) {
                        return new x(t)
                    }, i(x, S), x.prototype.convertTo = function(t) {
                        return this.imod(t.ushln(this.shift))
                    }, x.prototype.convertFrom = function(t) {
                        var e = this.imod(t.mul(this.rinv));
                        return e.red = null, e
                    }, x.prototype.imul = function(t, e) {
                        if (t.isZero() || e.isZero()) return t.words[0] = 0, t.length = 1, t;
                        var r = t.imul(e),
                            n = r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                            i = r.isub(n).iushrn(this.shift),
                            s = i;
                        return i.cmp(this.m) >= 0 ? s = i.isub(this.m) : i.cmpn(0) < 0 && (s = i.iadd(this.m)), s._forceRed(this)
                    }, x.prototype.mul = function(t, e) {
                        if (t.isZero() || e.isZero()) return new s(0)._forceRed(this);
                        var r = t.mul(e),
                            n = r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                            i = r.isub(n).iushrn(this.shift),
                            a = i;
                        return i.cmp(this.m) >= 0 ? a = i.isub(this.m) : i.cmpn(0) < 0 && (a = i.iadd(this.m)), a._forceRed(this)
                    }, x.prototype.invm = function(t) {
                        var e = this.imod(t._invmp(this.m).mul(this.r2));
                        return e._forceRed(this)
                    }
                })(t, this)
            }).call(this, r("62e4")(t))
        },
        "493f": function(t, e, r) {
            "use strict";
            (function(e) {
                function r(t, r) {
                    var s = this,
                        o = this._readableState && this._readableState.destroyed,
                        u = this._writableState && this._writableState.destroyed;
                    return o || u ? (r ? r(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, e.nextTick(a, this, t)) : e.nextTick(a, this, t)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(t || null, (function(t) {
                        !r && t ? s._writableState ? s._writableState.errorEmitted ? e.nextTick(i, s) : (s._writableState.errorEmitted = !0, e.nextTick(n, s, t)) : e.nextTick(n, s, t) : r ? (e.nextTick(i, s), r(t)) : e.nextTick(i, s)
                    })), this)
                }

                function n(t, e) {
                    a(t, e), i(t)
                }

                function i(t) {
                    t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close")
                }

                function s() {
                    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1)
                }

                function a(t, e) {
                    t.emit("error", e)
                }

                function o(t, e) {
                    var r = t._readableState,
                        n = t._writableState;
                    r && r.autoDestroy || n && n.autoDestroy ? t.destroy(e) : t.emit("error", e)
                }
                t.exports = {
                    destroy: r,
                    undestroy: s,
                    errorOrDestroy: o
                }
            }).call(this, r("4362"))
        },
        "4a87": function(t, e, r) {
            (function(t) {
                (function(t, e) {
                    "use strict";

                    function n(t, e) {
                        if (!t) throw new Error(e || "Assertion failed")
                    }

                    function i(t, e) {
                        t.super_ = e;
                        var r = function() {};
                        r.prototype = e.prototype, t.prototype = new r, t.prototype.constructor = t
                    }

                    function s(t, e, r) {
                        if (s.isBN(t)) return t;
                        this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== t && ("le" !== e && "be" !== e || (r = e, e = 10), this._init(t || 0, e || 10, r || "be"))
                    }
                    var a;
                    "object" === typeof t ? t.exports = s : e.BN = s, s.BN = s, s.wordSize = 26;
                    try {
                        a = r("b639").Buffer
                    } catch (E) {}

                    function o(t, e, r) {
                        for (var n = 0, i = Math.min(t.length, r), s = e; s < i; s++) {
                            var a = t.charCodeAt(s) - 48;
                            n <<= 4, n |= a >= 49 && a <= 54 ? a - 49 + 10 : a >= 17 && a <= 22 ? a - 17 + 10 : 15 & a
                        }
                        return n
                    }

                    function u(t, e, r, n) {
                        for (var i = 0, s = Math.min(t.length, r), a = e; a < s; a++) {
                            var o = t.charCodeAt(a) - 48;
                            i *= n, i += o >= 49 ? o - 49 + 10 : o >= 17 ? o - 17 + 10 : o
                        }
                        return i
                    }
                    s.isBN = function(t) {
                        return t instanceof s || null !== t && "object" === typeof t && t.constructor.wordSize === s.wordSize && Array.isArray(t.words)
                    }, s.max = function(t, e) {
                        return t.cmp(e) > 0 ? t : e
                    }, s.min = function(t, e) {
                        return t.cmp(e) < 0 ? t : e
                    }, s.prototype._init = function(t, e, r) {
                        if ("number" === typeof t) return this._initNumber(t, e, r);
                        if ("object" === typeof t) return this._initArray(t, e, r);
                        "hex" === e && (e = 16), n(e === (0 | e) && e >= 2 && e <= 36), t = t.toString().replace(/\s+/g, "");
                        var i = 0;
                        "-" === t[0] && i++, 16 === e ? this._parseHex(t, i) : this._parseBase(t, e, i), "-" === t[0] && (this.negative = 1), this.strip(), "le" === r && this._initArray(this.toArray(), e, r)
                    }, s.prototype._initNumber = function(t, e, r) {
                        t < 0 && (this.negative = 1, t = -t), t < 67108864 ? (this.words = [67108863 & t], this.length = 1) : t < 4503599627370496 ? (this.words = [67108863 & t, t / 67108864 & 67108863], this.length = 2) : (n(t < 9007199254740992), this.words = [67108863 & t, t / 67108864 & 67108863, 1], this.length = 3), "le" === r && this._initArray(this.toArray(), e, r)
                    }, s.prototype._initArray = function(t, e, r) {
                        if (n("number" === typeof t.length), t.length <= 0) return this.words = [0], this.length = 1, this;
                        this.length = Math.ceil(t.length / 3), this.words = new Array(this.length);
                        for (var i = 0; i < this.length; i++) this.words[i] = 0;
                        var s, a, o = 0;
                        if ("be" === r)
                            for (i = t.length - 1, s = 0; i >= 0; i -= 3) a = t[i] | t[i - 1] << 8 | t[i - 2] << 16, this.words[s] |= a << o & 67108863, this.words[s + 1] = a >>> 26 - o & 67108863, o += 24, o >= 26 && (o -= 26, s++);
                        else if ("le" === r)
                            for (i = 0, s = 0; i < t.length; i += 3) a = t[i] | t[i + 1] << 8 | t[i + 2] << 16, this.words[s] |= a << o & 67108863, this.words[s + 1] = a >>> 26 - o & 67108863, o += 24, o >= 26 && (o -= 26, s++);
                        return this.strip()
                    }, s.prototype._parseHex = function(t, e) {
                        this.length = Math.ceil((t.length - e) / 6), this.words = new Array(this.length);
                        for (var r = 0; r < this.length; r++) this.words[r] = 0;
                        var n, i, s = 0;
                        for (r = t.length - 6, n = 0; r >= e; r -= 6) i = o(t, r, r + 6), this.words[n] |= i << s & 67108863, this.words[n + 1] |= i >>> 26 - s & 4194303, s += 24, s >= 26 && (s -= 26, n++);
                        r + 6 !== e && (i = o(t, e, r + 6), this.words[n] |= i << s & 67108863, this.words[n + 1] |= i >>> 26 - s & 4194303), this.strip()
                    }, s.prototype._parseBase = function(t, e, r) {
                        this.words = [0], this.length = 1;
                        for (var n = 0, i = 1; i <= 67108863; i *= e) n++;
                        n--, i = i / e | 0;
                        for (var s = t.length - r, a = s % n, o = Math.min(s, s - a) + r, h = 0, f = r; f < o; f += n) h = u(t, f, f + n, e), this.imuln(i), this.words[0] + h < 67108864 ? this.words[0] += h : this._iaddn(h);
                        if (0 !== a) {
                            var c = 1;
                            for (h = u(t, f, t.length, e), f = 0; f < a; f++) c *= e;
                            this.imuln(c), this.words[0] + h < 67108864 ? this.words[0] += h : this._iaddn(h)
                        }
                    }, s.prototype.copy = function(t) {
                        t.words = new Array(this.length);
                        for (var e = 0; e < this.length; e++) t.words[e] = this.words[e];
                        t.length = this.length, t.negative = this.negative, t.red = this.red
                    }, s.prototype.clone = function() {
                        var t = new s(null);
                        return this.copy(t), t
                    }, s.prototype._expand = function(t) {
                        while (this.length < t) this.words[this.length++] = 0;
                        return this
                    }, s.prototype.strip = function() {
                        while (this.length > 1 && 0 === this.words[this.length - 1]) this.length--;
                        return this._normSign()
                    }, s.prototype._normSign = function() {
                        return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this
                    }, s.prototype.inspect = function() {
                        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
                    };
                    var h = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
                        f = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
                        c = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];

                    function l(t) {
                        for (var e = new Array(t.bitLength()), r = 0; r < e.length; r++) {
                            var n = r / 26 | 0,
                                i = r % 26;
                            e[r] = (t.words[n] & 1 << i) >>> i
                        }
                        return e
                    }

                    function d(t, e, r) {
                        r.negative = e.negative ^ t.negative;
                        var n = t.length + e.length | 0;
                        r.length = n, n = n - 1 | 0;
                        var i = 0 | t.words[0],
                            s = 0 | e.words[0],
                            a = i * s,
                            o = 67108863 & a,
                            u = a / 67108864 | 0;
                        r.words[0] = o;
                        for (var h = 1; h < n; h++) {
                            for (var f = u >>> 26, c = 67108863 & u, l = Math.min(h, e.length - 1), d = Math.max(0, h - t.length + 1); d <= l; d++) {
                                var p = h - d | 0;
                                i = 0 | t.words[p], s = 0 | e.words[d], a = i * s + c, f += a / 67108864 | 0, c = 67108863 & a
                            }
                            r.words[h] = 0 | c, u = 0 | f
                        }
                        return 0 !== u ? r.words[h] = 0 | u : r.length--, r.strip()
                    }
                    s.prototype.toString = function(t, e) {
                        var r;
                        if (t = t || 10, e = 0 | e || 1, 16 === t || "hex" === t) {
                            r = "";
                            for (var i = 0, s = 0, a = 0; a < this.length; a++) {
                                var o = this.words[a],
                                    u = (16777215 & (o << i | s)).toString(16);
                                s = o >>> 24 - i & 16777215, r = 0 !== s || a !== this.length - 1 ? h[6 - u.length] + u + r : u + r, i += 2, i >= 26 && (i -= 26, a--)
                            }
                            0 !== s && (r = s.toString(16) + r);
                            while (r.length % e !== 0) r = "0" + r;
                            return 0 !== this.negative && (r = "-" + r), r
                        }
                        if (t === (0 | t) && t >= 2 && t <= 36) {
                            var l = f[t],
                                d = c[t];
                            r = "";
                            var p = this.clone();
                            p.negative = 0;
                            while (!p.isZero()) {
                                var m = p.modn(d).toString(t);
                                p = p.idivn(d), r = p.isZero() ? m + r : h[l - m.length] + m + r
                            }
                            this.isZero() && (r = "0" + r);
                            while (r.length % e !== 0) r = "0" + r;
                            return 0 !== this.negative && (r = "-" + r), r
                        }
                        n(!1, "Base should be between 2 and 36")
                    }, s.prototype.toNumber = function() {
                        var t = this.words[0];
                        return 2 === this.length ? t += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? t += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), 0 !== this.negative ? -t : t
                    }, s.prototype.toJSON = function() {
                        return this.toString(16)
                    }, s.prototype.toBuffer = function(t, e) {
                        return n("undefined" !== typeof a), this.toArrayLike(a, t, e)
                    }, s.prototype.toArray = function(t, e) {
                        return this.toArrayLike(Array, t, e)
                    }, s.prototype.toArrayLike = function(t, e, r) {
                        var i = this.byteLength(),
                            s = r || Math.max(1, i);
                        n(i <= s, "byte array longer than desired length"), n(s > 0, "Requested array length <= 0"), this.strip();
                        var a, o, u = "le" === e,
                            h = new t(s),
                            f = this.clone();
                        if (u) {
                            for (o = 0; !f.isZero(); o++) a = f.andln(255), f.iushrn(8), h[o] = a;
                            for (; o < s; o++) h[o] = 0
                        } else {
                            for (o = 0; o < s - i; o++) h[o] = 0;
                            for (o = 0; !f.isZero(); o++) a = f.andln(255), f.iushrn(8), h[s - o - 1] = a
                        }
                        return h
                    }, Math.clz32 ? s.prototype._countBits = function(t) {
                        return 32 - Math.clz32(t)
                    } : s.prototype._countBits = function(t) {
                        var e = t,
                            r = 0;
                        return e >= 4096 && (r += 13, e >>>= 13), e >= 64 && (r += 7, e >>>= 7), e >= 8 && (r += 4, e >>>= 4), e >= 2 && (r += 2, e >>>= 2), r + e
                    }, s.prototype._zeroBits = function(t) {
                        if (0 === t) return 26;
                        var e = t,
                            r = 0;
                        return 0 === (8191 & e) && (r += 13, e >>>= 13), 0 === (127 & e) && (r += 7, e >>>= 7), 0 === (15 & e) && (r += 4, e >>>= 4), 0 === (3 & e) && (r += 2, e >>>= 2), 0 === (1 & e) && r++, r
                    }, s.prototype.bitLength = function() {
                        var t = this.words[this.length - 1],
                            e = this._countBits(t);
                        return 26 * (this.length - 1) + e
                    }, s.prototype.zeroBits = function() {
                        if (this.isZero()) return 0;
                        for (var t = 0, e = 0; e < this.length; e++) {
                            var r = this._zeroBits(this.words[e]);
                            if (t += r, 26 !== r) break
                        }
                        return t
                    }, s.prototype.byteLength = function() {
                        return Math.ceil(this.bitLength() / 8)
                    }, s.prototype.toTwos = function(t) {
                        return 0 !== this.negative ? this.abs().inotn(t).iaddn(1) : this.clone()
                    }, s.prototype.fromTwos = function(t) {
                        return this.testn(t - 1) ? this.notn(t).iaddn(1).ineg() : this.clone()
                    }, s.prototype.isNeg = function() {
                        return 0 !== this.negative
                    }, s.prototype.neg = function() {
                        return this.clone().ineg()
                    }, s.prototype.ineg = function() {
                        return this.isZero() || (this.negative ^= 1), this
                    }, s.prototype.iuor = function(t) {
                        while (this.length < t.length) this.words[this.length++] = 0;
                        for (var e = 0; e < t.length; e++) this.words[e] = this.words[e] | t.words[e];
                        return this.strip()
                    }, s.prototype.ior = function(t) {
                        return n(0 === (this.negative | t.negative)), this.iuor(t)
                    }, s.prototype.or = function(t) {
                        return this.length > t.length ? this.clone().ior(t) : t.clone().ior(this)
                    }, s.prototype.uor = function(t) {
                        return this.length > t.length ? this.clone().iuor(t) : t.clone().iuor(this)
                    }, s.prototype.iuand = function(t) {
                        var e;
                        e = this.length > t.length ? t : this;
                        for (var r = 0; r < e.length; r++) this.words[r] = this.words[r] & t.words[r];
                        return this.length = e.length, this.strip()
                    }, s.prototype.iand = function(t) {
                        return n(0 === (this.negative | t.negative)), this.iuand(t)
                    }, s.prototype.and = function(t) {
                        return this.length > t.length ? this.clone().iand(t) : t.clone().iand(this)
                    }, s.prototype.uand = function(t) {
                        return this.length > t.length ? this.clone().iuand(t) : t.clone().iuand(this)
                    }, s.prototype.iuxor = function(t) {
                        var e, r;
                        this.length > t.length ? (e = this, r = t) : (e = t, r = this);
                        for (var n = 0; n < r.length; n++) this.words[n] = e.words[n] ^ r.words[n];
                        if (this !== e)
                            for (; n < e.length; n++) this.words[n] = e.words[n];
                        return this.length = e.length, this.strip()
                    }, s.prototype.ixor = function(t) {
                        return n(0 === (this.negative | t.negative)), this.iuxor(t)
                    }, s.prototype.xor = function(t) {
                        return this.length > t.length ? this.clone().ixor(t) : t.clone().ixor(this)
                    }, s.prototype.uxor = function(t) {
                        return this.length > t.length ? this.clone().iuxor(t) : t.clone().iuxor(this)
                    }, s.prototype.inotn = function(t) {
                        n("number" === typeof t && t >= 0);
                        var e = 0 | Math.ceil(t / 26),
                            r = t % 26;
                        this._expand(e), r > 0 && e--;
                        for (var i = 0; i < e; i++) this.words[i] = 67108863 & ~this.words[i];
                        return r > 0 && (this.words[i] = ~this.words[i] & 67108863 >> 26 - r), this.strip()
                    }, s.prototype.notn = function(t) {
                        return this.clone().inotn(t)
                    }, s.prototype.setn = function(t, e) {
                        n("number" === typeof t && t >= 0);
                        var r = t / 26 | 0,
                            i = t % 26;
                        return this._expand(r + 1), this.words[r] = e ? this.words[r] | 1 << i : this.words[r] & ~(1 << i), this.strip()
                    }, s.prototype.iadd = function(t) {
                        var e, r, n;
                        if (0 !== this.negative && 0 === t.negative) return this.negative = 0, e = this.isub(t), this.negative ^= 1, this._normSign();
                        if (0 === this.negative && 0 !== t.negative) return t.negative = 0, e = this.isub(t), t.negative = 1, e._normSign();
                        this.length > t.length ? (r = this, n = t) : (r = t, n = this);
                        for (var i = 0, s = 0; s < n.length; s++) e = (0 | r.words[s]) + (0 | n.words[s]) + i, this.words[s] = 67108863 & e, i = e >>> 26;
                        for (; 0 !== i && s < r.length; s++) e = (0 | r.words[s]) + i, this.words[s] = 67108863 & e, i = e >>> 26;
                        if (this.length = r.length, 0 !== i) this.words[this.length] = i, this.length++;
                        else if (r !== this)
                            for (; s < r.length; s++) this.words[s] = r.words[s];
                        return this
                    }, s.prototype.add = function(t) {
                        var e;
                        return 0 !== t.negative && 0 === this.negative ? (t.negative = 0, e = this.sub(t), t.negative ^= 1, e) : 0 === t.negative && 0 !== this.negative ? (this.negative = 0, e = t.sub(this), this.negative = 1, e) : this.length > t.length ? this.clone().iadd(t) : t.clone().iadd(this)
                    }, s.prototype.isub = function(t) {
                        if (0 !== t.negative) {
                            t.negative = 0;
                            var e = this.iadd(t);
                            return t.negative = 1, e._normSign()
                        }
                        if (0 !== this.negative) return this.negative = 0, this.iadd(t), this.negative = 1, this._normSign();
                        var r, n, i = this.cmp(t);
                        if (0 === i) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
                        i > 0 ? (r = this, n = t) : (r = t, n = this);
                        for (var s = 0, a = 0; a < n.length; a++) e = (0 | r.words[a]) - (0 | n.words[a]) + s, s = e >> 26, this.words[a] = 67108863 & e;
                        for (; 0 !== s && a < r.length; a++) e = (0 | r.words[a]) + s, s = e >> 26, this.words[a] = 67108863 & e;
                        if (0 === s && a < r.length && r !== this)
                            for (; a < r.length; a++) this.words[a] = r.words[a];
                        return this.length = Math.max(this.length, a), r !== this && (this.negative = 1), this.strip()
                    }, s.prototype.sub = function(t) {
                        return this.clone().isub(t)
                    };
                    var p = function(t, e, r) {
                        var n, i, s, a = t.words,
                            o = e.words,
                            u = r.words,
                            h = 0,
                            f = 0 | a[0],
                            c = 8191 & f,
                            l = f >>> 13,
                            d = 0 | a[1],
                            p = 8191 & d,
                            m = d >>> 13,
                            b = 0 | a[2],
                            g = 8191 & b,
                            y = b >>> 13,
                            v = 0 | a[3],
                            w = 8191 & v,
                            _ = v >>> 13,
                            M = 0 | a[4],
                            A = 8191 & M,
                            S = M >>> 13,
                            x = 0 | a[5],
                            E = 8191 & x,
                            k = x >>> 13,
                            R = 0 | a[6],
                            O = 8191 & R,
                            I = R >>> 13,
                            P = 0 | a[7],
                            T = 8191 & P,
                            N = P >>> 13,
                            j = 0 | a[8],
                            C = 8191 & j,
                            z = j >>> 13,
                            D = 0 | a[9],
                            L = 8191 & D,
                            F = D >>> 13,
                            B = 0 | o[0],
                            $ = 8191 & B,
                            U = B >>> 13,
                            q = 0 | o[1],
                            K = 8191 & q,
                            V = q >>> 13,
                            W = 0 | o[2],
                            Z = 8191 & W,
                            H = W >>> 13,
                            G = 0 | o[3],
                            J = 8191 & G,
                            X = G >>> 13,
                            Y = 0 | o[4],
                            Q = 8191 & Y,
                            tt = Y >>> 13,
                            et = 0 | o[5],
                            rt = 8191 & et,
                            nt = et >>> 13,
                            it = 0 | o[6],
                            st = 8191 & it,
                            at = it >>> 13,
                            ot = 0 | o[7],
                            ut = 8191 & ot,
                            ht = ot >>> 13,
                            ft = 0 | o[8],
                            ct = 8191 & ft,
                            lt = ft >>> 13,
                            dt = 0 | o[9],
                            pt = 8191 & dt,
                            mt = dt >>> 13;
                        r.negative = t.negative ^ e.negative, r.length = 19, n = Math.imul(c, $), i = Math.imul(c, U), i = i + Math.imul(l, $) | 0, s = Math.imul(l, U);
                        var bt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, n = Math.imul(p, $), i = Math.imul(p, U), i = i + Math.imul(m, $) | 0, s = Math.imul(m, U), n = n + Math.imul(c, K) | 0, i = i + Math.imul(c, V) | 0, i = i + Math.imul(l, K) | 0, s = s + Math.imul(l, V) | 0;
                        var gt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (gt >>> 26) | 0, gt &= 67108863, n = Math.imul(g, $), i = Math.imul(g, U), i = i + Math.imul(y, $) | 0, s = Math.imul(y, U), n = n + Math.imul(p, K) | 0, i = i + Math.imul(p, V) | 0, i = i + Math.imul(m, K) | 0, s = s + Math.imul(m, V) | 0, n = n + Math.imul(c, Z) | 0, i = i + Math.imul(c, H) | 0, i = i + Math.imul(l, Z) | 0, s = s + Math.imul(l, H) | 0;
                        var yt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, n = Math.imul(w, $), i = Math.imul(w, U), i = i + Math.imul(_, $) | 0, s = Math.imul(_, U), n = n + Math.imul(g, K) | 0, i = i + Math.imul(g, V) | 0, i = i + Math.imul(y, K) | 0, s = s + Math.imul(y, V) | 0, n = n + Math.imul(p, Z) | 0, i = i + Math.imul(p, H) | 0, i = i + Math.imul(m, Z) | 0, s = s + Math.imul(m, H) | 0, n = n + Math.imul(c, J) | 0, i = i + Math.imul(c, X) | 0, i = i + Math.imul(l, J) | 0, s = s + Math.imul(l, X) | 0;
                        var vt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, n = Math.imul(A, $), i = Math.imul(A, U), i = i + Math.imul(S, $) | 0, s = Math.imul(S, U), n = n + Math.imul(w, K) | 0, i = i + Math.imul(w, V) | 0, i = i + Math.imul(_, K) | 0, s = s + Math.imul(_, V) | 0, n = n + Math.imul(g, Z) | 0, i = i + Math.imul(g, H) | 0, i = i + Math.imul(y, Z) | 0, s = s + Math.imul(y, H) | 0, n = n + Math.imul(p, J) | 0, i = i + Math.imul(p, X) | 0, i = i + Math.imul(m, J) | 0, s = s + Math.imul(m, X) | 0, n = n + Math.imul(c, Q) | 0, i = i + Math.imul(c, tt) | 0, i = i + Math.imul(l, Q) | 0, s = s + Math.imul(l, tt) | 0;
                        var wt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, n = Math.imul(E, $), i = Math.imul(E, U), i = i + Math.imul(k, $) | 0, s = Math.imul(k, U), n = n + Math.imul(A, K) | 0, i = i + Math.imul(A, V) | 0, i = i + Math.imul(S, K) | 0, s = s + Math.imul(S, V) | 0, n = n + Math.imul(w, Z) | 0, i = i + Math.imul(w, H) | 0, i = i + Math.imul(_, Z) | 0, s = s + Math.imul(_, H) | 0, n = n + Math.imul(g, J) | 0, i = i + Math.imul(g, X) | 0, i = i + Math.imul(y, J) | 0, s = s + Math.imul(y, X) | 0, n = n + Math.imul(p, Q) | 0, i = i + Math.imul(p, tt) | 0, i = i + Math.imul(m, Q) | 0, s = s + Math.imul(m, tt) | 0, n = n + Math.imul(c, rt) | 0, i = i + Math.imul(c, nt) | 0, i = i + Math.imul(l, rt) | 0, s = s + Math.imul(l, nt) | 0;
                        var _t = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, n = Math.imul(O, $), i = Math.imul(O, U), i = i + Math.imul(I, $) | 0, s = Math.imul(I, U), n = n + Math.imul(E, K) | 0, i = i + Math.imul(E, V) | 0, i = i + Math.imul(k, K) | 0, s = s + Math.imul(k, V) | 0, n = n + Math.imul(A, Z) | 0, i = i + Math.imul(A, H) | 0, i = i + Math.imul(S, Z) | 0, s = s + Math.imul(S, H) | 0, n = n + Math.imul(w, J) | 0, i = i + Math.imul(w, X) | 0, i = i + Math.imul(_, J) | 0, s = s + Math.imul(_, X) | 0, n = n + Math.imul(g, Q) | 0, i = i + Math.imul(g, tt) | 0, i = i + Math.imul(y, Q) | 0, s = s + Math.imul(y, tt) | 0, n = n + Math.imul(p, rt) | 0, i = i + Math.imul(p, nt) | 0, i = i + Math.imul(m, rt) | 0, s = s + Math.imul(m, nt) | 0, n = n + Math.imul(c, st) | 0, i = i + Math.imul(c, at) | 0, i = i + Math.imul(l, st) | 0, s = s + Math.imul(l, at) | 0;
                        var Mt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, n = Math.imul(T, $), i = Math.imul(T, U), i = i + Math.imul(N, $) | 0, s = Math.imul(N, U), n = n + Math.imul(O, K) | 0, i = i + Math.imul(O, V) | 0, i = i + Math.imul(I, K) | 0, s = s + Math.imul(I, V) | 0, n = n + Math.imul(E, Z) | 0, i = i + Math.imul(E, H) | 0, i = i + Math.imul(k, Z) | 0, s = s + Math.imul(k, H) | 0, n = n + Math.imul(A, J) | 0, i = i + Math.imul(A, X) | 0, i = i + Math.imul(S, J) | 0, s = s + Math.imul(S, X) | 0, n = n + Math.imul(w, Q) | 0, i = i + Math.imul(w, tt) | 0, i = i + Math.imul(_, Q) | 0, s = s + Math.imul(_, tt) | 0, n = n + Math.imul(g, rt) | 0, i = i + Math.imul(g, nt) | 0, i = i + Math.imul(y, rt) | 0, s = s + Math.imul(y, nt) | 0, n = n + Math.imul(p, st) | 0, i = i + Math.imul(p, at) | 0, i = i + Math.imul(m, st) | 0, s = s + Math.imul(m, at) | 0, n = n + Math.imul(c, ut) | 0, i = i + Math.imul(c, ht) | 0, i = i + Math.imul(l, ut) | 0, s = s + Math.imul(l, ht) | 0;
                        var At = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, n = Math.imul(C, $), i = Math.imul(C, U), i = i + Math.imul(z, $) | 0, s = Math.imul(z, U), n = n + Math.imul(T, K) | 0, i = i + Math.imul(T, V) | 0, i = i + Math.imul(N, K) | 0, s = s + Math.imul(N, V) | 0, n = n + Math.imul(O, Z) | 0, i = i + Math.imul(O, H) | 0, i = i + Math.imul(I, Z) | 0, s = s + Math.imul(I, H) | 0, n = n + Math.imul(E, J) | 0, i = i + Math.imul(E, X) | 0, i = i + Math.imul(k, J) | 0, s = s + Math.imul(k, X) | 0, n = n + Math.imul(A, Q) | 0, i = i + Math.imul(A, tt) | 0, i = i + Math.imul(S, Q) | 0, s = s + Math.imul(S, tt) | 0, n = n + Math.imul(w, rt) | 0, i = i + Math.imul(w, nt) | 0, i = i + Math.imul(_, rt) | 0, s = s + Math.imul(_, nt) | 0, n = n + Math.imul(g, st) | 0, i = i + Math.imul(g, at) | 0, i = i + Math.imul(y, st) | 0, s = s + Math.imul(y, at) | 0, n = n + Math.imul(p, ut) | 0, i = i + Math.imul(p, ht) | 0, i = i + Math.imul(m, ut) | 0, s = s + Math.imul(m, ht) | 0, n = n + Math.imul(c, ct) | 0, i = i + Math.imul(c, lt) | 0, i = i + Math.imul(l, ct) | 0, s = s + Math.imul(l, lt) | 0;
                        var St = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, n = Math.imul(L, $), i = Math.imul(L, U), i = i + Math.imul(F, $) | 0, s = Math.imul(F, U), n = n + Math.imul(C, K) | 0, i = i + Math.imul(C, V) | 0, i = i + Math.imul(z, K) | 0, s = s + Math.imul(z, V) | 0, n = n + Math.imul(T, Z) | 0, i = i + Math.imul(T, H) | 0, i = i + Math.imul(N, Z) | 0, s = s + Math.imul(N, H) | 0, n = n + Math.imul(O, J) | 0, i = i + Math.imul(O, X) | 0, i = i + Math.imul(I, J) | 0, s = s + Math.imul(I, X) | 0, n = n + Math.imul(E, Q) | 0, i = i + Math.imul(E, tt) | 0, i = i + Math.imul(k, Q) | 0, s = s + Math.imul(k, tt) | 0, n = n + Math.imul(A, rt) | 0, i = i + Math.imul(A, nt) | 0, i = i + Math.imul(S, rt) | 0, s = s + Math.imul(S, nt) | 0, n = n + Math.imul(w, st) | 0, i = i + Math.imul(w, at) | 0, i = i + Math.imul(_, st) | 0, s = s + Math.imul(_, at) | 0, n = n + Math.imul(g, ut) | 0, i = i + Math.imul(g, ht) | 0, i = i + Math.imul(y, ut) | 0, s = s + Math.imul(y, ht) | 0, n = n + Math.imul(p, ct) | 0, i = i + Math.imul(p, lt) | 0, i = i + Math.imul(m, ct) | 0, s = s + Math.imul(m, lt) | 0, n = n + Math.imul(c, pt) | 0, i = i + Math.imul(c, mt) | 0, i = i + Math.imul(l, pt) | 0, s = s + Math.imul(l, mt) | 0;
                        var xt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, n = Math.imul(L, K), i = Math.imul(L, V), i = i + Math.imul(F, K) | 0, s = Math.imul(F, V), n = n + Math.imul(C, Z) | 0, i = i + Math.imul(C, H) | 0, i = i + Math.imul(z, Z) | 0, s = s + Math.imul(z, H) | 0, n = n + Math.imul(T, J) | 0, i = i + Math.imul(T, X) | 0, i = i + Math.imul(N, J) | 0, s = s + Math.imul(N, X) | 0, n = n + Math.imul(O, Q) | 0, i = i + Math.imul(O, tt) | 0, i = i + Math.imul(I, Q) | 0, s = s + Math.imul(I, tt) | 0, n = n + Math.imul(E, rt) | 0, i = i + Math.imul(E, nt) | 0, i = i + Math.imul(k, rt) | 0, s = s + Math.imul(k, nt) | 0, n = n + Math.imul(A, st) | 0, i = i + Math.imul(A, at) | 0, i = i + Math.imul(S, st) | 0, s = s + Math.imul(S, at) | 0, n = n + Math.imul(w, ut) | 0, i = i + Math.imul(w, ht) | 0, i = i + Math.imul(_, ut) | 0, s = s + Math.imul(_, ht) | 0, n = n + Math.imul(g, ct) | 0, i = i + Math.imul(g, lt) | 0, i = i + Math.imul(y, ct) | 0, s = s + Math.imul(y, lt) | 0, n = n + Math.imul(p, pt) | 0, i = i + Math.imul(p, mt) | 0, i = i + Math.imul(m, pt) | 0, s = s + Math.imul(m, mt) | 0;
                        var Et = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, n = Math.imul(L, Z), i = Math.imul(L, H), i = i + Math.imul(F, Z) | 0, s = Math.imul(F, H), n = n + Math.imul(C, J) | 0, i = i + Math.imul(C, X) | 0, i = i + Math.imul(z, J) | 0, s = s + Math.imul(z, X) | 0, n = n + Math.imul(T, Q) | 0, i = i + Math.imul(T, tt) | 0, i = i + Math.imul(N, Q) | 0, s = s + Math.imul(N, tt) | 0, n = n + Math.imul(O, rt) | 0, i = i + Math.imul(O, nt) | 0, i = i + Math.imul(I, rt) | 0, s = s + Math.imul(I, nt) | 0, n = n + Math.imul(E, st) | 0, i = i + Math.imul(E, at) | 0, i = i + Math.imul(k, st) | 0, s = s + Math.imul(k, at) | 0, n = n + Math.imul(A, ut) | 0, i = i + Math.imul(A, ht) | 0, i = i + Math.imul(S, ut) | 0, s = s + Math.imul(S, ht) | 0, n = n + Math.imul(w, ct) | 0, i = i + Math.imul(w, lt) | 0, i = i + Math.imul(_, ct) | 0, s = s + Math.imul(_, lt) | 0, n = n + Math.imul(g, pt) | 0, i = i + Math.imul(g, mt) | 0, i = i + Math.imul(y, pt) | 0, s = s + Math.imul(y, mt) | 0;
                        var kt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, n = Math.imul(L, J), i = Math.imul(L, X), i = i + Math.imul(F, J) | 0, s = Math.imul(F, X), n = n + Math.imul(C, Q) | 0, i = i + Math.imul(C, tt) | 0, i = i + Math.imul(z, Q) | 0, s = s + Math.imul(z, tt) | 0, n = n + Math.imul(T, rt) | 0, i = i + Math.imul(T, nt) | 0, i = i + Math.imul(N, rt) | 0, s = s + Math.imul(N, nt) | 0, n = n + Math.imul(O, st) | 0, i = i + Math.imul(O, at) | 0, i = i + Math.imul(I, st) | 0, s = s + Math.imul(I, at) | 0, n = n + Math.imul(E, ut) | 0, i = i + Math.imul(E, ht) | 0, i = i + Math.imul(k, ut) | 0, s = s + Math.imul(k, ht) | 0, n = n + Math.imul(A, ct) | 0, i = i + Math.imul(A, lt) | 0, i = i + Math.imul(S, ct) | 0, s = s + Math.imul(S, lt) | 0, n = n + Math.imul(w, pt) | 0, i = i + Math.imul(w, mt) | 0, i = i + Math.imul(_, pt) | 0, s = s + Math.imul(_, mt) | 0;
                        var Rt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, n = Math.imul(L, Q), i = Math.imul(L, tt), i = i + Math.imul(F, Q) | 0, s = Math.imul(F, tt), n = n + Math.imul(C, rt) | 0, i = i + Math.imul(C, nt) | 0, i = i + Math.imul(z, rt) | 0, s = s + Math.imul(z, nt) | 0, n = n + Math.imul(T, st) | 0, i = i + Math.imul(T, at) | 0, i = i + Math.imul(N, st) | 0, s = s + Math.imul(N, at) | 0, n = n + Math.imul(O, ut) | 0, i = i + Math.imul(O, ht) | 0, i = i + Math.imul(I, ut) | 0, s = s + Math.imul(I, ht) | 0, n = n + Math.imul(E, ct) | 0, i = i + Math.imul(E, lt) | 0, i = i + Math.imul(k, ct) | 0, s = s + Math.imul(k, lt) | 0, n = n + Math.imul(A, pt) | 0, i = i + Math.imul(A, mt) | 0, i = i + Math.imul(S, pt) | 0, s = s + Math.imul(S, mt) | 0;
                        var Ot = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, n = Math.imul(L, rt), i = Math.imul(L, nt), i = i + Math.imul(F, rt) | 0, s = Math.imul(F, nt), n = n + Math.imul(C, st) | 0, i = i + Math.imul(C, at) | 0, i = i + Math.imul(z, st) | 0, s = s + Math.imul(z, at) | 0, n = n + Math.imul(T, ut) | 0, i = i + Math.imul(T, ht) | 0, i = i + Math.imul(N, ut) | 0, s = s + Math.imul(N, ht) | 0, n = n + Math.imul(O, ct) | 0, i = i + Math.imul(O, lt) | 0, i = i + Math.imul(I, ct) | 0, s = s + Math.imul(I, lt) | 0, n = n + Math.imul(E, pt) | 0, i = i + Math.imul(E, mt) | 0, i = i + Math.imul(k, pt) | 0, s = s + Math.imul(k, mt) | 0;
                        var It = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, n = Math.imul(L, st), i = Math.imul(L, at), i = i + Math.imul(F, st) | 0, s = Math.imul(F, at), n = n + Math.imul(C, ut) | 0, i = i + Math.imul(C, ht) | 0, i = i + Math.imul(z, ut) | 0, s = s + Math.imul(z, ht) | 0, n = n + Math.imul(T, ct) | 0, i = i + Math.imul(T, lt) | 0, i = i + Math.imul(N, ct) | 0, s = s + Math.imul(N, lt) | 0, n = n + Math.imul(O, pt) | 0, i = i + Math.imul(O, mt) | 0, i = i + Math.imul(I, pt) | 0, s = s + Math.imul(I, mt) | 0;
                        var Pt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, n = Math.imul(L, ut), i = Math.imul(L, ht), i = i + Math.imul(F, ut) | 0, s = Math.imul(F, ht), n = n + Math.imul(C, ct) | 0, i = i + Math.imul(C, lt) | 0, i = i + Math.imul(z, ct) | 0, s = s + Math.imul(z, lt) | 0, n = n + Math.imul(T, pt) | 0, i = i + Math.imul(T, mt) | 0, i = i + Math.imul(N, pt) | 0, s = s + Math.imul(N, mt) | 0;
                        var Tt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, n = Math.imul(L, ct), i = Math.imul(L, lt), i = i + Math.imul(F, ct) | 0, s = Math.imul(F, lt), n = n + Math.imul(C, pt) | 0, i = i + Math.imul(C, mt) | 0, i = i + Math.imul(z, pt) | 0, s = s + Math.imul(z, mt) | 0;
                        var Nt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, n = Math.imul(L, pt), i = Math.imul(L, mt), i = i + Math.imul(F, pt) | 0, s = Math.imul(F, mt);
                        var jt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        return h = (s + (i >>> 13) | 0) + (jt >>> 26) | 0, jt &= 67108863, u[0] = bt, u[1] = gt, u[2] = yt, u[3] = vt, u[4] = wt, u[5] = _t, u[6] = Mt, u[7] = At, u[8] = St, u[9] = xt, u[10] = Et, u[11] = kt, u[12] = Rt, u[13] = Ot, u[14] = It, u[15] = Pt, u[16] = Tt, u[17] = Nt, u[18] = jt, 0 !== h && (u[19] = h, r.length++), r
                    };

                    function m(t, e, r) {
                        r.negative = e.negative ^ t.negative, r.length = t.length + e.length;
                        for (var n = 0, i = 0, s = 0; s < r.length - 1; s++) {
                            var a = i;
                            i = 0;
                            for (var o = 67108863 & n, u = Math.min(s, e.length - 1), h = Math.max(0, s - t.length + 1); h <= u; h++) {
                                var f = s - h,
                                    c = 0 | t.words[f],
                                    l = 0 | e.words[h],
                                    d = c * l,
                                    p = 67108863 & d;
                                a = a + (d / 67108864 | 0) | 0, p = p + o | 0, o = 67108863 & p, a = a + (p >>> 26) | 0, i += a >>> 26, a &= 67108863
                            }
                            r.words[s] = o, n = a, a = i
                        }
                        return 0 !== n ? r.words[s] = n : r.length--, r.strip()
                    }

                    function b(t, e, r) {
                        var n = new g;
                        return n.mulp(t, e, r)
                    }

                    function g(t, e) {
                        this.x = t, this.y = e
                    }
                    Math.imul || (p = d), s.prototype.mulTo = function(t, e) {
                        var r, n = this.length + t.length;
                        return r = 10 === this.length && 10 === t.length ? p(this, t, e) : n < 63 ? d(this, t, e) : n < 1024 ? m(this, t, e) : b(this, t, e), r
                    }, g.prototype.makeRBT = function(t) {
                        for (var e = new Array(t), r = s.prototype._countBits(t) - 1, n = 0; n < t; n++) e[n] = this.revBin(n, r, t);
                        return e
                    }, g.prototype.revBin = function(t, e, r) {
                        if (0 === t || t === r - 1) return t;
                        for (var n = 0, i = 0; i < e; i++) n |= (1 & t) << e - i - 1, t >>= 1;
                        return n
                    }, g.prototype.permute = function(t, e, r, n, i, s) {
                        for (var a = 0; a < s; a++) n[a] = e[t[a]], i[a] = r[t[a]]
                    }, g.prototype.transform = function(t, e, r, n, i, s) {
                        this.permute(s, t, e, r, n, i);
                        for (var a = 1; a < i; a <<= 1)
                            for (var o = a << 1, u = Math.cos(2 * Math.PI / o), h = Math.sin(2 * Math.PI / o), f = 0; f < i; f += o)
                                for (var c = u, l = h, d = 0; d < a; d++) {
                                    var p = r[f + d],
                                        m = n[f + d],
                                        b = r[f + d + a],
                                        g = n[f + d + a],
                                        y = c * b - l * g;
                                    g = c * g + l * b, b = y, r[f + d] = p + b, n[f + d] = m + g, r[f + d + a] = p - b, n[f + d + a] = m - g, d !== o && (y = u * c - h * l, l = u * l + h * c, c = y)
                                }
                    }, g.prototype.guessLen13b = function(t, e) {
                        var r = 1 | Math.max(e, t),
                            n = 1 & r,
                            i = 0;
                        for (r = r / 2 | 0; r; r >>>= 1) i++;
                        return 1 << i + 1 + n
                    }, g.prototype.conjugate = function(t, e, r) {
                        if (!(r <= 1))
                            for (var n = 0; n < r / 2; n++) {
                                var i = t[n];
                                t[n] = t[r - n - 1], t[r - n - 1] = i, i = e[n], e[n] = -e[r - n - 1], e[r - n - 1] = -i
                            }
                    }, g.prototype.normalize13b = function(t, e) {
                        for (var r = 0, n = 0; n < e / 2; n++) {
                            var i = 8192 * Math.round(t[2 * n + 1] / e) + Math.round(t[2 * n] / e) + r;
                            t[n] = 67108863 & i, r = i < 67108864 ? 0 : i / 67108864 | 0
                        }
                        return t
                    }, g.prototype.convert13b = function(t, e, r, i) {
                        for (var s = 0, a = 0; a < e; a++) s += 0 | t[a], r[2 * a] = 8191 & s, s >>>= 13, r[2 * a + 1] = 8191 & s, s >>>= 13;
                        for (a = 2 * e; a < i; ++a) r[a] = 0;
                        n(0 === s), n(0 === (-8192 & s))
                    }, g.prototype.stub = function(t) {
                        for (var e = new Array(t), r = 0; r < t; r++) e[r] = 0;
                        return e
                    }, g.prototype.mulp = function(t, e, r) {
                        var n = 2 * this.guessLen13b(t.length, e.length),
                            i = this.makeRBT(n),
                            s = this.stub(n),
                            a = new Array(n),
                            o = new Array(n),
                            u = new Array(n),
                            h = new Array(n),
                            f = new Array(n),
                            c = new Array(n),
                            l = r.words;
                        l.length = n, this.convert13b(t.words, t.length, a, n), this.convert13b(e.words, e.length, h, n), this.transform(a, s, o, u, n, i), this.transform(h, s, f, c, n, i);
                        for (var d = 0; d < n; d++) {
                            var p = o[d] * f[d] - u[d] * c[d];
                            u[d] = o[d] * c[d] + u[d] * f[d], o[d] = p
                        }
                        return this.conjugate(o, u, n), this.transform(o, u, l, s, n, i), this.conjugate(l, s, n), this.normalize13b(l, n), r.negative = t.negative ^ e.negative, r.length = t.length + e.length, r.strip()
                    }, s.prototype.mul = function(t) {
                        var e = new s(null);
                        return e.words = new Array(this.length + t.length), this.mulTo(t, e)
                    }, s.prototype.mulf = function(t) {
                        var e = new s(null);
                        return e.words = new Array(this.length + t.length), b(this, t, e)
                    }, s.prototype.imul = function(t) {
                        return this.clone().mulTo(t, this)
                    }, s.prototype.imuln = function(t) {
                        n("number" === typeof t), n(t < 67108864);
                        for (var e = 0, r = 0; r < this.length; r++) {
                            var i = (0 | this.words[r]) * t,
                                s = (67108863 & i) + (67108863 & e);
                            e >>= 26, e += i / 67108864 | 0, e += s >>> 26, this.words[r] = 67108863 & s
                        }
                        return 0 !== e && (this.words[r] = e, this.length++), this
                    }, s.prototype.muln = function(t) {
                        return this.clone().imuln(t)
                    }, s.prototype.sqr = function() {
                        return this.mul(this)
                    }, s.prototype.isqr = function() {
                        return this.imul(this.clone())
                    }, s.prototype.pow = function(t) {
                        var e = l(t);
                        if (0 === e.length) return new s(1);
                        for (var r = this, n = 0; n < e.length; n++, r = r.sqr())
                            if (0 !== e[n]) break;
                        if (++n < e.length)
                            for (var i = r.sqr(); n < e.length; n++, i = i.sqr()) 0 !== e[n] && (r = r.mul(i));
                        return r
                    }, s.prototype.iushln = function(t) {
                        n("number" === typeof t && t >= 0);
                        var e, r = t % 26,
                            i = (t - r) / 26,
                            s = 67108863 >>> 26 - r << 26 - r;
                        if (0 !== r) {
                            var a = 0;
                            for (e = 0; e < this.length; e++) {
                                var o = this.words[e] & s,
                                    u = (0 | this.words[e]) - o << r;
                                this.words[e] = u | a, a = o >>> 26 - r
                            }
                            a && (this.words[e] = a, this.length++)
                        }
                        if (0 !== i) {
                            for (e = this.length - 1; e >= 0; e--) this.words[e + i] = this.words[e];
                            for (e = 0; e < i; e++) this.words[e] = 0;
                            this.length += i
                        }
                        return this.strip()
                    }, s.prototype.ishln = function(t) {
                        return n(0 === this.negative), this.iushln(t)
                    }, s.prototype.iushrn = function(t, e, r) {
                        var i;
                        n("number" === typeof t && t >= 0), i = e ? (e - e % 26) / 26 : 0;
                        var s = t % 26,
                            a = Math.min((t - s) / 26, this.length),
                            o = 67108863 ^ 67108863 >>> s << s,
                            u = r;
                        if (i -= a, i = Math.max(0, i), u) {
                            for (var h = 0; h < a; h++) u.words[h] = this.words[h];
                            u.length = a
                        }
                        if (0 === a);
                        else if (this.length > a)
                            for (this.length -= a, h = 0; h < this.length; h++) this.words[h] = this.words[h + a];
                        else this.words[0] = 0, this.length = 1;
                        var f = 0;
                        for (h = this.length - 1; h >= 0 && (0 !== f || h >= i); h--) {
                            var c = 0 | this.words[h];
                            this.words[h] = f << 26 - s | c >>> s, f = c & o
                        }
                        return u && 0 !== f && (u.words[u.length++] = f), 0 === this.length && (this.words[0] = 0, this.length = 1), this.strip()
                    }, s.prototype.ishrn = function(t, e, r) {
                        return n(0 === this.negative), this.iushrn(t, e, r)
                    }, s.prototype.shln = function(t) {
                        return this.clone().ishln(t)
                    }, s.prototype.ushln = function(t) {
                        return this.clone().iushln(t)
                    }, s.prototype.shrn = function(t) {
                        return this.clone().ishrn(t)
                    }, s.prototype.ushrn = function(t) {
                        return this.clone().iushrn(t)
                    }, s.prototype.testn = function(t) {
                        n("number" === typeof t && t >= 0);
                        var e = t % 26,
                            r = (t - e) / 26,
                            i = 1 << e;
                        if (this.length <= r) return !1;
                        var s = this.words[r];
                        return !!(s & i)
                    }, s.prototype.imaskn = function(t) {
                        n("number" === typeof t && t >= 0);
                        var e = t % 26,
                            r = (t - e) / 26;
                        if (n(0 === this.negative, "imaskn works only with positive numbers"), this.length <= r) return this;
                        if (0 !== e && r++, this.length = Math.min(r, this.length), 0 !== e) {
                            var i = 67108863 ^ 67108863 >>> e << e;
                            this.words[this.length - 1] &= i
                        }
                        return this.strip()
                    }, s.prototype.maskn = function(t) {
                        return this.clone().imaskn(t)
                    }, s.prototype.iaddn = function(t) {
                        return n("number" === typeof t), n(t < 67108864), t < 0 ? this.isubn(-t) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) < t ? (this.words[0] = t - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(t), this.negative = 1, this) : this._iaddn(t)
                    }, s.prototype._iaddn = function(t) {
                        this.words[0] += t;
                        for (var e = 0; e < this.length && this.words[e] >= 67108864; e++) this.words[e] -= 67108864, e === this.length - 1 ? this.words[e + 1] = 1 : this.words[e + 1]++;
                        return this.length = Math.max(this.length, e + 1), this
                    }, s.prototype.isubn = function(t) {
                        if (n("number" === typeof t), n(t < 67108864), t < 0) return this.iaddn(-t);
                        if (0 !== this.negative) return this.negative = 0, this.iaddn(t), this.negative = 1, this;
                        if (this.words[0] -= t, 1 === this.length && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
                        else
                            for (var e = 0; e < this.length && this.words[e] < 0; e++) this.words[e] += 67108864, this.words[e + 1] -= 1;
                        return this.strip()
                    }, s.prototype.addn = function(t) {
                        return this.clone().iaddn(t)
                    }, s.prototype.subn = function(t) {
                        return this.clone().isubn(t)
                    }, s.prototype.iabs = function() {
                        return this.negative = 0, this
                    }, s.prototype.abs = function() {
                        return this.clone().iabs()
                    }, s.prototype._ishlnsubmul = function(t, e, r) {
                        var i, s, a = t.length + r;
                        this._expand(a);
                        var o = 0;
                        for (i = 0; i < t.length; i++) {
                            s = (0 | this.words[i + r]) + o;
                            var u = (0 | t.words[i]) * e;
                            s -= 67108863 & u, o = (s >> 26) - (u / 67108864 | 0), this.words[i + r] = 67108863 & s
                        }
                        for (; i < this.length - r; i++) s = (0 | this.words[i + r]) + o, o = s >> 26, this.words[i + r] = 67108863 & s;
                        if (0 === o) return this.strip();
                        for (n(-1 === o), o = 0, i = 0; i < this.length; i++) s = -(0 | this.words[i]) + o, o = s >> 26, this.words[i] = 67108863 & s;
                        return this.negative = 1, this.strip()
                    }, s.prototype._wordDiv = function(t, e) {
                        var r = this.length - t.length,
                            n = this.clone(),
                            i = t,
                            a = 0 | i.words[i.length - 1],
                            o = this._countBits(a);
                        r = 26 - o, 0 !== r && (i = i.ushln(r), n.iushln(r), a = 0 | i.words[i.length - 1]);
                        var u, h = n.length - i.length;
                        if ("mod" !== e) {
                            u = new s(null), u.length = h + 1, u.words = new Array(u.length);
                            for (var f = 0; f < u.length; f++) u.words[f] = 0
                        }
                        var c = n.clone()._ishlnsubmul(i, 1, h);
                        0 === c.negative && (n = c, u && (u.words[h] = 1));
                        for (var l = h - 1; l >= 0; l--) {
                            var d = 67108864 * (0 | n.words[i.length + l]) + (0 | n.words[i.length + l - 1]);
                            d = Math.min(d / a | 0, 67108863), n._ishlnsubmul(i, d, l);
                            while (0 !== n.negative) d--, n.negative = 0, n._ishlnsubmul(i, 1, l), n.isZero() || (n.negative ^= 1);
                            u && (u.words[l] = d)
                        }
                        return u && u.strip(), n.strip(), "div" !== e && 0 !== r && n.iushrn(r), {
                            div: u || null,
                            mod: n
                        }
                    }, s.prototype.divmod = function(t, e, r) {
                        return n(!t.isZero()), this.isZero() ? {
                            div: new s(0),
                            mod: new s(0)
                        } : 0 !== this.negative && 0 === t.negative ? (o = this.neg().divmod(t, e), "mod" !== e && (i = o.div.neg()), "div" !== e && (a = o.mod.neg(), r && 0 !== a.negative && a.iadd(t)), {
                            div: i,
                            mod: a
                        }) : 0 === this.negative && 0 !== t.negative ? (o = this.divmod(t.neg(), e), "mod" !== e && (i = o.div.neg()), {
                            div: i,
                            mod: o.mod
                        }) : 0 !== (this.negative & t.negative) ? (o = this.neg().divmod(t.neg(), e), "div" !== e && (a = o.mod.neg(), r && 0 !== a.negative && a.isub(t)), {
                            div: o.div,
                            mod: a
                        }) : t.length > this.length || this.cmp(t) < 0 ? {
                            div: new s(0),
                            mod: this
                        } : 1 === t.length ? "div" === e ? {
                            div: this.divn(t.words[0]),
                            mod: null
                        } : "mod" === e ? {
                            div: null,
                            mod: new s(this.modn(t.words[0]))
                        } : {
                            div: this.divn(t.words[0]),
                            mod: new s(this.modn(t.words[0]))
                        } : this._wordDiv(t, e);
                        var i, a, o
                    }, s.prototype.div = function(t) {
                        return this.divmod(t, "div", !1).div
                    }, s.prototype.mod = function(t) {
                        return this.divmod(t, "mod", !1).mod
                    }, s.prototype.umod = function(t) {
                        return this.divmod(t, "mod", !0).mod
                    }, s.prototype.divRound = function(t) {
                        var e = this.divmod(t);
                        if (e.mod.isZero()) return e.div;
                        var r = 0 !== e.div.negative ? e.mod.isub(t) : e.mod,
                            n = t.ushrn(1),
                            i = t.andln(1),
                            s = r.cmp(n);
                        return s < 0 || 1 === i && 0 === s ? e.div : 0 !== e.div.negative ? e.div.isubn(1) : e.div.iaddn(1)
                    }, s.prototype.modn = function(t) {
                        n(t <= 67108863);
                        for (var e = (1 << 26) % t, r = 0, i = this.length - 1; i >= 0; i--) r = (e * r + (0 | this.words[i])) % t;
                        return r
                    }, s.prototype.idivn = function(t) {
                        n(t <= 67108863);
                        for (var e = 0, r = this.length - 1; r >= 0; r--) {
                            var i = (0 | this.words[r]) + 67108864 * e;
                            this.words[r] = i / t | 0, e = i % t
                        }
                        return this.strip()
                    }, s.prototype.divn = function(t) {
                        return this.clone().idivn(t)
                    }, s.prototype.egcd = function(t) {
                        n(0 === t.negative), n(!t.isZero());
                        var e = this,
                            r = t.clone();
                        e = 0 !== e.negative ? e.umod(t) : e.clone();
                        var i = new s(1),
                            a = new s(0),
                            o = new s(0),
                            u = new s(1),
                            h = 0;
                        while (e.isEven() && r.isEven()) e.iushrn(1), r.iushrn(1), ++h;
                        var f = r.clone(),
                            c = e.clone();
                        while (!e.isZero()) {
                            for (var l = 0, d = 1; 0 === (e.words[0] & d) && l < 26; ++l, d <<= 1);
                            if (l > 0) {
                                e.iushrn(l);
                                while (l-- > 0)(i.isOdd() || a.isOdd()) && (i.iadd(f), a.isub(c)), i.iushrn(1), a.iushrn(1)
                            }
                            for (var p = 0, m = 1; 0 === (r.words[0] & m) && p < 26; ++p, m <<= 1);
                            if (p > 0) {
                                r.iushrn(p);
                                while (p-- > 0)(o.isOdd() || u.isOdd()) && (o.iadd(f), u.isub(c)), o.iushrn(1), u.iushrn(1)
                            }
                            e.cmp(r) >= 0 ? (e.isub(r), i.isub(o), a.isub(u)) : (r.isub(e), o.isub(i), u.isub(a))
                        }
                        return {
                            a: o,
                            b: u,
                            gcd: r.iushln(h)
                        }
                    }, s.prototype._invmp = function(t) {
                        n(0 === t.negative), n(!t.isZero());
                        var e = this,
                            r = t.clone();
                        e = 0 !== e.negative ? e.umod(t) : e.clone();
                        var i, a = new s(1),
                            o = new s(0),
                            u = r.clone();
                        while (e.cmpn(1) > 0 && r.cmpn(1) > 0) {
                            for (var h = 0, f = 1; 0 === (e.words[0] & f) && h < 26; ++h, f <<= 1);
                            if (h > 0) {
                                e.iushrn(h);
                                while (h-- > 0) a.isOdd() && a.iadd(u), a.iushrn(1)
                            }
                            for (var c = 0, l = 1; 0 === (r.words[0] & l) && c < 26; ++c, l <<= 1);
                            if (c > 0) {
                                r.iushrn(c);
                                while (c-- > 0) o.isOdd() && o.iadd(u), o.iushrn(1)
                            }
                            e.cmp(r) >= 0 ? (e.isub(r), a.isub(o)) : (r.isub(e), o.isub(a))
                        }
                        return i = 0 === e.cmpn(1) ? a : o, i.cmpn(0) < 0 && i.iadd(t), i
                    }, s.prototype.gcd = function(t) {
                        if (this.isZero()) return t.abs();
                        if (t.isZero()) return this.abs();
                        var e = this.clone(),
                            r = t.clone();
                        e.negative = 0, r.negative = 0;
                        for (var n = 0; e.isEven() && r.isEven(); n++) e.iushrn(1), r.iushrn(1);
                        do {
                            while (e.isEven()) e.iushrn(1);
                            while (r.isEven()) r.iushrn(1);
                            var i = e.cmp(r);
                            if (i < 0) {
                                var s = e;
                                e = r, r = s
                            } else if (0 === i || 0 === r.cmpn(1)) break;
                            e.isub(r)
                        } while (1);
                        return r.iushln(n)
                    }, s.prototype.invm = function(t) {
                        return this.egcd(t).a.umod(t)
                    }, s.prototype.isEven = function() {
                        return 0 === (1 & this.words[0])
                    }, s.prototype.isOdd = function() {
                        return 1 === (1 & this.words[0])
                    }, s.prototype.andln = function(t) {
                        return this.words[0] & t
                    }, s.prototype.bincn = function(t) {
                        n("number" === typeof t);
                        var e = t % 26,
                            r = (t - e) / 26,
                            i = 1 << e;
                        if (this.length <= r) return this._expand(r + 1), this.words[r] |= i, this;
                        for (var s = i, a = r; 0 !== s && a < this.length; a++) {
                            var o = 0 | this.words[a];
                            o += s, s = o >>> 26, o &= 67108863, this.words[a] = o
                        }
                        return 0 !== s && (this.words[a] = s, this.length++), this
                    }, s.prototype.isZero = function() {
                        return 1 === this.length && 0 === this.words[0]
                    }, s.prototype.cmpn = function(t) {
                        var e, r = t < 0;
                        if (0 !== this.negative && !r) return -1;
                        if (0 === this.negative && r) return 1;
                        if (this.strip(), this.length > 1) e = 1;
                        else {
                            r && (t = -t), n(t <= 67108863, "Number is too big");
                            var i = 0 | this.words[0];
                            e = i === t ? 0 : i < t ? -1 : 1
                        }
                        return 0 !== this.negative ? 0 | -e : e
                    }, s.prototype.cmp = function(t) {
                        if (0 !== this.negative && 0 === t.negative) return -1;
                        if (0 === this.negative && 0 !== t.negative) return 1;
                        var e = this.ucmp(t);
                        return 0 !== this.negative ? 0 | -e : e
                    }, s.prototype.ucmp = function(t) {
                        if (this.length > t.length) return 1;
                        if (this.length < t.length) return -1;
                        for (var e = 0, r = this.length - 1; r >= 0; r--) {
                            var n = 0 | this.words[r],
                                i = 0 | t.words[r];
                            if (n !== i) {
                                n < i ? e = -1 : n > i && (e = 1);
                                break
                            }
                        }
                        return e
                    }, s.prototype.gtn = function(t) {
                        return 1 === this.cmpn(t)
                    }, s.prototype.gt = function(t) {
                        return 1 === this.cmp(t)
                    }, s.prototype.gten = function(t) {
                        return this.cmpn(t) >= 0
                    }, s.prototype.gte = function(t) {
                        return this.cmp(t) >= 0
                    }, s.prototype.ltn = function(t) {
                        return -1 === this.cmpn(t)
                    }, s.prototype.lt = function(t) {
                        return -1 === this.cmp(t)
                    }, s.prototype.lten = function(t) {
                        return this.cmpn(t) <= 0
                    }, s.prototype.lte = function(t) {
                        return this.cmp(t) <= 0
                    }, s.prototype.eqn = function(t) {
                        return 0 === this.cmpn(t)
                    }, s.prototype.eq = function(t) {
                        return 0 === this.cmp(t)
                    }, s.red = function(t) {
                        return new S(t)
                    }, s.prototype.toRed = function(t) {
                        return n(!this.red, "Already a number in reduction context"), n(0 === this.negative, "red works only with positives"), t.convertTo(this)._forceRed(t)
                    }, s.prototype.fromRed = function() {
                        return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
                    }, s.prototype._forceRed = function(t) {
                        return this.red = t, this
                    }, s.prototype.forceRed = function(t) {
                        return n(!this.red, "Already a number in reduction context"), this._forceRed(t)
                    }, s.prototype.redAdd = function(t) {
                        return n(this.red, "redAdd works only with red numbers"), this.red.add(this, t)
                    }, s.prototype.redIAdd = function(t) {
                        return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, t)
                    }, s.prototype.redSub = function(t) {
                        return n(this.red, "redSub works only with red numbers"), this.red.sub(this, t)
                    }, s.prototype.redISub = function(t) {
                        return n(this.red, "redISub works only with red numbers"), this.red.isub(this, t)
                    }, s.prototype.redShl = function(t) {
                        return n(this.red, "redShl works only with red numbers"), this.red.shl(this, t)
                    }, s.prototype.redMul = function(t) {
                        return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, t), this.red.mul(this, t)
                    }, s.prototype.redIMul = function(t) {
                        return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, t), this.red.imul(this, t)
                    }, s.prototype.redSqr = function() {
                        return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
                    }, s.prototype.redISqr = function() {
                        return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
                    }, s.prototype.redSqrt = function() {
                        return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
                    }, s.prototype.redInvm = function() {
                        return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
                    }, s.prototype.redNeg = function() {
                        return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
                    }, s.prototype.redPow = function(t) {
                        return n(this.red && !t.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, t)
                    };
                    var y = {
                        k256: null,
                        p224: null,
                        p192: null,
                        p25519: null
                    };

                    function v(t, e) {
                        this.name = t, this.p = new s(e, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
                    }

                    function w() {
                        v.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
                    }

                    function _() {
                        v.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
                    }

                    function M() {
                        v.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
                    }

                    function A() {
                        v.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
                    }

                    function S(t) {
                        if ("string" === typeof t) {
                            var e = s._prime(t);
                            this.m = e.p, this.prime = e
                        } else n(t.gtn(1), "modulus must be greater than 1"), this.m = t, this.prime = null
                    }

                    function x(t) {
                        S.call(this, t), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
                    }
                    v.prototype._tmp = function() {
                        var t = new s(null);
                        return t.words = new Array(Math.ceil(this.n / 13)), t
                    }, v.prototype.ireduce = function(t) {
                        var e, r = t;
                        do {
                            this.split(r, this.tmp), r = this.imulK(r), r = r.iadd(this.tmp), e = r.bitLength()
                        } while (e > this.n);
                        var n = e < this.n ? -1 : r.ucmp(this.p);
                        return 0 === n ? (r.words[0] = 0, r.length = 1) : n > 0 ? r.isub(this.p) : r.strip(), r
                    }, v.prototype.split = function(t, e) {
                        t.iushrn(this.n, 0, e)
                    }, v.prototype.imulK = function(t) {
                        return t.imul(this.k)
                    }, i(w, v), w.prototype.split = function(t, e) {
                        for (var r = 4194303, n = Math.min(t.length, 9), i = 0; i < n; i++) e.words[i] = t.words[i];
                        if (e.length = n, t.length <= 9) return t.words[0] = 0, void(t.length = 1);
                        var s = t.words[9];
                        for (e.words[e.length++] = s & r, i = 10; i < t.length; i++) {
                            var a = 0 | t.words[i];
                            t.words[i - 10] = (a & r) << 4 | s >>> 22, s = a
                        }
                        s >>>= 22, t.words[i - 10] = s, 0 === s && t.length > 10 ? t.length -= 10 : t.length -= 9
                    }, w.prototype.imulK = function(t) {
                        t.words[t.length] = 0, t.words[t.length + 1] = 0, t.length += 2;
                        for (var e = 0, r = 0; r < t.length; r++) {
                            var n = 0 | t.words[r];
                            e += 977 * n, t.words[r] = 67108863 & e, e = 64 * n + (e / 67108864 | 0)
                        }
                        return 0 === t.words[t.length - 1] && (t.length--, 0 === t.words[t.length - 1] && t.length--), t
                    }, i(_, v), i(M, v), i(A, v), A.prototype.imulK = function(t) {
                        for (var e = 0, r = 0; r < t.length; r++) {
                            var n = 19 * (0 | t.words[r]) + e,
                                i = 67108863 & n;
                            n >>>= 26, t.words[r] = i, e = n
                        }
                        return 0 !== e && (t.words[t.length++] = e), t
                    }, s._prime = function(t) {
                        if (y[t]) return y[t];
                        var e;
                        if ("k256" === t) e = new w;
                        else if ("p224" === t) e = new _;
                        else if ("p192" === t) e = new M;
                        else {
                            if ("p25519" !== t) throw new Error("Unknown prime " + t);
                            e = new A
                        }
                        return y[t] = e, e
                    }, S.prototype._verify1 = function(t) {
                        n(0 === t.negative, "red works only with positives"), n(t.red, "red works only with red numbers")
                    }, S.prototype._verify2 = function(t, e) {
                        n(0 === (t.negative | e.negative), "red works only with positives"), n(t.red && t.red === e.red, "red works only with red numbers")
                    }, S.prototype.imod = function(t) {
                        return this.prime ? this.prime.ireduce(t)._forceRed(this) : t.umod(this.m)._forceRed(this)
                    }, S.prototype.neg = function(t) {
                        return t.isZero() ? t.clone() : this.m.sub(t)._forceRed(this)
                    }, S.prototype.add = function(t, e) {
                        this._verify2(t, e);
                        var r = t.add(e);
                        return r.cmp(this.m) >= 0 && r.isub(this.m), r._forceRed(this)
                    }, S.prototype.iadd = function(t, e) {
                        this._verify2(t, e);
                        var r = t.iadd(e);
                        return r.cmp(this.m) >= 0 && r.isub(this.m), r
                    }, S.prototype.sub = function(t, e) {
                        this._verify2(t, e);
                        var r = t.sub(e);
                        return r.cmpn(0) < 0 && r.iadd(this.m), r._forceRed(this)
                    }, S.prototype.isub = function(t, e) {
                        this._verify2(t, e);
                        var r = t.isub(e);
                        return r.cmpn(0) < 0 && r.iadd(this.m), r
                    }, S.prototype.shl = function(t, e) {
                        return this._verify1(t), this.imod(t.ushln(e))
                    }, S.prototype.imul = function(t, e) {
                        return this._verify2(t, e), this.imod(t.imul(e))
                    }, S.prototype.mul = function(t, e) {
                        return this._verify2(t, e), this.imod(t.mul(e))
                    }, S.prototype.isqr = function(t) {
                        return this.imul(t, t.clone())
                    }, S.prototype.sqr = function(t) {
                        return this.mul(t, t)
                    }, S.prototype.sqrt = function(t) {
                        if (t.isZero()) return t.clone();
                        var e = this.m.andln(3);
                        if (n(e % 2 === 1), 3 === e) {
                            var r = this.m.add(new s(1)).iushrn(2);
                            return this.pow(t, r)
                        }
                        var i = this.m.subn(1),
                            a = 0;
                        while (!i.isZero() && 0 === i.andln(1)) a++, i.iushrn(1);
                        n(!i.isZero());
                        var o = new s(1).toRed(this),
                            u = o.redNeg(),
                            h = this.m.subn(1).iushrn(1),
                            f = this.m.bitLength();
                        f = new s(2 * f * f).toRed(this);
                        while (0 !== this.pow(f, h).cmp(u)) f.redIAdd(u);
                        var c = this.pow(f, i),
                            l = this.pow(t, i.addn(1).iushrn(1)),
                            d = this.pow(t, i),
                            p = a;
                        while (0 !== d.cmp(o)) {
                            for (var m = d, b = 0; 0 !== m.cmp(o); b++) m = m.redSqr();
                            n(b < p);
                            var g = this.pow(c, new s(1).iushln(p - b - 1));
                            l = l.redMul(g), c = g.redSqr(), d = d.redMul(c), p = b
                        }
                        return l
                    }, S.prototype.invm = function(t) {
                        var e = t._invmp(this.m);
                        return 0 !== e.negative ? (e.negative = 0, this.imod(e).redNeg()) : this.imod(e)
                    }, S.prototype.pow = function(t, e) {
                        if (e.isZero()) return new s(1);
                        if (0 === e.cmpn(1)) return t.clone();
                        var r = 4,
                            n = new Array(1 << r);
                        n[0] = new s(1).toRed(this), n[1] = t;
                        for (var i = 2; i < n.length; i++) n[i] = this.mul(n[i - 1], t);
                        var a = n[0],
                            o = 0,
                            u = 0,
                            h = e.bitLength() % 26;
                        for (0 === h && (h = 26), i = e.length - 1; i >= 0; i--) {
                            for (var f = e.words[i], c = h - 1; c >= 0; c--) {
                                var l = f >> c & 1;
                                a !== n[0] && (a = this.sqr(a)), 0 !== l || 0 !== o ? (o <<= 1, o |= l, u++, (u === r || 0 === i && 0 === c) && (a = this.mul(a, n[o]), u = 0, o = 0)) : u = 0
                            }
                            h = 26
                        }
                        return a
                    }, S.prototype.convertTo = function(t) {
                        var e = t.umod(this.m);
                        return e === t ? e.clone() : e
                    }, S.prototype.convertFrom = function(t) {
                        var e = t.clone();
                        return e.red = null, e
                    }, s.mont = function(t) {
                        return new x(t)
                    }, i(x, S), x.prototype.convertTo = function(t) {
                        return this.imod(t.ushln(this.shift))
                    }, x.prototype.convertFrom = function(t) {
                        var e = this.imod(t.mul(this.rinv));
                        return e.red = null, e
                    }, x.prototype.imul = function(t, e) {
                        if (t.isZero() || e.isZero()) return t.words[0] = 0, t.length = 1, t;
                        var r = t.imul(e),
                            n = r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                            i = r.isub(n).iushrn(this.shift),
                            s = i;
                        return i.cmp(this.m) >= 0 ? s = i.isub(this.m) : i.cmpn(0) < 0 && (s = i.iadd(this.m)), s._forceRed(this)
                    }, x.prototype.mul = function(t, e) {
                        if (t.isZero() || e.isZero()) return new s(0)._forceRed(this);
                        var r = t.mul(e),
                            n = r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                            i = r.isub(n).iushrn(this.shift),
                            a = i;
                        return i.cmp(this.m) >= 0 ? a = i.isub(this.m) : i.cmpn(0) < 0 && (a = i.iadd(this.m)), a._forceRed(this)
                    }, x.prototype.invm = function(t) {
                        var e = this.imod(t._invmp(this.m).mul(this.r2));
                        return e._forceRed(this)
                    }
                })(t, this)
            }).call(this, r("62e4")(t))
        },
        "4e2b": function(t, e, r) {
            "use strict";
            var n = r("da3e"),
                i = r("3fb5"),
                s = r("5ee7"),
                a = r("0184");

            function o() {
                this.tmp = new Array(2), this.keys = null
            }

            function u(t) {
                a.call(this, t);
                var e = new o;
                this._desState = e, this.deriveKeys(e, t.key)
            }
            i(u, a), t.exports = u, u.create = function(t) {
                return new u(t)
            };
            var h = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
            u.prototype.deriveKeys = function(t, e) {
                t.keys = new Array(32), n.equal(e.length, this.blockSize, "Invalid key length");
                var r = s.readUInt32BE(e, 0),
                    i = s.readUInt32BE(e, 4);
                s.pc1(r, i, t.tmp, 0), r = t.tmp[0], i = t.tmp[1];
                for (var a = 0; a < t.keys.length; a += 2) {
                    var o = h[a >>> 1];
                    r = s.r28shl(r, o), i = s.r28shl(i, o), s.pc2(r, i, t.keys, a)
                }
            }, u.prototype._update = function(t, e, r, n) {
                var i = this._desState,
                    a = s.readUInt32BE(t, e),
                    o = s.readUInt32BE(t, e + 4);
                s.ip(a, o, i.tmp, 0), a = i.tmp[0], o = i.tmp[1], "encrypt" === this.type ? this._encrypt(i, a, o, i.tmp, 0) : this._decrypt(i, a, o, i.tmp, 0), a = i.tmp[0], o = i.tmp[1], s.writeUInt32BE(r, a, n), s.writeUInt32BE(r, o, n + 4)
            }, u.prototype._pad = function(t, e) {
                for (var r = t.length - e, n = e; n < t.length; n++) t[n] = r;
                return !0
            }, u.prototype._unpad = function(t) {
                for (var e = t[t.length - 1], r = t.length - e; r < t.length; r++) n.equal(t[r], e);
                return t.slice(0, t.length - e)
            }, u.prototype._encrypt = function(t, e, r, n, i) {
                for (var a = e, o = r, u = 0; u < t.keys.length; u += 2) {
                    var h = t.keys[u],
                        f = t.keys[u + 1];
                    s.expand(o, t.tmp, 0), h ^= t.tmp[0], f ^= t.tmp[1];
                    var c = s.substitute(h, f),
                        l = s.permute(c),
                        d = o;
                    o = (a ^ l) >>> 0, a = d
                }
                s.rip(o, a, n, i)
            }, u.prototype._decrypt = function(t, e, r, n, i) {
                for (var a = r, o = e, u = t.keys.length - 2; u >= 0; u -= 2) {
                    var h = t.keys[u],
                        f = t.keys[u + 1];
                    s.expand(a, t.tmp, 0), h ^= t.tmp[0], f ^= t.tmp[1];
                    var c = s.substitute(h, f),
                        l = s.permute(c),
                        d = a;
                    a = (o ^ l) >>> 0, o = d
                }
                s.rip(a, o, n, i)
            }
        },
        "500b": function(t, e, r) {
            /**
             *
             * @revision    $Id: index.js 2012-03-24 16:21:10 Aleksey $
             * @created     2016-09-24 16:21:10
             * @category    Express Helpers
             * @package     device-uuid
             * @version     1.0.2
             * @copyright   Copyright (c) 2016-2017 - All rights reserved.
             * @license     MIT License
             * @author      Alexey Gordeyev IK <aleksej@gordejev.lv>
             * @link        http://www.gordejev.lv
             *
             */
            t.exports = r("6279")
        },
        "502a": function(t, e, r) {
            "use strict";
            const n = r("e26f").v4,
                i = r("db97"),
                s = function(t, e) {
                    if (!(this instanceof s)) return new s(t, e);
                    e || (e = {}), this.options = {
                        reviver: "undefined" !== typeof e.reviver ? e.reviver : null,
                        replacer: "undefined" !== typeof e.replacer ? e.replacer : null,
                        generator: "undefined" !== typeof e.generator ? e.generator : function() {
                            return n()
                        },
                        version: "undefined" !== typeof e.version ? e.version : 2,
                        notificationIdNull: "boolean" === typeof e.notificationIdNull && e.notificationIdNull
                    }, this.callServer = t
                };
            t.exports = s, s.prototype.request = function(t, e, r, n) {
                const s = this;
                let a = null;
                const o = Array.isArray(t) && "function" === typeof e;
                if (1 === this.options.version && o) throw new TypeError("JSON-RPC 1.0 does not support batching");
                const u = !o && t && "object" === typeof t && "function" === typeof e;
                if (o || u) n = e, a = t;
                else {
                    "function" === typeof r && (n = r, r = void 0);
                    const s = "function" === typeof n;
                    try {
                        a = i(t, e, r, {
                            generator: this.options.generator,
                            version: this.options.version,
                            notificationIdNull: this.options.notificationIdNull
                        })
                    } catch (f) {
                        if (s) return n(f);
                        throw f
                    }
                    if (!s) return a
                }
                let h;
                try {
                    h = JSON.stringify(a, this.options.replacer)
                } catch (f) {
                    return n(f)
                }
                return this.callServer(h, (function(t, e) {
                    s._parseResponse(t, e, n)
                })), a
            }, s.prototype._parseResponse = function(t, e, r) {
                if (t) return void r(t);
                if (!e) return r();
                let n;
                try {
                    n = JSON.parse(e, this.options.reviver)
                } catch (t) {
                    return r(t)
                }
                if (3 === r.length) {
                    if (Array.isArray(n)) {
                        const t = function(t) {
                                return "undefined" !== typeof t.error
                            },
                            e = function(e) {
                                return !t(e)
                            };
                        return r(null, n.filter(t), n.filter(e))
                    }
                    return r(null, n.error, n.result)
                }
                r(null, n)
            }
        },
        5162: function(t, e) {
            t.exports = function(t) {
                if ("string" !== typeof t) throw new Error("[is-hex-prefixed] value must be type 'string', is currently type " + typeof t + ", while checking isHexPrefixed.");
                return "0x" === t.slice(0, 2)
            }
        },
        "561d": function(t, e, r) {
            (function(e) {
                var n = r("48e6"),
                    i = r("7a10"),
                    s = new i,
                    a = new n(24),
                    o = new n(11),
                    u = new n(10),
                    h = new n(3),
                    f = new n(7),
                    c = r("58a2a"),
                    l = r("11dc");

                function d(t, r) {
                    return r = r || "utf8", e.isBuffer(t) || (t = new e(t, r)), this._pub = new n(t), this
                }

                function p(t, r) {
                    return r = r || "utf8", e.isBuffer(t) || (t = new e(t, r)), this._priv = new n(t), this
                }
                t.exports = g;
                var m = {};

                function b(t, e) {
                    var r = e.toString("hex"),
                        n = [r, t.toString(16)].join("_");
                    if (n in m) return m[n];
                    var i, l = 0;
                    if (t.isEven() || !c.simpleSieve || !c.fermatTest(t) || !s.test(t)) return l += 1, l += "02" === r || "05" === r ? 8 : 4, m[n] = l, l;
                    switch (s.test(t.shrn(1)) || (l += 2), r) {
                        case "02":
                            t.mod(a).cmp(o) && (l += 8);
                            break;
                        case "05":
                            i = t.mod(u), i.cmp(h) && i.cmp(f) && (l += 8);
                            break;
                        default:
                            l += 4
                    }
                    return m[n] = l, l
                }

                function g(t, e, r) {
                    this.setGenerator(e), this.__prime = new n(t), this._prime = n.mont(this.__prime), this._primeLen = t.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, r ? (this.setPublicKey = d, this.setPrivateKey = p) : this._primeCode = 8
                }

                function y(t, r) {
                    var n = new e(t.toArray());
                    return r ? n.toString(r) : n
                }
                Object.defineProperty(g.prototype, "verifyError", {
                    enumerable: !0,
                    get: function() {
                        return "number" !== typeof this._primeCode && (this._primeCode = b(this.__prime, this.__gen)), this._primeCode
                    }
                }), g.prototype.generateKeys = function() {
                    return this._priv || (this._priv = new n(l(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey()
                }, g.prototype.computeSecret = function(t) {
                    t = new n(t), t = t.toRed(this._prime);
                    var r = t.redPow(this._priv).fromRed(),
                        i = new e(r.toArray()),
                        s = this.getPrime();
                    if (i.length < s.length) {
                        var a = new e(s.length - i.length);
                        a.fill(0), i = e.concat([a, i])
                    }
                    return i
                }, g.prototype.getPublicKey = function(t) {
                    return y(this._pub, t)
                }, g.prototype.getPrivateKey = function(t) {
                    return y(this._priv, t)
                }, g.prototype.getPrime = function(t) {
                    return y(this.__prime, t)
                }, g.prototype.getGenerator = function(t) {
                    return y(this._gen, t)
                }, g.prototype.setGenerator = function(t, r) {
                    return r = r || "utf8", e.isBuffer(t) || (t = new e(t, r)), this.__gen = t, this._gen = new n(t), this
                }
            }).call(this, r("b639").Buffer)
        },
        "58a2a": function(t, e, r) {
            var n = r("11dc");
            t.exports = v, v.simpleSieve = g, v.fermatTest = y;
            var i = r("48e6"),
                s = new i(24),
                a = r("7a10"),
                o = new a,
                u = new i(1),
                h = new i(2),
                f = new i(5),
                c = (new i(16), new i(8), new i(10)),
                l = new i(3),
                d = (new i(7), new i(11)),
                p = new i(4),
                m = (new i(12), null);

            function b() {
                if (null !== m) return m;
                var t = 1048576,
                    e = [];
                e[0] = 2;
                for (var r = 1, n = 3; n < t; n += 2) {
                    for (var i = Math.ceil(Math.sqrt(n)), s = 0; s < r && e[s] <= i; s++)
                        if (n % e[s] === 0) break;
                    r !== s && e[s] <= i || (e[r++] = n)
                }
                return m = e, e
            }

            function g(t) {
                for (var e = b(), r = 0; r < e.length; r++)
                    if (0 === t.modn(e[r])) return 0 === t.cmpn(e[r]);
                return !0
            }

            function y(t) {
                var e = i.mont(t);
                return 0 === h.toRed(e).redPow(t.subn(1)).fromRed().cmpn(1)
            }

            function v(t, e) {
                if (t < 16) return new i(2 === e || 5 === e ? [140, 123] : [140, 39]);
                var r, a;
                e = new i(e);
                while (1) {
                    r = new i(n(Math.ceil(t / 8)));
                    while (r.bitLength() > t) r.ishrn(1);
                    if (r.isEven() && r.iadd(u), r.testn(1) || r.iadd(h), e.cmp(h)) {
                        if (!e.cmp(f))
                            while (r.mod(c).cmp(l)) r.iadd(p)
                    } else
                        while (r.mod(s).cmp(d)) r.iadd(p);
                    if (a = r.shrn(1), g(a) && g(r) && y(a) && y(r) && o.test(a) && o.test(r)) return r
                }
            }
        },
        5919: function(t, e, r) {
            "use strict";
            e.sha1 = r("13e2"), e.sha224 = r("07f2"), e.sha256 = r("6eed"), e.sha384 = r("8b95"), e.sha512 = r("b525")
        },
        5934: function(t, e, r) {
            (function(t) {
                var r, n;
                (function(i, s) {
                    var a = s(i, i && i.jQuery);
                    "exports" in t ? t.exports = a : (r = [], n = function() {
                        return a
                    }.apply(e, r), void 0 === n || (t.exports = n))
                })("undefined" !== typeof self ? self : this, (function(t, e) {
                    function r(t, e, r) {
                        for (var n = document.createElementNS("http://www.w3.org/2000/svg", e), i = 2; i + 1 < arguments.length; i += 2) n.setAttribute(arguments[i], arguments[i + 1]);
                        t.appendChild(n)
                    }

                    function n(t) {
                        for (this.b = Math.min(Number(t.getAttribute("width")) || 100, Number(t.getAttribute("height")) || 100), this.a = t; t.firstChild;) t.removeChild(t.firstChild);
                        t.setAttribute("viewBox", "0 0 " + this.b + " " + this.b), t.setAttribute("preserveAspectRatio", "xMidYMid meet")
                    }

                    function i(t) {
                        this.b = t, this.a = '<svg xmlns="http://www.w3.org/2000/svg" width="' + t + '" height="' + t + '" viewBox="0 0 ' + t + " " + t + '" preserveAspectRatio="xMidYMid meet">'
                    }

                    function s(t) {
                        "undefined" != typeof MutationObserver && new MutationObserver((function(e) {
                            for (var r = 0; r < e.length; r++) {
                                for (var n = e[r], i = n.addedNodes, s = 0; i && s < i.length; s++) {
                                    var a = i[s];
                                    if (1 == a.nodeType)
                                        if (A.B(a)) t(a);
                                        else {
                                            a = a.querySelectorAll(A.C);
                                            for (var o = 0; o < a.length; o++) t(a[o])
                                        }
                                }
                                "attributes" == n.type && A.B(n.target) && t(n.target)
                            }
                        })).observe(document.body, {
                            childList: !0,
                            attributes: !0,
                            attributeFilter: [A.o, A.v, "width", "height"],
                            subtree: !0
                        })
                    }

                    function a(t, e, r) {
                        return parseInt(t.substr(e, r), 16)
                    }

                    function o(t) {
                        return (10 * t + .5 | 0) / 10
                    }

                    function u() {
                        this.j = ""
                    }

                    function h(t) {
                        this.b = {}, this.h = t, this.a = t.b
                    }

                    function f(t, e) {
                        var r = t.canvas.width,
                            n = t.canvas.height;
                        t.save(), this.b = t, e ? this.a = e : (this.a = Math.min(r, n), t.translate((r - this.a) / 2 | 0, (n - this.a) / 2 | 0)), t.clearRect(0, 0, this.a, this.a)
                    }

                    function c(t) {
                        this.h = t, this.c = y.a
                    }

                    function l(t, e) {
                        return t = e.R(t), [E.i(t, e.J, e.I(0)), E.i(t, e.A, e.w(.5)), E.i(t, e.J, e.I(1)), E.i(t, e.A, e.w(1)), E.i(t, e.A, e.w(0))]
                    }

                    function d(t) {
                        return function(t) {
                            for (var e = [], r = 0; r < t.length; r++)
                                for (var n = t[r], i = 28; 0 <= i; i -= 4) e.push((n >>> i & 15).toString(16));
                            return e.join("")
                        }(function(t) {
                            for (var e = 1732584193, r = 4023233417, n = 2562383102, i = 271733878, s = 3285377520, a = [e, r, n, i, s], o = 0; o < t.length; o++) {
                                for (var u = t[o], h = 16; 80 > h; h++) {
                                    var f = u[h - 3] ^ u[h - 8] ^ u[h - 14] ^ u[h - 16];
                                    u[h] = f << 1 | f >>> 31
                                }
                                for (h = 0; 80 > h; h++) f = (e << 5 | e >>> 27) + (20 > h ? 1518500249 + (r & n ^ ~r & i) : 40 > h ? 1859775393 + (r ^ n ^ i) : 60 > h ? 2400959708 + (r & n ^ r & i ^ n & i) : 3395469782 + (r ^ n ^ i)) + s + u[h], s = i, i = n, n = r << 30 | r >>> 2, r = e, e = 0 | f;
                                a[0] = e = a[0] + e | 0, a[1] = r = a[1] + r | 0, a[2] = n = a[2] + n | 0, a[3] = i = a[3] + i | 0, a[4] = s = a[4] + s | 0
                            }
                            return a
                        }(function(t) {
                            function e(t, e) {
                                for (var r = [], i = -1, s = 0; s < e; s++) i = s / 4 | 0, r[i] = (r[i] || 0) + (n[t + s] << 8 * (3 - (3 & s)));
                                for (; 16 > ++i;) r[i] = 0;
                                return r
                            }
                            var r = encodeURI(t),
                                n = [];
                            t = 0;
                            var i, s = [];
                            for (i = 0; i < r.length; i++) {
                                if ("%" == r[i]) {
                                    var o = a(r, i + 1, 2);
                                    i += 2
                                } else o = r.charCodeAt(i);
                                n[t++] = o
                            }
                            for (n[t++] = 128, i = 0; i + 64 <= t; i += 64) s.push(e(i, 64));
                            return r = t - i, i = e(i, r), 64 < r + 8 && (s.push(i), i = e(0, 0)), i[15] = 8 * t - 8, s.push(i), s
                        }(t)))
                    }

                    function p(t) {
                        return t |= 0, 0 > t ? "00" : 16 > t ? "0" + t.toString(16) : 256 > t ? t.toString(16) : "ff"
                    }

                    function m(t, e, r) {
                        return r = 0 > r ? r + 6 : 6 < r ? r - 6 : r, p(255 * (1 > r ? t + (e - t) * r : 3 > r ? e : 4 > r ? t + (e - t) * (4 - r) : t))
                    }

                    function b(t, e, r, n) {
                        function i(t, e) {
                            var r = a[t];
                            return r && 1 < r.length || (r = e),
                                function(t) {
                                    return t = r[0] + t * (r[1] - r[0]), 0 > t ? 0 : 1 < t ? 1 : t
                                }
                        }
                        var s = "object" == typeof r && r || t.config || e.jdenticon_config || {},
                            a = s.lightness || {};
                        e = s.saturation || {}, t = "color" in e ? e.color : e, e = e.grayscale;
                        var o = s.backColor,
                            u = s.padding;
                        return {
                            R: function(t) {
                                var e, r = s.hues;
                                return r && 0 < r.length && (e = r[0 | .999 * t * r.length]), "number" == typeof e ? (e / 360 % 1 + 1) % 1 : t
                            },
                            A: "number" == typeof t ? t : .5,
                            J: "number" == typeof e ? e : 0,
                            w: i("color", [.4, .8]),
                            I: i("grayscale", [.3, .9]),
                            F: E.parse(o),
                            padding: "number" == typeof r ? r : "number" == typeof u ? u : n
                        }
                    }

                    function g(t, e) {
                        this.x = t, this.y = e
                    }

                    function y(t, e, r, n) {
                        this.b = t, this.c = e, this.h = r, this.a = n
                    }

                    function v(t, e, r, n, i, s) {
                        function o(i, s, o, u, h) {
                            for (u = u ? a(e, u, 1) : 0, s = s[a(e, o, 1) % s.length], t.G(p[m[i]]), i = 0; i < h.length; i++) f.c = new y(r + h[i][0] * d, n + h[i][1] * d, d, u++ % 4), s(f, d, i);
                            t.H()
                        }

                        function u(t) {
                            if (0 <= t.indexOf(b))
                                for (var e = 0; e < t.length; e++)
                                    if (0 <= m.indexOf(t[e])) return !0
                        }
                        s.F && t.m(s.F);
                        var h = .5 + i * s.padding | 0;
                        i -= 2 * h;
                        var f = new c(t),
                            d = 0 | i / 4;
                        r += 0 | h + i / 2 - 2 * d, n += 0 | h + i / 2 - 2 * d, i = a(e, -7) / 268435455;
                        var p = l(i, s),
                            m = [];
                        for (s = 0; 3 > s; s++) {
                            var b = a(e, 8 + s, 1) % p.length;
                            (u([0, 4]) || u([2, 3])) && (b = 1), m.push(b)
                        }
                        o(0, S.K, 2, 3, [
                            [1, 0],
                            [2, 0],
                            [2, 3],
                            [1, 3],
                            [0, 1],
                            [3, 1],
                            [3, 2],
                            [0, 2]
                        ]), o(1, S.K, 4, 5, [
                            [0, 0],
                            [3, 0],
                            [3, 3],
                            [0, 3]
                        ]), o(2, S.O, 1, null, [
                            [1, 1],
                            [2, 1],
                            [2, 2],
                            [1, 2]
                        ]), t.finish()
                    }

                    function w(e, r, i) {
                        if ("string" === typeof e) {
                            if (A.L) {
                                e = document.querySelectorAll(e);
                                for (var s = 0; s < e.length; s++) w(e[s], r, i)
                            }
                        } else(s = A.B(e)) && (r = x.u(r) || null != r && x.s(r) || x.u(e.getAttribute(A.v)) || e.hasAttribute(A.o) && x.s(e.getAttribute(A.o))) && (e = s == A.D ? new h(new n(e)) : new f(e.getContext("2d")), v(e, r, 0, 0, e.a, b(_, t, i, .08)))
                    }

                    function _() {
                        A.L && w(A.C)
                    }

                    function M() {
                        var e = (_.config || t.jdenticon_config || {}).replaceMode;
                        "never" != e && (_(), "observe" == e && s(w))
                    }
                    n.prototype = {
                        m: function(t, e) {
                            e && r(this.a, "rect", "width", "100%", "height", "100%", "fill", t, "opacity", e)
                        },
                        c: function(t, e) {
                            r(this.a, "path", "fill", t, "d", e)
                        }
                    }, i.prototype = {
                        m: function(t, e) {
                            e && (this.a += '<rect width="100%" height="100%" fill="' + t + '" opacity="' + e.toFixed(2) + '"/>')
                        },
                        c: function(t, e) {
                            this.a += '<path fill="' + t + '" d="' + e + '"/>'
                        },
                        toString: function() {
                            return this.a + "</svg>"
                        }
                    };
                    var A = {
                        D: 1,
                        N: 2,
                        v: "data-jdenticon-hash",
                        o: "data-jdenticon-value",
                        L: "undefined" !== typeof document && "querySelectorAll" in document,
                        B: function(t) {
                            if (t) {
                                var e = t.tagName;
                                if (/svg/i.test(e)) return A.D;
                                if (/canvas/i.test(e) && "getContext" in t) return A.N
                            }
                        }
                    };
                    A.C = "[" + A.v + "],[" + A.o + "]";
                    var S = {
                        O: [function(t, e) {
                            var r = .42 * e;
                            t.f([0, 0, e, 0, e, e - 2 * r, e - r, e, 0, e])
                        }, function(t, e) {
                            var r = 0 | .5 * e;
                            t.b(e - r, 0, r, 0 | .8 * e, 2)
                        }, function(t, e) {
                            var r = 0 | e / 3;
                            t.a(r, r, e - r, e - r)
                        }, function(t, e) {
                            var r = .1 * e,
                                n = 6 > e ? 1 : 8 > e ? 2 : 0 | .25 * e;
                            r = 1 < r ? 0 | r : .5 < r ? 1 : r, t.a(n, n, e - r - n, e - r - n)
                        }, function(t, e) {
                            var r = 0 | .15 * e,
                                n = 0 | .5 * e;
                            t.g(e - n - r, e - n - r, n)
                        }, function(t, e) {
                            var r = .1 * e,
                                n = 4 * r;
                            3 < n && (n |= 0), t.a(0, 0, e, e), t.f([n, n, e - r, n, n + (e - n - r) / 2, e - r], !0)
                        }, function(t, e) {
                            t.f([0, 0, e, 0, e, .7 * e, .4 * e, .4 * e, .7 * e, e, 0, e])
                        }, function(t, e) {
                            t.b(e / 2, e / 2, e / 2, e / 2, 3)
                        }, function(t, e) {
                            t.a(0, 0, e, e / 2), t.a(0, e / 2, e / 2, e / 2), t.b(e / 2, e / 2, e / 2, e / 2, 1)
                        }, function(t, e) {
                            var r = .14 * e,
                                n = 4 > e ? 1 : 6 > e ? 2 : 0 | .35 * e;
                            r = 8 > e ? r : 0 | r, t.a(0, 0, e, e), t.a(n, n, e - n - r, e - n - r, !0)
                        }, function(t, e) {
                            var r = .12 * e,
                                n = 3 * r;
                            t.a(0, 0, e, e), t.g(n, n, e - r - n, !0)
                        }, function(t, e) {
                            t.b(e / 2, e / 2, e / 2, e / 2, 3)
                        }, function(t, e) {
                            var r = .25 * e;
                            t.a(0, 0, e, e), t.l(r, r, e - r, e - r, !0)
                        }, function(t, e, r) {
                            var n = .4 * e;
                            r || t.g(n, n, 1.2 * e)
                        }],
                        K: [function(t, e) {
                            t.b(0, 0, e, e, 0)
                        }, function(t, e) {
                            t.b(0, e / 2, e, e / 2, 0)
                        }, function(t, e) {
                            t.l(0, 0, e, e)
                        }, function(t, e) {
                            var r = e / 6;
                            t.g(r, r, e - 2 * r)
                        }]
                    };
                    u.prototype = {
                        f: function(t) {
                            for (var e = "M" + o(t[0].x) + " " + o(t[0].y), r = 1; r < t.length; r++) e += "L" + o(t[r].x) + " " + o(t[r].y);
                            this.j += e + "Z"
                        },
                        g: function(t, e, r) {
                            r = r ? 0 : 1;
                            var n = o(e / 2),
                                i = o(e);
                            this.j += "M" + o(t.x) + " " + o(t.y + e / 2) + "a" + n + "," + n + " 0 1," + r + " " + i + ",0a" + n + "," + n + " 0 1," + r + " " + -i + ",0"
                        }
                    }, h.prototype = {
                        m: function(t) {
                            t = /^(#......)(..)?/.exec(t);
                            var e = t[2] ? a(t[2], 0) / 255 : 1;
                            this.h.m(t[1], e)
                        },
                        G: function(t) {
                            this.c = this.b[t] || (this.b[t] = new u)
                        },
                        H: function() {},
                        f: function(t) {
                            this.c.f(t)
                        },
                        g: function(t, e, r) {
                            this.c.g(t, e, r)
                        },
                        finish: function() {
                            for (var t in this.b) this.h.c(t, this.b[t].j)
                        }
                    }, f.prototype = {
                        m: function(t) {
                            var e = this.b,
                                r = this.a;
                            e.fillStyle = E.M(t), e.fillRect(0, 0, r, r)
                        },
                        G: function(t) {
                            this.b.fillStyle = E.M(t), this.b.beginPath()
                        },
                        H: function() {
                            this.b.fill()
                        },
                        f: function(t) {
                            var e, r = this.b;
                            for (r.moveTo(t[0].x, t[0].y), e = 1; e < t.length; e++) r.lineTo(t[e].x, t[e].y);
                            r.closePath()
                        },
                        g: function(t, e, r) {
                            var n = this.b;
                            e /= 2, n.moveTo(t.x + e, t.y + e), n.arc(t.x + e, t.y + e, e, 0, 2 * Math.PI, r), n.closePath()
                        },
                        finish: function() {
                            this.b.restore()
                        }
                    }, c.prototype = {
                        f: function(t, e) {
                            var r = e ? -2 : 2,
                                n = this.c,
                                i = [];
                            for (e = e ? t.length - 2 : 0; e < t.length && 0 <= e; e += r) i.push(n.l(t[e], t[e + 1]));
                            this.h.f(i)
                        },
                        g: function(t, e, r, n) {
                            t = this.c.l(t, e, r, r), this.h.g(t, r, n)
                        },
                        a: function(t, e, r, n, i) {
                            this.f([t, e, t + r, e, t + r, e + n, t, e + n], i)
                        },
                        b: function(t, e, r, n, i, s) {
                            t = [t + r, e, t + r, e + n, t, e + n, t, e], t.splice((i || 0) % 4 * 2, 2), this.f(t, s)
                        },
                        l: function(t, e, r, n, i) {
                            this.f([t + r / 2, e, t + r, e + n / 2, t + r / 2, e + n, t, e + n / 2], i)
                        }
                    };
                    var x = {
                            u: function(t) {
                                return /^[0-9a-f]{11,}$/i.test(t) && t
                            },
                            s: function(t) {
                                return d(null == t ? "" : "" + t)
                            }
                        },
                        E = {
                            S: function(t, e, r) {
                                return "#" + p(t) + p(e) + p(r)
                            },
                            parse: function(t) {
                                if (/^#[0-9a-f]{3,8}$/i.test(t)) {
                                    if (6 > t.length) {
                                        var e = t[1],
                                            r = t[2],
                                            n = t[3];
                                        return t = t[4] || "", "#" + e + e + r + r + n + n + t + t
                                    }
                                    if (7 == t.length || 8 < t.length) return t
                                }
                            },
                            M: function(t) {
                                var e = a(t, 7, 2);
                                if (isNaN(e)) return t;
                                var r = a(t, 1, 2),
                                    n = a(t, 3, 2);
                                return t = a(t, 5, 2), "rgba(" + r + "," + n + "," + t + "," + (e / 255).toFixed(2) + ")"
                            },
                            P: function(t, e, r) {
                                return 0 == e ? (t = p(255 * r), "#" + t + t + t) : (e = .5 >= r ? r * (e + 1) : r + e - r * e, r = 2 * r - e, "#" + m(r, e, 6 * t + 2) + m(r, e, 6 * t) + m(r, e, 6 * t - 2))
                            },
                            i: function(t, e, r) {
                                var n = [.55, .5, .5, .46, .6, .55, .55][6 * t + .5 | 0];
                                return E.P(t, e, .5 > r ? r * n * 2 : n + (r - .5) * (1 - n) * 2)
                            }
                        };
                    return y.prototype = {
                        l: function(t, e, r, n) {
                            var i = this.b + this.h,
                                s = this.c + this.h;
                            return 1 === this.a ? new g(i - e - (n || 0), this.c + t) : 2 === this.a ? new g(i - t - (r || 0), s - e - (n || 0)) : 3 === this.a ? new g(this.b + e, s - t - (r || 0)) : new g(this.b + t, this.c + e)
                        }
                    }, y.a = new y(0, 0, 0, 0), _.drawIcon = function(e, r, n, i) {
                        if (!e) throw Error("No canvas specified.");
                        e = new f(e, n), v(e, x.u(r) || x.s(r), 0, 0, n, b(_, t, i, 0))
                    }, _.toSvg = function(e, r, n) {
                        var s = new i(r),
                            a = new h(s);
                        return v(a, x.u(e) || x.s(e), 0, 0, r, b(_, t, n, .08)), s.toString()
                    }, _.update = w, _.version = "2.2.0", e && (e.fn.jdenticon = function(t, e) {
                        return this.each((function(r, n) {
                            w(n, t, e)
                        })), this
                    }), "function" === typeof setTimeout && setTimeout(M, 0), _
                }))
            }).call(this, r("62e4")(t))
        },
        "5a0c": function(t, e, r) {
            ! function(e, r) {
                t.exports = r()
            }(0, (function() {
                "use strict";
                var t = "millisecond",
                    e = "second",
                    r = "minute",
                    n = "hour",
                    i = "day",
                    s = "week",
                    a = "month",
                    o = "quarter",
                    u = "year",
                    h = "date",
                    f = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[^0-9]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
                    c = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
                    l = {
                        name: "en",
                        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_")
                    },
                    d = function(t, e, r) {
                        var n = String(t);
                        return !n || n.length >= e ? t : "" + Array(e + 1 - n.length).join(r) + t
                    },
                    p = {
                        s: d,
                        z: function(t) {
                            var e = -t.utcOffset(),
                                r = Math.abs(e),
                                n = Math.floor(r / 60),
                                i = r % 60;
                            return (e <= 0 ? "+" : "-") + d(n, 2, "0") + ":" + d(i, 2, "0")
                        },
                        m: function t(e, r) {
                            if (e.date() < r.date()) return -t(r, e);
                            var n = 12 * (r.year() - e.year()) + (r.month() - e.month()),
                                i = e.clone().add(n, a),
                                s = r - i < 0,
                                o = e.clone().add(n + (s ? -1 : 1), a);
                            return +(-(n + (r - i) / (s ? i - o : o - i)) || 0)
                        },
                        a: function(t) {
                            return t < 0 ? Math.ceil(t) || 0 : Math.floor(t)
                        },
                        p: function(f) {
                            return {
                                M: a,
                                y: u,
                                w: s,
                                d: i,
                                D: h,
                                h: n,
                                m: r,
                                s: e,
                                ms: t,
                                Q: o
                            }[f] || String(f || "").toLowerCase().replace(/s$/, "")
                        },
                        u: function(t) {
                            return void 0 === t
                        }
                    },
                    m = "en",
                    b = {};
                b[m] = l;
                var g = function(t) {
                        return t instanceof _
                    },
                    y = function(t, e, r) {
                        var n;
                        if (!t) return m;
                        if ("string" == typeof t) b[t] && (n = t), e && (b[t] = e, n = t);
                        else {
                            var i = t.name;
                            b[i] = t, n = i
                        }
                        return !r && n && (m = n), n || !r && m
                    },
                    v = function(t, e) {
                        if (g(t)) return t.clone();
                        var r = "object" == typeof e ? e : {};
                        return r.date = t, r.args = arguments, new _(r)
                    },
                    w = p;
                w.l = y, w.i = g, w.w = function(t, e) {
                    return v(t, {
                        locale: e.$L,
                        utc: e.$u,
                        x: e.$x,
                        $offset: e.$offset
                    })
                };
                var _ = function() {
                        function l(t) {
                            this.$L = y(t.locale, null, !0), this.parse(t)
                        }
                        var d = l.prototype;
                        return d.parse = function(t) {
                            this.$d = function(t) {
                                var e = t.date,
                                    r = t.utc;
                                if (null === e) return new Date(NaN);
                                if (w.u(e)) return new Date;
                                if (e instanceof Date) return new Date(e);
                                if ("string" == typeof e && !/Z$/i.test(e)) {
                                    var n = e.match(f);
                                    if (n) {
                                        var i = n[2] - 1 || 0,
                                            s = (n[7] || "0").substring(0, 3);
                                        return r ? new Date(Date.UTC(n[1], i, n[3] || 1, n[4] || 0, n[5] || 0, n[6] || 0, s)) : new Date(n[1], i, n[3] || 1, n[4] || 0, n[5] || 0, n[6] || 0, s)
                                    }
                                }
                                return new Date(e)
                            }(t), this.$x = t.x || {}, this.init()
                        }, d.init = function() {
                            var t = this.$d;
                            this.$y = t.getFullYear(), this.$M = t.getMonth(), this.$D = t.getDate(), this.$W = t.getDay(), this.$H = t.getHours(), this.$m = t.getMinutes(), this.$s = t.getSeconds(), this.$ms = t.getMilliseconds()
                        }, d.$utils = function() {
                            return w
                        }, d.isValid = function() {
                            return !("Invalid Date" === this.$d.toString())
                        }, d.isSame = function(t, e) {
                            var r = v(t);
                            return this.startOf(e) <= r && r <= this.endOf(e)
                        }, d.isAfter = function(t, e) {
                            return v(t) < this.startOf(e)
                        }, d.isBefore = function(t, e) {
                            return this.endOf(e) < v(t)
                        }, d.$g = function(t, e, r) {
                            return w.u(t) ? this[e] : this.set(r, t)
                        }, d.unix = function() {
                            return Math.floor(this.valueOf() / 1e3)
                        }, d.valueOf = function() {
                            return this.$d.getTime()
                        }, d.startOf = function(t, o) {
                            var f = this,
                                c = !!w.u(o) || o,
                                l = w.p(t),
                                d = function(t, e) {
                                    var r = w.w(f.$u ? Date.UTC(f.$y, e, t) : new Date(f.$y, e, t), f);
                                    return c ? r : r.endOf(i)
                                },
                                p = function(t, e) {
                                    return w.w(f.toDate()[t].apply(f.toDate("s"), (c ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e)), f)
                                },
                                m = this.$W,
                                b = this.$M,
                                g = this.$D,
                                y = "set" + (this.$u ? "UTC" : "");
                            switch (l) {
                                case u:
                                    return c ? d(1, 0) : d(31, 11);
                                case a:
                                    return c ? d(1, b) : d(0, b + 1);
                                case s:
                                    var v = this.$locale().weekStart || 0,
                                        _ = (m < v ? m + 7 : m) - v;
                                    return d(c ? g - _ : g + (6 - _), b);
                                case i:
                                case h:
                                    return p(y + "Hours", 0);
                                case n:
                                    return p(y + "Minutes", 1);
                                case r:
                                    return p(y + "Seconds", 2);
                                case e:
                                    return p(y + "Milliseconds", 3);
                                default:
                                    return this.clone()
                            }
                        }, d.endOf = function(t) {
                            return this.startOf(t, !1)
                        }, d.$set = function(s, o) {
                            var f, c = w.p(s),
                                l = "set" + (this.$u ? "UTC" : ""),
                                d = (f = {}, f[i] = l + "Date", f[h] = l + "Date", f[a] = l + "Month", f[u] = l + "FullYear", f[n] = l + "Hours", f[r] = l + "Minutes", f[e] = l + "Seconds", f[t] = l + "Milliseconds", f)[c],
                                p = c === i ? this.$D + (o - this.$W) : o;
                            if (c === a || c === u) {
                                var m = this.clone().set(h, 1);
                                m.$d[d](p), m.init(), this.$d = m.set(h, Math.min(this.$D, m.daysInMonth())).$d
                            } else d && this.$d[d](p);
                            return this.init(), this
                        }, d.set = function(t, e) {
                            return this.clone().$set(t, e)
                        }, d.get = function(t) {
                            return this[w.p(t)]()
                        }, d.add = function(t, o) {
                            var h, f = this;
                            t = Number(t);
                            var c = w.p(o),
                                l = function(e) {
                                    var r = v(f);
                                    return w.w(r.date(r.date() + Math.round(e * t)), f)
                                };
                            if (c === a) return this.set(a, this.$M + t);
                            if (c === u) return this.set(u, this.$y + t);
                            if (c === i) return l(1);
                            if (c === s) return l(7);
                            var d = (h = {}, h[r] = 6e4, h[n] = 36e5, h[e] = 1e3, h)[c] || 1,
                                p = this.$d.getTime() + t * d;
                            return w.w(p, this)
                        }, d.subtract = function(t, e) {
                            return this.add(-1 * t, e)
                        }, d.format = function(t) {
                            var e = this;
                            if (!this.isValid()) return "Invalid Date";
                            var r = t || "YYYY-MM-DDTHH:mm:ssZ",
                                n = w.z(this),
                                i = this.$locale(),
                                s = this.$H,
                                a = this.$m,
                                o = this.$M,
                                u = i.weekdays,
                                h = i.months,
                                f = function(t, n, i, s) {
                                    return t && (t[n] || t(e, r)) || i[n].substr(0, s)
                                },
                                l = function(t) {
                                    return w.s(s % 12 || 12, t, "0")
                                },
                                d = i.meridiem || function(t, e, r) {
                                    var n = t < 12 ? "AM" : "PM";
                                    return r ? n.toLowerCase() : n
                                },
                                p = {
                                    YY: String(this.$y).slice(-2),
                                    YYYY: this.$y,
                                    M: o + 1,
                                    MM: w.s(o + 1, 2, "0"),
                                    MMM: f(i.monthsShort, o, h, 3),
                                    MMMM: f(h, o),
                                    D: this.$D,
                                    DD: w.s(this.$D, 2, "0"),
                                    d: String(this.$W),
                                    dd: f(i.weekdaysMin, this.$W, u, 2),
                                    ddd: f(i.weekdaysShort, this.$W, u, 3),
                                    dddd: u[this.$W],
                                    H: String(s),
                                    HH: w.s(s, 2, "0"),
                                    h: l(1),
                                    hh: l(2),
                                    a: d(s, a, !0),
                                    A: d(s, a, !1),
                                    m: String(a),
                                    mm: w.s(a, 2, "0"),
                                    s: String(this.$s),
                                    ss: w.s(this.$s, 2, "0"),
                                    SSS: w.s(this.$ms, 3, "0"),
                                    Z: n
                                };
                            return r.replace(c, (function(t, e) {
                                return e || p[t] || n.replace(":", "")
                            }))
                        }, d.utcOffset = function() {
                            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15)
                        }, d.diff = function(t, h, f) {
                            var c, l = w.p(h),
                                d = v(t),
                                p = 6e4 * (d.utcOffset() - this.utcOffset()),
                                m = this - d,
                                b = w.m(this, d);
                            return b = (c = {}, c[u] = b / 12, c[a] = b, c[o] = b / 3, c[s] = (m - p) / 6048e5, c[i] = (m - p) / 864e5, c[n] = m / 36e5, c[r] = m / 6e4, c[e] = m / 1e3, c)[l] || m, f ? b : w.a(b)
                        }, d.daysInMonth = function() {
                            return this.endOf(a).$D
                        }, d.$locale = function() {
                            return b[this.$L]
                        }, d.locale = function(t, e) {
                            if (!t) return this.$L;
                            var r = this.clone(),
                                n = y(t, e, !0);
                            return n && (r.$L = n), r
                        }, d.clone = function() {
                            return w.w(this.$d, this)
                        }, d.toDate = function() {
                            return new Date(this.valueOf())
                        }, d.toJSON = function() {
                            return this.isValid() ? this.toISOString() : null
                        }, d.toISOString = function() {
                            return this.$d.toISOString()
                        }, d.toString = function() {
                            return this.$d.toUTCString()
                        }, l
                    }(),
                    M = _.prototype;
                return v.prototype = M, [
                    ["$ms", t],
                    ["$s", e],
                    ["$m", r],
                    ["$H", n],
                    ["$W", i],
                    ["$M", a],
                    ["$y", u],
                    ["$D", h]
                ].forEach((function(t) {
                    M[t[1]] = function(e) {
                        return this.$g(e, t[0], t[1])
                    }
                })), v.extend = function(t, e) {
                    return t.$i || (t(e, _, v), t.$i = !0), v
                }, v.locale = y, v.isDayjs = g, v.unix = function(t) {
                    return v(1e3 * t)
                }, v.en = b[m], v.Ls = b, v.p = {}, v
            }))
        },
        "5bbb": function(t, e, r) {
            t.exports = r("faa1").EventEmitter
        },
        "5ee7": function(t, e, r) {
            "use strict";
            e.readUInt32BE = function(t, e) {
                var r = t[0 + e] << 24 | t[1 + e] << 16 | t[2 + e] << 8 | t[3 + e];
                return r >>> 0
            }, e.writeUInt32BE = function(t, e, r) {
                t[0 + r] = e >>> 24, t[1 + r] = e >>> 16 & 255, t[2 + r] = e >>> 8 & 255, t[3 + r] = 255 & e
            }, e.ip = function(t, e, r, n) {
                for (var i = 0, s = 0, a = 6; a >= 0; a -= 2) {
                    for (var o = 0; o <= 24; o += 8) i <<= 1, i |= e >>> o + a & 1;
                    for (o = 0; o <= 24; o += 8) i <<= 1, i |= t >>> o + a & 1
                }
                for (a = 6; a >= 0; a -= 2) {
                    for (o = 1; o <= 25; o += 8) s <<= 1, s |= e >>> o + a & 1;
                    for (o = 1; o <= 25; o += 8) s <<= 1, s |= t >>> o + a & 1
                }
                r[n + 0] = i >>> 0, r[n + 1] = s >>> 0
            }, e.rip = function(t, e, r, n) {
                for (var i = 0, s = 0, a = 0; a < 4; a++)
                    for (var o = 24; o >= 0; o -= 8) i <<= 1, i |= e >>> o + a & 1, i <<= 1, i |= t >>> o + a & 1;
                for (a = 4; a < 8; a++)
                    for (o = 24; o >= 0; o -= 8) s <<= 1, s |= e >>> o + a & 1, s <<= 1, s |= t >>> o + a & 1;
                r[n + 0] = i >>> 0, r[n + 1] = s >>> 0
            }, e.pc1 = function(t, e, r, n) {
                for (var i = 0, s = 0, a = 7; a >= 5; a--) {
                    for (var o = 0; o <= 24; o += 8) i <<= 1, i |= e >> o + a & 1;
                    for (o = 0; o <= 24; o += 8) i <<= 1, i |= t >> o + a & 1
                }
                for (o = 0; o <= 24; o += 8) i <<= 1, i |= e >> o + a & 1;
                for (a = 1; a <= 3; a++) {
                    for (o = 0; o <= 24; o += 8) s <<= 1, s |= e >> o + a & 1;
                    for (o = 0; o <= 24; o += 8) s <<= 1, s |= t >> o + a & 1
                }
                for (o = 0; o <= 24; o += 8) s <<= 1, s |= t >> o + a & 1;
                r[n + 0] = i >>> 0, r[n + 1] = s >>> 0
            }, e.r28shl = function(t, e) {
                return t << e & 268435455 | t >>> 28 - e
            };
            var n = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
            e.pc2 = function(t, e, r, i) {
                for (var s = 0, a = 0, o = n.length >>> 1, u = 0; u < o; u++) s <<= 1, s |= t >>> n[u] & 1;
                for (u = o; u < n.length; u++) a <<= 1, a |= e >>> n[u] & 1;
                r[i + 0] = s >>> 0, r[i + 1] = a >>> 0
            }, e.expand = function(t, e, r) {
                var n = 0,
                    i = 0;
                n = (1 & t) << 5 | t >>> 27;
                for (var s = 23; s >= 15; s -= 4) n <<= 6, n |= t >>> s & 63;
                for (s = 11; s >= 3; s -= 4) i |= t >>> s & 63, i <<= 6;
                i |= (31 & t) << 1 | t >>> 31, e[r + 0] = n >>> 0, e[r + 1] = i >>> 0
            };
            var i = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
            e.substitute = function(t, e) {
                for (var r = 0, n = 0; n < 4; n++) {
                    var s = t >>> 18 - 6 * n & 63,
                        a = i[64 * n + s];
                    r <<= 4, r |= a
                }
                for (n = 0; n < 4; n++) {
                    s = e >>> 18 - 6 * n & 63, a = i[256 + 64 * n + s];
                    r <<= 4, r |= a
                }
                return r >>> 0
            };
            var s = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
            e.permute = function(t) {
                for (var e = 0, r = 0; r < s.length; r++) e <<= 1, e |= t >>> s[r] & 1;
                return e >>> 0
            }, e.padSplit = function(t, e, r) {
                var n = t.toString(2);
                while (n.length < e) n = "0" + n;
                for (var i = [], s = 0; s < e; s += r) i.push(n.slice(s, s + r));
                return i.join(" ")
            }
        },
        6279: function(t, e) {
            /*!
             * device-uuid.js v1.0.4 (https://github.com/biggora/device-uuid/)
             * Copyright 2016-2017 Alexey Gordeyev
             * Licensed under MIT (https://github.com/biggora/device-uuid/blob/master/LICENSE)
             */
            (function(t) {
                "use strict";
                var e = ["\\+https:\\/\\/developers.google.com\\/\\+\\/web\\/snippet\\/", "googlebot", "baiduspider", "gurujibot", "yandexbot", "slurp", "msnbot", "bingbot", "facebookexternalhit", "linkedinbot", "twitterbot", "slackbot", "telegrambot", "applebot", "pingdom", "tumblr ", "Embedly", "spbot"],
                    r = new RegExp("^.*(" + e.join("|") + ").*$"),
                    n = function(t) {
                        t = t || {};
                        var e = {
                            version: !1,
                            language: !1,
                            platform: !0,
                            os: !0,
                            pixelDepth: !0,
                            colorDepth: !0,
                            resolution: !1,
                            isAuthoritative: !0,
                            silkAccelerated: !0,
                            isKindleFire: !0,
                            isDesktop: !0,
                            isMobile: !0,
                            isTablet: !0,
                            isWindows: !0,
                            isLinux: !0,
                            isLinux64: !0,
                            isChromeOS: !0,
                            isMac: !0,
                            isiPad: !0,
                            isiPhone: !0,
                            isiPod: !0,
                            isAndroid: !0,
                            isSamsung: !0,
                            isSmartTV: !0,
                            isRaspberry: !0,
                            isBlackberry: !0,
                            isTouchScreen: !0,
                            isOpera: !1,
                            isIE: !1,
                            isEdge: !1,
                            isIECompatibilityMode: !1,
                            isSafari: !1,
                            isFirefox: !1,
                            isWebkit: !1,
                            isChrome: !1,
                            isKonqueror: !1,
                            isOmniWeb: !1,
                            isSeaMonkey: !1,
                            isFlock: !1,
                            isAmaya: !1,
                            isPhantomJS: !1,
                            isEpiphany: !1,
                            source: !1,
                            cpuCores: !1
                        };
                        for (var i in t) t.hasOwnProperty(i) && "undefined" !== typeof e[i] && (e[i] = t[i]);
                        return this.options = e, this.version = "1.0.0", this._Versions = {
                            Edge: /Edge\/([\d\w\.\-]+)/i,
                            Firefox: /firefox\/([\d\w\.\-]+)/i,
                            IE: /msie\s([\d\.]+[\d])|trident\/\d+\.\d+;.*[rv:]+(\d+\.\d)/i,
                            Chrome: /chrome\/([\d\w\.\-]+)/i,
                            Chromium: /(?:chromium|crios)\/([\d\w\.\-]+)/i,
                            Safari: /version\/([\d\w\.\-]+)/i,
                            Opera: /version\/([\d\w\.\-]+)|OPR\/([\d\w\.\-]+)/i,
                            Ps3: /([\d\w\.\-]+)\)\s*$/i,
                            Psp: /([\d\w\.\-]+)\)?\s*$/i,
                            Amaya: /amaya\/([\d\w\.\-]+)/i,
                            SeaMonkey: /seamonkey\/([\d\w\.\-]+)/i,
                            OmniWeb: /omniweb\/v([\d\w\.\-]+)/i,
                            Flock: /flock\/([\d\w\.\-]+)/i,
                            Epiphany: /epiphany\/([\d\w\.\-]+)/i,
                            WinJs: /msapphost\/([\d\w\.\-]+)/i,
                            PhantomJS: /phantomjs\/([\d\w\.\-]+)/i,
                            UC: /UCBrowser\/([\d\w\.]+)/i
                        }, this._Browsers = {
                            Edge: /edge/i,
                            Amaya: /amaya/i,
                            Konqueror: /konqueror/i,
                            Epiphany: /epiphany/i,
                            SeaMonkey: /seamonkey/i,
                            Flock: /flock/i,
                            OmniWeb: /omniweb/i,
                            Chromium: /chromium|crios/i,
                            Chrome: /chrome/i,
                            Safari: /safari/i,
                            IE: /msie|trident/i,
                            Opera: /opera|OPR/i,
                            PS3: /playstation 3/i,
                            PSP: /playstation portable/i,
                            Firefox: /firefox/i,
                            WinJs: /msapphost/i,
                            PhantomJS: /phantomjs/i,
                            UC: /UCBrowser/i
                        }, this._OS = {
                            Windows10: /windows nt 10\.0/i,
                            Windows81: /windows nt 6\.3/i,
                            Windows8: /windows nt 6\.2/i,
                            Windows7: /windows nt 6\.1/i,
                            UnknownWindows: /windows nt 6\.\d+/i,
                            WindowsVista: /windows nt 6\.0/i,
                            Windows2003: /windows nt 5\.2/i,
                            WindowsXP: /windows nt 5\.1/i,
                            Windows2000: /windows nt 5\.0/i,
                            WindowsPhone8: /windows phone 8\./,
                            OSXCheetah: /os x 10[._]0/i,
                            OSXPuma: /os x 10[._]1(\D|$)/i,
                            OSXJaguar: /os x 10[._]2/i,
                            OSXPanther: /os x 10[._]3/i,
                            OSXTiger: /os x 10[._]4/i,
                            OSXLeopard: /os x 10[._]5/i,
                            OSXSnowLeopard: /os x 10[._]6/i,
                            OSXLion: /os x 10[._]7/i,
                            OSXMountainLion: /os x 10[._]8/i,
                            OSXMavericks: /os x 10[._]9/i,
                            OSXYosemite: /os x 10[._]10/i,
                            OSXElCapitan: /os x 10[._]11/i,
                            OSXSierra: /os x 10[._]12/i,
                            Mac: /os x/i,
                            Linux: /linux/i,
                            Linux64: /linux x86_64/i,
                            ChromeOS: /cros/i,
                            Wii: /wii/i,
                            PS3: /playstation 3/i,
                            PSP: /playstation portable/i,
                            iPad: /\(iPad.*os (\d+)[._](\d+)/i,
                            iPhone: /\(iPhone.*os (\d+)[._](\d+)/i,
                            Bada: /Bada\/(\d+)\.(\d+)/i,
                            Curl: /curl\/(\d+)\.(\d+)\.(\d+)/i
                        }, this._Platform = {
                            Windows: /windows nt/i,
                            WindowsPhone: /windows phone/i,
                            Mac: /macintosh/i,
                            Linux: /linux/i,
                            Wii: /wii/i,
                            Playstation: /playstation/i,
                            iPad: /ipad/i,
                            iPod: /ipod/i,
                            iPhone: /iphone/i,
                            Android: /android/i,
                            Blackberry: /blackberry/i,
                            Samsung: /samsung/i,
                            Curl: /curl/i
                        }, this.DefaultAgent = {
                            isAuthoritative: !0,
                            isMobile: !1,
                            isTablet: !1,
                            isiPad: !1,
                            isiPod: !1,
                            isiPhone: !1,
                            isAndroid: !1,
                            isBlackberry: !1,
                            isOpera: !1,
                            isIE: !1,
                            isEdge: !1,
                            isIECompatibilityMode: !1,
                            isSafari: !1,
                            isFirefox: !1,
                            isWebkit: !1,
                            isChrome: !1,
                            isKonqueror: !1,
                            isOmniWeb: !1,
                            isSeaMonkey: !1,
                            isFlock: !1,
                            isAmaya: !1,
                            isPhantomJS: !1,
                            isEpiphany: !1,
                            isDesktop: !1,
                            isWindows: !1,
                            isLinux: !1,
                            isLinux64: !1,
                            isMac: !1,
                            isChromeOS: !1,
                            isBada: !1,
                            isSamsung: !1,
                            isRaspberry: !1,
                            isBot: !1,
                            isCurl: !1,
                            isAndroidTablet: !1,
                            isWinJs: !1,
                            isKindleFire: !1,
                            isSilk: !1,
                            isCaptive: !1,
                            isSmartTV: !1,
                            isUC: !1,
                            isTouchScreen: !1,
                            silkAccelerated: !1,
                            colorDepth: -1,
                            pixelDepth: -1,
                            resolution: [],
                            cpuCores: -1,
                            language: "unknown",
                            browser: "unknown",
                            version: "unknown",
                            os: "unknown",
                            platform: "unknown",
                            geoIp: {},
                            source: "",
                            hashInt: function(t) {
                                var e, r, n, i = 0;
                                if (0 === t.length) return i;
                                for (e = 0, n = t.length; e < n; e++) r = t.charCodeAt(e), i = (i << 5) - i + r, i |= 0;
                                return i
                            },
                            hashMD5: function(t) {
                                function e(t, e) {
                                    return t << e | t >>> 32 - e
                                }

                                function r(t, e) {
                                    var r, n, i, s, a;
                                    return i = 2147483648 & t, s = 2147483648 & e, r = 1073741824 & t, n = 1073741824 & e, a = (1073741823 & t) + (1073741823 & e), r & n ? 2147483648 ^ a ^ i ^ s : r | n ? 1073741824 & a ? 3221225472 ^ a ^ i ^ s : 1073741824 ^ a ^ i ^ s : a ^ i ^ s
                                }

                                function n(t, e, r) {
                                    return t & e | ~t & r
                                }

                                function i(t, e, r) {
                                    return t & r | e & ~r
                                }

                                function s(t, e, r) {
                                    return t ^ e ^ r
                                }

                                function a(t, e, r) {
                                    return e ^ (t | ~r)
                                }

                                function o(t, i, s, a, o, u, h) {
                                    return t = r(t, r(r(n(i, s, a), o), h)), r(e(t, u), i)
                                }

                                function u(t, n, s, a, o, u, h) {
                                    return t = r(t, r(r(i(n, s, a), o), h)), r(e(t, u), n)
                                }

                                function h(t, n, i, a, o, u, h) {
                                    return t = r(t, r(r(s(n, i, a), o), h)), r(e(t, u), n)
                                }

                                function f(t, n, i, s, o, u, h) {
                                    return t = r(t, r(r(a(n, i, s), o), h)), r(e(t, u), n)
                                }

                                function c(t) {
                                    var e, r = t.length,
                                        n = r + 8,
                                        i = (n - n % 64) / 64,
                                        s = 16 * (i + 1),
                                        a = new Array(s - 1),
                                        o = 0,
                                        u = 0;
                                    while (u < r) e = (u - u % 4) / 4, o = u % 4 * 8, a[e] = a[e] | t.charCodeAt(u) << o, u++;
                                    return e = (u - u % 4) / 4, o = u % 4 * 8, a[e] = a[e] | 128 << o, a[s - 2] = r << 3, a[s - 1] = r >>> 29, a
                                }

                                function l(t) {
                                    var e, r, n = "",
                                        i = "";
                                    for (r = 0; r <= 3; r++) e = t >>> 8 * r & 255, i = "0" + e.toString(16), n += i.substr(i.length - 2, 2);
                                    return n
                                }

                                function d(t) {
                                    t = t.replace(/\r\n/g, "\n");
                                    for (var e = "", r = 0; r < t.length; r++) {
                                        var n = t.charCodeAt(r);
                                        n < 128 ? e += String.fromCharCode(n) : n > 127 && n < 2048 ? (e += String.fromCharCode(n >> 6 | 192), e += String.fromCharCode(63 & n | 128)) : (e += String.fromCharCode(n >> 12 | 224), e += String.fromCharCode(n >> 6 & 63 | 128), e += String.fromCharCode(63 & n | 128))
                                    }
                                    return e
                                }
                                var p, m, b, g, y, v, w, _, M, A = [],
                                    S = 7,
                                    x = 12,
                                    E = 17,
                                    k = 22,
                                    R = 5,
                                    O = 9,
                                    I = 14,
                                    P = 20,
                                    T = 4,
                                    N = 11,
                                    j = 16,
                                    C = 23,
                                    z = 6,
                                    D = 10,
                                    L = 15,
                                    F = 21;
                                for (t = d(t), A = c(t), v = 1732584193, w = 4023233417, _ = 2562383102, M = 271733878, p = 0; p < A.length; p += 16) m = v, b = w, g = _, y = M, v = o(v, w, _, M, A[p + 0], S, 3614090360), M = o(M, v, w, _, A[p + 1], x, 3905402710), _ = o(_, M, v, w, A[p + 2], E, 606105819), w = o(w, _, M, v, A[p + 3], k, 3250441966), v = o(v, w, _, M, A[p + 4], S, 4118548399), M = o(M, v, w, _, A[p + 5], x, 1200080426), _ = o(_, M, v, w, A[p + 6], E, 2821735955), w = o(w, _, M, v, A[p + 7], k, 4249261313), v = o(v, w, _, M, A[p + 8], S, 1770035416), M = o(M, v, w, _, A[p + 9], x, 2336552879), _ = o(_, M, v, w, A[p + 10], E, 4294925233), w = o(w, _, M, v, A[p + 11], k, 2304563134), v = o(v, w, _, M, A[p + 12], S, 1804603682), M = o(M, v, w, _, A[p + 13], x, 4254626195), _ = o(_, M, v, w, A[p + 14], E, 2792965006), w = o(w, _, M, v, A[p + 15], k, 1236535329), v = u(v, w, _, M, A[p + 1], R, 4129170786), M = u(M, v, w, _, A[p + 6], O, 3225465664), _ = u(_, M, v, w, A[p + 11], I, 643717713), w = u(w, _, M, v, A[p + 0], P, 3921069994), v = u(v, w, _, M, A[p + 5], R, 3593408605), M = u(M, v, w, _, A[p + 10], O, 38016083), _ = u(_, M, v, w, A[p + 15], I, 3634488961), w = u(w, _, M, v, A[p + 4], P, 3889429448), v = u(v, w, _, M, A[p + 9], R, 568446438), M = u(M, v, w, _, A[p + 14], O, 3275163606), _ = u(_, M, v, w, A[p + 3], I, 4107603335), w = u(w, _, M, v, A[p + 8], P, 1163531501), v = u(v, w, _, M, A[p + 13], R, 2850285829), M = u(M, v, w, _, A[p + 2], O, 4243563512), _ = u(_, M, v, w, A[p + 7], I, 1735328473), w = u(w, _, M, v, A[p + 12], P, 2368359562), v = h(v, w, _, M, A[p + 5], T, 4294588738), M = h(M, v, w, _, A[p + 8], N, 2272392833), _ = h(_, M, v, w, A[p + 11], j, 1839030562), w = h(w, _, M, v, A[p + 14], C, 4259657740), v = h(v, w, _, M, A[p + 1], T, 2763975236), M = h(M, v, w, _, A[p + 4], N, 1272893353), _ = h(_, M, v, w, A[p + 7], j, 4139469664), w = h(w, _, M, v, A[p + 10], C, 3200236656), v = h(v, w, _, M, A[p + 13], T, 681279174), M = h(M, v, w, _, A[p + 0], N, 3936430074), _ = h(_, M, v, w, A[p + 3], j, 3572445317), w = h(w, _, M, v, A[p + 6], C, 76029189), v = h(v, w, _, M, A[p + 9], T, 3654602809), M = h(M, v, w, _, A[p + 12], N, 3873151461), _ = h(_, M, v, w, A[p + 15], j, 530742520), w = h(w, _, M, v, A[p + 2], C, 3299628645), v = f(v, w, _, M, A[p + 0], z, 4096336452), M = f(M, v, w, _, A[p + 7], D, 1126891415), _ = f(_, M, v, w, A[p + 14], L, 2878612391), w = f(w, _, M, v, A[p + 5], F, 4237533241), v = f(v, w, _, M, A[p + 12], z, 1700485571), M = f(M, v, w, _, A[p + 3], D, 2399980690), _ = f(_, M, v, w, A[p + 10], L, 4293915773), w = f(w, _, M, v, A[p + 1], F, 2240044497), v = f(v, w, _, M, A[p + 8], z, 1873313359), M = f(M, v, w, _, A[p + 15], D, 4264355552), _ = f(_, M, v, w, A[p + 6], L, 2734768916), w = f(w, _, M, v, A[p + 13], F, 1309151649), v = f(v, w, _, M, A[p + 4], z, 4149444226), M = f(M, v, w, _, A[p + 11], D, 3174756917), _ = f(_, M, v, w, A[p + 2], L, 718787259), w = f(w, _, M, v, A[p + 9], F, 3951481745), v = r(v, m), w = r(w, b), _ = r(_, g), M = r(M, y);
                                var B = l(v) + l(w) + l(_) + l(M);
                                return B.toLowerCase()
                            }
                        }, this.Agent = {}, this.getBrowser = function(t) {
                            switch (!0) {
                                case this._Browsers.Edge.test(t):
                                    return this.Agent.isEdge = !0, "Edge";
                                case this._Browsers.PhantomJS.test(t):
                                    return this.Agent.isPhantomJS = !0, "PhantomJS";
                                case this._Browsers.Konqueror.test(t):
                                    return this.Agent.isKonqueror = !0, "Konqueror";
                                case this._Browsers.Amaya.test(t):
                                    return this.Agent.isAmaya = !0, "Amaya";
                                case this._Browsers.Epiphany.test(t):
                                    return this.Agent.isEpiphany = !0, "Epiphany";
                                case this._Browsers.SeaMonkey.test(t):
                                    return this.Agent.isSeaMonkey = !0, "SeaMonkey";
                                case this._Browsers.Flock.test(t):
                                    return this.Agent.isFlock = !0, "Flock";
                                case this._Browsers.OmniWeb.test(t):
                                    return this.Agent.isOmniWeb = !0, "OmniWeb";
                                case this._Browsers.Opera.test(t):
                                    return this.Agent.isOpera = !0, "Opera";
                                case this._Browsers.Chromium.test(t):
                                    return this.Agent.isChrome = !0, "Chromium";
                                case this._Browsers.Chrome.test(t):
                                    return this.Agent.isChrome = !0, "Chrome";
                                case this._Browsers.Safari.test(t):
                                    return this.Agent.isSafari = !0, "Safari";
                                case this._Browsers.WinJs.test(t):
                                    return this.Agent.isWinJs = !0, "WinJs";
                                case this._Browsers.IE.test(t):
                                    return this.Agent.isIE = !0, "IE";
                                case this._Browsers.PS3.test(t):
                                    return "ps3";
                                case this._Browsers.PSP.test(t):
                                    return "psp";
                                case this._Browsers.Firefox.test(t):
                                    return this.Agent.isFirefox = !0, "Firefox";
                                case this._Browsers.UC.test(t):
                                    return this.Agent.isUC = !0, "UCBrowser";
                                default:
                                    return 0 !== t.indexOf("Mozilla") && /^([\d\w\-\.]+)\/[\d\w\.\-]+/i.test(t) ? (this.Agent.isAuthoritative = !1, RegExp.$1) : "unknown"
                            }
                        }, this.getBrowserVersion = function(t) {
                            var e;
                            switch (this.Agent.browser) {
                                case "Edge":
                                    if (this._Versions.Edge.test(t)) return RegExp.$1;
                                    break;
                                case "PhantomJS":
                                    if (this._Versions.PhantomJS.test(t)) return RegExp.$1;
                                    break;
                                case "Chrome":
                                    if (this._Versions.Chrome.test(t)) return RegExp.$1;
                                    break;
                                case "Chromium":
                                    if (this._Versions.Chromium.test(t)) return RegExp.$1;
                                    break;
                                case "Safari":
                                    if (this._Versions.Safari.test(t)) return RegExp.$1;
                                    break;
                                case "Opera":
                                    if (this._Versions.Opera.test(t)) return RegExp.$1 ? RegExp.$1 : RegExp.$2;
                                    break;
                                case "Firefox":
                                    if (this._Versions.Firefox.test(t)) return RegExp.$1;
                                    break;
                                case "WinJs":
                                    if (this._Versions.WinJs.test(t)) return RegExp.$1;
                                    break;
                                case "IE":
                                    if (this._Versions.IE.test(t)) return RegExp.$2 ? RegExp.$2 : RegExp.$1;
                                    break;
                                case "ps3":
                                    if (this._Versions.Ps3.test(t)) return RegExp.$1;
                                    break;
                                case "psp":
                                    if (this._Versions.Psp.test(t)) return RegExp.$1;
                                    break;
                                case "Amaya":
                                    if (this._Versions.Amaya.test(t)) return RegExp.$1;
                                    break;
                                case "Epiphany":
                                    if (this._Versions.Epiphany.test(t)) return RegExp.$1;
                                    break;
                                case "SeaMonkey":
                                    if (this._Versions.SeaMonkey.test(t)) return RegExp.$1;
                                    break;
                                case "Flock":
                                    if (this._Versions.Flock.test(t)) return RegExp.$1;
                                    break;
                                case "OmniWeb":
                                    if (this._Versions.OmniWeb.test(t)) return RegExp.$1;
                                    break;
                                case "UCBrowser":
                                    if (this._Versions.UC.test(t)) return RegExp.$1;
                                    break;
                                default:
                                    if ("unknown" !== this.Agent.browser && (e = new RegExp(this.Agent.browser + "[\\/ ]([\\d\\w\\.\\-]+)", "i"), e.test(t))) return RegExp.$1
                            }
                        }, this.getOS = function(t) {
                            switch (!0) {
                                case this._OS.WindowsVista.test(t):
                                    return this.Agent.isWindows = !0, "Windows Vista";
                                case this._OS.Windows7.test(t):
                                    return this.Agent.isWindows = !0, "Windows 7";
                                case this._OS.Windows8.test(t):
                                    return this.Agent.isWindows = !0, "Windows 8";
                                case this._OS.Windows81.test(t):
                                    return this.Agent.isWindows = !0, "Windows 8.1";
                                case this._OS.Windows10.test(t):
                                    return this.Agent.isWindows = !0, "Windows 10.0";
                                case this._OS.Windows2003.test(t):
                                    return this.Agent.isWindows = !0, "Windows 2003";
                                case this._OS.WindowsXP.test(t):
                                    return this.Agent.isWindows = !0, "Windows XP";
                                case this._OS.Windows2000.test(t):
                                    return this.Agent.isWindows = !0, "Windows 2000";
                                case this._OS.WindowsPhone8.test(t):
                                    return "Windows Phone 8";
                                case this._OS.Linux64.test(t):
                                    return this.Agent.isLinux = !0, this.Agent.isLinux64 = !0, "Linux 64";
                                case this._OS.Linux.test(t):
                                    return this.Agent.isLinux = !0, "Linux";
                                case this._OS.ChromeOS.test(t):
                                    return this.Agent.isChromeOS = !0, "Chrome OS";
                                case this._OS.Wii.test(t):
                                    return "Wii";
                                case this._OS.PS3.test(t):
                                    return "Playstation";
                                case this._OS.PSP.test(t):
                                    return "Playstation";
                                case this._OS.OSXCheetah.test(t):
                                    return this.Agent.isMac = !0, "OS X Cheetah";
                                case this._OS.OSXPuma.test(t):
                                    return this.Agent.isMac = !0, "OS X Puma";
                                case this._OS.OSXJaguar.test(t):
                                    return this.Agent.isMac = !0, "OS X Jaguar";
                                case this._OS.OSXPanther.test(t):
                                    return this.Agent.isMac = !0, "OS X Panther";
                                case this._OS.OSXTiger.test(t):
                                    return this.Agent.isMac = !0, "OS X Tiger";
                                case this._OS.OSXLeopard.test(t):
                                    return this.Agent.isMac = !0, "OS X Leopard";
                                case this._OS.OSXSnowLeopard.test(t):
                                    return this.Agent.isMac = !0, "OS X Snow Leopard";
                                case this._OS.OSXLion.test(t):
                                    return this.Agent.isMac = !0, "OS X Lion";
                                case this._OS.OSXMountainLion.test(t):
                                    return this.Agent.isMac = !0, "OS X Mountain Lion";
                                case this._OS.OSXMavericks.test(t):
                                    return this.Agent.isMac = !0, "OS X Mavericks";
                                case this._OS.OSXYosemite.test(t):
                                    return this.Agent.isMac = !0, "OS X Yosemite";
                                case this._OS.OSXElCapitan.test(t):
                                    return this.Agent.isMac = !0, "OS X El Capitan";
                                case this._OS.OSXSierra.test(t):
                                    return this.Agent.isMac = !0, "macOS Sierra";
                                case this._OS.Mac.test(t):
                                    return this.Agent.isMac = !0, "OS X";
                                case this._OS.iPad.test(t):
                                    return this.Agent.isiPad = !0, t.match(this._OS.iPad)[0].replace("_", ".");
                                case this._OS.iPhone.test(t):
                                    return this.Agent.isiPhone = !0, t.match(this._OS.iPhone)[0].replace("_", ".");
                                case this._OS.Bada.test(t):
                                    return this.Agent.isBada = !0, "Bada";
                                case this._OS.Curl.test(t):
                                    return this.Agent.isCurl = !0, "Curl";
                                default:
                                    return "unknown"
                            }
                        }, this.getPlatform = function(t) {
                            switch (!0) {
                                case this._Platform.Windows.test(t):
                                    return "Microsoft Windows";
                                case this._Platform.WindowsPhone.test(t):
                                    return this.Agent.isWindowsPhone = !0, "Microsoft Windows Phone";
                                case this._Platform.Mac.test(t):
                                    return "Apple Mac";
                                case this._Platform.Curl.test(t):
                                    return "Curl";
                                case this._Platform.Android.test(t):
                                    return this.Agent.isAndroid = !0, "Android";
                                case this._Platform.Blackberry.test(t):
                                    return this.Agent.isBlackberry = !0, "Blackberry";
                                case this._Platform.Linux.test(t):
                                    return "Linux";
                                case this._Platform.Wii.test(t):
                                    return "Wii";
                                case this._Platform.Playstation.test(t):
                                    return "Playstation";
                                case this._Platform.iPad.test(t):
                                    return this.Agent.isiPad = !0, "iPad";
                                case this._Platform.iPod.test(t):
                                    return this.Agent.isiPod = !0, "iPod";
                                case this._Platform.iPhone.test(t):
                                    return this.Agent.isiPhone = !0, "iPhone";
                                case this._Platform.Samsung.test(t):
                                    return this.Agent.isiSamsung = !0, "Samsung";
                                default:
                                    return "unknown"
                            }
                        }, this.testCompatibilityMode = function() {
                            var t = this;
                            if (this.Agent.isIE && /Trident\/(\d)\.0/i.test(t.Agent.source)) {
                                var e = parseInt(RegExp.$1, 10),
                                    r = parseInt(t.Agent.version, 10);
                                7 === r && 7 === e && (t.Agent.isIECompatibilityMode = !0, t.Agent.version = 11), 7 === r && 6 === e && (t.Agent.isIECompatibilityMode = !0, t.Agent.version = 10), 7 === r && 5 === e && (t.Agent.isIECompatibilityMode = !0, t.Agent.version = 9), 7 === r && 4 === e && (t.Agent.isIECompatibilityMode = !0, t.Agent.version = 8)
                            }
                        }, this.testSilk = function() {
                            var t = this;
                            switch (!0) {
                                case new RegExp("silk", "gi").test(t.Agent.source):
                                    this.Agent.isSilk = !0;
                                    break;
                                default:
                            }
                            return /Silk-Accelerated=true/gi.test(t.Agent.source) && (this.Agent.SilkAccelerated = !0), !!this.Agent.isSilk && "Silk"
                        }, this.testKindleFire = function() {
                            var t = this;
                            switch (!0) {
                                case /KFOT/gi.test(t.Agent.source):
                                    return this.Agent.isKindleFire = !0, "Kindle Fire";
                                case /KFTT/gi.test(t.Agent.source):
                                    return this.Agent.isKindleFire = !0, "Kindle Fire HD";
                                case /KFJWI/gi.test(t.Agent.source):
                                    return this.Agent.isKindleFire = !0, "Kindle Fire HD 8.9";
                                case /KFJWA/gi.test(t.Agent.source):
                                    return this.Agent.isKindleFire = !0, "Kindle Fire HD 8.9 4G";
                                case /KFSOWI/gi.test(t.Agent.source):
                                    return this.Agent.isKindleFire = !0, "Kindle Fire HD 7";
                                case /KFTHWI/gi.test(t.Agent.source):
                                    return this.Agent.isKindleFire = !0, "Kindle Fire HDX 7";
                                case /KFTHWA/gi.test(t.Agent.source):
                                    return this.Agent.isKindleFire = !0, "Kindle Fire HDX 7 4G";
                                case /KFAPWI/gi.test(t.Agent.source):
                                    return this.Agent.isKindleFire = !0, "Kindle Fire HDX 8.9";
                                case /KFAPWA/gi.test(t.Agent.source):
                                    return this.Agent.isKindleFire = !0, "Kindle Fire HDX 8.9 4G";
                                default:
                                    return !1
                            }
                        }, this.testCaptiveNetwork = function() {
                            var t = this;
                            switch (!0) {
                                case /CaptiveNetwork/gi.test(t.Agent.source):
                                    return t.Agent.isCaptive = !0, t.Agent.isMac = !0, t.Agent.platform = "Apple Mac", "CaptiveNetwork";
                                default:
                                    return !1
                            }
                        }, this.testMobile = function() {
                            var t = this;
                            switch (!0) {
                                case t.Agent.isWindows:
                                case t.Agent.isLinux:
                                case t.Agent.isMac:
                                case t.Agent.isChromeOS:
                                    t.Agent.isDesktop = !0;
                                    break;
                                case t.Agent.isAndroid:
                                case t.Agent.isSamsung:
                                    t.Agent.isMobile = !0, t.Agent.isDesktop = !1;
                                    break;
                                default:
                            }
                            switch (!0) {
                                case t.Agent.isiPad:
                                case t.Agent.isiPod:
                                case t.Agent.isiPhone:
                                case t.Agent.isBada:
                                case t.Agent.isBlackberry:
                                case t.Agent.isAndroid:
                                case t.Agent.isWindowsPhone:
                                    t.Agent.isMobile = !0, t.Agent.isDesktop = !1;
                                    break;
                                default:
                            }
                            /mobile/i.test(t.Agent.source) && (t.Agent.isMobile = !0, t.Agent.isDesktop = !1)
                        }, this.testTablet = function() {
                            var t = this;
                            switch (!0) {
                                case t.Agent.isiPad:
                                case t.Agent.isAndroidTablet:
                                case t.Agent.isKindleFire:
                                    t.Agent.isTablet = !0;
                                    break
                            }
                            /tablet/i.test(t.Agent.source) && (t.Agent.isTablet = !0)
                        }, this.testNginxGeoIP = function(t) {
                            var e = this;
                            Object.keys(t).forEach((function(r) {
                                /^GEOIP/i.test(r) && (e.Agent.geoIp[r] = t[r])
                            }))
                        }, this.testBot = function() {
                            var t = this,
                                e = r.exec(t.Agent.source.toLowerCase());
                            e ? t.Agent.isBot = e[1] : t.Agent.isAuthoritative || (t.Agent.isBot = /bot/i.test(t.Agent.source))
                        }, this.testSmartTV = function() {
                            var t = this,
                                e = new RegExp("smart-tv|smarttv|googletv|appletv|hbbtv|pov_tv|netcast.tv", "gi").exec(t.Agent.source.toLowerCase());
                            e && (t.Agent.isSmartTV = e[1])
                        }, this.testAndroidTablet = function() {
                            var t = this;
                            t.Agent.isAndroid && !/mobile/i.test(t.Agent.source) && (t.Agent.isAndroidTablet = !0)
                        }, this.testTouchSupport = function() {
                            var t = this;
                            t.Agent.isTouchScreen = "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0
                        }, this.getLaguage = function() {
                            var t = this;
                            t.Agent.language = (navigator.language || navigator.userLanguage || navigator.browserLanguage || navigator.systemLanguage || "").toLowerCase()
                        }, this.getColorDepth = function() {
                            var t = this;
                            t.Agent.colorDepth = screen.colorDepth || -1
                        }, this.getScreenResolution = function() {
                            var t = this;
                            t.Agent.resolution = [screen.availWidth, screen.availHeight]
                        }, this.getPixelDepth = function() {
                            var t = this;
                            t.Agent.pixelDepth = screen.pixelDepth || -1
                        }, this.getCPU = function() {
                            var t = this;
                            t.Agent.cpuCores = navigator.hardwareConcurrency || -1
                        }, this.reset = function() {
                            var t = this;
                            for (var e in t.DefaultAgent) t.DefaultAgent.hasOwnProperty(e) && (t.Agent[e] = t.DefaultAgent[e]);
                            return t
                        }, this.parse = function(t) {
                            t = t || navigator.userAgent;
                            var e = new n;
                            return e.Agent.source = t.replace(/^\s*/, "").replace(/\s*$/, ""), e.Agent.os = e.getOS(e.Agent.source), e.Agent.platform = e.getPlatform(e.Agent.source), e.Agent.browser = e.getBrowser(e.Agent.source), e.Agent.version = e.getBrowserVersion(e.Agent.source), e.testBot(), e.testSmartTV(), e.testMobile(), e.testAndroidTablet(), e.testTablet(), e.testCompatibilityMode(), e.testSilk(), e.testKindleFire(), e.testCaptiveNetwork(), e.testTouchSupport(), e.getLaguage(), e.getColorDepth(), e.getPixelDepth(), e.getScreenResolution(), e.getCPU(), e.Agent
                        }, this.get = function(t) {
                            var e = "a",
                                r = this.parse(),
                                n = [];
                            for (var i in this.options) this.options.hasOwnProperty(i) && !0 === this.options[i] && n.push(r[i]);
                            t && n.push(t), !this.options.resolution && r.isMobile && n.push(r.resolution), e = "b";
                            var s = r.hashMD5(n.join(":")),
                                a = [s.slice(0, 8), s.slice(8, 12), "4" + s.slice(12, 15), e + s.slice(15, 18), s.slice(20)];
                            return a.join("-")
                        }, this.Agent = this.DefaultAgent, this
                    };
                t.DeviceUUID = n, new n(navigator.userAgent)
            })(this)
        },
        "66b1": function(t) {
            t.exports = JSON.parse('{"version":"eosio::abi/1.0","types":[{"new_type_name":"account_name","type":"name"},{"new_type_name":"action_name","type":"name"},{"new_type_name":"permission_name","type":"name"}],"structs":[{"name":"permission_level","base":"","fields":[{"name":"actor","type":"account_name"},{"name":"permission","type":"permission_name"}]},{"name":"action","base":"","fields":[{"name":"account","type":"account_name"},{"name":"name","type":"action_name"},{"name":"authorization","type":"permission_level[]"},{"name":"data","type":"bytes"}]},{"name":"extension","base":"","fields":[{"name":"type","type":"uint16"},{"name":"data","type":"bytes"}]},{"name":"transaction_header","base":"","fields":[{"name":"expiration","type":"time_point_sec"},{"name":"ref_block_num","type":"uint16"},{"name":"ref_block_prefix","type":"uint32"},{"name":"max_net_usage_words","type":"varuint32"},{"name":"max_cpu_usage_ms","type":"uint8"},{"name":"delay_sec","type":"varuint32"}]},{"name":"transaction","base":"transaction_header","fields":[{"name":"context_free_actions","type":"action[]"},{"name":"actions","type":"action[]"},{"name":"transaction_extensions","type":"extension[]"}]}]}')
        },
        "676f": function(t, e, r) {
            "use strict";
            var n = r("80af"),
                i = r("3fb5"),
                s = r("ea53"),
                a = r("f3a3");

            function o(t) {
                s.call(this, "mont", t), this.a = new n(t.a, 16).toRed(this.red), this.b = new n(t.b, 16).toRed(this.red), this.i4 = new n(4).toRed(this.red).redInvm(), this.two = new n(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two))
            }

            function u(t, e, r) {
                s.BasePoint.call(this, t, "projective"), null === e && null === r ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new n(e, 16), this.z = new n(r, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)))
            }
            i(o, s), t.exports = o, o.prototype.validate = function(t) {
                var e = t.normalize().x,
                    r = e.redSqr(),
                    n = r.redMul(e).redAdd(r.redMul(this.a)).redAdd(e),
                    i = n.redSqrt();
                return 0 === i.redSqr().cmp(n)
            }, i(u, s.BasePoint), o.prototype.decodePoint = function(t, e) {
                return this.point(a.toArray(t, e), 1)
            }, o.prototype.point = function(t, e) {
                return new u(this, t, e)
            }, o.prototype.pointFromJSON = function(t) {
                return u.fromJSON(this, t)
            }, u.prototype.precompute = function() {}, u.prototype._encode = function() {
                return this.getX().toArray("be", this.curve.p.byteLength())
            }, u.fromJSON = function(t, e) {
                return new u(t, e[0], e[1] || t.one)
            }, u.prototype.inspect = function() {
                return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">"
            }, u.prototype.isInfinity = function() {
                return 0 === this.z.cmpn(0)
            }, u.prototype.dbl = function() {
                var t = this.x.redAdd(this.z),
                    e = t.redSqr(),
                    r = this.x.redSub(this.z),
                    n = r.redSqr(),
                    i = e.redSub(n),
                    s = e.redMul(n),
                    a = i.redMul(n.redAdd(this.curve.a24.redMul(i)));
                return this.curve.point(s, a)
            }, u.prototype.add = function() {
                throw new Error("Not supported on Montgomery curve")
            }, u.prototype.diffAdd = function(t, e) {
                var r = this.x.redAdd(this.z),
                    n = this.x.redSub(this.z),
                    i = t.x.redAdd(t.z),
                    s = t.x.redSub(t.z),
                    a = s.redMul(r),
                    o = i.redMul(n),
                    u = e.z.redMul(a.redAdd(o).redSqr()),
                    h = e.x.redMul(a.redISub(o).redSqr());
                return this.curve.point(u, h)
            }, u.prototype.mul = function(t) {
                for (var e = t.clone(), r = this, n = this.curve.point(null, null), i = this, s = []; 0 !== e.cmpn(0); e.iushrn(1)) s.push(e.andln(1));
                for (var a = s.length - 1; a >= 0; a--) 0 === s[a] ? (r = r.diffAdd(n, i), n = n.dbl()) : (n = r.diffAdd(n, i), r = r.dbl());
                return n
            }, u.prototype.mulAdd = function() {
                throw new Error("Not supported on Montgomery curve")
            }, u.prototype.jumlAdd = function() {
                throw new Error("Not supported on Montgomery curve")
            }, u.prototype.eq = function(t) {
                return 0 === this.getX().cmp(t.getX())
            }, u.prototype.normalize = function() {
                return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this
            }, u.prototype.getX = function() {
                return this.normalize(), this.x.fromRed()
            }
        },
        "6aa2": function(t, e, r) {
            "use strict";
            var n = r("7d92"),
                i = r("7658"),
                s = r("da3e");

            function a(t) {
                if (!(this instanceof a)) return new a(t);
                this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
                var e = i.toArray(t.entropy, t.entropyEnc || "hex"),
                    r = i.toArray(t.nonce, t.nonceEnc || "hex"),
                    n = i.toArray(t.pers, t.persEnc || "hex");
                s(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, r, n)
            }
            t.exports = a, a.prototype._init = function(t, e, r) {
                var n = t.concat(e).concat(r);
                this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
                for (var i = 0; i < this.V.length; i++) this.K[i] = 0, this.V[i] = 1;
                this._update(n), this._reseed = 1, this.reseedInterval = 281474976710656
            }, a.prototype._hmac = function() {
                return new n.hmac(this.hash, this.K)
            }, a.prototype._update = function(t) {
                var e = this._hmac().update(this.V).update([0]);
                t && (e = e.update(t)), this.K = e.digest(), this.V = this._hmac().update(this.V).digest(), t && (this.K = this._hmac().update(this.V).update([1]).update(t).digest(), this.V = this._hmac().update(this.V).digest())
            }, a.prototype.reseed = function(t, e, r, n) {
                "string" !== typeof e && (n = r, r = e, e = null), t = i.toArray(t, e), r = i.toArray(r, n), s(t.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(t.concat(r || [])), this._reseed = 1
            }, a.prototype.generate = function(t, e, r, n) {
                if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
                "string" !== typeof e && (n = r, r = e, e = null), r && (r = i.toArray(r, n || "hex"), this._update(r));
                var s = [];
                while (s.length < t) this.V = this._hmac().update(this.V).digest(), s = s.concat(this.V);
                var a = s.slice(0, t);
                return this._update(r), this._reseed++, i.encode(a, e)
            }
        },
        "6eed": function(t, e, r) {
            "use strict";
            var n = r("c3c0"),
                i = r("edc9"),
                s = r("aa56"),
                a = r("da3e"),
                o = n.sum32,
                u = n.sum32_4,
                h = n.sum32_5,
                f = s.ch32,
                c = s.maj32,
                l = s.s0_256,
                d = s.s1_256,
                p = s.g0_256,
                m = s.g1_256,
                b = i.BlockHash,
                g = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];

            function y() {
                if (!(this instanceof y)) return new y;
                b.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = g, this.W = new Array(64)
            }
            n.inherits(y, b), t.exports = y, y.blockSize = 512, y.outSize = 256, y.hmacStrength = 192, y.padLength = 64, y.prototype._update = function(t, e) {
                for (var r = this.W, n = 0; n < 16; n++) r[n] = t[e + n];
                for (; n < r.length; n++) r[n] = u(m(r[n - 2]), r[n - 7], p(r[n - 15]), r[n - 16]);
                var i = this.h[0],
                    s = this.h[1],
                    b = this.h[2],
                    g = this.h[3],
                    y = this.h[4],
                    v = this.h[5],
                    w = this.h[6],
                    _ = this.h[7];
                for (a(this.k.length === r.length), n = 0; n < r.length; n++) {
                    var M = h(_, d(y), f(y, v, w), this.k[n], r[n]),
                        A = o(l(i), c(i, s, b));
                    _ = w, w = v, v = y, y = o(g, M), g = b, b = s, s = i, i = o(M, A)
                }
                this.h[0] = o(this.h[0], i), this.h[1] = o(this.h[1], s), this.h[2] = o(this.h[2], b), this.h[3] = o(this.h[3], g), this.h[4] = o(this.h[4], y), this.h[5] = o(this.h[5], v), this.h[6] = o(this.h[6], w), this.h[7] = o(this.h[7], _)
            }, y.prototype._digest = function(t) {
                return "hex" === t ? n.toHex32(this.h, "big") : n.split32(this.h, "big")
            }
        },
        "70c1": function(t, e, r) {
            "use strict";
            var n = r("4a87"),
                i = r("a6b6"),
                s = new n(0),
                a = new n(-1),
                o = {
                    noether: "0",
                    wei: "1",
                    kwei: "1000",
                    Kwei: "1000",
                    babbage: "1000",
                    femtoether: "1000",
                    mwei: "1000000",
                    Mwei: "1000000",
                    lovelace: "1000000",
                    picoether: "1000000",
                    gwei: "1000000000",
                    Gwei: "1000000000",
                    shannon: "1000000000",
                    nanoether: "1000000000",
                    nano: "1000000000",
                    szabo: "1000000000000",
                    microether: "1000000000000",
                    micro: "1000000000000",
                    finney: "1000000000000000",
                    milliether: "1000000000000000",
                    milli: "1000000000000000",
                    ether: "1000000000000000000",
                    kether: "1000000000000000000000",
                    grand: "1000000000000000000000",
                    mether: "1000000000000000000000000",
                    gether: "1000000000000000000000000000",
                    tether: "1000000000000000000000000000000"
                };

            function u(t) {
                var e = t ? t.toLowerCase() : "ether",
                    r = o[e];
                if ("string" !== typeof r) throw new Error("[ethjs-unit] the unit provided " + t + " doesn't exists, please use the one of the following units " + JSON.stringify(o, null, 2));
                return new n(r, 10)
            }

            function h(t) {
                if ("string" === typeof t) {
                    if (!t.match(/^-?[0-9.]+$/)) throw new Error("while converting number to string, invalid number value '" + t + "', should be a number matching (^-?[0-9.]+).");
                    return t
                }
                if ("number" === typeof t) return String(t);
                if ("object" === typeof t && t.toString && (t.toTwos || t.dividedToIntegerBy)) return t.toPrecision ? String(t.toPrecision()) : t.toString(10);
                throw new Error("while converting number to string, invalid number value '" + t + "' type " + typeof t + ".")
            }

            function f(t, e, r) {
                var n = i(t),
                    h = n.lt(s),
                    f = u(e),
                    c = o[e].length - 1 || 1,
                    l = r || {};
                h && (n = n.mul(a));
                var d = n.mod(f).toString(10);
                while (d.length < c) d = "0" + d;
                l.pad || (d = d.match(/^([0-9]*[1-9]|0)(0*)/)[1]);
                var p = n.div(f).toString(10);
                l.commify && (p = p.replace(/\B(?=(\d{3})+(?!\d))/g, ","));
                var m = p + ("0" == d ? "" : "." + d);
                return h && (m = "-" + m), m
            }

            function c(t, e) {
                var r = h(t),
                    i = u(e),
                    s = o[e].length - 1 || 1,
                    f = "-" === r.substring(0, 1);
                if (f && (r = r.substring(1)), "." === r) throw new Error("[ethjs-unit] while converting number " + t + " to wei, invalid value");
                var c = r.split(".");
                if (c.length > 2) throw new Error("[ethjs-unit] while converting number " + t + " to wei,  too many decimal points");
                var l = c[0],
                    d = c[1];
                if (l || (l = "0"), d || (d = "0"), d.length > s) throw new Error("[ethjs-unit] while converting number " + t + " to wei, too many decimal places");
                while (d.length < s) d += "0";
                l = new n(l), d = new n(d);
                var p = l.mul(i).add(d);
                return f && (p = p.mul(a)), new n(p.toString(10), 10)
            }
            t.exports = {
                unitMap: o,
                numberToString: h,
                getValueOfUnit: u,
                fromWei: f,
                toWei: c
            }
        },
        7626: function(t) {
            t.exports = JSON.parse('{"version":"eosio::abi/1.1","structs":[{"name":"extensions_entry","base":"","fields":[{"name":"tag","type":"uint16"},{"name":"value","type":"bytes"}]},{"name":"type_def","base":"","fields":[{"name":"new_type_name","type":"string"},{"name":"type","type":"string"}]},{"name":"field_def","base":"","fields":[{"name":"name","type":"string"},{"name":"type","type":"string"}]},{"name":"struct_def","base":"","fields":[{"name":"name","type":"string"},{"name":"base","type":"string"},{"name":"fields","type":"field_def[]"}]},{"name":"action_def","base":"","fields":[{"name":"name","type":"name"},{"name":"type","type":"string"},{"name":"ricardian_contract","type":"string"}]},{"name":"table_def","base":"","fields":[{"name":"name","type":"name"},{"name":"index_type","type":"string"},{"name":"key_names","type":"string[]"},{"name":"key_types","type":"string[]"},{"name":"type","type":"string"}]},{"name":"clause_pair","base":"","fields":[{"name":"id","type":"string"},{"name":"body","type":"string"}]},{"name":"error_message","base":"","fields":[{"name":"error_code","type":"uint64"},{"name":"error_msg","type":"string"}]},{"name":"variant_def","base":"","fields":[{"name":"name","type":"string"},{"name":"types","type":"string[]"}]},{"name":"abi_def","base":"","fields":[{"name":"version","type":"string"},{"name":"types","type":"type_def[]"},{"name":"structs","type":"struct_def[]"},{"name":"actions","type":"action_def[]"},{"name":"tables","type":"table_def[]"},{"name":"ricardian_clauses","type":"clause_pair[]"},{"name":"error_messages","type":"error_message[]"},{"name":"abi_extensions","type":"extensions_entry[]"},{"name":"variants","type":"variant_def[]$"}]}]}')
        },
        "7d92": function(t, e, r) {
            var n = e;
            n.utils = r("c3c0"), n.common = r("edc9"), n.sha = r("5919"), n.ripemd = r("bb44"), n.hmac = r("2137"), n.sha1 = n.sha.sha1, n.sha256 = n.sha.sha256, n.sha224 = n.sha.sha224, n.sha384 = n.sha.sha384, n.sha512 = n.sha.sha512, n.ripemd160 = n.ripemd.ripemd160
        },
        "80af": function(t, e, r) {
            (function(t) {
                (function(t, e) {
                    "use strict";

                    function n(t, e) {
                        if (!t) throw new Error(e || "Assertion failed")
                    }

                    function i(t, e) {
                        t.super_ = e;
                        var r = function() {};
                        r.prototype = e.prototype, t.prototype = new r, t.prototype.constructor = t
                    }

                    function s(t, e, r) {
                        if (s.isBN(t)) return t;
                        this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== t && ("le" !== e && "be" !== e || (r = e, e = 10), this._init(t || 0, e || 10, r || "be"))
                    }
                    var a;
                    "object" === typeof t ? t.exports = s : e.BN = s, s.BN = s, s.wordSize = 26;
                    try {
                        a = r(17).Buffer
                    } catch (E) {}

                    function o(t, e, r) {
                        for (var n = 0, i = Math.min(t.length, r), s = e; s < i; s++) {
                            var a = t.charCodeAt(s) - 48;
                            n <<= 4, n |= a >= 49 && a <= 54 ? a - 49 + 10 : a >= 17 && a <= 22 ? a - 17 + 10 : 15 & a
                        }
                        return n
                    }

                    function u(t, e, r, n) {
                        for (var i = 0, s = Math.min(t.length, r), a = e; a < s; a++) {
                            var o = t.charCodeAt(a) - 48;
                            i *= n, i += o >= 49 ? o - 49 + 10 : o >= 17 ? o - 17 + 10 : o
                        }
                        return i
                    }
                    s.isBN = function(t) {
                        return t instanceof s || null !== t && "object" === typeof t && t.constructor.wordSize === s.wordSize && Array.isArray(t.words)
                    }, s.max = function(t, e) {
                        return t.cmp(e) > 0 ? t : e
                    }, s.min = function(t, e) {
                        return t.cmp(e) < 0 ? t : e
                    }, s.prototype._init = function(t, e, r) {
                        if ("number" === typeof t) return this._initNumber(t, e, r);
                        if ("object" === typeof t) return this._initArray(t, e, r);
                        "hex" === e && (e = 16), n(e === (0 | e) && e >= 2 && e <= 36), t = t.toString().replace(/\s+/g, "");
                        var i = 0;
                        "-" === t[0] && i++, 16 === e ? this._parseHex(t, i) : this._parseBase(t, e, i), "-" === t[0] && (this.negative = 1), this.strip(), "le" === r && this._initArray(this.toArray(), e, r)
                    }, s.prototype._initNumber = function(t, e, r) {
                        t < 0 && (this.negative = 1, t = -t), t < 67108864 ? (this.words = [67108863 & t], this.length = 1) : t < 4503599627370496 ? (this.words = [67108863 & t, t / 67108864 & 67108863], this.length = 2) : (n(t < 9007199254740992), this.words = [67108863 & t, t / 67108864 & 67108863, 1], this.length = 3), "le" === r && this._initArray(this.toArray(), e, r)
                    }, s.prototype._initArray = function(t, e, r) {
                        if (n("number" === typeof t.length), t.length <= 0) return this.words = [0], this.length = 1, this;
                        this.length = Math.ceil(t.length / 3), this.words = new Array(this.length);
                        for (var i = 0; i < this.length; i++) this.words[i] = 0;
                        var s, a, o = 0;
                        if ("be" === r)
                            for (i = t.length - 1, s = 0; i >= 0; i -= 3) a = t[i] | t[i - 1] << 8 | t[i - 2] << 16, this.words[s] |= a << o & 67108863, this.words[s + 1] = a >>> 26 - o & 67108863, o += 24, o >= 26 && (o -= 26, s++);
                        else if ("le" === r)
                            for (i = 0, s = 0; i < t.length; i += 3) a = t[i] | t[i + 1] << 8 | t[i + 2] << 16, this.words[s] |= a << o & 67108863, this.words[s + 1] = a >>> 26 - o & 67108863, o += 24, o >= 26 && (o -= 26, s++);
                        return this.strip()
                    }, s.prototype._parseHex = function(t, e) {
                        this.length = Math.ceil((t.length - e) / 6), this.words = new Array(this.length);
                        for (var r = 0; r < this.length; r++) this.words[r] = 0;
                        var n, i, s = 0;
                        for (r = t.length - 6, n = 0; r >= e; r -= 6) i = o(t, r, r + 6), this.words[n] |= i << s & 67108863, this.words[n + 1] |= i >>> 26 - s & 4194303, s += 24, s >= 26 && (s -= 26, n++);
                        r + 6 !== e && (i = o(t, e, r + 6), this.words[n] |= i << s & 67108863, this.words[n + 1] |= i >>> 26 - s & 4194303), this.strip()
                    }, s.prototype._parseBase = function(t, e, r) {
                        this.words = [0], this.length = 1;
                        for (var n = 0, i = 1; i <= 67108863; i *= e) n++;
                        n--, i = i / e | 0;
                        for (var s = t.length - r, a = s % n, o = Math.min(s, s - a) + r, h = 0, f = r; f < o; f += n) h = u(t, f, f + n, e), this.imuln(i), this.words[0] + h < 67108864 ? this.words[0] += h : this._iaddn(h);
                        if (0 !== a) {
                            var c = 1;
                            for (h = u(t, f, t.length, e), f = 0; f < a; f++) c *= e;
                            this.imuln(c), this.words[0] + h < 67108864 ? this.words[0] += h : this._iaddn(h)
                        }
                    }, s.prototype.copy = function(t) {
                        t.words = new Array(this.length);
                        for (var e = 0; e < this.length; e++) t.words[e] = this.words[e];
                        t.length = this.length, t.negative = this.negative, t.red = this.red
                    }, s.prototype.clone = function() {
                        var t = new s(null);
                        return this.copy(t), t
                    }, s.prototype._expand = function(t) {
                        while (this.length < t) this.words[this.length++] = 0;
                        return this
                    }, s.prototype.strip = function() {
                        while (this.length > 1 && 0 === this.words[this.length - 1]) this.length--;
                        return this._normSign()
                    }, s.prototype._normSign = function() {
                        return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this
                    }, s.prototype.inspect = function() {
                        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
                    };
                    var h = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
                        f = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
                        c = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];

                    function l(t) {
                        for (var e = new Array(t.bitLength()), r = 0; r < e.length; r++) {
                            var n = r / 26 | 0,
                                i = r % 26;
                            e[r] = (t.words[n] & 1 << i) >>> i
                        }
                        return e
                    }

                    function d(t, e, r) {
                        r.negative = e.negative ^ t.negative;
                        var n = t.length + e.length | 0;
                        r.length = n, n = n - 1 | 0;
                        var i = 0 | t.words[0],
                            s = 0 | e.words[0],
                            a = i * s,
                            o = 67108863 & a,
                            u = a / 67108864 | 0;
                        r.words[0] = o;
                        for (var h = 1; h < n; h++) {
                            for (var f = u >>> 26, c = 67108863 & u, l = Math.min(h, e.length - 1), d = Math.max(0, h - t.length + 1); d <= l; d++) {
                                var p = h - d | 0;
                                i = 0 | t.words[p], s = 0 | e.words[d], a = i * s + c, f += a / 67108864 | 0, c = 67108863 & a
                            }
                            r.words[h] = 0 | c, u = 0 | f
                        }
                        return 0 !== u ? r.words[h] = 0 | u : r.length--, r.strip()
                    }
                    s.prototype.toString = function(t, e) {
                        var r;
                        if (t = t || 10, e = 0 | e || 1, 16 === t || "hex" === t) {
                            r = "";
                            for (var i = 0, s = 0, a = 0; a < this.length; a++) {
                                var o = this.words[a],
                                    u = (16777215 & (o << i | s)).toString(16);
                                s = o >>> 24 - i & 16777215, r = 0 !== s || a !== this.length - 1 ? h[6 - u.length] + u + r : u + r, i += 2, i >= 26 && (i -= 26, a--)
                            }
                            0 !== s && (r = s.toString(16) + r);
                            while (r.length % e !== 0) r = "0" + r;
                            return 0 !== this.negative && (r = "-" + r), r
                        }
                        if (t === (0 | t) && t >= 2 && t <= 36) {
                            var l = f[t],
                                d = c[t];
                            r = "";
                            var p = this.clone();
                            p.negative = 0;
                            while (!p.isZero()) {
                                var m = p.modn(d).toString(t);
                                p = p.idivn(d), r = p.isZero() ? m + r : h[l - m.length] + m + r
                            }
                            this.isZero() && (r = "0" + r);
                            while (r.length % e !== 0) r = "0" + r;
                            return 0 !== this.negative && (r = "-" + r), r
                        }
                        n(!1, "Base should be between 2 and 36")
                    }, s.prototype.toNumber = function() {
                        var t = this.words[0];
                        return 2 === this.length ? t += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? t += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), 0 !== this.negative ? -t : t
                    }, s.prototype.toJSON = function() {
                        return this.toString(16)
                    }, s.prototype.toBuffer = function(t, e) {
                        return n("undefined" !== typeof a), this.toArrayLike(a, t, e)
                    }, s.prototype.toArray = function(t, e) {
                        return this.toArrayLike(Array, t, e)
                    }, s.prototype.toArrayLike = function(t, e, r) {
                        var i = this.byteLength(),
                            s = r || Math.max(1, i);
                        n(i <= s, "byte array longer than desired length"), n(s > 0, "Requested array length <= 0"), this.strip();
                        var a, o, u = "le" === e,
                            h = new t(s),
                            f = this.clone();
                        if (u) {
                            for (o = 0; !f.isZero(); o++) a = f.andln(255), f.iushrn(8), h[o] = a;
                            for (; o < s; o++) h[o] = 0
                        } else {
                            for (o = 0; o < s - i; o++) h[o] = 0;
                            for (o = 0; !f.isZero(); o++) a = f.andln(255), f.iushrn(8), h[s - o - 1] = a
                        }
                        return h
                    }, Math.clz32 ? s.prototype._countBits = function(t) {
                        return 32 - Math.clz32(t)
                    } : s.prototype._countBits = function(t) {
                        var e = t,
                            r = 0;
                        return e >= 4096 && (r += 13, e >>>= 13), e >= 64 && (r += 7, e >>>= 7), e >= 8 && (r += 4, e >>>= 4), e >= 2 && (r += 2, e >>>= 2), r + e
                    }, s.prototype._zeroBits = function(t) {
                        if (0 === t) return 26;
                        var e = t,
                            r = 0;
                        return 0 === (8191 & e) && (r += 13, e >>>= 13), 0 === (127 & e) && (r += 7, e >>>= 7), 0 === (15 & e) && (r += 4, e >>>= 4), 0 === (3 & e) && (r += 2, e >>>= 2), 0 === (1 & e) && r++, r
                    }, s.prototype.bitLength = function() {
                        var t = this.words[this.length - 1],
                            e = this._countBits(t);
                        return 26 * (this.length - 1) + e
                    }, s.prototype.zeroBits = function() {
                        if (this.isZero()) return 0;
                        for (var t = 0, e = 0; e < this.length; e++) {
                            var r = this._zeroBits(this.words[e]);
                            if (t += r, 26 !== r) break
                        }
                        return t
                    }, s.prototype.byteLength = function() {
                        return Math.ceil(this.bitLength() / 8)
                    }, s.prototype.toTwos = function(t) {
                        return 0 !== this.negative ? this.abs().inotn(t).iaddn(1) : this.clone()
                    }, s.prototype.fromTwos = function(t) {
                        return this.testn(t - 1) ? this.notn(t).iaddn(1).ineg() : this.clone()
                    }, s.prototype.isNeg = function() {
                        return 0 !== this.negative
                    }, s.prototype.neg = function() {
                        return this.clone().ineg()
                    }, s.prototype.ineg = function() {
                        return this.isZero() || (this.negative ^= 1), this
                    }, s.prototype.iuor = function(t) {
                        while (this.length < t.length) this.words[this.length++] = 0;
                        for (var e = 0; e < t.length; e++) this.words[e] = this.words[e] | t.words[e];
                        return this.strip()
                    }, s.prototype.ior = function(t) {
                        return n(0 === (this.negative | t.negative)), this.iuor(t)
                    }, s.prototype.or = function(t) {
                        return this.length > t.length ? this.clone().ior(t) : t.clone().ior(this)
                    }, s.prototype.uor = function(t) {
                        return this.length > t.length ? this.clone().iuor(t) : t.clone().iuor(this)
                    }, s.prototype.iuand = function(t) {
                        var e;
                        e = this.length > t.length ? t : this;
                        for (var r = 0; r < e.length; r++) this.words[r] = this.words[r] & t.words[r];
                        return this.length = e.length, this.strip()
                    }, s.prototype.iand = function(t) {
                        return n(0 === (this.negative | t.negative)), this.iuand(t)
                    }, s.prototype.and = function(t) {
                        return this.length > t.length ? this.clone().iand(t) : t.clone().iand(this)
                    }, s.prototype.uand = function(t) {
                        return this.length > t.length ? this.clone().iuand(t) : t.clone().iuand(this)
                    }, s.prototype.iuxor = function(t) {
                        var e, r;
                        this.length > t.length ? (e = this, r = t) : (e = t, r = this);
                        for (var n = 0; n < r.length; n++) this.words[n] = e.words[n] ^ r.words[n];
                        if (this !== e)
                            for (; n < e.length; n++) this.words[n] = e.words[n];
                        return this.length = e.length, this.strip()
                    }, s.prototype.ixor = function(t) {
                        return n(0 === (this.negative | t.negative)), this.iuxor(t)
                    }, s.prototype.xor = function(t) {
                        return this.length > t.length ? this.clone().ixor(t) : t.clone().ixor(this)
                    }, s.prototype.uxor = function(t) {
                        return this.length > t.length ? this.clone().iuxor(t) : t.clone().iuxor(this)
                    }, s.prototype.inotn = function(t) {
                        n("number" === typeof t && t >= 0);
                        var e = 0 | Math.ceil(t / 26),
                            r = t % 26;
                        this._expand(e), r > 0 && e--;
                        for (var i = 0; i < e; i++) this.words[i] = 67108863 & ~this.words[i];
                        return r > 0 && (this.words[i] = ~this.words[i] & 67108863 >> 26 - r), this.strip()
                    }, s.prototype.notn = function(t) {
                        return this.clone().inotn(t)
                    }, s.prototype.setn = function(t, e) {
                        n("number" === typeof t && t >= 0);
                        var r = t / 26 | 0,
                            i = t % 26;
                        return this._expand(r + 1), this.words[r] = e ? this.words[r] | 1 << i : this.words[r] & ~(1 << i), this.strip()
                    }, s.prototype.iadd = function(t) {
                        var e, r, n;
                        if (0 !== this.negative && 0 === t.negative) return this.negative = 0, e = this.isub(t), this.negative ^= 1, this._normSign();
                        if (0 === this.negative && 0 !== t.negative) return t.negative = 0, e = this.isub(t), t.negative = 1, e._normSign();
                        this.length > t.length ? (r = this, n = t) : (r = t, n = this);
                        for (var i = 0, s = 0; s < n.length; s++) e = (0 | r.words[s]) + (0 | n.words[s]) + i, this.words[s] = 67108863 & e, i = e >>> 26;
                        for (; 0 !== i && s < r.length; s++) e = (0 | r.words[s]) + i, this.words[s] = 67108863 & e, i = e >>> 26;
                        if (this.length = r.length, 0 !== i) this.words[this.length] = i, this.length++;
                        else if (r !== this)
                            for (; s < r.length; s++) this.words[s] = r.words[s];
                        return this
                    }, s.prototype.add = function(t) {
                        var e;
                        return 0 !== t.negative && 0 === this.negative ? (t.negative = 0, e = this.sub(t), t.negative ^= 1, e) : 0 === t.negative && 0 !== this.negative ? (this.negative = 0, e = t.sub(this), this.negative = 1, e) : this.length > t.length ? this.clone().iadd(t) : t.clone().iadd(this)
                    }, s.prototype.isub = function(t) {
                        if (0 !== t.negative) {
                            t.negative = 0;
                            var e = this.iadd(t);
                            return t.negative = 1, e._normSign()
                        }
                        if (0 !== this.negative) return this.negative = 0, this.iadd(t), this.negative = 1, this._normSign();
                        var r, n, i = this.cmp(t);
                        if (0 === i) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
                        i > 0 ? (r = this, n = t) : (r = t, n = this);
                        for (var s = 0, a = 0; a < n.length; a++) e = (0 | r.words[a]) - (0 | n.words[a]) + s, s = e >> 26, this.words[a] = 67108863 & e;
                        for (; 0 !== s && a < r.length; a++) e = (0 | r.words[a]) + s, s = e >> 26, this.words[a] = 67108863 & e;
                        if (0 === s && a < r.length && r !== this)
                            for (; a < r.length; a++) this.words[a] = r.words[a];
                        return this.length = Math.max(this.length, a), r !== this && (this.negative = 1), this.strip()
                    }, s.prototype.sub = function(t) {
                        return this.clone().isub(t)
                    };
                    var p = function(t, e, r) {
                        var n, i, s, a = t.words,
                            o = e.words,
                            u = r.words,
                            h = 0,
                            f = 0 | a[0],
                            c = 8191 & f,
                            l = f >>> 13,
                            d = 0 | a[1],
                            p = 8191 & d,
                            m = d >>> 13,
                            b = 0 | a[2],
                            g = 8191 & b,
                            y = b >>> 13,
                            v = 0 | a[3],
                            w = 8191 & v,
                            _ = v >>> 13,
                            M = 0 | a[4],
                            A = 8191 & M,
                            S = M >>> 13,
                            x = 0 | a[5],
                            E = 8191 & x,
                            k = x >>> 13,
                            R = 0 | a[6],
                            O = 8191 & R,
                            I = R >>> 13,
                            P = 0 | a[7],
                            T = 8191 & P,
                            N = P >>> 13,
                            j = 0 | a[8],
                            C = 8191 & j,
                            z = j >>> 13,
                            D = 0 | a[9],
                            L = 8191 & D,
                            F = D >>> 13,
                            B = 0 | o[0],
                            $ = 8191 & B,
                            U = B >>> 13,
                            q = 0 | o[1],
                            K = 8191 & q,
                            V = q >>> 13,
                            W = 0 | o[2],
                            Z = 8191 & W,
                            H = W >>> 13,
                            G = 0 | o[3],
                            J = 8191 & G,
                            X = G >>> 13,
                            Y = 0 | o[4],
                            Q = 8191 & Y,
                            tt = Y >>> 13,
                            et = 0 | o[5],
                            rt = 8191 & et,
                            nt = et >>> 13,
                            it = 0 | o[6],
                            st = 8191 & it,
                            at = it >>> 13,
                            ot = 0 | o[7],
                            ut = 8191 & ot,
                            ht = ot >>> 13,
                            ft = 0 | o[8],
                            ct = 8191 & ft,
                            lt = ft >>> 13,
                            dt = 0 | o[9],
                            pt = 8191 & dt,
                            mt = dt >>> 13;
                        r.negative = t.negative ^ e.negative, r.length = 19, n = Math.imul(c, $), i = Math.imul(c, U), i = i + Math.imul(l, $) | 0, s = Math.imul(l, U);
                        var bt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, n = Math.imul(p, $), i = Math.imul(p, U), i = i + Math.imul(m, $) | 0, s = Math.imul(m, U), n = n + Math.imul(c, K) | 0, i = i + Math.imul(c, V) | 0, i = i + Math.imul(l, K) | 0, s = s + Math.imul(l, V) | 0;
                        var gt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (gt >>> 26) | 0, gt &= 67108863, n = Math.imul(g, $), i = Math.imul(g, U), i = i + Math.imul(y, $) | 0, s = Math.imul(y, U), n = n + Math.imul(p, K) | 0, i = i + Math.imul(p, V) | 0, i = i + Math.imul(m, K) | 0, s = s + Math.imul(m, V) | 0, n = n + Math.imul(c, Z) | 0, i = i + Math.imul(c, H) | 0, i = i + Math.imul(l, Z) | 0, s = s + Math.imul(l, H) | 0;
                        var yt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, n = Math.imul(w, $), i = Math.imul(w, U), i = i + Math.imul(_, $) | 0, s = Math.imul(_, U), n = n + Math.imul(g, K) | 0, i = i + Math.imul(g, V) | 0, i = i + Math.imul(y, K) | 0, s = s + Math.imul(y, V) | 0, n = n + Math.imul(p, Z) | 0, i = i + Math.imul(p, H) | 0, i = i + Math.imul(m, Z) | 0, s = s + Math.imul(m, H) | 0, n = n + Math.imul(c, J) | 0, i = i + Math.imul(c, X) | 0, i = i + Math.imul(l, J) | 0, s = s + Math.imul(l, X) | 0;
                        var vt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, n = Math.imul(A, $), i = Math.imul(A, U), i = i + Math.imul(S, $) | 0, s = Math.imul(S, U), n = n + Math.imul(w, K) | 0, i = i + Math.imul(w, V) | 0, i = i + Math.imul(_, K) | 0, s = s + Math.imul(_, V) | 0, n = n + Math.imul(g, Z) | 0, i = i + Math.imul(g, H) | 0, i = i + Math.imul(y, Z) | 0, s = s + Math.imul(y, H) | 0, n = n + Math.imul(p, J) | 0, i = i + Math.imul(p, X) | 0, i = i + Math.imul(m, J) | 0, s = s + Math.imul(m, X) | 0, n = n + Math.imul(c, Q) | 0, i = i + Math.imul(c, tt) | 0, i = i + Math.imul(l, Q) | 0, s = s + Math.imul(l, tt) | 0;
                        var wt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, n = Math.imul(E, $), i = Math.imul(E, U), i = i + Math.imul(k, $) | 0, s = Math.imul(k, U), n = n + Math.imul(A, K) | 0, i = i + Math.imul(A, V) | 0, i = i + Math.imul(S, K) | 0, s = s + Math.imul(S, V) | 0, n = n + Math.imul(w, Z) | 0, i = i + Math.imul(w, H) | 0, i = i + Math.imul(_, Z) | 0, s = s + Math.imul(_, H) | 0, n = n + Math.imul(g, J) | 0, i = i + Math.imul(g, X) | 0, i = i + Math.imul(y, J) | 0, s = s + Math.imul(y, X) | 0, n = n + Math.imul(p, Q) | 0, i = i + Math.imul(p, tt) | 0, i = i + Math.imul(m, Q) | 0, s = s + Math.imul(m, tt) | 0, n = n + Math.imul(c, rt) | 0, i = i + Math.imul(c, nt) | 0, i = i + Math.imul(l, rt) | 0, s = s + Math.imul(l, nt) | 0;
                        var _t = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, n = Math.imul(O, $), i = Math.imul(O, U), i = i + Math.imul(I, $) | 0, s = Math.imul(I, U), n = n + Math.imul(E, K) | 0, i = i + Math.imul(E, V) | 0, i = i + Math.imul(k, K) | 0, s = s + Math.imul(k, V) | 0, n = n + Math.imul(A, Z) | 0, i = i + Math.imul(A, H) | 0, i = i + Math.imul(S, Z) | 0, s = s + Math.imul(S, H) | 0, n = n + Math.imul(w, J) | 0, i = i + Math.imul(w, X) | 0, i = i + Math.imul(_, J) | 0, s = s + Math.imul(_, X) | 0, n = n + Math.imul(g, Q) | 0, i = i + Math.imul(g, tt) | 0, i = i + Math.imul(y, Q) | 0, s = s + Math.imul(y, tt) | 0, n = n + Math.imul(p, rt) | 0, i = i + Math.imul(p, nt) | 0, i = i + Math.imul(m, rt) | 0, s = s + Math.imul(m, nt) | 0, n = n + Math.imul(c, st) | 0, i = i + Math.imul(c, at) | 0, i = i + Math.imul(l, st) | 0, s = s + Math.imul(l, at) | 0;
                        var Mt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, n = Math.imul(T, $), i = Math.imul(T, U), i = i + Math.imul(N, $) | 0, s = Math.imul(N, U), n = n + Math.imul(O, K) | 0, i = i + Math.imul(O, V) | 0, i = i + Math.imul(I, K) | 0, s = s + Math.imul(I, V) | 0, n = n + Math.imul(E, Z) | 0, i = i + Math.imul(E, H) | 0, i = i + Math.imul(k, Z) | 0, s = s + Math.imul(k, H) | 0, n = n + Math.imul(A, J) | 0, i = i + Math.imul(A, X) | 0, i = i + Math.imul(S, J) | 0, s = s + Math.imul(S, X) | 0, n = n + Math.imul(w, Q) | 0, i = i + Math.imul(w, tt) | 0, i = i + Math.imul(_, Q) | 0, s = s + Math.imul(_, tt) | 0, n = n + Math.imul(g, rt) | 0, i = i + Math.imul(g, nt) | 0, i = i + Math.imul(y, rt) | 0, s = s + Math.imul(y, nt) | 0, n = n + Math.imul(p, st) | 0, i = i + Math.imul(p, at) | 0, i = i + Math.imul(m, st) | 0, s = s + Math.imul(m, at) | 0, n = n + Math.imul(c, ut) | 0, i = i + Math.imul(c, ht) | 0, i = i + Math.imul(l, ut) | 0, s = s + Math.imul(l, ht) | 0;
                        var At = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, n = Math.imul(C, $), i = Math.imul(C, U), i = i + Math.imul(z, $) | 0, s = Math.imul(z, U), n = n + Math.imul(T, K) | 0, i = i + Math.imul(T, V) | 0, i = i + Math.imul(N, K) | 0, s = s + Math.imul(N, V) | 0, n = n + Math.imul(O, Z) | 0, i = i + Math.imul(O, H) | 0, i = i + Math.imul(I, Z) | 0, s = s + Math.imul(I, H) | 0, n = n + Math.imul(E, J) | 0, i = i + Math.imul(E, X) | 0, i = i + Math.imul(k, J) | 0, s = s + Math.imul(k, X) | 0, n = n + Math.imul(A, Q) | 0, i = i + Math.imul(A, tt) | 0, i = i + Math.imul(S, Q) | 0, s = s + Math.imul(S, tt) | 0, n = n + Math.imul(w, rt) | 0, i = i + Math.imul(w, nt) | 0, i = i + Math.imul(_, rt) | 0, s = s + Math.imul(_, nt) | 0, n = n + Math.imul(g, st) | 0, i = i + Math.imul(g, at) | 0, i = i + Math.imul(y, st) | 0, s = s + Math.imul(y, at) | 0, n = n + Math.imul(p, ut) | 0, i = i + Math.imul(p, ht) | 0, i = i + Math.imul(m, ut) | 0, s = s + Math.imul(m, ht) | 0, n = n + Math.imul(c, ct) | 0, i = i + Math.imul(c, lt) | 0, i = i + Math.imul(l, ct) | 0, s = s + Math.imul(l, lt) | 0;
                        var St = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, n = Math.imul(L, $), i = Math.imul(L, U), i = i + Math.imul(F, $) | 0, s = Math.imul(F, U), n = n + Math.imul(C, K) | 0, i = i + Math.imul(C, V) | 0, i = i + Math.imul(z, K) | 0, s = s + Math.imul(z, V) | 0, n = n + Math.imul(T, Z) | 0, i = i + Math.imul(T, H) | 0, i = i + Math.imul(N, Z) | 0, s = s + Math.imul(N, H) | 0, n = n + Math.imul(O, J) | 0, i = i + Math.imul(O, X) | 0, i = i + Math.imul(I, J) | 0, s = s + Math.imul(I, X) | 0, n = n + Math.imul(E, Q) | 0, i = i + Math.imul(E, tt) | 0, i = i + Math.imul(k, Q) | 0, s = s + Math.imul(k, tt) | 0, n = n + Math.imul(A, rt) | 0, i = i + Math.imul(A, nt) | 0, i = i + Math.imul(S, rt) | 0, s = s + Math.imul(S, nt) | 0, n = n + Math.imul(w, st) | 0, i = i + Math.imul(w, at) | 0, i = i + Math.imul(_, st) | 0, s = s + Math.imul(_, at) | 0, n = n + Math.imul(g, ut) | 0, i = i + Math.imul(g, ht) | 0, i = i + Math.imul(y, ut) | 0, s = s + Math.imul(y, ht) | 0, n = n + Math.imul(p, ct) | 0, i = i + Math.imul(p, lt) | 0, i = i + Math.imul(m, ct) | 0, s = s + Math.imul(m, lt) | 0, n = n + Math.imul(c, pt) | 0, i = i + Math.imul(c, mt) | 0, i = i + Math.imul(l, pt) | 0, s = s + Math.imul(l, mt) | 0;
                        var xt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, n = Math.imul(L, K), i = Math.imul(L, V), i = i + Math.imul(F, K) | 0, s = Math.imul(F, V), n = n + Math.imul(C, Z) | 0, i = i + Math.imul(C, H) | 0, i = i + Math.imul(z, Z) | 0, s = s + Math.imul(z, H) | 0, n = n + Math.imul(T, J) | 0, i = i + Math.imul(T, X) | 0, i = i + Math.imul(N, J) | 0, s = s + Math.imul(N, X) | 0, n = n + Math.imul(O, Q) | 0, i = i + Math.imul(O, tt) | 0, i = i + Math.imul(I, Q) | 0, s = s + Math.imul(I, tt) | 0, n = n + Math.imul(E, rt) | 0, i = i + Math.imul(E, nt) | 0, i = i + Math.imul(k, rt) | 0, s = s + Math.imul(k, nt) | 0, n = n + Math.imul(A, st) | 0, i = i + Math.imul(A, at) | 0, i = i + Math.imul(S, st) | 0, s = s + Math.imul(S, at) | 0, n = n + Math.imul(w, ut) | 0, i = i + Math.imul(w, ht) | 0, i = i + Math.imul(_, ut) | 0, s = s + Math.imul(_, ht) | 0, n = n + Math.imul(g, ct) | 0, i = i + Math.imul(g, lt) | 0, i = i + Math.imul(y, ct) | 0, s = s + Math.imul(y, lt) | 0, n = n + Math.imul(p, pt) | 0, i = i + Math.imul(p, mt) | 0, i = i + Math.imul(m, pt) | 0, s = s + Math.imul(m, mt) | 0;
                        var Et = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, n = Math.imul(L, Z), i = Math.imul(L, H), i = i + Math.imul(F, Z) | 0, s = Math.imul(F, H), n = n + Math.imul(C, J) | 0, i = i + Math.imul(C, X) | 0, i = i + Math.imul(z, J) | 0, s = s + Math.imul(z, X) | 0, n = n + Math.imul(T, Q) | 0, i = i + Math.imul(T, tt) | 0, i = i + Math.imul(N, Q) | 0, s = s + Math.imul(N, tt) | 0, n = n + Math.imul(O, rt) | 0, i = i + Math.imul(O, nt) | 0, i = i + Math.imul(I, rt) | 0, s = s + Math.imul(I, nt) | 0, n = n + Math.imul(E, st) | 0, i = i + Math.imul(E, at) | 0, i = i + Math.imul(k, st) | 0, s = s + Math.imul(k, at) | 0, n = n + Math.imul(A, ut) | 0, i = i + Math.imul(A, ht) | 0, i = i + Math.imul(S, ut) | 0, s = s + Math.imul(S, ht) | 0, n = n + Math.imul(w, ct) | 0, i = i + Math.imul(w, lt) | 0, i = i + Math.imul(_, ct) | 0, s = s + Math.imul(_, lt) | 0, n = n + Math.imul(g, pt) | 0, i = i + Math.imul(g, mt) | 0, i = i + Math.imul(y, pt) | 0, s = s + Math.imul(y, mt) | 0;
                        var kt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, n = Math.imul(L, J), i = Math.imul(L, X), i = i + Math.imul(F, J) | 0, s = Math.imul(F, X), n = n + Math.imul(C, Q) | 0, i = i + Math.imul(C, tt) | 0, i = i + Math.imul(z, Q) | 0, s = s + Math.imul(z, tt) | 0, n = n + Math.imul(T, rt) | 0, i = i + Math.imul(T, nt) | 0, i = i + Math.imul(N, rt) | 0, s = s + Math.imul(N, nt) | 0, n = n + Math.imul(O, st) | 0, i = i + Math.imul(O, at) | 0, i = i + Math.imul(I, st) | 0, s = s + Math.imul(I, at) | 0, n = n + Math.imul(E, ut) | 0, i = i + Math.imul(E, ht) | 0, i = i + Math.imul(k, ut) | 0, s = s + Math.imul(k, ht) | 0, n = n + Math.imul(A, ct) | 0, i = i + Math.imul(A, lt) | 0, i = i + Math.imul(S, ct) | 0, s = s + Math.imul(S, lt) | 0, n = n + Math.imul(w, pt) | 0, i = i + Math.imul(w, mt) | 0, i = i + Math.imul(_, pt) | 0, s = s + Math.imul(_, mt) | 0;
                        var Rt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, n = Math.imul(L, Q), i = Math.imul(L, tt), i = i + Math.imul(F, Q) | 0, s = Math.imul(F, tt), n = n + Math.imul(C, rt) | 0, i = i + Math.imul(C, nt) | 0, i = i + Math.imul(z, rt) | 0, s = s + Math.imul(z, nt) | 0, n = n + Math.imul(T, st) | 0, i = i + Math.imul(T, at) | 0, i = i + Math.imul(N, st) | 0, s = s + Math.imul(N, at) | 0, n = n + Math.imul(O, ut) | 0, i = i + Math.imul(O, ht) | 0, i = i + Math.imul(I, ut) | 0, s = s + Math.imul(I, ht) | 0, n = n + Math.imul(E, ct) | 0, i = i + Math.imul(E, lt) | 0, i = i + Math.imul(k, ct) | 0, s = s + Math.imul(k, lt) | 0, n = n + Math.imul(A, pt) | 0, i = i + Math.imul(A, mt) | 0, i = i + Math.imul(S, pt) | 0, s = s + Math.imul(S, mt) | 0;
                        var Ot = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, n = Math.imul(L, rt), i = Math.imul(L, nt), i = i + Math.imul(F, rt) | 0, s = Math.imul(F, nt), n = n + Math.imul(C, st) | 0, i = i + Math.imul(C, at) | 0, i = i + Math.imul(z, st) | 0, s = s + Math.imul(z, at) | 0, n = n + Math.imul(T, ut) | 0, i = i + Math.imul(T, ht) | 0, i = i + Math.imul(N, ut) | 0, s = s + Math.imul(N, ht) | 0, n = n + Math.imul(O, ct) | 0, i = i + Math.imul(O, lt) | 0, i = i + Math.imul(I, ct) | 0, s = s + Math.imul(I, lt) | 0, n = n + Math.imul(E, pt) | 0, i = i + Math.imul(E, mt) | 0, i = i + Math.imul(k, pt) | 0, s = s + Math.imul(k, mt) | 0;
                        var It = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, n = Math.imul(L, st), i = Math.imul(L, at), i = i + Math.imul(F, st) | 0, s = Math.imul(F, at), n = n + Math.imul(C, ut) | 0, i = i + Math.imul(C, ht) | 0, i = i + Math.imul(z, ut) | 0, s = s + Math.imul(z, ht) | 0, n = n + Math.imul(T, ct) | 0, i = i + Math.imul(T, lt) | 0, i = i + Math.imul(N, ct) | 0, s = s + Math.imul(N, lt) | 0, n = n + Math.imul(O, pt) | 0, i = i + Math.imul(O, mt) | 0, i = i + Math.imul(I, pt) | 0, s = s + Math.imul(I, mt) | 0;
                        var Pt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, n = Math.imul(L, ut), i = Math.imul(L, ht), i = i + Math.imul(F, ut) | 0, s = Math.imul(F, ht), n = n + Math.imul(C, ct) | 0, i = i + Math.imul(C, lt) | 0, i = i + Math.imul(z, ct) | 0, s = s + Math.imul(z, lt) | 0, n = n + Math.imul(T, pt) | 0, i = i + Math.imul(T, mt) | 0, i = i + Math.imul(N, pt) | 0, s = s + Math.imul(N, mt) | 0;
                        var Tt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, n = Math.imul(L, ct), i = Math.imul(L, lt), i = i + Math.imul(F, ct) | 0, s = Math.imul(F, lt), n = n + Math.imul(C, pt) | 0, i = i + Math.imul(C, mt) | 0, i = i + Math.imul(z, pt) | 0, s = s + Math.imul(z, mt) | 0;
                        var Nt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        h = (s + (i >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, n = Math.imul(L, pt), i = Math.imul(L, mt), i = i + Math.imul(F, pt) | 0, s = Math.imul(F, mt);
                        var jt = (h + n | 0) + ((8191 & i) << 13) | 0;
                        return h = (s + (i >>> 13) | 0) + (jt >>> 26) | 0, jt &= 67108863, u[0] = bt, u[1] = gt, u[2] = yt, u[3] = vt, u[4] = wt, u[5] = _t, u[6] = Mt, u[7] = At, u[8] = St, u[9] = xt, u[10] = Et, u[11] = kt, u[12] = Rt, u[13] = Ot, u[14] = It, u[15] = Pt, u[16] = Tt, u[17] = Nt, u[18] = jt, 0 !== h && (u[19] = h, r.length++), r
                    };

                    function m(t, e, r) {
                        r.negative = e.negative ^ t.negative, r.length = t.length + e.length;
                        for (var n = 0, i = 0, s = 0; s < r.length - 1; s++) {
                            var a = i;
                            i = 0;
                            for (var o = 67108863 & n, u = Math.min(s, e.length - 1), h = Math.max(0, s - t.length + 1); h <= u; h++) {
                                var f = s - h,
                                    c = 0 | t.words[f],
                                    l = 0 | e.words[h],
                                    d = c * l,
                                    p = 67108863 & d;
                                a = a + (d / 67108864 | 0) | 0, p = p + o | 0, o = 67108863 & p, a = a + (p >>> 26) | 0, i += a >>> 26, a &= 67108863
                            }
                            r.words[s] = o, n = a, a = i
                        }
                        return 0 !== n ? r.words[s] = n : r.length--, r.strip()
                    }

                    function b(t, e, r) {
                        var n = new g;
                        return n.mulp(t, e, r)
                    }

                    function g(t, e) {
                        this.x = t, this.y = e
                    }
                    Math.imul || (p = d), s.prototype.mulTo = function(t, e) {
                        var r, n = this.length + t.length;
                        return r = 10 === this.length && 10 === t.length ? p(this, t, e) : n < 63 ? d(this, t, e) : n < 1024 ? m(this, t, e) : b(this, t, e), r
                    }, g.prototype.makeRBT = function(t) {
                        for (var e = new Array(t), r = s.prototype._countBits(t) - 1, n = 0; n < t; n++) e[n] = this.revBin(n, r, t);
                        return e
                    }, g.prototype.revBin = function(t, e, r) {
                        if (0 === t || t === r - 1) return t;
                        for (var n = 0, i = 0; i < e; i++) n |= (1 & t) << e - i - 1, t >>= 1;
                        return n
                    }, g.prototype.permute = function(t, e, r, n, i, s) {
                        for (var a = 0; a < s; a++) n[a] = e[t[a]], i[a] = r[t[a]]
                    }, g.prototype.transform = function(t, e, r, n, i, s) {
                        this.permute(s, t, e, r, n, i);
                        for (var a = 1; a < i; a <<= 1)
                            for (var o = a << 1, u = Math.cos(2 * Math.PI / o), h = Math.sin(2 * Math.PI / o), f = 0; f < i; f += o)
                                for (var c = u, l = h, d = 0; d < a; d++) {
                                    var p = r[f + d],
                                        m = n[f + d],
                                        b = r[f + d + a],
                                        g = n[f + d + a],
                                        y = c * b - l * g;
                                    g = c * g + l * b, b = y, r[f + d] = p + b, n[f + d] = m + g, r[f + d + a] = p - b, n[f + d + a] = m - g, d !== o && (y = u * c - h * l, l = u * l + h * c, c = y)
                                }
                    }, g.prototype.guessLen13b = function(t, e) {
                        var r = 1 | Math.max(e, t),
                            n = 1 & r,
                            i = 0;
                        for (r = r / 2 | 0; r; r >>>= 1) i++;
                        return 1 << i + 1 + n
                    }, g.prototype.conjugate = function(t, e, r) {
                        if (!(r <= 1))
                            for (var n = 0; n < r / 2; n++) {
                                var i = t[n];
                                t[n] = t[r - n - 1], t[r - n - 1] = i, i = e[n], e[n] = -e[r - n - 1], e[r - n - 1] = -i
                            }
                    }, g.prototype.normalize13b = function(t, e) {
                        for (var r = 0, n = 0; n < e / 2; n++) {
                            var i = 8192 * Math.round(t[2 * n + 1] / e) + Math.round(t[2 * n] / e) + r;
                            t[n] = 67108863 & i, r = i < 67108864 ? 0 : i / 67108864 | 0
                        }
                        return t
                    }, g.prototype.convert13b = function(t, e, r, i) {
                        for (var s = 0, a = 0; a < e; a++) s += 0 | t[a], r[2 * a] = 8191 & s, s >>>= 13, r[2 * a + 1] = 8191 & s, s >>>= 13;
                        for (a = 2 * e; a < i; ++a) r[a] = 0;
                        n(0 === s), n(0 === (-8192 & s))
                    }, g.prototype.stub = function(t) {
                        for (var e = new Array(t), r = 0; r < t; r++) e[r] = 0;
                        return e
                    }, g.prototype.mulp = function(t, e, r) {
                        var n = 2 * this.guessLen13b(t.length, e.length),
                            i = this.makeRBT(n),
                            s = this.stub(n),
                            a = new Array(n),
                            o = new Array(n),
                            u = new Array(n),
                            h = new Array(n),
                            f = new Array(n),
                            c = new Array(n),
                            l = r.words;
                        l.length = n, this.convert13b(t.words, t.length, a, n), this.convert13b(e.words, e.length, h, n), this.transform(a, s, o, u, n, i), this.transform(h, s, f, c, n, i);
                        for (var d = 0; d < n; d++) {
                            var p = o[d] * f[d] - u[d] * c[d];
                            u[d] = o[d] * c[d] + u[d] * f[d], o[d] = p
                        }
                        return this.conjugate(o, u, n), this.transform(o, u, l, s, n, i), this.conjugate(l, s, n), this.normalize13b(l, n), r.negative = t.negative ^ e.negative, r.length = t.length + e.length, r.strip()
                    }, s.prototype.mul = function(t) {
                        var e = new s(null);
                        return e.words = new Array(this.length + t.length), this.mulTo(t, e)
                    }, s.prototype.mulf = function(t) {
                        var e = new s(null);
                        return e.words = new Array(this.length + t.length), b(this, t, e)
                    }, s.prototype.imul = function(t) {
                        return this.clone().mulTo(t, this)
                    }, s.prototype.imuln = function(t) {
                        n("number" === typeof t), n(t < 67108864);
                        for (var e = 0, r = 0; r < this.length; r++) {
                            var i = (0 | this.words[r]) * t,
                                s = (67108863 & i) + (67108863 & e);
                            e >>= 26, e += i / 67108864 | 0, e += s >>> 26, this.words[r] = 67108863 & s
                        }
                        return 0 !== e && (this.words[r] = e, this.length++), this
                    }, s.prototype.muln = function(t) {
                        return this.clone().imuln(t)
                    }, s.prototype.sqr = function() {
                        return this.mul(this)
                    }, s.prototype.isqr = function() {
                        return this.imul(this.clone())
                    }, s.prototype.pow = function(t) {
                        var e = l(t);
                        if (0 === e.length) return new s(1);
                        for (var r = this, n = 0; n < e.length; n++, r = r.sqr())
                            if (0 !== e[n]) break;
                        if (++n < e.length)
                            for (var i = r.sqr(); n < e.length; n++, i = i.sqr()) 0 !== e[n] && (r = r.mul(i));
                        return r
                    }, s.prototype.iushln = function(t) {
                        n("number" === typeof t && t >= 0);
                        var e, r = t % 26,
                            i = (t - r) / 26,
                            s = 67108863 >>> 26 - r << 26 - r;
                        if (0 !== r) {
                            var a = 0;
                            for (e = 0; e < this.length; e++) {
                                var o = this.words[e] & s,
                                    u = (0 | this.words[e]) - o << r;
                                this.words[e] = u | a, a = o >>> 26 - r
                            }
                            a && (this.words[e] = a, this.length++)
                        }
                        if (0 !== i) {
                            for (e = this.length - 1; e >= 0; e--) this.words[e + i] = this.words[e];
                            for (e = 0; e < i; e++) this.words[e] = 0;
                            this.length += i
                        }
                        return this.strip()
                    }, s.prototype.ishln = function(t) {
                        return n(0 === this.negative), this.iushln(t)
                    }, s.prototype.iushrn = function(t, e, r) {
                        var i;
                        n("number" === typeof t && t >= 0), i = e ? (e - e % 26) / 26 : 0;
                        var s = t % 26,
                            a = Math.min((t - s) / 26, this.length),
                            o = 67108863 ^ 67108863 >>> s << s,
                            u = r;
                        if (i -= a, i = Math.max(0, i), u) {
                            for (var h = 0; h < a; h++) u.words[h] = this.words[h];
                            u.length = a
                        }
                        if (0 === a);
                        else if (this.length > a)
                            for (this.length -= a, h = 0; h < this.length; h++) this.words[h] = this.words[h + a];
                        else this.words[0] = 0, this.length = 1;
                        var f = 0;
                        for (h = this.length - 1; h >= 0 && (0 !== f || h >= i); h--) {
                            var c = 0 | this.words[h];
                            this.words[h] = f << 26 - s | c >>> s, f = c & o
                        }
                        return u && 0 !== f && (u.words[u.length++] = f), 0 === this.length && (this.words[0] = 0, this.length = 1), this.strip()
                    }, s.prototype.ishrn = function(t, e, r) {
                        return n(0 === this.negative), this.iushrn(t, e, r)
                    }, s.prototype.shln = function(t) {
                        return this.clone().ishln(t)
                    }, s.prototype.ushln = function(t) {
                        return this.clone().iushln(t)
                    }, s.prototype.shrn = function(t) {
                        return this.clone().ishrn(t)
                    }, s.prototype.ushrn = function(t) {
                        return this.clone().iushrn(t)
                    }, s.prototype.testn = function(t) {
                        n("number" === typeof t && t >= 0);
                        var e = t % 26,
                            r = (t - e) / 26,
                            i = 1 << e;
                        if (this.length <= r) return !1;
                        var s = this.words[r];
                        return !!(s & i)
                    }, s.prototype.imaskn = function(t) {
                        n("number" === typeof t && t >= 0);
                        var e = t % 26,
                            r = (t - e) / 26;
                        if (n(0 === this.negative, "imaskn works only with positive numbers"), this.length <= r) return this;
                        if (0 !== e && r++, this.length = Math.min(r, this.length), 0 !== e) {
                            var i = 67108863 ^ 67108863 >>> e << e;
                            this.words[this.length - 1] &= i
                        }
                        return this.strip()
                    }, s.prototype.maskn = function(t) {
                        return this.clone().imaskn(t)
                    }, s.prototype.iaddn = function(t) {
                        return n("number" === typeof t), n(t < 67108864), t < 0 ? this.isubn(-t) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) < t ? (this.words[0] = t - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(t), this.negative = 1, this) : this._iaddn(t)
                    }, s.prototype._iaddn = function(t) {
                        this.words[0] += t;
                        for (var e = 0; e < this.length && this.words[e] >= 67108864; e++) this.words[e] -= 67108864, e === this.length - 1 ? this.words[e + 1] = 1 : this.words[e + 1]++;
                        return this.length = Math.max(this.length, e + 1), this
                    }, s.prototype.isubn = function(t) {
                        if (n("number" === typeof t), n(t < 67108864), t < 0) return this.iaddn(-t);
                        if (0 !== this.negative) return this.negative = 0, this.iaddn(t), this.negative = 1, this;
                        if (this.words[0] -= t, 1 === this.length && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
                        else
                            for (var e = 0; e < this.length && this.words[e] < 0; e++) this.words[e] += 67108864, this.words[e + 1] -= 1;
                        return this.strip()
                    }, s.prototype.addn = function(t) {
                        return this.clone().iaddn(t)
                    }, s.prototype.subn = function(t) {
                        return this.clone().isubn(t)
                    }, s.prototype.iabs = function() {
                        return this.negative = 0, this
                    }, s.prototype.abs = function() {
                        return this.clone().iabs()
                    }, s.prototype._ishlnsubmul = function(t, e, r) {
                        var i, s, a = t.length + r;
                        this._expand(a);
                        var o = 0;
                        for (i = 0; i < t.length; i++) {
                            s = (0 | this.words[i + r]) + o;
                            var u = (0 | t.words[i]) * e;
                            s -= 67108863 & u, o = (s >> 26) - (u / 67108864 | 0), this.words[i + r] = 67108863 & s
                        }
                        for (; i < this.length - r; i++) s = (0 | this.words[i + r]) + o, o = s >> 26, this.words[i + r] = 67108863 & s;
                        if (0 === o) return this.strip();
                        for (n(-1 === o), o = 0, i = 0; i < this.length; i++) s = -(0 | this.words[i]) + o, o = s >> 26, this.words[i] = 67108863 & s;
                        return this.negative = 1, this.strip()
                    }, s.prototype._wordDiv = function(t, e) {
                        var r = this.length - t.length,
                            n = this.clone(),
                            i = t,
                            a = 0 | i.words[i.length - 1],
                            o = this._countBits(a);
                        r = 26 - o, 0 !== r && (i = i.ushln(r), n.iushln(r), a = 0 | i.words[i.length - 1]);
                        var u, h = n.length - i.length;
                        if ("mod" !== e) {
                            u = new s(null), u.length = h + 1, u.words = new Array(u.length);
                            for (var f = 0; f < u.length; f++) u.words[f] = 0
                        }
                        var c = n.clone()._ishlnsubmul(i, 1, h);
                        0 === c.negative && (n = c, u && (u.words[h] = 1));
                        for (var l = h - 1; l >= 0; l--) {
                            var d = 67108864 * (0 | n.words[i.length + l]) + (0 | n.words[i.length + l - 1]);
                            d = Math.min(d / a | 0, 67108863), n._ishlnsubmul(i, d, l);
                            while (0 !== n.negative) d--, n.negative = 0, n._ishlnsubmul(i, 1, l), n.isZero() || (n.negative ^= 1);
                            u && (u.words[l] = d)
                        }
                        return u && u.strip(), n.strip(), "div" !== e && 0 !== r && n.iushrn(r), {
                            div: u || null,
                            mod: n
                        }
                    }, s.prototype.divmod = function(t, e, r) {
                        return n(!t.isZero()), this.isZero() ? {
                            div: new s(0),
                            mod: new s(0)
                        } : 0 !== this.negative && 0 === t.negative ? (o = this.neg().divmod(t, e), "mod" !== e && (i = o.div.neg()), "div" !== e && (a = o.mod.neg(), r && 0 !== a.negative && a.iadd(t)), {
                            div: i,
                            mod: a
                        }) : 0 === this.negative && 0 !== t.negative ? (o = this.divmod(t.neg(), e), "mod" !== e && (i = o.div.neg()), {
                            div: i,
                            mod: o.mod
                        }) : 0 !== (this.negative & t.negative) ? (o = this.neg().divmod(t.neg(), e), "div" !== e && (a = o.mod.neg(), r && 0 !== a.negative && a.isub(t)), {
                            div: o.div,
                            mod: a
                        }) : t.length > this.length || this.cmp(t) < 0 ? {
                            div: new s(0),
                            mod: this
                        } : 1 === t.length ? "div" === e ? {
                            div: this.divn(t.words[0]),
                            mod: null
                        } : "mod" === e ? {
                            div: null,
                            mod: new s(this.modn(t.words[0]))
                        } : {
                            div: this.divn(t.words[0]),
                            mod: new s(this.modn(t.words[0]))
                        } : this._wordDiv(t, e);
                        var i, a, o
                    }, s.prototype.div = function(t) {
                        return this.divmod(t, "div", !1).div
                    }, s.prototype.mod = function(t) {
                        return this.divmod(t, "mod", !1).mod
                    }, s.prototype.umod = function(t) {
                        return this.divmod(t, "mod", !0).mod
                    }, s.prototype.divRound = function(t) {
                        var e = this.divmod(t);
                        if (e.mod.isZero()) return e.div;
                        var r = 0 !== e.div.negative ? e.mod.isub(t) : e.mod,
                            n = t.ushrn(1),
                            i = t.andln(1),
                            s = r.cmp(n);
                        return s < 0 || 1 === i && 0 === s ? e.div : 0 !== e.div.negative ? e.div.isubn(1) : e.div.iaddn(1)
                    }, s.prototype.modn = function(t) {
                        n(t <= 67108863);
                        for (var e = (1 << 26) % t, r = 0, i = this.length - 1; i >= 0; i--) r = (e * r + (0 | this.words[i])) % t;
                        return r
                    }, s.prototype.idivn = function(t) {
                        n(t <= 67108863);
                        for (var e = 0, r = this.length - 1; r >= 0; r--) {
                            var i = (0 | this.words[r]) + 67108864 * e;
                            this.words[r] = i / t | 0, e = i % t
                        }
                        return this.strip()
                    }, s.prototype.divn = function(t) {
                        return this.clone().idivn(t)
                    }, s.prototype.egcd = function(t) {
                        n(0 === t.negative), n(!t.isZero());
                        var e = this,
                            r = t.clone();
                        e = 0 !== e.negative ? e.umod(t) : e.clone();
                        var i = new s(1),
                            a = new s(0),
                            o = new s(0),
                            u = new s(1),
                            h = 0;
                        while (e.isEven() && r.isEven()) e.iushrn(1), r.iushrn(1), ++h;
                        var f = r.clone(),
                            c = e.clone();
                        while (!e.isZero()) {
                            for (var l = 0, d = 1; 0 === (e.words[0] & d) && l < 26; ++l, d <<= 1);
                            if (l > 0) {
                                e.iushrn(l);
                                while (l-- > 0)(i.isOdd() || a.isOdd()) && (i.iadd(f), a.isub(c)), i.iushrn(1), a.iushrn(1)
                            }
                            for (var p = 0, m = 1; 0 === (r.words[0] & m) && p < 26; ++p, m <<= 1);
                            if (p > 0) {
                                r.iushrn(p);
                                while (p-- > 0)(o.isOdd() || u.isOdd()) && (o.iadd(f), u.isub(c)), o.iushrn(1), u.iushrn(1)
                            }
                            e.cmp(r) >= 0 ? (e.isub(r), i.isub(o), a.isub(u)) : (r.isub(e), o.isub(i), u.isub(a))
                        }
                        return {
                            a: o,
                            b: u,
                            gcd: r.iushln(h)
                        }
                    }, s.prototype._invmp = function(t) {
                        n(0 === t.negative), n(!t.isZero());
                        var e = this,
                            r = t.clone();
                        e = 0 !== e.negative ? e.umod(t) : e.clone();
                        var i, a = new s(1),
                            o = new s(0),
                            u = r.clone();
                        while (e.cmpn(1) > 0 && r.cmpn(1) > 0) {
                            for (var h = 0, f = 1; 0 === (e.words[0] & f) && h < 26; ++h, f <<= 1);
                            if (h > 0) {
                                e.iushrn(h);
                                while (h-- > 0) a.isOdd() && a.iadd(u), a.iushrn(1)
                            }
                            for (var c = 0, l = 1; 0 === (r.words[0] & l) && c < 26; ++c, l <<= 1);
                            if (c > 0) {
                                r.iushrn(c);
                                while (c-- > 0) o.isOdd() && o.iadd(u), o.iushrn(1)
                            }
                            e.cmp(r) >= 0 ? (e.isub(r), a.isub(o)) : (r.isub(e), o.isub(a))
                        }
                        return i = 0 === e.cmpn(1) ? a : o, i.cmpn(0) < 0 && i.iadd(t), i
                    }, s.prototype.gcd = function(t) {
                        if (this.isZero()) return t.abs();
                        if (t.isZero()) return this.abs();
                        var e = this.clone(),
                            r = t.clone();
                        e.negative = 0, r.negative = 0;
                        for (var n = 0; e.isEven() && r.isEven(); n++) e.iushrn(1), r.iushrn(1);
                        do {
                            while (e.isEven()) e.iushrn(1);
                            while (r.isEven()) r.iushrn(1);
                            var i = e.cmp(r);
                            if (i < 0) {
                                var s = e;
                                e = r, r = s
                            } else if (0 === i || 0 === r.cmpn(1)) break;
                            e.isub(r)
                        } while (1);
                        return r.iushln(n)
                    }, s.prototype.invm = function(t) {
                        return this.egcd(t).a.umod(t)
                    }, s.prototype.isEven = function() {
                        return 0 === (1 & this.words[0])
                    }, s.prototype.isOdd = function() {
                        return 1 === (1 & this.words[0])
                    }, s.prototype.andln = function(t) {
                        return this.words[0] & t
                    }, s.prototype.bincn = function(t) {
                        n("number" === typeof t);
                        var e = t % 26,
                            r = (t - e) / 26,
                            i = 1 << e;
                        if (this.length <= r) return this._expand(r + 1), this.words[r] |= i, this;
                        for (var s = i, a = r; 0 !== s && a < this.length; a++) {
                            var o = 0 | this.words[a];
                            o += s, s = o >>> 26, o &= 67108863, this.words[a] = o
                        }
                        return 0 !== s && (this.words[a] = s, this.length++), this
                    }, s.prototype.isZero = function() {
                        return 1 === this.length && 0 === this.words[0]
                    }, s.prototype.cmpn = function(t) {
                        var e, r = t < 0;
                        if (0 !== this.negative && !r) return -1;
                        if (0 === this.negative && r) return 1;
                        if (this.strip(), this.length > 1) e = 1;
                        else {
                            r && (t = -t), n(t <= 67108863, "Number is too big");
                            var i = 0 | this.words[0];
                            e = i === t ? 0 : i < t ? -1 : 1
                        }
                        return 0 !== this.negative ? 0 | -e : e
                    }, s.prototype.cmp = function(t) {
                        if (0 !== this.negative && 0 === t.negative) return -1;
                        if (0 === this.negative && 0 !== t.negative) return 1;
                        var e = this.ucmp(t);
                        return 0 !== this.negative ? 0 | -e : e
                    }, s.prototype.ucmp = function(t) {
                        if (this.length > t.length) return 1;
                        if (this.length < t.length) return -1;
                        for (var e = 0, r = this.length - 1; r >= 0; r--) {
                            var n = 0 | this.words[r],
                                i = 0 | t.words[r];
                            if (n !== i) {
                                n < i ? e = -1 : n > i && (e = 1);
                                break
                            }
                        }
                        return e
                    }, s.prototype.gtn = function(t) {
                        return 1 === this.cmpn(t)
                    }, s.prototype.gt = function(t) {
                        return 1 === this.cmp(t)
                    }, s.prototype.gten = function(t) {
                        return this.cmpn(t) >= 0
                    }, s.prototype.gte = function(t) {
                        return this.cmp(t) >= 0
                    }, s.prototype.ltn = function(t) {
                        return -1 === this.cmpn(t)
                    }, s.prototype.lt = function(t) {
                        return -1 === this.cmp(t)
                    }, s.prototype.lten = function(t) {
                        return this.cmpn(t) <= 0
                    }, s.prototype.lte = function(t) {
                        return this.cmp(t) <= 0
                    }, s.prototype.eqn = function(t) {
                        return 0 === this.cmpn(t)
                    }, s.prototype.eq = function(t) {
                        return 0 === this.cmp(t)
                    }, s.red = function(t) {
                        return new S(t)
                    }, s.prototype.toRed = function(t) {
                        return n(!this.red, "Already a number in reduction context"), n(0 === this.negative, "red works only with positives"), t.convertTo(this)._forceRed(t)
                    }, s.prototype.fromRed = function() {
                        return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
                    }, s.prototype._forceRed = function(t) {
                        return this.red = t, this
                    }, s.prototype.forceRed = function(t) {
                        return n(!this.red, "Already a number in reduction context"), this._forceRed(t)
                    }, s.prototype.redAdd = function(t) {
                        return n(this.red, "redAdd works only with red numbers"), this.red.add(this, t)
                    }, s.prototype.redIAdd = function(t) {
                        return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, t)
                    }, s.prototype.redSub = function(t) {
                        return n(this.red, "redSub works only with red numbers"), this.red.sub(this, t)
                    }, s.prototype.redISub = function(t) {
                        return n(this.red, "redISub works only with red numbers"), this.red.isub(this, t)
                    }, s.prototype.redShl = function(t) {
                        return n(this.red, "redShl works only with red numbers"), this.red.shl(this, t)
                    }, s.prototype.redMul = function(t) {
                        return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, t), this.red.mul(this, t)
                    }, s.prototype.redIMul = function(t) {
                        return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, t), this.red.imul(this, t)
                    }, s.prototype.redSqr = function() {
                        return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
                    }, s.prototype.redISqr = function() {
                        return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
                    }, s.prototype.redSqrt = function() {
                        return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
                    }, s.prototype.redInvm = function() {
                        return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
                    }, s.prototype.redNeg = function() {
                        return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
                    }, s.prototype.redPow = function(t) {
                        return n(this.red && !t.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, t)
                    };
                    var y = {
                        k256: null,
                        p224: null,
                        p192: null,
                        p25519: null
                    };

                    function v(t, e) {
                        this.name = t, this.p = new s(e, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
                    }

                    function w() {
                        v.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
                    }

                    function _() {
                        v.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
                    }

                    function M() {
                        v.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
                    }

                    function A() {
                        v.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
                    }

                    function S(t) {
                        if ("string" === typeof t) {
                            var e = s._prime(t);
                            this.m = e.p, this.prime = e
                        } else n(t.gtn(1), "modulus must be greater than 1"), this.m = t, this.prime = null
                    }

                    function x(t) {
                        S.call(this, t), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
                    }
                    v.prototype._tmp = function() {
                        var t = new s(null);
                        return t.words = new Array(Math.ceil(this.n / 13)), t
                    }, v.prototype.ireduce = function(t) {
                        var e, r = t;
                        do {
                            this.split(r, this.tmp), r = this.imulK(r), r = r.iadd(this.tmp), e = r.bitLength()
                        } while (e > this.n);
                        var n = e < this.n ? -1 : r.ucmp(this.p);
                        return 0 === n ? (r.words[0] = 0, r.length = 1) : n > 0 ? r.isub(this.p) : void 0 !== r.strip ? r.strip() : r._strip(), r
                    }, v.prototype.split = function(t, e) {
                        t.iushrn(this.n, 0, e)
                    }, v.prototype.imulK = function(t) {
                        return t.imul(this.k)
                    }, i(w, v), w.prototype.split = function(t, e) {
                        for (var r = 4194303, n = Math.min(t.length, 9), i = 0; i < n; i++) e.words[i] = t.words[i];
                        if (e.length = n, t.length <= 9) return t.words[0] = 0, void(t.length = 1);
                        var s = t.words[9];
                        for (e.words[e.length++] = s & r, i = 10; i < t.length; i++) {
                            var a = 0 | t.words[i];
                            t.words[i - 10] = (a & r) << 4 | s >>> 22, s = a
                        }
                        s >>>= 22, t.words[i - 10] = s, 0 === s && t.length > 10 ? t.length -= 10 : t.length -= 9
                    }, w.prototype.imulK = function(t) {
                        t.words[t.length] = 0, t.words[t.length + 1] = 0, t.length += 2;
                        for (var e = 0, r = 0; r < t.length; r++) {
                            var n = 0 | t.words[r];
                            e += 977 * n, t.words[r] = 67108863 & e, e = 64 * n + (e / 67108864 | 0)
                        }
                        return 0 === t.words[t.length - 1] && (t.length--, 0 === t.words[t.length - 1] && t.length--), t
                    }, i(_, v), i(M, v), i(A, v), A.prototype.imulK = function(t) {
                        for (var e = 0, r = 0; r < t.length; r++) {
                            var n = 19 * (0 | t.words[r]) + e,
                                i = 67108863 & n;
                            n >>>= 26, t.words[r] = i, e = n
                        }
                        return 0 !== e && (t.words[t.length++] = e), t
                    }, s._prime = function(t) {
                        if (y[t]) return y[t];
                        var e;
                        if ("k256" === t) e = new w;
                        else if ("p224" === t) e = new _;
                        else if ("p192" === t) e = new M;
                        else {
                            if ("p25519" !== t) throw new Error("Unknown prime " + t);
                            e = new A
                        }
                        return y[t] = e, e
                    }, S.prototype._verify1 = function(t) {
                        n(0 === t.negative, "red works only with positives"), n(t.red, "red works only with red numbers")
                    }, S.prototype._verify2 = function(t, e) {
                        n(0 === (t.negative | e.negative), "red works only with positives"), n(t.red && t.red === e.red, "red works only with red numbers")
                    }, S.prototype.imod = function(t) {
                        return this.prime ? this.prime.ireduce(t)._forceRed(this) : t.umod(this.m)._forceRed(this)
                    }, S.prototype.neg = function(t) {
                        return t.isZero() ? t.clone() : this.m.sub(t)._forceRed(this)
                    }, S.prototype.add = function(t, e) {
                        this._verify2(t, e);
                        var r = t.add(e);
                        return r.cmp(this.m) >= 0 && r.isub(this.m), r._forceRed(this)
                    }, S.prototype.iadd = function(t, e) {
                        this._verify2(t, e);
                        var r = t.iadd(e);
                        return r.cmp(this.m) >= 0 && r.isub(this.m), r
                    }, S.prototype.sub = function(t, e) {
                        this._verify2(t, e);
                        var r = t.sub(e);
                        return r.cmpn(0) < 0 && r.iadd(this.m), r._forceRed(this)
                    }, S.prototype.isub = function(t, e) {
                        this._verify2(t, e);
                        var r = t.isub(e);
                        return r.cmpn(0) < 0 && r.iadd(this.m), r
                    }, S.prototype.shl = function(t, e) {
                        return this._verify1(t), this.imod(t.ushln(e))
                    }, S.prototype.imul = function(t, e) {
                        return this._verify2(t, e), this.imod(t.imul(e))
                    }, S.prototype.mul = function(t, e) {
                        return this._verify2(t, e), this.imod(t.mul(e))
                    }, S.prototype.isqr = function(t) {
                        return this.imul(t, t.clone())
                    }, S.prototype.sqr = function(t) {
                        return this.mul(t, t)
                    }, S.prototype.sqrt = function(t) {
                        if (t.isZero()) return t.clone();
                        var e = this.m.andln(3);
                        if (n(e % 2 === 1), 3 === e) {
                            var r = this.m.add(new s(1)).iushrn(2);
                            return this.pow(t, r)
                        }
                        var i = this.m.subn(1),
                            a = 0;
                        while (!i.isZero() && 0 === i.andln(1)) a++, i.iushrn(1);
                        n(!i.isZero());
                        var o = new s(1).toRed(this),
                            u = o.redNeg(),
                            h = this.m.subn(1).iushrn(1),
                            f = this.m.bitLength();
                        f = new s(2 * f * f).toRed(this);
                        while (0 !== this.pow(f, h).cmp(u)) f.redIAdd(u);
                        var c = this.pow(f, i),
                            l = this.pow(t, i.addn(1).iushrn(1)),
                            d = this.pow(t, i),
                            p = a;
                        while (0 !== d.cmp(o)) {
                            for (var m = d, b = 0; 0 !== m.cmp(o); b++) m = m.redSqr();
                            n(b < p);
                            var g = this.pow(c, new s(1).iushln(p - b - 1));
                            l = l.redMul(g), c = g.redSqr(), d = d.redMul(c), p = b
                        }
                        return l
                    }, S.prototype.invm = function(t) {
                        var e = t._invmp(this.m);
                        return 0 !== e.negative ? (e.negative = 0, this.imod(e).redNeg()) : this.imod(e)
                    }, S.prototype.pow = function(t, e) {
                        if (e.isZero()) return new s(1).toRed(this);
                        if (0 === e.cmpn(1)) return t.clone();
                        var r = 4,
                            n = new Array(1 << r);
                        n[0] = new s(1).toRed(this), n[1] = t;
                        for (var i = 2; i < n.length; i++) n[i] = this.mul(n[i - 1], t);
                        var a = n[0],
                            o = 0,
                            u = 0,
                            h = e.bitLength() % 26;
                        for (0 === h && (h = 26), i = e.length - 1; i >= 0; i--) {
                            for (var f = e.words[i], c = h - 1; c >= 0; c--) {
                                var l = f >> c & 1;
                                a !== n[0] && (a = this.sqr(a)), 0 !== l || 0 !== o ? (o <<= 1, o |= l, u++, (u === r || 0 === i && 0 === c) && (a = this.mul(a, n[o]), u = 0, o = 0)) : u = 0
                            }
                            h = 26
                        }
                        return a
                    }, S.prototype.convertTo = function(t) {
                        var e = t.umod(this.m);
                        return e === t ? e.clone() : e
                    }, S.prototype.convertFrom = function(t) {
                        var e = t.clone();
                        return e.red = null, e
                    }, s.mont = function(t) {
                        return new x(t)
                    }, i(x, S), x.prototype.convertTo = function(t) {
                        return this.imod(t.ushln(this.shift))
                    }, x.prototype.convertFrom = function(t) {
                        var e = this.imod(t.mul(this.rinv));
                        return e.red = null, e
                    }, x.prototype.imul = function(t, e) {
                        if (t.isZero() || e.isZero()) return t.words[0] = 0, t.length = 1, t;
                        var r = t.imul(e),
                            n = r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                            i = r.isub(n).iushrn(this.shift),
                            s = i;
                        return i.cmp(this.m) >= 0 ? s = i.isub(this.m) : i.cmpn(0) < 0 && (s = i.iadd(this.m)), s._forceRed(this)
                    }, x.prototype.mul = function(t, e) {
                        if (t.isZero() || e.isZero()) return new s(0)._forceRed(this);
                        var r = t.mul(e),
                            n = r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                            i = r.isub(n).iushrn(this.shift),
                            a = i;
                        return i.cmp(this.m) >= 0 ? a = i.isub(this.m) : i.cmpn(0) < 0 && (a = i.iadd(this.m)), a._forceRed(this)
                    }, x.prototype.invm = function(t) {
                        var e = this.imod(t._invmp(this.m).mul(this.r2));
                        return e._forceRed(this)
                    }
                })(t, this)
            }).call(this, r("62e4")(t))
        },
        8658: function(t, e, r) {
            "use strict";
            r.r(e);
            r("d101");
            e["default"] = window.crypto
        },
        "8b95": function(t, e, r) {
            "use strict";
            var n = r("c3c0"),
                i = r("b525");

            function s() {
                if (!(this instanceof s)) return new s;
                i.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]
            }
            n.inherits(s, i), t.exports = s, s.blockSize = 1024, s.outSize = 384, s.hmacStrength = 192, s.padLength = 128, s.prototype._digest = function(t) {
                return "hex" === t ? n.toHex32(this.h.slice(0, 12), "big") : n.split32(this.h.slice(0, 12), "big")
            }
        },
        "8cb0": function(t, e, r) {
            "use strict";
            var n = this && this.__read || function(t, e) {
                    var r = "function" === typeof Symbol && t[Symbol.iterator];
                    if (!r) return t;
                    var n, i, s = r.call(t),
                        a = [];
                    try {
                        while ((void 0 === e || e-- > 0) && !(n = s.next()).done) a.push(n.value)
                    } catch (o) {
                        i = {
                            error: o
                        }
                    } finally {
                        try {
                            n && !n.done && (r = s["return"]) && r.call(s)
                        } finally {
                            if (i) throw i.error
                        }
                    }
                    return a
                },
                i = this && this.__spreadArray || function(t, e) {
                    for (var r = 0, n = e.length, i = t.length; r < n; r++, i++) t[i] = e[r];
                    return t
                },
                s = this && this.__values || function(t) {
                    var e = "function" === typeof Symbol && Symbol.iterator,
                        r = e && t[e],
                        n = 0;
                    if (r) return r.call(t);
                    if (t && "number" === typeof t.length) return {
                        next: function() {
                            return t && n >= t.length && (t = void 0), {
                                value: t && t[n++],
                                done: !t
                            }
                        }
                    };
                    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
                };
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.signatureToString = e.stringToSignature = e.privateKeyToString = e.privateKeyToLegacyString = e.stringToPrivateKey = e.convertLegacyPublicKeys = e.convertLegacyPublicKey = e.publicKeyToString = e.publicKeyToLegacyString = e.stringToPublicKey = e.signatureDataSize = e.privateKeyDataSize = e.publicKeyDataSize = e.KeyType = e.base64ToBinary = e.binaryToBase58 = e.base58ToBinary = e.signedBinaryToDecimal = e.binaryToDecimal = e.signedDecimalToBinary = e.decimalToBinary = e.negate = e.isNegative = void 0;
            var a = r("7d92"),
                o = r("40a1").RIPEMD160.hash,
                u = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
                h = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
                f = function() {
                    for (var t = Array(256).fill(-1), e = 0; e < u.length; ++e) t[u.charCodeAt(e)] = e;
                    return t
                },
                c = f(),
                l = function() {
                    for (var t = Array(256).fill(-1), e = 0; e < h.length; ++e) t[h.charCodeAt(e)] = e;
                    return t["=".charCodeAt(0)] = 0, t
                },
                d = l(),
                p = function(t) {
                    return 0 !== (128 & t[t.length - 1])
                };
            e.isNegative = p;
            var m = function(t) {
                for (var e = 1, r = 0; r < t.length; ++r) {
                    var n = (255 & ~t[r]) + e;
                    t[r] = n, e = n >> 8
                }
            };
            e.negate = m;
            var b = function(t, e) {
                for (var r = new Uint8Array(t), n = 0; n < e.length; ++n) {
                    var i = e.charCodeAt(n);
                    if (i < "0".charCodeAt(0) || i > "9".charCodeAt(0)) throw new Error("invalid number");
                    for (var s = i - "0".charCodeAt(0), a = 0; a < t; ++a) {
                        var o = 10 * r[a] + s;
                        r[a] = o, s = o >> 8
                    }
                    if (s) throw new Error("number is out of range")
                }
                return r
            };
            e.decimalToBinary = b;
            var g = function(t, r) {
                var n = "-" === r[0];
                n && (r = r.substr(1));
                var i = e.decimalToBinary(t, r);
                if (n) {
                    if (e.negate(i), !e.isNegative(i)) throw new Error("number is out of range")
                } else if (e.isNegative(i)) throw new Error("number is out of range");
                return i
            };
            e.signedDecimalToBinary = g;
            var y = function(t, e) {
                void 0 === e && (e = 1);
                for (var r = Array(e).fill("0".charCodeAt(0)), s = t.length - 1; s >= 0; --s) {
                    for (var a = t[s], o = 0; o < r.length; ++o) {
                        var u = (r[o] - "0".charCodeAt(0) << 8) + a;
                        r[o] = "0".charCodeAt(0) + u % 10, a = u / 10 | 0
                    }
                    while (a) r.push("0".charCodeAt(0) + a % 10), a = a / 10 | 0
                }
                return r.reverse(), String.fromCharCode.apply(String, i([], n(r)))
            };
            e.binaryToDecimal = y;
            var v = function(t, r) {
                if (void 0 === r && (r = 1), e.isNegative(t)) {
                    var n = t.slice();
                    return e.negate(n), "-" + e.binaryToDecimal(n, r)
                }
                return e.binaryToDecimal(t, r)
            };
            e.signedBinaryToDecimal = v;
            var w = function(t) {
                    for (var e, r, n = [], i = 0; i < t.length; ++i) {
                        var a = c[t.charCodeAt(i)];
                        if (a < 0) throw new Error("invalid base-58 value");
                        for (var o = 0; o < n.length; ++o) {
                            var u = 58 * n[o] + a;
                            n[o] = 255 & u, a = u >> 8
                        }
                        a && n.push(a)
                    }
                    try {
                        for (var h = s(t), f = h.next(); !f.done; f = h.next()) {
                            var l = f.value;
                            if ("1" !== l) break;
                            n.push(0)
                        }
                    } catch (d) {
                        e = {
                            error: d
                        }
                    } finally {
                        try {
                            f && !f.done && (r = h.return) && r.call(h)
                        } finally {
                            if (e) throw e.error
                        }
                    }
                    return n.reverse(), new Uint8Array(n)
                },
                _ = function(t, e) {
                    if (!t) return w(e);
                    for (var r = new Uint8Array(t), n = 0; n < e.length; ++n) {
                        var i = c[e.charCodeAt(n)];
                        if (i < 0) throw new Error("invalid base-58 value");
                        for (var s = 0; s < t; ++s) {
                            var a = 58 * r[s] + i;
                            r[s] = a, i = a >> 8
                        }
                        if (i) throw new Error("base-58 value is out of range")
                    }
                    return r.reverse(), r
                };
            e.base58ToBinary = _;
            var M = function(t, e) {
                var r, a, o, h;
                void 0 === e && (e = 1);
                var f = [];
                try {
                    for (var l = s(t), d = l.next(); !d.done; d = l.next()) {
                        for (var p = d.value, m = p, b = 0; b < f.length; ++b) {
                            var g = (c[f[b]] << 8) + m;
                            f[b] = u.charCodeAt(g % 58), m = g / 58 | 0
                        }
                        while (m) f.push(u.charCodeAt(m % 58)), m = m / 58 | 0
                    }
                } catch (w) {
                    r = {
                        error: w
                    }
                } finally {
                    try {
                        d && !d.done && (a = l.return) && a.call(l)
                    } finally {
                        if (r) throw r.error
                    }
                }
                try {
                    for (var y = s(t), v = y.next(); !v.done; v = y.next()) {
                        p = v.value;
                        if (p) break;
                        f.push("1".charCodeAt(0))
                    }
                } catch (_) {
                    o = {
                        error: _
                    }
                } finally {
                    try {
                        v && !v.done && (h = y.return) && h.call(y)
                    } finally {
                        if (o) throw o.error
                    }
                }
                return f.reverse(), String.fromCharCode.apply(String, i([], n(f)))
            };
            e.binaryToBase58 = M;
            var A, S = function(t) {
                var e = t.length;
                if (1 === (3 & e) && "=" === t[e - 1] && (e -= 1), 0 !== (3 & e)) throw new Error("base-64 value is not padded correctly");
                var r = e >> 2,
                    n = 3 * r;
                e > 0 && "=" === t[e - 1] && ("=" === t[e - 2] ? n -= 2 : n -= 1);
                for (var i = new Uint8Array(n), s = 0; s < r; ++s) {
                    var a = d[t.charCodeAt(4 * s + 0)],
                        o = d[t.charCodeAt(4 * s + 1)],
                        u = d[t.charCodeAt(4 * s + 2)],
                        h = d[t.charCodeAt(4 * s + 3)];
                    i[3 * s + 0] = a << 2 | o >> 4, 3 * s + 1 < n && (i[3 * s + 1] = (15 & o) << 4 | u >> 2), 3 * s + 2 < n && (i[3 * s + 2] = (3 & u) << 6 | h)
                }
                return i
            };
            e.base64ToBinary = S,
                function(t) {
                    t[t["k1"] = 0] = "k1", t[t["r1"] = 1] = "r1", t[t["wa"] = 2] = "wa"
                }(A = e.KeyType || (e.KeyType = {})), e.publicKeyDataSize = 33, e.privateKeyDataSize = 32, e.signatureDataSize = 65;
            var x = function(t, e) {
                    for (var r = new Uint8Array(t.length + e.length), n = 0; n < t.length; ++n) r[n] = t[n];
                    for (n = 0; n < e.length; ++n) r[t.length + n] = e.charCodeAt(n);
                    return o(r)
                },
                E = function(t, r, n, i) {
                    var s = e.base58ToBinary(n ? n + 4 : 0, t),
                        a = {
                            type: r,
                            data: new Uint8Array(s.buffer, 0, s.length - 4)
                        },
                        o = new Uint8Array(x(a.data, i));
                    if (o[0] !== s[s.length - 4] || o[1] !== s[s.length - 3] || o[2] !== s[s.length - 2] || o[3] !== s[s.length - 1]) throw new Error("checksum doesn't match");
                    return a
                },
                k = function(t, r, n) {
                    for (var i = new Uint8Array(x(t.data, r)), s = new Uint8Array(t.data.length + 4), a = 0; a < t.data.length; ++a) s[a] = t.data[a];
                    for (a = 0; a < 4; ++a) s[a + t.data.length] = i[a];
                    return n + e.binaryToBase58(s)
                },
                R = function(t) {
                    if ("string" !== typeof t) throw new Error("expected string containing public key");
                    if ("EOS" === t.substr(0, 3)) {
                        for (var r = e.base58ToBinary(e.publicKeyDataSize + 4, t.substr(3)), n = {
                                type: A.k1,
                                data: new Uint8Array(e.publicKeyDataSize)
                            }, i = 0; i < e.publicKeyDataSize; ++i) n.data[i] = r[i];
                        var s = new Uint8Array(o(n.data));
                        if (s[0] !== r[e.publicKeyDataSize] || s[1] !== r[34] || s[2] !== r[35] || s[3] !== r[36]) throw new Error("checksum doesn't match");
                        return n
                    }
                    if ("PUB_K1_" === t.substr(0, 7)) return E(t.substr(7), A.k1, e.publicKeyDataSize, "K1");
                    if ("PUB_R1_" === t.substr(0, 7)) return E(t.substr(7), A.r1, e.publicKeyDataSize, "R1");
                    if ("PUB_WA_" === t.substr(0, 7)) return E(t.substr(7), A.wa, 0, "WA");
                    throw new Error("unrecognized public key format")
                };
            e.stringToPublicKey = R;
            var O = function(t) {
                if (t.type === A.k1 && t.data.length === e.publicKeyDataSize) return k(t, "", "EOS");
                throw t.type === A.r1 || t.type === A.wa ? new Error("Key format not supported in legacy conversion") : new Error("unrecognized public key format")
            };
            e.publicKeyToLegacyString = O;
            var I = function(t) {
                if (t.type === A.k1 && t.data.length === e.publicKeyDataSize) return k(t, "K1", "PUB_K1_");
                if (t.type === A.r1 && t.data.length === e.publicKeyDataSize) return k(t, "R1", "PUB_R1_");
                if (t.type === A.wa) return k(t, "WA", "PUB_WA_");
                throw new Error("unrecognized public key format")
            };
            e.publicKeyToString = I;
            var P = function(t) {
                return "EOS" === t.substr(0, 3) ? e.publicKeyToString(e.stringToPublicKey(t)) : t
            };
            e.convertLegacyPublicKey = P;
            var T = function(t) {
                return t.map(e.convertLegacyPublicKey)
            };
            e.convertLegacyPublicKeys = T;
            var N = function(t) {
                if ("string" !== typeof t) throw new Error("expected string containing private key");
                if ("PVT_R1_" === t.substr(0, 7)) return E(t.substr(7), A.r1, e.privateKeyDataSize, "R1");
                if ("PVT_K1_" === t.substr(0, 7)) return E(t.substr(7), A.k1, e.privateKeyDataSize, "K1");
                var r = e.base58ToBinary(e.privateKeyDataSize + 5, t),
                    n = {
                        type: A.k1,
                        data: new Uint8Array(e.privateKeyDataSize)
                    };
                if (128 !== r[0]) throw new Error("unrecognized private key type");
                for (var i = 0; i < e.privateKeyDataSize; ++i) n.data[i] = r[i + 1];
                return n
            };
            e.stringToPrivateKey = N;
            var j = function(t) {
                if (t.type === A.k1 && t.data.length === e.privateKeyDataSize) {
                    var r = [];
                    r.push(128), t.data.forEach((function(t) {
                        return r.push(t)
                    }));
                    for (var n = new Uint8Array(a.sha256().update(a.sha256().update(r).digest()).digest()), i = new Uint8Array(e.privateKeyDataSize + 5), s = 0; s < r.length; s++) i[s] = r[s];
                    for (s = 0; s < 4; s++) i[s + r.length] = n[s];
                    return e.binaryToBase58(i)
                }
                throw t.type === A.r1 || t.type === A.wa ? new Error("Key format not supported in legacy conversion") : new Error("unrecognized public key format")
            };
            e.privateKeyToLegacyString = j;
            var C = function(t) {
                if (t.type === A.r1) return k(t, "R1", "PVT_R1_");
                if (t.type === A.k1) return k(t, "K1", "PVT_K1_");
                throw new Error("unrecognized private key format")
            };
            e.privateKeyToString = C;
            var z = function(t) {
                if ("string" !== typeof t) throw new Error("expected string containing signature");
                if ("SIG_K1_" === t.substr(0, 7)) return E(t.substr(7), A.k1, e.signatureDataSize, "K1");
                if ("SIG_R1_" === t.substr(0, 7)) return E(t.substr(7), A.r1, e.signatureDataSize, "R1");
                if ("SIG_WA_" === t.substr(0, 7)) return E(t.substr(7), A.wa, 0, "WA");
                throw new Error("unrecognized signature format")
            };
            e.stringToSignature = z;
            var D = function(t) {
                if (t.type === A.k1) return k(t, "K1", "SIG_K1_");
                if (t.type === A.r1) return k(t, "R1", "SIG_R1_");
                if (t.type === A.wa) return k(t, "WA", "SIG_WA_");
                throw new Error("unrecognized signature format")
            };
            e.signatureToString = D
        },
        9152: function(t, e) {
            /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
            e.read = function(t, e, r, n, i) {
                var s, a, o = 8 * i - n - 1,
                    u = (1 << o) - 1,
                    h = u >> 1,
                    f = -7,
                    c = r ? i - 1 : 0,
                    l = r ? -1 : 1,
                    d = t[e + c];
                for (c += l, s = d & (1 << -f) - 1, d >>= -f, f += o; f > 0; s = 256 * s + t[e + c], c += l, f -= 8);
                for (a = s & (1 << -f) - 1, s >>= -f, f += n; f > 0; a = 256 * a + t[e + c], c += l, f -= 8);
                if (0 === s) s = 1 - h;
                else {
                    if (s === u) return a ? NaN : 1 / 0 * (d ? -1 : 1);
                    a += Math.pow(2, n), s -= h
                }
                return (d ? -1 : 1) * a * Math.pow(2, s - n)
            }, e.write = function(t, e, r, n, i, s) {
                var a, o, u, h = 8 * s - i - 1,
                    f = (1 << h) - 1,
                    c = f >> 1,
                    l = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                    d = n ? 0 : s - 1,
                    p = n ? 1 : -1,
                    m = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;
                for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (o = isNaN(e) ? 1 : 0, a = f) : (a = Math.floor(Math.log(e) / Math.LN2), e * (u = Math.pow(2, -a)) < 1 && (a--, u *= 2), e += a + c >= 1 ? l / u : l * Math.pow(2, 1 - c), e * u >= 2 && (a++, u /= 2), a + c >= f ? (o = 0, a = f) : a + c >= 1 ? (o = (e * u - 1) * Math.pow(2, i), a += c) : (o = e * Math.pow(2, c - 1) * Math.pow(2, i), a = 0)); i >= 8; t[r + d] = 255 & o, d += p, o /= 256, i -= 8);
                for (a = a << i | o, h += i; h > 0; t[r + d] = 255 & a, d += p, a /= 256, h -= 8);
                t[r + d - p] |= 128 * m
            }
        },
        "919c": function(t, e) {
            t.exports = function() {
                throw new Error("Readable.from is not available in the browser")
            }
        },
        9367: function(t, e, r) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            })
        },
        9392: function(t, e, r) {
            "use strict";
            var n = this && this.__assign || function() {
                    return n = Object.assign || function(t) {
                        for (var e, r = 1, n = arguments.length; r < n; r++)
                            for (var i in e = arguments[r], e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
                        return t
                    }, n.apply(this, arguments)
                },
                i = this && this.__read || function(t, e) {
                    var r = "function" === typeof Symbol && t[Symbol.iterator];
                    if (!r) return t;
                    var n, i, s = r.call(t),
                        a = [];
                    try {
                        while ((void 0 === e || e-- > 0) && !(n = s.next()).done) a.push(n.value)
                    } catch (o) {
                        i = {
                            error: o
                        }
                    } finally {
                        try {
                            n && !n.done && (r = s["return"]) && r.call(s)
                        } finally {
                            if (i) throw i.error
                        }
                    }
                    return a
                },
                s = this && this.__spreadArray || function(t, e) {
                    for (var r = 0, n = e.length, i = t.length; r < n; r++, i++) t[i] = e[r];
                    return t
                },
                a = this && this.__values || function(t) {
                    var e = "function" === typeof Symbol && Symbol.iterator,
                        r = e && t[e],
                        n = 0;
                    if (r) return r.call(t);
                    if (t && "number" === typeof t.length) return {
                        next: function() {
                            return t && n >= t.length && (t = void 0), {
                                value: t && t[n++],
                                done: !t
                            }
                        }
                    };
                    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
                };
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.deserializeAction = e.deserializeActionData = e.serializeAction = e.serializeActionData = e.transactionHeader = e.getTypesFromAbi = e.getType = e.createInitialTypes = e.hexToUint8Array = e.arrayToHex = e.symbolToString = e.stringToSymbol = e.blockTimestampToDate = e.dateToBlockTimestamp = e.timePointSecToDate = e.dateToTimePointSec = e.timePointToDate = e.dateToTimePoint = e.supportedAbiVersion = e.SerialBuffer = e.SerializerState = void 0;
            var o = r("8cb0"),
                u = function() {
                    function t(t) {
                        void 0 === t && (t = {}), this.skippedBinaryExtension = !1, this.options = t
                    }
                    return t
                }();
            e.SerializerState = u;
            var h = function() {
                function t(t) {
                    var e = void 0 === t ? {} : t,
                        r = e.textEncoder,
                        n = e.textDecoder,
                        i = e.array;
                    this.readPos = 0, this.array = i || new Uint8Array(1024), this.length = i ? i.length : 0, this.textEncoder = r || new TextEncoder, this.textDecoder = n || new TextDecoder("utf-8", {
                        fatal: !0
                    })
                }
                return t.prototype.reserve = function(t) {
                    if (!(this.length + t <= this.array.length)) {
                        var e = this.array.length;
                        while (this.length + t > e) e = Math.ceil(1.5 * e);
                        var r = new Uint8Array(e);
                        r.set(this.array), this.array = r
                    }
                }, t.prototype.haveReadData = function() {
                    return this.readPos < this.length
                }, t.prototype.restartRead = function() {
                    this.readPos = 0
                }, t.prototype.asUint8Array = function() {
                    return new Uint8Array(this.array.buffer, this.array.byteOffset, this.length)
                }, t.prototype.pushArray = function(t) {
                    this.reserve(t.length), this.array.set(t, this.length), this.length += t.length
                }, t.prototype.push = function() {
                    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
                    this.pushArray(t)
                }, t.prototype.get = function() {
                    if (this.readPos < this.length) return this.array[this.readPos++];
                    throw new Error("Read past end of buffer")
                }, t.prototype.pushUint8ArrayChecked = function(t, e) {
                    if (t.length !== e) throw new Error("Binary data has incorrect size");
                    this.pushArray(t)
                }, t.prototype.getUint8Array = function(t) {
                    if (this.readPos + t > this.length) throw new Error("Read past end of buffer");
                    var e = new Uint8Array(this.array.buffer, this.array.byteOffset + this.readPos, t);
                    return this.readPos += t, e
                }, t.prototype.skip = function(t) {
                    if (this.readPos + t > this.length) throw new Error("Read past end of buffer");
                    this.readPos += t
                }, t.prototype.pushUint16 = function(t) {
                    this.push(t >> 0 & 255, t >> 8 & 255)
                }, t.prototype.getUint16 = function() {
                    var t = 0;
                    return t |= this.get() << 0, t |= this.get() << 8, t
                }, t.prototype.pushUint32 = function(t) {
                    this.push(t >> 0 & 255, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255)
                }, t.prototype.getUint32 = function() {
                    var t = 0;
                    return t |= this.get() << 0, t |= this.get() << 8, t |= this.get() << 16, t |= this.get() << 24, t >>> 0
                }, t.prototype.pushNumberAsUint64 = function(t) {
                    this.pushUint32(t >>> 0), this.pushUint32(Math.floor(t / 4294967296) >>> 0)
                }, t.prototype.getUint64AsNumber = function() {
                    var t = this.getUint32(),
                        e = this.getUint32();
                    return 4294967296 * (e >>> 0) + (t >>> 0)
                }, t.prototype.pushVaruint32 = function(t) {
                    while (1) {
                        if (!(t >>> 7)) {
                            this.push(t);
                            break
                        }
                        this.push(128 | 127 & t), t >>>= 7
                    }
                }, t.prototype.getVaruint32 = function() {
                    var t = 0,
                        e = 0;
                    while (1) {
                        var r = this.get();
                        if (t |= (127 & r) << e, e += 7, !(128 & r)) break
                    }
                    return t >>> 0
                }, t.prototype.pushVarint32 = function(t) {
                    this.pushVaruint32(t << 1 ^ t >> 31)
                }, t.prototype.getVarint32 = function() {
                    var t = this.getVaruint32();
                    return 1 & t ? ~t >> 1 | 2147483648 : t >>> 1
                }, t.prototype.pushFloat32 = function(t) {
                    this.pushArray(new Uint8Array(new Float32Array([t]).buffer))
                }, t.prototype.getFloat32 = function() {
                    return new Float32Array(this.getUint8Array(4).slice().buffer)[0]
                }, t.prototype.pushFloat64 = function(t) {
                    this.pushArray(new Uint8Array(new Float64Array([t]).buffer))
                }, t.prototype.getFloat64 = function() {
                    return new Float64Array(this.getUint8Array(8).slice().buffer)[0]
                }, t.prototype.pushName = function(t) {
                    if ("string" !== typeof t) throw new Error("Expected string containing name");
                    var e = new RegExp(/^[.1-5a-z]{0,12}[.1-5a-j]?$/);
                    if (!e.test(t)) throw new Error("Name should be less than 13 characters, or less than 14 if last character is between 1-5 or a-j, and only contain the following symbols .12345abcdefghijklmnopqrstuvwxyz");
                    for (var r = function(t) {
                            return t >= "a".charCodeAt(0) && t <= "z".charCodeAt(0) ? t - "a".charCodeAt(0) + 6 : t >= "1".charCodeAt(0) && t <= "5".charCodeAt(0) ? t - "1".charCodeAt(0) + 1 : 0
                        }, n = new Uint8Array(8), i = 63, s = 0; s < t.length; ++s) {
                        var a = r(t.charCodeAt(s));
                        i < 5 && (a <<= 1);
                        for (var o = 4; o >= 0; --o) i >= 0 && (n[Math.floor(i / 8)] |= (a >> o & 1) << i % 8, --i)
                    }
                    this.pushArray(n)
                }, t.prototype.getName = function() {
                    for (var t = this.getUint8Array(8), e = "", r = 63; r >= 0;) {
                        for (var n = 0, i = 0; i < 5; ++i) r >= 0 && (n = n << 1 | t[Math.floor(r / 8)] >> r % 8 & 1, --r);
                        e += n >= 6 ? String.fromCharCode(n + "a".charCodeAt(0) - 6) : n >= 1 ? String.fromCharCode(n + "1".charCodeAt(0) - 1) : "."
                    }
                    while (e.endsWith(".")) e = e.substr(0, e.length - 1);
                    return e
                }, t.prototype.pushBytes = function(t) {
                    this.pushVaruint32(t.length), this.pushArray(t)
                }, t.prototype.getBytes = function() {
                    return this.getUint8Array(this.getVaruint32())
                }, t.prototype.pushString = function(t) {
                    this.pushBytes(this.textEncoder.encode(t))
                }, t.prototype.getString = function() {
                    return this.textDecoder.decode(this.getBytes())
                }, t.prototype.pushSymbolCode = function(t) {
                    if ("string" !== typeof t) throw new Error("Expected string containing symbol_code");
                    var e = [];
                    e.push.apply(e, s([], i(this.textEncoder.encode(t))));
                    while (e.length < 8) e.push(0);
                    this.pushArray(e.slice(0, 8))
                }, t.prototype.getSymbolCode = function() {
                    var t, e = this.getUint8Array(8);
                    for (t = 0; t < e.length; ++t)
                        if (!e[t]) break;
                    var r = this.textDecoder.decode(new Uint8Array(e.buffer, e.byteOffset, t));
                    return r
                }, t.prototype.pushSymbol = function(t) {
                    var e = t.name,
                        r = t.precision;
                    if (!/^[A-Z]{1,7}$/.test(e)) throw new Error("Expected symbol to be A-Z and between one and seven characters");
                    var n = [255 & r];
                    n.push.apply(n, s([], i(this.textEncoder.encode(e))));
                    while (n.length < 8) n.push(0);
                    this.pushArray(n.slice(0, 8))
                }, t.prototype.getSymbol = function() {
                    var t, e = this.get(),
                        r = this.getUint8Array(7);
                    for (t = 0; t < r.length; ++t)
                        if (!r[t]) break;
                    var n = this.textDecoder.decode(new Uint8Array(r.buffer, r.byteOffset, t));
                    return {
                        name: n,
                        precision: e
                    }
                }, t.prototype.pushAsset = function(t) {
                    if ("string" !== typeof t) throw new Error("Expected string containing asset");
                    t = t.trim();
                    var e = 0,
                        r = "",
                        n = 0;
                    "-" === t[e] && (r += "-", ++e);
                    var i = !1;
                    while (e < t.length && t.charCodeAt(e) >= "0".charCodeAt(0) && t.charCodeAt(e) <= "9".charCodeAt(0)) i = !0, r += t[e], ++e;
                    if (!i) throw new Error("Asset must begin with a number");
                    if ("." === t[e]) {
                        ++e;
                        while (e < t.length && t.charCodeAt(e) >= "0".charCodeAt(0) && t.charCodeAt(e) <= "9".charCodeAt(0)) r += t[e], ++n, ++e
                    }
                    var s = t.substr(e).trim();
                    this.pushArray(o.signedDecimalToBinary(8, r)), this.pushSymbol({
                        name: s,
                        precision: n
                    })
                }, t.prototype.getAsset = function() {
                    var t = this.getUint8Array(8),
                        e = this.getSymbol(),
                        r = e.name,
                        n = e.precision,
                        i = o.signedBinaryToDecimal(t, n + 1);
                    return n && (i = i.substr(0, i.length - n) + "." + i.substr(i.length - n)), i + " " + r
                }, t.prototype.pushPublicKey = function(t) {
                    var e = o.stringToPublicKey(t);
                    this.push(e.type), this.pushArray(e.data)
                }, t.prototype.getPublicKey = function() {
                    var t, e = this.get();
                    if (e === o.KeyType.wa) {
                        var r = this.readPos;
                        this.skip(34), this.skip(this.getVaruint32()), t = new Uint8Array(this.array.buffer, this.array.byteOffset + r, this.readPos - r)
                    } else t = this.getUint8Array(o.publicKeyDataSize);
                    return o.publicKeyToString({
                        type: e,
                        data: t
                    })
                }, t.prototype.pushPrivateKey = function(t) {
                    var e = o.stringToPrivateKey(t);
                    this.push(e.type), this.pushArray(e.data)
                }, t.prototype.getPrivateKey = function() {
                    var t = this.get(),
                        e = this.getUint8Array(o.privateKeyDataSize);
                    return o.privateKeyToString({
                        type: t,
                        data: e
                    })
                }, t.prototype.pushSignature = function(t) {
                    var e = o.stringToSignature(t);
                    this.push(e.type), this.pushArray(e.data)
                }, t.prototype.getSignature = function() {
                    var t, e = this.get();
                    if (e === o.KeyType.wa) {
                        var r = this.readPos;
                        this.skip(65), this.skip(this.getVaruint32()), this.skip(this.getVaruint32()), t = new Uint8Array(this.array.buffer, this.array.byteOffset + r, this.readPos - r)
                    } else t = this.getUint8Array(o.signatureDataSize);
                    return o.signatureToString({
                        type: e,
                        data: t
                    })
                }, t
            }();
            e.SerialBuffer = h;
            var f = function(t) {
                return t.startsWith("eosio::abi/1.")
            };
            e.supportedAbiVersion = f;
            var c = function(t) {
                    var e = Date.parse(t);
                    if (Number.isNaN(e)) throw new Error("Invalid time format");
                    return e
                },
                l = function(t) {
                    return Math.round(1e3 * c(t + "Z"))
                };
            e.dateToTimePoint = l;
            var d = function(t) {
                var e = new Date(t / 1e3).toISOString();
                return e.substr(0, e.length - 1)
            };
            e.timePointToDate = d;
            var p = function(t) {
                return Math.round(c(t + "Z") / 1e3)
            };
            e.dateToTimePointSec = p;
            var m = function(t) {
                var e = new Date(1e3 * t).toISOString();
                return e.substr(0, e.length - 1)
            };
            e.timePointSecToDate = m;
            var b = function(t) {
                return Math.round((c(t + "Z") - 9466848e5) / 500)
            };
            e.dateToBlockTimestamp = b;
            var g = function(t) {
                var e = new Date(500 * t + 9466848e5).toISOString();
                return e.substr(0, e.length - 1)
            };
            e.blockTimestampToDate = g;
            var y = function(t) {
                if ("string" !== typeof t) throw new Error("Expected string containing symbol");
                var e = t.match(/^([0-9]+),([A-Z]+)$/);
                if (!e) throw new Error("Invalid symbol");
                return {
                    name: e[2],
                    precision: +e[1]
                }
            };
            e.stringToSymbol = y;
            var v = function(t) {
                var e = t.name,
                    r = t.precision;
                return r + "," + e
            };
            e.symbolToString = v;
            var w = function(t) {
                var e, r, n = "";
                try {
                    for (var i = a(t), s = i.next(); !s.done; s = i.next()) {
                        var o = s.value;
                        n += ("00" + o.toString(16)).slice(-2)
                    }
                } catch (u) {
                    e = {
                        error: u
                    }
                } finally {
                    try {
                        s && !s.done && (r = i.return) && r.call(i)
                    } finally {
                        if (e) throw e.error
                    }
                }
                return n.toUpperCase()
            };
            e.arrayToHex = w;
            var _ = function(t) {
                if ("string" !== typeof t) throw new Error("Expected string containing hex digits");
                if (t.length % 2) throw new Error("Odd number of hex digits");
                for (var e = t.length / 2, r = new Uint8Array(e), n = 0; n < e; ++n) {
                    var i = parseInt(t.substr(2 * n, 2), 16);
                    if (Number.isNaN(i)) throw new Error("Expected hex string");
                    r[n] = i
                }
                return r
            };

            function M(t, e) {
                throw new Error("Don't know how to serialize " + this.name)
            }

            function A(t) {
                throw new Error("Don't know how to deserialize " + this.name)
            }

            function S(t, e, r, n) {
                var i, s;
                if (void 0 === r && (r = new u), void 0 === n && (n = !0), "object" !== typeof e) throw new Error("expected object containing data: " + JSON.stringify(e));
                this.base && this.base.serialize(t, e, r, n);
                try {
                    for (var o = a(this.fields), h = o.next(); !h.done; h = o.next()) {
                        var f = h.value;
                        if (f.name in e) {
                            if (r.skippedBinaryExtension) throw new Error("unexpected " + this.name + "." + f.name);
                            f.type.serialize(t, e[f.name], r, n && f === this.fields[this.fields.length - 1])
                        } else {
                            if (!n || !f.type.extensionOf) throw new Error("missing " + this.name + "." + f.name + " (type=" + f.type.name + ")");
                            r.skippedBinaryExtension = !0
                        }
                    }
                } catch (c) {
                    i = {
                        error: c
                    }
                } finally {
                    try {
                        h && !h.done && (s = o.return) && s.call(o)
                    } finally {
                        if (i) throw i.error
                    }
                }
            }

            function x(t, e, r) {
                var n, i, s;
                void 0 === e && (e = new u), void 0 === r && (r = !0), s = this.base ? this.base.deserialize(t, e, r) : {};
                try {
                    for (var o = a(this.fields), h = o.next(); !h.done; h = o.next()) {
                        var f = h.value;
                        r && f.type.extensionOf && !t.haveReadData() ? e.skippedBinaryExtension = !0 : s[f.name] = f.type.deserialize(t, e, r)
                    }
                } catch (c) {
                    n = {
                        error: c
                    }
                } finally {
                    try {
                        h && !h.done && (i = o.return) && i.call(o)
                    } finally {
                        if (n) throw n.error
                    }
                }
                return s
            }

            function E(t, e, r, n) {
                if (!Array.isArray(e) || 2 !== e.length || "string" !== typeof e[0]) throw new Error('expected variant: ["type", value]');
                var i = this.fields.findIndex((function(t) {
                    return t.name === e[0]
                }));
                if (i < 0) throw new Error('type "' + e[0] + '" is not valid for variant');
                t.pushVaruint32(i), this.fields[i].type.serialize(t, e[1], r, n)
            }

            function k(t, e, r) {
                var n = t.getVaruint32();
                if (n >= this.fields.length) throw new Error("type index " + n + " is not valid for variant");
                var i = this.fields[n];
                return [i.name, i.type.deserialize(t, e, r)]
            }

            function R(t, e, r, n) {
                var i, s;
                t.pushVaruint32(e.length);
                try {
                    for (var o = a(e), u = o.next(); !u.done; u = o.next()) {
                        var h = u.value;
                        this.arrayOf.serialize(t, h, r, !1)
                    }
                } catch (f) {
                    i = {
                        error: f
                    }
                } finally {
                    try {
                        u && !u.done && (s = o.return) && s.call(o)
                    } finally {
                        if (i) throw i.error
                    }
                }
            }

            function O(t, e, r) {
                for (var n = t.getVaruint32(), i = [], s = 0; s < n; ++s) i.push(this.arrayOf.deserialize(t, e, !1));
                return i
            }

            function I(t, e, r, n) {
                null === e || void 0 === e ? t.push(0) : (t.push(1), this.optionalOf.serialize(t, e, r, n))
            }

            function P(t, e, r) {
                return t.get() ? this.optionalOf.deserialize(t, e, r) : null
            }

            function T(t, e, r, n) {
                this.extensionOf.serialize(t, e, r, n)
            }

            function N(t, e, r) {
                return this.extensionOf.deserialize(t, e, r)
            }
            e.hexToUint8Array = _;
            var j = function(t) {
                    return n({
                        name: "<missing name>",
                        aliasOfName: "",
                        arrayOf: null,
                        optionalOf: null,
                        extensionOf: null,
                        baseName: "",
                        base: null,
                        fields: [],
                        serialize: M,
                        deserialize: A
                    }, t)
                },
                C = function(t, e) {
                    if (Number.isNaN(+t) || Number.isNaN(+e) || "number" !== typeof t && "string" !== typeof t) throw new Error("Expected number");
                    if (+t !== +e) throw new Error("Number is out of range");
                    return +t
                },
                z = function() {
                    var t = new Map(Object.entries({
                        bool: j({
                            name: "bool",
                            serialize: function(t, e) {
                                if ("boolean" !== typeof e && ("number" !== typeof e || 1 !== e && 0 !== e)) throw new Error("Expected boolean or number equal to 1 or 0");
                                t.push(e ? 1 : 0)
                            },
                            deserialize: function(t) {
                                return !!t.get()
                            }
                        }),
                        uint8: j({
                            name: "uint8",
                            serialize: function(t, e) {
                                t.push(C(e, 255 & e))
                            },
                            deserialize: function(t) {
                                return t.get()
                            }
                        }),
                        int8: j({
                            name: "int8",
                            serialize: function(t, e) {
                                t.push(C(e, e << 24 >> 24))
                            },
                            deserialize: function(t) {
                                return t.get() << 24 >> 24
                            }
                        }),
                        uint16: j({
                            name: "uint16",
                            serialize: function(t, e) {
                                t.pushUint16(C(e, 65535 & e))
                            },
                            deserialize: function(t) {
                                return t.getUint16()
                            }
                        }),
                        int16: j({
                            name: "int16",
                            serialize: function(t, e) {
                                t.pushUint16(C(e, e << 16 >> 16))
                            },
                            deserialize: function(t) {
                                return t.getUint16() << 16 >> 16
                            }
                        }),
                        uint32: j({
                            name: "uint32",
                            serialize: function(t, e) {
                                t.pushUint32(C(e, e >>> 0))
                            },
                            deserialize: function(t) {
                                return t.getUint32()
                            }
                        }),
                        uint64: j({
                            name: "uint64",
                            serialize: function(t, e) {
                                t.pushArray(o.decimalToBinary(8, "" + e))
                            },
                            deserialize: function(t) {
                                return o.binaryToDecimal(t.getUint8Array(8))
                            }
                        }),
                        int64: j({
                            name: "int64",
                            serialize: function(t, e) {
                                t.pushArray(o.signedDecimalToBinary(8, "" + e))
                            },
                            deserialize: function(t) {
                                return o.signedBinaryToDecimal(t.getUint8Array(8))
                            }
                        }),
                        int32: j({
                            name: "int32",
                            serialize: function(t, e) {
                                t.pushUint32(C(e, 0 | e))
                            },
                            deserialize: function(t) {
                                return 0 | t.getUint32()
                            }
                        }),
                        varuint32: j({
                            name: "varuint32",
                            serialize: function(t, e) {
                                t.pushVaruint32(C(e, e >>> 0))
                            },
                            deserialize: function(t) {
                                return t.getVaruint32()
                            }
                        }),
                        varint32: j({
                            name: "varint32",
                            serialize: function(t, e) {
                                t.pushVarint32(C(e, 0 | e))
                            },
                            deserialize: function(t) {
                                return t.getVarint32()
                            }
                        }),
                        uint128: j({
                            name: "uint128",
                            serialize: function(t, e) {
                                t.pushArray(o.decimalToBinary(16, "" + e))
                            },
                            deserialize: function(t) {
                                return o.binaryToDecimal(t.getUint8Array(16))
                            }
                        }),
                        int128: j({
                            name: "int128",
                            serialize: function(t, e) {
                                t.pushArray(o.signedDecimalToBinary(16, "" + e))
                            },
                            deserialize: function(t) {
                                return o.signedBinaryToDecimal(t.getUint8Array(16))
                            }
                        }),
                        float32: j({
                            name: "float32",
                            serialize: function(t, e) {
                                t.pushFloat32(e)
                            },
                            deserialize: function(t) {
                                return t.getFloat32()
                            }
                        }),
                        float64: j({
                            name: "float64",
                            serialize: function(t, e) {
                                t.pushFloat64(e)
                            },
                            deserialize: function(t) {
                                return t.getFloat64()
                            }
                        }),
                        float128: j({
                            name: "float128",
                            serialize: function(t, r) {
                                t.pushUint8ArrayChecked(e.hexToUint8Array(r), 16)
                            },
                            deserialize: function(t) {
                                return e.arrayToHex(t.getUint8Array(16))
                            }
                        }),
                        bytes: j({
                            name: "bytes",
                            serialize: function(t, r) {
                                r instanceof Uint8Array || Array.isArray(r) ? t.pushBytes(r) : t.pushBytes(e.hexToUint8Array(r))
                            },
                            deserialize: function(t, r) {
                                return r && r.options.bytesAsUint8Array ? t.getBytes() : e.arrayToHex(t.getBytes())
                            }
                        }),
                        string: j({
                            name: "string",
                            serialize: function(t, e) {
                                t.pushString(e)
                            },
                            deserialize: function(t) {
                                return t.getString()
                            }
                        }),
                        name: j({
                            name: "name",
                            serialize: function(t, e) {
                                t.pushName(e)
                            },
                            deserialize: function(t) {
                                return t.getName()
                            }
                        }),
                        time_point: j({
                            name: "time_point",
                            serialize: function(t, r) {
                                t.pushNumberAsUint64(e.dateToTimePoint(r))
                            },
                            deserialize: function(t) {
                                return e.timePointToDate(t.getUint64AsNumber())
                            }
                        }),
                        time_point_sec: j({
                            name: "time_point_sec",
                            serialize: function(t, r) {
                                t.pushUint32(e.dateToTimePointSec(r))
                            },
                            deserialize: function(t) {
                                return e.timePointSecToDate(t.getUint32())
                            }
                        }),
                        block_timestamp_type: j({
                            name: "block_timestamp_type",
                            serialize: function(t, r) {
                                t.pushUint32(e.dateToBlockTimestamp(r))
                            },
                            deserialize: function(t) {
                                return e.blockTimestampToDate(t.getUint32())
                            }
                        }),
                        symbol_code: j({
                            name: "symbol_code",
                            serialize: function(t, e) {
                                t.pushSymbolCode(e)
                            },
                            deserialize: function(t) {
                                return t.getSymbolCode()
                            }
                        }),
                        symbol: j({
                            name: "symbol",
                            serialize: function(t, r) {
                                t.pushSymbol(e.stringToSymbol(r))
                            },
                            deserialize: function(t) {
                                return e.symbolToString(t.getSymbol())
                            }
                        }),
                        asset: j({
                            name: "asset",
                            serialize: function(t, e) {
                                t.pushAsset(e)
                            },
                            deserialize: function(t) {
                                return t.getAsset()
                            }
                        }),
                        checksum160: j({
                            name: "checksum160",
                            serialize: function(t, r) {
                                t.pushUint8ArrayChecked(e.hexToUint8Array(r), 20)
                            },
                            deserialize: function(t) {
                                return e.arrayToHex(t.getUint8Array(20))
                            }
                        }),
                        checksum256: j({
                            name: "checksum256",
                            serialize: function(t, r) {
                                t.pushUint8ArrayChecked(e.hexToUint8Array(r), 32)
                            },
                            deserialize: function(t) {
                                return e.arrayToHex(t.getUint8Array(32))
                            }
                        }),
                        checksum512: j({
                            name: "checksum512",
                            serialize: function(t, r) {
                                t.pushUint8ArrayChecked(e.hexToUint8Array(r), 64)
                            },
                            deserialize: function(t) {
                                return e.arrayToHex(t.getUint8Array(64))
                            }
                        }),
                        public_key: j({
                            name: "public_key",
                            serialize: function(t, e) {
                                t.pushPublicKey(e)
                            },
                            deserialize: function(t) {
                                return t.getPublicKey()
                            }
                        }),
                        private_key: j({
                            name: "private_key",
                            serialize: function(t, e) {
                                t.pushPrivateKey(e)
                            },
                            deserialize: function(t) {
                                return t.getPrivateKey()
                            }
                        }),
                        signature: j({
                            name: "signature",
                            serialize: function(t, e) {
                                t.pushSignature(e)
                            },
                            deserialize: function(t) {
                                return t.getSignature()
                            }
                        })
                    }));
                    return t.set("extended_asset", j({
                        name: "extended_asset",
                        baseName: "",
                        fields: [{
                            name: "quantity",
                            typeName: "asset",
                            type: t.get("asset")
                        }, {
                            name: "contract",
                            typeName: "name",
                            type: t.get("name")
                        }],
                        serialize: S,
                        deserialize: x
                    })), t
                };
            e.createInitialTypes = z;
            var D = function(t, r) {
                var n = t.get(r);
                if (n && n.aliasOfName) return e.getType(t, n.aliasOfName);
                if (n) return n;
                if (r.endsWith("[]")) return j({
                    name: r,
                    arrayOf: e.getType(t, r.substr(0, r.length - 2)),
                    serialize: R,
                    deserialize: O
                });
                if (r.endsWith("?")) return j({
                    name: r,
                    optionalOf: e.getType(t, r.substr(0, r.length - 1)),
                    serialize: I,
                    deserialize: P
                });
                if (r.endsWith("$")) return j({
                    name: r,
                    extensionOf: e.getType(t, r.substr(0, r.length - 1)),
                    serialize: T,
                    deserialize: N
                });
                throw new Error("Unknown type: " + r)
            };
            e.getType = D;
            var L = function(t, r) {
                var n, s, o, u, h, f, c, l, d, p, m = new Map(t);
                if (r.types) try {
                    for (var b = a(r.types), g = b.next(); !g.done; g = b.next()) {
                        var y = g.value,
                            v = y.new_type_name,
                            w = y.type;
                        m.set(v, j({
                            name: v,
                            aliasOfName: w
                        }))
                    }
                } catch (q) {
                    n = {
                        error: q
                    }
                } finally {
                    try {
                        g && !g.done && (s = b.return) && s.call(b)
                    } finally {
                        if (n) throw n.error
                    }
                }
                if (r.structs) try {
                    for (var _ = a(r.structs), M = _.next(); !M.done; M = _.next()) {
                        var A = M.value,
                            R = A.name,
                            O = A.base,
                            I = A.fields;
                        m.set(R, j({
                            name: R,
                            baseName: O,
                            fields: I.map((function(t) {
                                var e = t.name,
                                    r = t.type;
                                return {
                                    name: e,
                                    typeName: r,
                                    type: null
                                }
                            })),
                            serialize: S,
                            deserialize: x
                        }))
                    }
                } catch (K) {
                    o = {
                        error: K
                    }
                } finally {
                    try {
                        M && !M.done && (u = _.return) && u.call(_)
                    } finally {
                        if (o) throw o.error
                    }
                }
                if (r.variants) try {
                    for (var P = a(r.variants), T = P.next(); !T.done; T = P.next()) {
                        var N = T.value,
                            C = N.name,
                            z = N.types;
                        m.set(C, j({
                            name: C,
                            fields: z.map((function(t) {
                                return {
                                    name: t,
                                    typeName: t,
                                    type: null
                                }
                            })),
                            serialize: E,
                            deserialize: k
                        }))
                    }
                } catch (V) {
                    h = {
                        error: V
                    }
                } finally {
                    try {
                        T && !T.done && (f = P.return) && f.call(P)
                    } finally {
                        if (h) throw h.error
                    }
                }
                try {
                    for (var D = a(m), L = D.next(); !L.done; L = D.next()) {
                        var F = i(L.value, 2);
                        F[0], w = F[1];
                        w.baseName && (w.base = e.getType(m, w.baseName));
                        try {
                            for (var B = (d = void 0, a(w.fields)), $ = B.next(); !$.done; $ = B.next()) {
                                var U = $.value;
                                U.type = e.getType(m, U.typeName)
                            }
                        } catch (W) {
                            d = {
                                error: W
                            }
                        } finally {
                            try {
                                $ && !$.done && (p = B.return) && p.call(B)
                            } finally {
                                if (d) throw d.error
                            }
                        }
                    }
                } catch (Z) {
                    c = {
                        error: Z
                    }
                } finally {
                    try {
                        L && !L.done && (l = D.return) && l.call(D)
                    } finally {
                        if (c) throw c.error
                    }
                }
                return m
            };
            e.getTypesFromAbi = L;
            var F = function(t) {
                    return t.substr(6, 2) + t.substr(4, 2) + t.substr(2, 2) + t.substr(0, 2)
                },
                B = function(t, r) {
                    var n = t.header ? t.header.timestamp : t.timestamp,
                        i = parseInt(F(t.id.substr(16, 8)), 16);
                    return {
                        expiration: e.timePointSecToDate(e.dateToTimePointSec(n) + r),
                        ref_block_num: 65535 & t.block_num,
                        ref_block_prefix: i
                    }
                };
            e.transactionHeader = B;
            var $ = function(t, r, n, i, s, a) {
                var o = t.actions.get(n);
                if (!o) throw new Error("Unknown action " + n + " in contract " + r);
                var u = new h({
                    textEncoder: s,
                    textDecoder: a
                });
                return o.serialize(u, i), e.arrayToHex(u.asUint8Array())
            };
            e.serializeActionData = $;
            var U = function(t, r, n, i, s, a, o) {
                return {
                    account: r,
                    name: n,
                    authorization: i,
                    data: e.serializeActionData(t, r, n, s, a, o)
                }
            };
            e.serializeAction = U;
            var q = function(t, r, n, i, s, a) {
                var o = t.actions.get(n);
                if ("string" === typeof i && (i = e.hexToUint8Array(i)), !o) throw new Error("Unknown action " + n + " in contract " + r);
                var u = new h({
                    textDecoder: a,
                    textEncoder: s
                });
                return u.pushArray(i), o.deserialize(u)
            };
            e.deserializeActionData = q;
            var K = function(t, r, n, i, s, a, o) {
                return {
                    account: r,
                    name: n,
                    authorization: i,
                    data: e.deserializeActionData(t, r, n, s, a, o)
                }
            };
            e.deserializeAction = K
        },
        "93e6": function(t, e, r) {
            "use strict";
            var n = r("0632").Buffer,
                i = r("334a").Transform,
                s = r("3fb5");

            function a(t, e) {
                if (!n.isBuffer(t) && "string" !== typeof t) throw new TypeError(e + " must be a string or a buffer")
            }

            function o(t) {
                i.call(this), this._block = n.allocUnsafe(t), this._blockSize = t, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1
            }
            s(o, i), o.prototype._transform = function(t, e, r) {
                var n = null;
                try {
                    this.update(t, e)
                } catch (i) {
                    n = i
                }
                r(n)
            }, o.prototype._flush = function(t) {
                var e = null;
                try {
                    this.push(this.digest())
                } catch (r) {
                    e = r
                }
                t(e)
            }, o.prototype.update = function(t, e) {
                if (a(t, "Data"), this._finalized) throw new Error("Digest already called");
                n.isBuffer(t) || (t = n.from(t, e));
                var r = this._block,
                    i = 0;
                while (this._blockOffset + t.length - i >= this._blockSize) {
                    for (var s = this._blockOffset; s < this._blockSize;) r[s++] = t[i++];
                    this._update(), this._blockOffset = 0
                }
                while (i < t.length) r[this._blockOffset++] = t[i++];
                for (var o = 0, u = 8 * t.length; u > 0; ++o) this._length[o] += u, u = this._length[o] / 4294967296 | 0, u > 0 && (this._length[o] -= 4294967296 * u);
                return this
            }, o.prototype._update = function() {
                throw new Error("_update is not implemented")
            }, o.prototype.digest = function(t) {
                if (this._finalized) throw new Error("Digest already called");
                this._finalized = !0;
                var e = this._digest();
                void 0 !== t && (e = e.toString(t)), this._block.fill(0), this._blockOffset = 0;
                for (var r = 0; r < 4; ++r) this._length[r] = 0;
                return e
            }, o.prototype._digest = function() {
                throw new Error("_digest is not implemented")
            }, t.exports = o
        },
        "945d": function(t, e, r) {
            "use strict";
            var n = r("7d92"),
                i = r("0cbb"),
                s = r("f3a3"),
                a = s.assert,
                o = s.parseBytes,
                u = r("380f"),
                h = r("44a3");

            function f(t) {
                if (a("ed25519" === t, "only tested with ed25519 so far"), !(this instanceof f)) return new f(t);
                t = i[t].curve, this.curve = t, this.g = t.g, this.g.precompute(t.n.bitLength() + 1), this.pointClass = t.point().constructor, this.encodingLength = Math.ceil(t.n.bitLength() / 8), this.hash = n.sha512
            }
            t.exports = f, f.prototype.sign = function(t, e) {
                t = o(t);
                var r = this.keyFromSecret(e),
                    n = this.hashInt(r.messagePrefix(), t),
                    i = this.g.mul(n),
                    s = this.encodePoint(i),
                    a = this.hashInt(s, r.pubBytes(), t).mul(r.priv()),
                    u = n.add(a).umod(this.curve.n);
                return this.makeSignature({
                    R: i,
                    S: u,
                    Rencoded: s
                })
            }, f.prototype.verify = function(t, e, r) {
                t = o(t), e = this.makeSignature(e);
                var n = this.keyFromPublic(r),
                    i = this.hashInt(e.Rencoded(), n.pubBytes(), t),
                    s = this.g.mul(e.S()),
                    a = e.R().add(n.pub().mul(i));
                return a.eq(s)
            }, f.prototype.hashInt = function() {
                for (var t = this.hash(), e = 0; e < arguments.length; e++) t.update(arguments[e]);
                return s.intFromLE(t.digest()).umod(this.curve.n)
            }, f.prototype.keyFromPublic = function(t) {
                return u.fromPublic(this, t)
            }, f.prototype.keyFromSecret = function(t) {
                return u.fromSecret(this, t)
            }, f.prototype.makeSignature = function(t) {
                return t instanceof h ? t : new h(this, t)
            }, f.prototype.encodePoint = function(t) {
                var e = t.getY().toArray("le", this.encodingLength);
                return e[this.encodingLength - 1] |= t.getX().isOdd() ? 128 : 0, e
            }, f.prototype.decodePoint = function(t) {
                t = s.parseBytes(t);
                var e = t.length - 1,
                    r = t.slice(0, e).concat(-129 & t[e]),
                    n = 0 !== (128 & t[e]),
                    i = s.intFromLE(r);
                return this.curve.pointFromY(i, n)
            }, f.prototype.encodeInt = function(t) {
                return t.toArray("le", this.encodingLength)
            }, f.prototype.decodeInt = function(t) {
                return s.intFromLE(t)
            }, f.prototype.isPoint = function(t) {
                return t instanceof this.pointClass
            }
        },
        "96a5": function(t, e, r) {
            "use strict";

            function n(t, e) {
                var r = Object.keys(t);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(t);
                    e && (n = n.filter((function(e) {
                        return Object.getOwnPropertyDescriptor(t, e).enumerable
                    }))), r.push.apply(r, n)
                }
                return r
            }

            function i(t) {
                for (var e = 1; e < arguments.length; e++) {
                    var r = null != arguments[e] ? arguments[e] : {};
                    e % 2 ? n(Object(r), !0).forEach((function(e) {
                        s(t, e, r[e])
                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : n(Object(r)).forEach((function(e) {
                        Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(r, e))
                    }))
                }
                return t
            }

            function s(t, e, r) {
                return e in t ? Object.defineProperty(t, e, {
                    value: r,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : t[e] = r, t
            }

            function a(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }

            function o(t, e) {
                for (var r = 0; r < e.length; r++) {
                    var n = e[r];
                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                }
            }

            function u(t, e, r) {
                return e && o(t.prototype, e), r && o(t, r), t
            }
            var h = r("b639"),
                f = h.Buffer,
                c = r(5),
                l = c.inspect,
                d = l && l.custom || "inspect";

            function p(t, e, r) {
                f.prototype.copy.call(t, e, r)
            }
            t.exports = function() {
                function t() {
                    a(this, t), this.head = null, this.tail = null, this.length = 0
                }
                return u(t, [{
                    key: "push",
                    value: function(t) {
                        var e = {
                            data: t,
                            next: null
                        };
                        this.length > 0 ? this.tail.next = e : this.head = e, this.tail = e, ++this.length
                    }
                }, {
                    key: "unshift",
                    value: function(t) {
                        var e = {
                            data: t,
                            next: this.head
                        };
                        0 === this.length && (this.tail = e), this.head = e, ++this.length
                    }
                }, {
                    key: "shift",
                    value: function() {
                        if (0 !== this.length) {
                            var t = this.head.data;
                            return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, t
                        }
                    }
                }, {
                    key: "clear",
                    value: function() {
                        this.head = this.tail = null, this.length = 0
                    }
                }, {
                    key: "join",
                    value: function(t) {
                        if (0 === this.length) return "";
                        var e = this.head,
                            r = "" + e.data;
                        while (e = e.next) r += t + e.data;
                        return r
                    }
                }, {
                    key: "concat",
                    value: function(t) {
                        if (0 === this.length) return f.alloc(0);
                        var e = f.allocUnsafe(t >>> 0),
                            r = this.head,
                            n = 0;
                        while (r) p(r.data, e, n), n += r.data.length, r = r.next;
                        return e
                    }
                }, {
                    key: "consume",
                    value: function(t, e) {
                        var r;
                        return t < this.head.data.length ? (r = this.head.data.slice(0, t), this.head.data = this.head.data.slice(t)) : r = t === this.head.data.length ? this.shift() : e ? this._getString(t) : this._getBuffer(t), r
                    }
                }, {
                    key: "first",
                    value: function() {
                        return this.head.data
                    }
                }, {
                    key: "_getString",
                    value: function(t) {
                        var e = this.head,
                            r = 1,
                            n = e.data;
                        t -= n.length;
                        while (e = e.next) {
                            var i = e.data,
                                s = t > i.length ? i.length : t;
                            if (s === i.length ? n += i : n += i.slice(0, t), t -= s, 0 === t) {
                                s === i.length ? (++r, e.next ? this.head = e.next : this.head = this.tail = null) : (this.head = e, e.data = i.slice(s));
                                break
                            }++r
                        }
                        return this.length -= r, n
                    }
                }, {
                    key: "_getBuffer",
                    value: function(t) {
                        var e = f.allocUnsafe(t),
                            r = this.head,
                            n = 1;
                        r.data.copy(e), t -= r.data.length;
                        while (r = r.next) {
                            var i = r.data,
                                s = t > i.length ? i.length : t;
                            if (i.copy(e, e.length - t, 0, s), t -= s, 0 === t) {
                                s === i.length ? (++n, r.next ? this.head = r.next : this.head = this.tail = null) : (this.head = r, r.data = i.slice(s));
                                break
                            }++n
                        }
                        return this.length -= n, e
                    }
                }, {
                    key: d,
                    value: function(t, e) {
                        return l(this, i({}, e, {
                            depth: 0,
                            customInspect: !1
                        }))
                    }
                }]), t
            }()
        },
        "9b67": function(t, e, r) {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            })
        },
        "9d8a": function(t, e, r) {
            "use strict";

            function n(t, e) {
                t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e
            }
            var i = {};

            function s(t, e, r) {
                function s(t, r, n) {
                    return "string" === typeof e ? e : e(t, r, n)
                }
                r || (r = Error);
                var a = function(t) {
                    function e(e, r, n) {
                        return t.call(this, s(e, r, n)) || this
                    }
                    return n(e, t), e
                }(r);
                a.prototype.name = r.name, a.prototype.code = t, i[t] = a
            }

            function a(t, e) {
                if (Array.isArray(t)) {
                    var r = t.length;
                    return t = t.map((function(t) {
                        return String(t)
                    })), r > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : 2 === r ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0])
                }
                return "of ".concat(e, " ").concat(String(t))
            }

            function o(t, e, r) {
                return t.substr(!r || r < 0 ? 0 : +r, e.length) === e
            }

            function u(t, e, r) {
                return (void 0 === r || r > t.length) && (r = t.length), t.substring(r - e.length, r) === e
            }

            function h(t, e, r) {
                return "number" !== typeof r && (r = 0), !(r + e.length > t.length) && -1 !== t.indexOf(e, r)
            }
            s("ERR_INVALID_OPT_VALUE", (function(t, e) {
                return 'The value "' + e + '" is invalid for option "' + t + '"'
            }), TypeError), s("ERR_INVALID_ARG_TYPE", (function(t, e, r) {
                var n, i;
                if ("string" === typeof e && o(e, "not ") ? (n = "must not be", e = e.replace(/^not /, "")) : n = "must be", u(t, " argument")) i = "The ".concat(t, " ").concat(n, " ").concat(a(e, "type"));
                else {
                    var s = h(t, ".") ? "property" : "argument";
                    i = 'The "'.concat(t, '" ').concat(s, " ").concat(n, " ").concat(a(e, "type"))
                }
                return i += ". Received type ".concat(typeof r), i
            }), TypeError), s("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), s("ERR_METHOD_NOT_IMPLEMENTED", (function(t) {
                return "The " + t + " method is not implemented"
            })), s("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), s("ERR_STREAM_DESTROYED", (function(t) {
                return "Cannot call " + t + " after a stream was destroyed"
            })), s("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), s("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), s("ERR_STREAM_WRITE_AFTER_END", "write after end"), s("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), s("ERR_UNKNOWN_ENCODING", (function(t) {
                return "Unknown encoding: " + t
            }), TypeError), s("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), t.exports.codes = i
        },
        a795: function(t, e, r) {
            "use strict";
            var n = this && this.__assign || function() {
                    return n = Object.assign || function(t) {
                        for (var e, r = 1, n = arguments.length; r < n; r++)
                            for (var i in e = arguments[r], e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
                        return t
                    }, n.apply(this, arguments)
                },
                i = this && this.__awaiter || function(t, e, r, n) {
                    function i(t) {
                        return t instanceof r ? t : new r((function(e) {
                            e(t)
                        }))
                    }
                    return new(r || (r = Promise))((function(r, s) {
                        function a(t) {
                            try {
                                u(n.next(t))
                            } catch (e) {
                                s(e)
                            }
                        }

                        function o(t) {
                            try {
                                u(n["throw"](t))
                            } catch (e) {
                                s(e)
                            }
                        }

                        function u(t) {
                            t.done ? r(t.value) : i(t.value).then(a, o)
                        }
                        u((n = n.apply(t, e || [])).next())
                    }))
                },
                s = this && this.__generator || function(t, e) {
                    var r, n, i, s, a = {
                        label: 0,
                        sent: function() {
                            if (1 & i[0]) throw i[1];
                            return i[1]
                        },
                        trys: [],
                        ops: []
                    };
                    return s = {
                        next: o(0),
                        throw: o(1),
                        return: o(2)
                    }, "function" === typeof Symbol && (s[Symbol.iterator] = function() {
                        return this
                    }), s;

                    function o(t) {
                        return function(e) {
                            return u([t, e])
                        }
                    }

                    function u(s) {
                        if (r) throw new TypeError("Generator is already executing.");
                        while (a) try {
                            if (r = 1, n && (i = 2 & s[0] ? n["return"] : s[0] ? n["throw"] || ((i = n["return"]) && i.call(n), 0) : n.next) && !(i = i.call(n, s[1])).done) return i;
                            switch (n = 0, i && (s = [2 & s[0], i.value]), s[0]) {
                                case 0:
                                case 1:
                                    i = s;
                                    break;
                                case 4:
                                    return a.label++, {
                                        value: s[1],
                                        done: !1
                                    };
                                case 5:
                                    a.label++, n = s[1], s = [0];
                                    continue;
                                case 7:
                                    s = a.ops.pop(), a.trys.pop();
                                    continue;
                                default:
                                    if (i = a.trys, !(i = i.length > 0 && i[i.length - 1]) && (6 === s[0] || 2 === s[0])) {
                                        a = 0;
                                        continue
                                    }
                                    if (3 === s[0] && (!i || s[1] > i[0] && s[1] < i[3])) {
                                        a.label = s[1];
                                        break
                                    }
                                    if (6 === s[0] && a.label < i[1]) {
                                        a.label = i[1], i = s;
                                        break
                                    }
                                    if (i && a.label < i[2]) {
                                        a.label = i[2], a.ops.push(s);
                                        break
                                    }
                                    i[2] && a.ops.pop(), a.trys.pop();
                                    continue
                            }
                            s = e.call(t, a)
                        } catch (o) {
                            s = [6, o], n = 0
                        } finally {
                            r = i = 0
                        }
                        if (5 & s[0]) throw s[1];
                        return {
                            value: s[0] ? s[1] : void 0,
                            done: !0
                        }
                    }
                },
                a = this && this.__read || function(t, e) {
                    var r = "function" === typeof Symbol && t[Symbol.iterator];
                    if (!r) return t;
                    var n, i, s = r.call(t),
                        a = [];
                    try {
                        while ((void 0 === e || e-- > 0) && !(n = s.next()).done) a.push(n.value)
                    } catch (o) {
                        i = {
                            error: o
                        }
                    } finally {
                        try {
                            n && !n.done && (r = s["return"]) && r.call(s)
                        } finally {
                            if (i) throw i.error
                        }
                    }
                    return a
                },
                o = this && this.__spreadArray || function(t, e) {
                    for (var r = 0, n = e.length, i = t.length; r < n; r++, i++) t[i] = e[r];
                    return t
                },
                u = this && this.__values || function(t) {
                    var e = "function" === typeof Symbol && Symbol.iterator,
                        r = e && t[e],
                        n = 0;
                    if (r) return r.call(t);
                    if (t && "number" === typeof t.length) return {
                        next: function() {
                            return t && n >= t.length && (t = void 0), {
                                value: t && t[n++],
                                done: !t
                            }
                        }
                    };
                    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
                };
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.Api = void 0;
            var h = r("14c5"),
                f = r("9392"),
                c = r("7626"),
                l = r("66b1"),
                d = function() {
                    function t(t) {
                        this.contracts = new Map, this.cachedAbis = new Map, this.rpc = t.rpc, this.authorityProvider = t.authorityProvider || t.rpc, this.abiProvider = t.abiProvider || t.rpc, this.signatureProvider = t.signatureProvider, this.chainId = t.chainId, this.textEncoder = t.textEncoder, this.textDecoder = t.textDecoder, this.abiTypes = f.getTypesFromAbi(f.createInitialTypes(), c), this.transactionTypes = f.getTypesFromAbi(f.createInitialTypes(), l)
                    }
                    return t.prototype.rawAbiToJson = function(t) {
                        var e = new f.SerialBuffer({
                            textEncoder: this.textEncoder,
                            textDecoder: this.textDecoder,
                            array: t
                        });
                        if (!f.supportedAbiVersion(e.getString())) throw new Error("Unsupported abi version");
                        return e.restartRead(), this.abiTypes.get("abi_def").deserialize(e)
                    }, t.prototype.jsonToRawAbi = function(t) {
                        var e = new f.SerialBuffer({
                            textEncoder: this.textEncoder,
                            textDecoder: this.textDecoder
                        });
                        if (this.abiTypes.get("abi_def").serialize(e, t), !f.supportedAbiVersion(e.getString())) throw new Error("Unsupported abi version");
                        return e.asUint8Array()
                    }, t.prototype.getCachedAbi = function(t, e) {
                        return void 0 === e && (e = !1), i(this, void 0, void 0, (function() {
                            var r, n, i, a;
                            return s(this, (function(s) {
                                switch (s.label) {
                                    case 0:
                                        if (!e && this.cachedAbis.get(t)) return [2, this.cachedAbis.get(t)];
                                        s.label = 1;
                                    case 1:
                                        return s.trys.push([1, 3, , 4]), [4, this.abiProvider.getRawAbi(t)];
                                    case 2:
                                        return n = s.sent().abi, i = this.rawAbiToJson(n), r = {
                                            rawAbi: n,
                                            abi: i
                                        }, [3, 4];
                                    case 3:
                                        throw a = s.sent(), a.message = "fetching abi for " + t + ": " + a.message, a;
                                    case 4:
                                        if (!r) throw new Error("Missing abi for " + t);
                                        return this.cachedAbis.set(t, r), [2, r]
                                }
                            }))
                        }))
                    }, t.prototype.getAbi = function(t, e) {
                        return void 0 === e && (e = !1), i(this, void 0, void 0, (function() {
                            return s(this, (function(r) {
                                switch (r.label) {
                                    case 0:
                                        return [4, this.getCachedAbi(t, e)];
                                    case 1:
                                        return [2, r.sent().abi]
                                }
                            }))
                        }))
                    }, t.prototype.getTransactionAbis = function(t, e) {
                        return void 0 === e && (e = !1), i(this, void 0, void 0, (function() {
                            var r, n, u, h, f = this;
                            return s(this, (function(c) {
                                return r = (t.context_free_actions || []).concat(t.actions), n = r.map((function(t) {
                                    return t.account
                                })), u = new Set(n), h = o([], a(u)).map((function(t) {
                                    return i(f, void 0, void 0, (function() {
                                        var r;
                                        return s(this, (function(n) {
                                            switch (n.label) {
                                                case 0:
                                                    return r = {
                                                        accountName: t
                                                    }, [4, this.getCachedAbi(t, e)];
                                                case 1:
                                                    return [2, (r.abi = n.sent().rawAbi, r)]
                                            }
                                        }))
                                    }))
                                })), [2, Promise.all(h)]
                            }))
                        }))
                    }, t.prototype.getContract = function(t, e) {
                        return void 0 === e && (e = !1), i(this, void 0, void 0, (function() {
                            var r, n, i, a, o, h, c, l, d, p, m;
                            return s(this, (function(s) {
                                switch (s.label) {
                                    case 0:
                                        return !e && this.contracts.get(t) ? [2, this.contracts.get(t)] : [4, this.getAbi(t, e)];
                                    case 1:
                                        r = s.sent(), n = f.getTypesFromAbi(f.createInitialTypes(), r), i = new Map;
                                        try {
                                            for (a = u(r.actions), o = a.next(); !o.done; o = a.next()) h = o.value, c = h.name, l = h.type, i.set(c, f.getType(n, l))
                                        } catch (b) {
                                            p = {
                                                error: b
                                            }
                                        } finally {
                                            try {
                                                o && !o.done && (m = a.return) && m.call(a)
                                            } finally {
                                                if (p) throw p.error
                                            }
                                        }
                                        return d = {
                                            types: n,
                                            actions: i
                                        }, this.contracts.set(t, d), [2, d]
                                }
                            }))
                        }))
                    }, t.prototype.serialize = function(t, e, r) {
                        this.transactionTypes.get(e).serialize(t, r)
                    }, t.prototype.deserialize = function(t, e) {
                        return this.transactionTypes.get(e).deserialize(t)
                    }, t.prototype.serializeTransaction = function(t) {
                        var e = new f.SerialBuffer({
                            textEncoder: this.textEncoder,
                            textDecoder: this.textDecoder
                        });
                        return this.serialize(e, "transaction", n({
                            max_net_usage_words: 0,
                            max_cpu_usage_ms: 0,
                            delay_sec: 0,
                            context_free_actions: [],
                            actions: [],
                            transaction_extensions: []
                        }, t)), e.asUint8Array()
                    }, t.prototype.serializeContextFreeData = function(t) {
                        var e, r;
                        if (!t || !t.length) return null;
                        var n = new f.SerialBuffer({
                            textEncoder: this.textEncoder,
                            textDecoder: this.textDecoder
                        });
                        n.pushVaruint32(t.length);
                        try {
                            for (var i = u(t), s = i.next(); !s.done; s = i.next()) {
                                var a = s.value;
                                n.pushBytes(a)
                            }
                        } catch (o) {
                            e = {
                                error: o
                            }
                        } finally {
                            try {
                                s && !s.done && (r = i.return) && r.call(i)
                            } finally {
                                if (e) throw e.error
                            }
                        }
                        return n.asUint8Array()
                    }, t.prototype.deserializeTransaction = function(t) {
                        var e = new f.SerialBuffer({
                            textEncoder: this.textEncoder,
                            textDecoder: this.textDecoder
                        });
                        return e.pushArray(t), this.deserialize(e, "transaction")
                    }, t.prototype.serializeActions = function(t) {
                        return i(this, void 0, void 0, (function() {
                            var e = this;
                            return s(this, (function(r) {
                                switch (r.label) {
                                    case 0:
                                        return [4, Promise.all(t.map((function(t) {
                                            var r = t.account,
                                                n = t.name,
                                                a = t.authorization,
                                                o = t.data;
                                            return i(e, void 0, void 0, (function() {
                                                var t;
                                                return s(this, (function(e) {
                                                    switch (e.label) {
                                                        case 0:
                                                            return [4, this.getContract(r)];
                                                        case 1:
                                                            return t = e.sent(), [2, f.serializeAction(t, r, n, a, o, this.textEncoder, this.textDecoder)]
                                                    }
                                                }))
                                            }))
                                        })))];
                                    case 1:
                                        return [2, r.sent()]
                                }
                            }))
                        }))
                    }, t.prototype.deserializeActions = function(t) {
                        return i(this, void 0, void 0, (function() {
                            var e = this;
                            return s(this, (function(r) {
                                switch (r.label) {
                                    case 0:
                                        return [4, Promise.all(t.map((function(t) {
                                            var r = t.account,
                                                n = t.name,
                                                a = t.authorization,
                                                o = t.data;
                                            return i(e, void 0, void 0, (function() {
                                                var t;
                                                return s(this, (function(e) {
                                                    switch (e.label) {
                                                        case 0:
                                                            return [4, this.getContract(r)];
                                                        case 1:
                                                            return t = e.sent(), [2, f.deserializeAction(t, r, n, a, o, this.textEncoder, this.textDecoder)]
                                                    }
                                                }))
                                            }))
                                        })))];
                                    case 1:
                                        return [2, r.sent()]
                                }
                            }))
                        }))
                    }, t.prototype.deserializeTransactionWithActions = function(t) {
                        return i(this, void 0, void 0, (function() {
                            var e, r, i;
                            return s(this, (function(s) {
                                switch (s.label) {
                                    case 0:
                                        return "string" === typeof t && (t = f.hexToUint8Array(t)), e = this.deserializeTransaction(t), [4, this.deserializeActions(e.context_free_actions)];
                                    case 1:
                                        return r = s.sent(), [4, this.deserializeActions(e.actions)];
                                    case 2:
                                        return i = s.sent(), [2, n(n({}, e), {
                                            context_free_actions: r,
                                            actions: i
                                        })]
                                }
                            }))
                        }))
                    }, t.prototype.deflateSerializedArray = function(t) {
                        return h.deflate(t, {
                            level: 9
                        })
                    }, t.prototype.inflateSerializedArray = function(t) {
                        return h.inflate(t)
                    }, t.prototype.transact = function(t, e) {
                        var r = void 0 === e ? {} : e,
                            a = r.broadcast,
                            o = void 0 === a || a,
                            u = r.sign,
                            h = void 0 === u || u,
                            f = r.compression,
                            c = r.blocksBehind,
                            l = r.useLastIrreversible,
                            d = r.expireSeconds;
                        return i(this, void 0, void 0, (function() {
                            var e, r, i, a, u, p, m, b, g;
                            return s(this, (function(s) {
                                switch (s.label) {
                                    case 0:
                                        if ("number" === typeof c && l) throw new Error("Use either blocksBehind or useLastIrreversible");
                                        return this.chainId ? [3, 2] : [4, this.rpc.get_info()];
                                    case 1:
                                        e = s.sent(), this.chainId = e.chain_id, s.label = 2;
                                    case 2:
                                        return "number" !== typeof c && !l || !d ? [3, 4] : [4, this.generateTapos(e, t, c, l, d)];
                                    case 3:
                                        t = s.sent(), s.label = 4;
                                    case 4:
                                        if (!this.hasRequiredTaposFields(t)) throw new Error("Required configuration or TAPOS fields are not present");
                                        return [4, this.getTransactionAbis(t)];
                                    case 5:
                                        return r = s.sent(), i = [n({}, t)], g = {}, [4, this.serializeActions(t.context_free_actions || [])];
                                    case 6:
                                        return g.context_free_actions = s.sent(), [4, this.serializeActions(t.actions)];
                                    case 7:
                                        return t = n.apply(void 0, i.concat([(g.actions = s.sent(), g)])), a = this.serializeTransaction(t), u = this.serializeContextFreeData(t.context_free_data), p = {
                                            serializedTransaction: a,
                                            serializedContextFreeData: u,
                                            signatures: []
                                        }, h ? [4, this.signatureProvider.getAvailableKeys()] : [3, 11];
                                    case 8:
                                        return m = s.sent(), [4, this.authorityProvider.getRequiredKeys({
                                            transaction: t,
                                            availableKeys: m
                                        })];
                                    case 9:
                                        return b = s.sent(), [4, this.signatureProvider.sign({
                                            chainId: this.chainId,
                                            requiredKeys: b,
                                            serializedTransaction: a,
                                            serializedContextFreeData: u,
                                            abis: r
                                        })];
                                    case 10:
                                        p = s.sent(), s.label = 11;
                                    case 11:
                                        return o ? f ? [2, this.pushCompressedSignedTransaction(p)] : [2, this.pushSignedTransaction(p)] : [2, p]
                                }
                            }))
                        }))
                    }, t.prototype.pushSignedTransaction = function(t) {
                        var e = t.signatures,
                            r = t.serializedTransaction,
                            n = t.serializedContextFreeData;
                        return i(this, void 0, void 0, (function() {
                            return s(this, (function(t) {
                                return [2, this.rpc.push_transaction({
                                    signatures: e,
                                    serializedTransaction: r,
                                    serializedContextFreeData: n
                                })]
                            }))
                        }))
                    }, t.prototype.pushCompressedSignedTransaction = function(t) {
                        var e = t.signatures,
                            r = t.serializedTransaction,
                            n = t.serializedContextFreeData;
                        return i(this, void 0, void 0, (function() {
                            var t, i;
                            return s(this, (function(s) {
                                return t = this.deflateSerializedArray(r), i = this.deflateSerializedArray(n || new Uint8Array(0)), [2, this.rpc.push_transaction({
                                    signatures: e,
                                    compression: 1,
                                    serializedTransaction: t,
                                    serializedContextFreeData: i
                                })]
                            }))
                        }))
                    }, t.prototype.generateTapos = function(t, e, r, a, o) {
                        return i(this, void 0, void 0, (function() {
                            var i, u, h;
                            return s(this, (function(s) {
                                switch (s.label) {
                                    case 0:
                                        return t ? [3, 2] : [4, this.rpc.get_info()];
                                    case 1:
                                        t = s.sent(), s.label = 2;
                                    case 2:
                                        return i = a ? t.last_irreversible_block_num : t.head_block_num - r, i <= t.last_irreversible_block_num ? [4, this.rpc.get_block(i)] : [3, 4];
                                    case 3:
                                        return h = s.sent(), [3, 6];
                                    case 4:
                                        return [4, this.tryGetBlockHeaderState(i)];
                                    case 5:
                                        h = s.sent(), s.label = 6;
                                    case 6:
                                        return u = h, [2, n(n({}, f.transactionHeader(u, o)), e)]
                                }
                            }))
                        }))
                    }, t.prototype.hasRequiredTaposFields = function(t) {
                        var e = t.expiration,
                            r = t.ref_block_num,
                            n = t.ref_block_prefix;
                        return !(!e || "number" !== typeof r || "number" !== typeof n)
                    }, t.prototype.tryGetBlockHeaderState = function(t) {
                        return i(this, void 0, void 0, (function() {
                            return s(this, (function(e) {
                                switch (e.label) {
                                    case 0:
                                        return e.trys.push([0, 2, , 4]), [4, this.rpc.get_block_header_state(t)];
                                    case 1:
                                        return [2, e.sent()];
                                    case 2:
                                        return e.sent(), [4, this.rpc.get_block(t)];
                                    case 3:
                                        return [2, e.sent()];
                                    case 4:
                                        return [2]
                                }
                            }))
                        }))
                    }, t
                }();
            e.Api = d
        },
        aa56: function(t, e, r) {
            "use strict";
            var n = r("c3c0"),
                i = n.rotr32;

            function s(t, e, r, n) {
                return 0 === t ? a(e, r, n) : 1 === t || 3 === t ? u(e, r, n) : 2 === t ? o(e, r, n) : void 0
            }

            function a(t, e, r) {
                return t & e ^ ~t & r
            }

            function o(t, e, r) {
                return t & e ^ t & r ^ e & r
            }

            function u(t, e, r) {
                return t ^ e ^ r
            }

            function h(t) {
                return i(t, 2) ^ i(t, 13) ^ i(t, 22)
            }

            function f(t) {
                return i(t, 6) ^ i(t, 11) ^ i(t, 25)
            }

            function c(t) {
                return i(t, 7) ^ i(t, 18) ^ t >>> 3
            }

            function l(t) {
                return i(t, 17) ^ i(t, 19) ^ t >>> 10
            }
            e.ft_1 = s, e.ch32 = a, e.maj32 = o, e.p32 = u, e.s0_256 = h, e.s1_256 = f, e.g0_256 = c, e.g1_256 = l
        },
        ae84: function(t, e, r) {
            var n = r("8707").Buffer,
                i = r("f576");

            function s(t, e, r, s) {
                if (n.isBuffer(t) || (t = n.from(t, "binary")), e && (n.isBuffer(e) || (e = n.from(e, "binary")), 8 !== e.length)) throw new RangeError("salt should be Buffer with 8 byte length");
                var a = r / 8,
                    o = n.alloc(a),
                    u = n.alloc(s || 0),
                    h = n.alloc(0);
                while (a > 0 || s > 0) {
                    var f = new i;
                    f.update(h), f.update(t), e && f.update(e), h = f.digest();
                    var c = 0;
                    if (a > 0) {
                        var l = o.length - a;
                        c = Math.min(a, h.length), h.copy(o, l, 0, c), a -= c
                    }
                    if (c < h.length && s > 0) {
                        var d = u.length - s,
                            p = Math.min(s, h.length - c);
                        h.copy(u, d, c, c + p), s -= p
                    }
                }
                return h.fill(0), {
                    key: o,
                    iv: u
                }
            }
            t.exports = s
        },
        b525: function(t, e, r) {
            "use strict";
            var n = r("c3c0"),
                i = r("edc9"),
                s = r("da3e"),
                a = n.rotr64_hi,
                o = n.rotr64_lo,
                u = n.shr64_hi,
                h = n.shr64_lo,
                f = n.sum64,
                c = n.sum64_hi,
                l = n.sum64_lo,
                d = n.sum64_4_hi,
                p = n.sum64_4_lo,
                m = n.sum64_5_hi,
                b = n.sum64_5_lo,
                g = i.BlockHash,
                y = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];

            function v() {
                if (!(this instanceof v)) return new v;
                g.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = y, this.W = new Array(160)
            }

            function w(t, e, r, n, i) {
                var s = t & r ^ ~t & i;
                return s < 0 && (s += 4294967296), s
            }

            function _(t, e, r, n, i, s) {
                var a = e & n ^ ~e & s;
                return a < 0 && (a += 4294967296), a
            }

            function M(t, e, r, n, i) {
                var s = t & r ^ t & i ^ r & i;
                return s < 0 && (s += 4294967296), s
            }

            function A(t, e, r, n, i, s) {
                var a = e & n ^ e & s ^ n & s;
                return a < 0 && (a += 4294967296), a
            }

            function S(t, e) {
                var r = a(t, e, 28),
                    n = a(e, t, 2),
                    i = a(e, t, 7),
                    s = r ^ n ^ i;
                return s < 0 && (s += 4294967296), s
            }

            function x(t, e) {
                var r = o(t, e, 28),
                    n = o(e, t, 2),
                    i = o(e, t, 7),
                    s = r ^ n ^ i;
                return s < 0 && (s += 4294967296), s
            }

            function E(t, e) {
                var r = a(t, e, 14),
                    n = a(t, e, 18),
                    i = a(e, t, 9),
                    s = r ^ n ^ i;
                return s < 0 && (s += 4294967296), s
            }

            function k(t, e) {
                var r = o(t, e, 14),
                    n = o(t, e, 18),
                    i = o(e, t, 9),
                    s = r ^ n ^ i;
                return s < 0 && (s += 4294967296), s
            }

            function R(t, e) {
                var r = a(t, e, 1),
                    n = a(t, e, 8),
                    i = u(t, e, 7),
                    s = r ^ n ^ i;
                return s < 0 && (s += 4294967296), s
            }

            function O(t, e) {
                var r = o(t, e, 1),
                    n = o(t, e, 8),
                    i = h(t, e, 7),
                    s = r ^ n ^ i;
                return s < 0 && (s += 4294967296), s
            }

            function I(t, e) {
                var r = a(t, e, 19),
                    n = a(e, t, 29),
                    i = u(t, e, 6),
                    s = r ^ n ^ i;
                return s < 0 && (s += 4294967296), s
            }

            function P(t, e) {
                var r = o(t, e, 19),
                    n = o(e, t, 29),
                    i = h(t, e, 6),
                    s = r ^ n ^ i;
                return s < 0 && (s += 4294967296), s
            }
            n.inherits(v, g), t.exports = v, v.blockSize = 1024, v.outSize = 512, v.hmacStrength = 192, v.padLength = 128, v.prototype._prepareBlock = function(t, e) {
                for (var r = this.W, n = 0; n < 32; n++) r[n] = t[e + n];
                for (; n < r.length; n += 2) {
                    var i = I(r[n - 4], r[n - 3]),
                        s = P(r[n - 4], r[n - 3]),
                        a = r[n - 14],
                        o = r[n - 13],
                        u = R(r[n - 30], r[n - 29]),
                        h = O(r[n - 30], r[n - 29]),
                        f = r[n - 32],
                        c = r[n - 31];
                    r[n] = d(i, s, a, o, u, h, f, c), r[n + 1] = p(i, s, a, o, u, h, f, c)
                }
            }, v.prototype._update = function(t, e) {
                this._prepareBlock(t, e);
                var r = this.W,
                    n = this.h[0],
                    i = this.h[1],
                    a = this.h[2],
                    o = this.h[3],
                    u = this.h[4],
                    h = this.h[5],
                    d = this.h[6],
                    p = this.h[7],
                    g = this.h[8],
                    y = this.h[9],
                    v = this.h[10],
                    R = this.h[11],
                    O = this.h[12],
                    I = this.h[13],
                    P = this.h[14],
                    T = this.h[15];
                s(this.k.length === r.length);
                for (var N = 0; N < r.length; N += 2) {
                    var j = P,
                        C = T,
                        z = E(g, y),
                        D = k(g, y),
                        L = w(g, y, v, R, O, I),
                        F = _(g, y, v, R, O, I),
                        B = this.k[N],
                        $ = this.k[N + 1],
                        U = r[N],
                        q = r[N + 1],
                        K = m(j, C, z, D, L, F, B, $, U, q),
                        V = b(j, C, z, D, L, F, B, $, U, q);
                    j = S(n, i), C = x(n, i), z = M(n, i, a, o, u, h), D = A(n, i, a, o, u, h);
                    var W = c(j, C, z, D),
                        Z = l(j, C, z, D);
                    P = O, T = I, O = v, I = R, v = g, R = y, g = c(d, p, K, V), y = l(p, p, K, V), d = u, p = h, u = a, h = o, a = n, o = i, n = c(K, V, W, Z), i = l(K, V, W, Z)
                }
                f(this.h, 0, n, i), f(this.h, 2, a, o), f(this.h, 4, u, h), f(this.h, 6, d, p), f(this.h, 8, g, y), f(this.h, 10, v, R), f(this.h, 12, O, I), f(this.h, 14, P, T)
            }, v.prototype._digest = function(t) {
                return "hex" === t ? n.toHex32(this.h, "big") : n.split32(this.h, "big")
            }
        },
        b73f: function(t, e, r) {
            "use strict";
            var n = r("80af"),
                i = r("f3a3"),
                s = i.assert;

            function a(t, e) {
                if (t instanceof a) return t;
                this._importDER(t, e) || (s(t.r && t.s, "Signature without r or s"), this.r = new n(t.r, 16), this.s = new n(t.s, 16), void 0 === t.recoveryParam ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam)
            }

            function o() {
                this.place = 0
            }

            function u(t, e) {
                var r = t[e.place++];
                if (!(128 & r)) return r;
                var n = 15 & r;
                if (0 === n || n > 4) return !1;
                for (var i = 0, s = 0, a = e.place; s < n; s++, a++) i <<= 8, i |= t[a], i >>>= 0;
                return !(i <= 127) && (e.place = a, i)
            }

            function h(t) {
                var e = 0,
                    r = t.length - 1;
                while (!t[e] && !(128 & t[e + 1]) && e < r) e++;
                return 0 === e ? t : t.slice(e)
            }

            function f(t, e) {
                if (e < 128) t.push(e);
                else {
                    var r = 1 + (Math.log(e) / Math.LN2 >>> 3);
                    t.push(128 | r);
                    while (--r) t.push(e >>> (r << 3) & 255);
                    t.push(e)
                }
            }
            t.exports = a, a.prototype._importDER = function(t, e) {
                t = i.toArray(t, e);
                var r = new o;
                if (48 !== t[r.place++]) return !1;
                var s = u(t, r);
                if (!1 === s) return !1;
                if (s + r.place !== t.length) return !1;
                if (2 !== t[r.place++]) return !1;
                var a = u(t, r);
                if (!1 === a) return !1;
                var h = t.slice(r.place, a + r.place);
                if (r.place += a, 2 !== t[r.place++]) return !1;
                var f = u(t, r);
                if (!1 === f) return !1;
                if (t.length !== f + r.place) return !1;
                var c = t.slice(r.place, f + r.place);
                if (0 === h[0]) {
                    if (!(128 & h[1])) return !1;
                    h = h.slice(1)
                }
                if (0 === c[0]) {
                    if (!(128 & c[1])) return !1;
                    c = c.slice(1)
                }
                return this.r = new n(h), this.s = new n(c), this.recoveryParam = null, !0
            }, a.prototype.toDER = function(t) {
                var e = this.r.toArray(),
                    r = this.s.toArray();
                128 & e[0] && (e = [0].concat(e)), 128 & r[0] && (r = [0].concat(r)), e = h(e), r = h(r);
                while (!r[0] && !(128 & r[1])) r = r.slice(1);
                var n = [2];
                f(n, e.length), n = n.concat(e), n.push(2), f(n, r.length);
                var s = n.concat(r),
                    a = [48];
                return f(a, s.length), a = a.concat(s), i.encode(a, t)
            }
        },
        b927: function(t, e, r) {
            "use strict";
            (function(t) {
                var n = this && this.__awaiter || function(t, e, r, n) {
                        function i(t) {
                            return t instanceof r ? t : new r((function(e) {
                                e(t)
                            }))
                        }
                        return new(r || (r = Promise))((function(r, s) {
                            function a(t) {
                                try {
                                    u(n.next(t))
                                } catch (e) {
                                    s(e)
                                }
                            }

                            function o(t) {
                                try {
                                    u(n["throw"](t))
                                } catch (e) {
                                    s(e)
                                }
                            }

                            function u(t) {
                                t.done ? r(t.value) : i(t.value).then(a, o)
                            }
                            u((n = n.apply(t, e || [])).next())
                        }))
                    },
                    i = this && this.__generator || function(t, e) {
                        var r, n, i, s, a = {
                            label: 0,
                            sent: function() {
                                if (1 & i[0]) throw i[1];
                                return i[1]
                            },
                            trys: [],
                            ops: []
                        };
                        return s = {
                            next: o(0),
                            throw: o(1),
                            return: o(2)
                        }, "function" === typeof Symbol && (s[Symbol.iterator] = function() {
                            return this
                        }), s;

                        function o(t) {
                            return function(e) {
                                return u([t, e])
                            }
                        }

                        function u(s) {
                            if (r) throw new TypeError("Generator is already executing.");
                            while (a) try {
                                if (r = 1, n && (i = 2 & s[0] ? n["return"] : s[0] ? n["throw"] || ((i = n["return"]) && i.call(n), 0) : n.next) && !(i = i.call(n, s[1])).done) return i;
                                switch (n = 0, i && (s = [2 & s[0], i.value]), s[0]) {
                                    case 0:
                                    case 1:
                                        i = s;
                                        break;
                                    case 4:
                                        return a.label++, {
                                            value: s[1],
                                            done: !1
                                        };
                                    case 5:
                                        a.label++, n = s[1], s = [0];
                                        continue;
                                    case 7:
                                        s = a.ops.pop(), a.trys.pop();
                                        continue;
                                    default:
                                        if (i = a.trys, !(i = i.length > 0 && i[i.length - 1]) && (6 === s[0] || 2 === s[0])) {
                                            a = 0;
                                            continue
                                        }
                                        if (3 === s[0] && (!i || s[1] > i[0] && s[1] < i[3])) {
                                            a.label = s[1];
                                            break
                                        }
                                        if (6 === s[0] && a.label < i[1]) {
                                            a.label = i[1], i = s;
                                            break
                                        }
                                        if (i && a.label < i[2]) {
                                            a.label = i[2], a.ops.push(s);
                                            break
                                        }
                                        i[2] && a.ops.pop(), a.trys.pop();
                                        continue
                                }
                                s = e.call(t, a)
                            } catch (o) {
                                s = [6, o], n = 0
                            } finally {
                                r = i = 0
                            }
                            if (5 & s[0]) throw s[1];
                            return {
                                value: s[0] ? s[1] : void 0,
                                done: !0
                            }
                        }
                    },
                    s = this && this.__values || function(t) {
                        var e = "function" === typeof Symbol && Symbol.iterator,
                            r = e && t[e],
                            n = 0;
                        if (r) return r.call(t);
                        if (t && "number" === typeof t.length) return {
                            next: function() {
                                return t && n >= t.length && (t = void 0), {
                                    value: t && t[n++],
                                    done: !t
                                }
                            }
                        };
                        throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
                    };
                Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.JsonRpc = void 0;
                var a = r("8cb0"),
                    o = r("32b6"),
                    u = function(t) {
                        var e, r, n = "";
                        try {
                            for (var i = s(t), a = i.next(); !a.done; a = i.next()) {
                                var o = a.value;
                                n += ("00" + o.toString(16)).slice(-2)
                            }
                        } catch (u) {
                            e = {
                                error: u
                            }
                        } finally {
                            try {
                                a && !a.done && (r = i.return) && r.call(i)
                            } finally {
                                if (e) throw e.error
                            }
                        }
                        return n
                    },
                    h = function() {
                        function e(e, r) {
                            void 0 === r && (r = {}), this.endpoint = e.replace(/\/$/, ""), r.fetch ? this.fetchBuiltin = r.fetch : this.fetchBuiltin = t.fetch
                        }
                        return e.prototype.fetch = function(t, e) {
                            return n(this, void 0, void 0, (function() {
                                var r, n, s, a;
                                return i(this, (function(i) {
                                    switch (i.label) {
                                        case 0:
                                            return i.trys.push([0, 3, , 4]), s = this.fetchBuiltin, [4, s(this.endpoint + t, {
                                                body: JSON.stringify(e),
                                                method: "POST"
                                            })];
                                        case 1:
                                            return r = i.sent(), [4, r.json()];
                                        case 2:
                                            if (n = i.sent(), n.processed && n.processed.except) throw new o.RpcError(n);
                                            return [3, 4];
                                        case 3:
                                            throw a = i.sent(), a.isFetchError = !0, a;
                                        case 4:
                                            if (!r.ok) throw new o.RpcError(n);
                                            return [2, n]
                                    }
                                }))
                            }))
                        }, e.prototype.get_abi = function(t) {
                            return n(this, void 0, void 0, (function() {
                                return i(this, (function(e) {
                                    switch (e.label) {
                                        case 0:
                                            return [4, this.fetch("/v1/chain/get_abi", {
                                                account_name: t
                                            })];
                                        case 1:
                                            return [2, e.sent()]
                                    }
                                }))
                            }))
                        }, e.prototype.get_account = function(t) {
                            return n(this, void 0, void 0, (function() {
                                return i(this, (function(e) {
                                    switch (e.label) {
                                        case 0:
                                            return [4, this.fetch("/v1/chain/get_account", {
                                                account_name: t
                                            })];
                                        case 1:
                                            return [2, e.sent()]
                                    }
                                }))
                            }))
                        }, e.prototype.get_block_header_state = function(t) {
                            return n(this, void 0, void 0, (function() {
                                return i(this, (function(e) {
                                    switch (e.label) {
                                        case 0:
                                            return [4, this.fetch("/v1/chain/get_block_header_state", {
                                                block_num_or_id: t
                                            })];
                                        case 1:
                                            return [2, e.sent()]
                                    }
                                }))
                            }))
                        }, e.prototype.get_block = function(t) {
                            return n(this, void 0, void 0, (function() {
                                return i(this, (function(e) {
                                    switch (e.label) {
                                        case 0:
                                            return [4, this.fetch("/v1/chain/get_block", {
                                                block_num_or_id: t
                                            })];
                                        case 1:
                                            return [2, e.sent()]
                                    }
                                }))
                            }))
                        }, e.prototype.get_code = function(t) {
                            return n(this, void 0, void 0, (function() {
                                return i(this, (function(e) {
                                    switch (e.label) {
                                        case 0:
                                            return [4, this.fetch("/v1/chain/get_code", {
                                                account_name: t,
                                                code_as_wasm: !0
                                            })];
                                        case 1:
                                            return [2, e.sent()]
                                    }
                                }))
                            }))
                        }, e.prototype.get_currency_balance = function(t, e, r) {
                            return void 0 === r && (r = null), n(this, void 0, void 0, (function() {
                                return i(this, (function(n) {
                                    switch (n.label) {
                                        case 0:
                                            return [4, this.fetch("/v1/chain/get_currency_balance", {
                                                code: t,
                                                account: e,
                                                symbol: r
                                            })];
                                        case 1:
                                            return [2, n.sent()]
                                    }
                                }))
                            }))
                        }, e.prototype.get_currency_stats = function(t, e) {
                            return n(this, void 0, void 0, (function() {
                                return i(this, (function(r) {
                                    switch (r.label) {
                                        case 0:
                                            return [4, this.fetch("/v1/chain/get_currency_stats", {
                                                code: t,
                                                symbol: e
                                            })];
                                        case 1:
                                            return [2, r.sent()]
                                    }
                                }))
                            }))
                        }, e.prototype.get_info = function() {
                            return n(this, void 0, void 0, (function() {
                                return i(this, (function(t) {
                                    switch (t.label) {
                                        case 0:
                                            return [4, this.fetch("/v1/chain/get_info", {})];
                                        case 1:
                                            return [2, t.sent()]
                                    }
                                }))
                            }))
                        }, e.prototype.get_producer_schedule = function() {
                            return n(this, void 0, void 0, (function() {
                                return i(this, (function(t) {
                                    switch (t.label) {
                                        case 0:
                                            return [4, this.fetch("/v1/chain/get_producer_schedule", {})];
                                        case 1:
                                            return [2, t.sent()]
                                    }
                                }))
                            }))
                        }, e.prototype.get_producers = function(t, e, r) {
                            return void 0 === t && (t = !0), void 0 === e && (e = ""), void 0 === r && (r = 50), n(this, void 0, void 0, (function() {
                                return i(this, (function(n) {
                                    switch (n.label) {
                                        case 0:
                                            return [4, this.fetch("/v1/chain/get_producers", {
                                                json: t,
                                                lower_bound: e,
                                                limit: r
                                            })];
                                        case 1:
                                            return [2, n.sent()]
                                    }
                                }))
                            }))
                        }, e.prototype.get_raw_code_and_abi = function(t) {
                            return n(this, void 0, void 0, (function() {
                                return i(this, (function(e) {
                                    switch (e.label) {
                                        case 0:
                                            return [4, this.fetch("/v1/chain/get_raw_code_and_abi", {
                                                account_name: t
                                            })];
                                        case 1:
                                            return [2, e.sent()]
                                    }
                                }))
                            }))
                        }, e.prototype.getRawAbi = function(t) {
                            return n(this, void 0, void 0, (function() {
                                var e, r;
                                return i(this, (function(n) {
                                    switch (n.label) {
                                        case 0:
                                            return [4, this.get_raw_code_and_abi(t)];
                                        case 1:
                                            return e = n.sent(), r = a.base64ToBinary(e.abi), [2, {
                                                accountName: e.account_name,
                                                abi: r
                                            }]
                                    }
                                }))
                            }))
                        }, e.prototype.get_scheduled_transactions = function(t, e, r) {
                            return void 0 === t && (t = !0), void 0 === e && (e = ""), void 0 === r && (r = 50), n(this, void 0, void 0, (function() {
                                return i(this, (function(n) {
                                    switch (n.label) {
                                        case 0:
                                            return [4, this.fetch("/v1/chain/get_scheduled_transactions", {
                                                json: t,
                                                lower_bound: e,
                                                limit: r
                                            })];
                                        case 1:
                                            return [2, n.sent()]
                                    }
                                }))
                            }))
                        }, e.prototype.get_table_rows = function(t) {
                            var e = t.json,
                                r = void 0 === e || e,
                                s = t.code,
                                a = t.scope,
                                o = t.table,
                                u = t.lower_bound,
                                h = void 0 === u ? "" : u,
                                f = t.upper_bound,
                                c = void 0 === f ? "" : f,
                                l = t.index_position,
                                d = void 0 === l ? 1 : l,
                                p = t.key_type,
                                m = void 0 === p ? "" : p,
                                b = t.limit,
                                g = void 0 === b ? 10 : b,
                                y = t.reverse,
                                v = void 0 !== y && y,
                                w = t.show_payer,
                                _ = void 0 !== w && w;
                            return n(this, void 0, void 0, (function() {
                                return i(this, (function(t) {
                                    switch (t.label) {
                                        case 0:
                                            return [4, this.fetch("/v1/chain/get_table_rows", {
                                                json: r,
                                                code: s,
                                                scope: a,
                                                table: o,
                                                lower_bound: h,
                                                upper_bound: c,
                                                index_position: d,
                                                key_type: m,
                                                limit: g,
                                                reverse: v,
                                                show_payer: _
                                            })];
                                        case 1:
                                            return [2, t.sent()]
                                    }
                                }))
                            }))
                        }, e.prototype.get_table_by_scope = function(t) {
                            var e = t.code,
                                r = t.table,
                                s = t.lower_bound,
                                a = void 0 === s ? "" : s,
                                o = t.upper_bound,
                                u = void 0 === o ? "" : o,
                                h = t.limit,
                                f = void 0 === h ? 10 : h;
                            return n(this, void 0, void 0, (function() {
                                return i(this, (function(t) {
                                    switch (t.label) {
                                        case 0:
                                            return [4, this.fetch("/v1/chain/get_table_by_scope", {
                                                code: e,
                                                table: r,
                                                lower_bound: a,
                                                upper_bound: u,
                                                limit: f
                                            })];
                                        case 1:
                                            return [2, t.sent()]
                                    }
                                }))
                            }))
                        }, e.prototype.getRequiredKeys = function(t) {
                            return n(this, void 0, void 0, (function() {
                                var e;
                                return i(this, (function(r) {
                                    switch (r.label) {
                                        case 0:
                                            return e = a.convertLegacyPublicKeys, [4, this.fetch("/v1/chain/get_required_keys", {
                                                transaction: t.transaction,
                                                available_keys: t.availableKeys
                                            })];
                                        case 1:
                                            return [2, e.apply(void 0, [r.sent().required_keys])]
                                    }
                                }))
                            }))
                        }, e.prototype.push_transaction = function(t) {
                            var e = t.signatures,
                                r = t.compression,
                                s = void 0 === r ? 0 : r,
                                a = t.serializedTransaction,
                                o = t.serializedContextFreeData;
                            return n(this, void 0, void 0, (function() {
                                return i(this, (function(t) {
                                    switch (t.label) {
                                        case 0:
                                            return [4, this.fetch("/v1/chain/push_transaction", {
                                                signatures: e,
                                                compression: s,
                                                packed_context_free_data: u(o || new Uint8Array(0)),
                                                packed_trx: u(a)
                                            })];
                                        case 1:
                                            return [2, t.sent()]
                                    }
                                }))
                            }))
                        }, e.prototype.send_transaction = function(t) {
                            var e = t.signatures,
                                r = t.compression,
                                s = void 0 === r ? 0 : r,
                                a = t.serializedTransaction,
                                o = t.serializedContextFreeData;
                            return n(this, void 0, void 0, (function() {
                                return i(this, (function(t) {
                                    switch (t.label) {
                                        case 0:
                                            return [4, this.fetch("/v1/chain/send_transaction", {
                                                signatures: e,
                                                compression: s,
                                                packed_context_free_data: u(o || new Uint8Array(0)),
                                                packed_trx: u(a)
                                            })];
                                        case 1:
                                            return [2, t.sent()]
                                    }
                                }))
                            }))
                        }, e.prototype.db_size_get = function() {
                            return n(this, void 0, void 0, (function() {
                                return i(this, (function(t) {
                                    switch (t.label) {
                                        case 0:
                                            return [4, this.fetch("/v1/db_size/get", {})];
                                        case 1:
                                            return [2, t.sent()]
                                    }
                                }))
                            }))
                        }, e.prototype.history_get_actions = function(t, e, r) {
                            return void 0 === e && (e = null), void 0 === r && (r = null), n(this, void 0, void 0, (function() {
                                return i(this, (function(n) {
                                    switch (n.label) {
                                        case 0:
                                            return [4, this.fetch("/v1/history/get_actions", {
                                                account_name: t,
                                                pos: e,
                                                offset: r
                                            })];
                                        case 1:
                                            return [2, n.sent()]
                                    }
                                }))
                            }))
                        }, e.prototype.history_get_transaction = function(t, e) {
                            return void 0 === e && (e = null), n(this, void 0, void 0, (function() {
                                return i(this, (function(r) {
                                    switch (r.label) {
                                        case 0:
                                            return [4, this.fetch("/v1/history/get_transaction", {
                                                id: t,
                                                block_num_hint: e
                                            })];
                                        case 1:
                                            return [2, r.sent()]
                                    }
                                }))
                            }))
                        }, e.prototype.history_get_key_accounts = function(t) {
                            return n(this, void 0, void 0, (function() {
                                return i(this, (function(e) {
                                    switch (e.label) {
                                        case 0:
                                            return [4, this.fetch("/v1/history/get_key_accounts", {
                                                public_key: t
                                            })];
                                        case 1:
                                            return [2, e.sent()]
                                    }
                                }))
                            }))
                        }, e.prototype.history_get_controlled_accounts = function(t) {
                            return n(this, void 0, void 0, (function() {
                                return i(this, (function(e) {
                                    switch (e.label) {
                                        case 0:
                                            return [4, this.fetch("/v1/history/get_controlled_accounts", {
                                                controlling_account: t
                                            })];
                                        case 1:
                                            return [2, e.sent()]
                                    }
                                }))
                            }))
                        }, e
                    }();
                e.JsonRpc = h
            }).call(this, r("c8ba"))
        },
        b9a8: function(t, e, r) {
            "use strict";
            var n = r("80af"),
                i = r("6aa2"),
                s = r("f3a3"),
                a = r("0cbb"),
                o = r("fdac"),
                u = s.assert,
                h = r("bb34"),
                f = r("b73f");

            function c(t) {
                if (!(this instanceof c)) return new c(t);
                "string" === typeof t && (u(Object.prototype.hasOwnProperty.call(a, t), "Unknown curve " + t), t = a[t]), t instanceof a.PresetCurve && (t = {
                    curve: t
                }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash
            }
            t.exports = c, c.prototype.keyPair = function(t) {
                return new h(this, t)
            }, c.prototype.keyFromPrivate = function(t, e) {
                return h.fromPrivate(this, t, e)
            }, c.prototype.keyFromPublic = function(t, e) {
                return h.fromPublic(this, t, e)
            }, c.prototype.genKeyPair = function(t) {
                t || (t = {});
                for (var e = new i({
                        hash: this.hash,
                        pers: t.pers,
                        persEnc: t.persEnc || "utf8",
                        entropy: t.entropy || o(this.hash.hmacStrength),
                        entropyEnc: t.entropy && t.entropyEnc || "utf8",
                        nonce: this.n.toArray()
                    }), r = this.n.byteLength(), s = this.n.sub(new n(2));;) {
                    var a = new n(e.generate(r));
                    if (!(a.cmp(s) > 0)) return a.iaddn(1), this.keyFromPrivate(a)
                }
            }, c.prototype._truncateToN = function(t, e) {
                var r = 8 * t.byteLength() - this.n.bitLength();
                return r > 0 && (t = t.ushrn(r)), !e && t.cmp(this.n) >= 0 ? t.sub(this.n) : t
            }, c.prototype.sign = function(t, e, r, s) {
                "object" === typeof r && (s = r, r = null), s || (s = {}), e = this.keyFromPrivate(e, r), t = this._truncateToN(new n(t, 16));
                for (var a = this.n.byteLength(), o = e.getPrivate().toArray("be", a), u = t.toArray("be", a), h = new i({
                        hash: this.hash,
                        entropy: o,
                        nonce: u,
                        pers: s.pers,
                        persEnc: s.persEnc || "utf8"
                    }), c = this.n.sub(new n(1)), l = 0;; l++) {
                    var d = s.k ? s.k(l) : new n(h.generate(this.n.byteLength()));
                    if (d = this._truncateToN(d, !0), !(d.cmpn(1) <= 0 || d.cmp(c) >= 0)) {
                        var p = this.g.mul(d);
                        if (!p.isInfinity()) {
                            var m = p.getX(),
                                b = m.umod(this.n);
                            if (0 !== b.cmpn(0)) {
                                var g = d.invm(this.n).mul(b.mul(e.getPrivate()).iadd(t));
                                if (g = g.umod(this.n), 0 !== g.cmpn(0)) {
                                    var y = (p.getY().isOdd() ? 1 : 0) | (0 !== m.cmp(b) ? 2 : 0);
                                    return s.canonical && g.cmp(this.nh) > 0 && (g = this.n.sub(g), y ^= 1), new f({
                                        r: b,
                                        s: g,
                                        recoveryParam: y
                                    })
                                }
                            }
                        }
                    }
                }
            }, c.prototype.verify = function(t, e, r, i) {
                t = this._truncateToN(new n(t, 16)), r = this.keyFromPublic(r, i), e = new f(e, "hex");
                var s = e.r,
                    a = e.s;
                if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0) return !1;
                if (a.cmpn(1) < 0 || a.cmp(this.n) >= 0) return !1;
                var o, u = a.invm(this.n),
                    h = u.mul(t).umod(this.n),
                    c = u.mul(s).umod(this.n);
                return this.curve._maxwellTrick ? (o = this.g.jmulAdd(h, r.getPublic(), c), !o.isInfinity() && o.eqXToP(s)) : (o = this.g.mulAdd(h, r.getPublic(), c), !o.isInfinity() && 0 === o.getX().umod(this.n).cmp(s))
            }, c.prototype.recoverPubKey = function(t, e, r, i) {
                u((3 & r) === r, "The recovery param is more than two bits"), e = new f(e, i);
                var s = this.n,
                    a = new n(t),
                    o = e.r,
                    h = e.s,
                    c = 1 & r,
                    l = r >> 1;
                if (o.cmp(this.curve.p.umod(this.curve.n)) >= 0 && l) throw new Error("Unable to find sencond key candinate");
                o = l ? this.curve.pointFromX(o.add(this.curve.n), c) : this.curve.pointFromX(o, c);
                var d = e.r.invm(s),
                    p = s.sub(a).mul(d).umod(s),
                    m = h.mul(d).umod(s);
                return this.g.mulAdd(p, o, m)
            }, c.prototype.getKeyRecoveryParam = function(t, e, r, n) {
                if (e = new f(e, n), null !== e.recoveryParam) return e.recoveryParam;
                for (var i = 0; i < 4; i++) {
                    var s;
                    try {
                        s = this.recoverPubKey(t, e, i)
                    } catch (t) {
                        continue
                    }
                    if (s.eq(r)) return i
                }
                throw new Error("Unable to find valid recovery factor")
            }
        },
        b9b5: function(t, e, r) {
            "use strict";
            var n = r("9d8a").codes.ERR_INVALID_OPT_VALUE;

            function i(t, e, r) {
                return null != t.highWaterMark ? t.highWaterMark : e ? t[r] : null
            }

            function s(t, e, r, s) {
                var a = i(e, s, r);
                if (null != a) {
                    if (!isFinite(a) || Math.floor(a) !== a || a < 0) {
                        var o = s ? r : "highWaterMark";
                        throw new n(o, a)
                    }
                    return Math.floor(a)
                }
                return t.objectMode ? 16 : 16384
            }
            t.exports = {
                getHighWaterMark: s
            }
        },
        ba10: function(t, e, r) {
            "use strict";
            var n = Object.prototype.hasOwnProperty,
                i = "~";

            function s() {}

            function a(t, e, r) {
                this.fn = t, this.context = e, this.once = r || !1
            }

            function o(t, e, r, n, s) {
                if ("function" !== typeof r) throw new TypeError("The listener must be a function");
                var o = new a(r, n || t, s),
                    u = i ? i + e : e;
                return t._events[u] ? t._events[u].fn ? t._events[u] = [t._events[u], o] : t._events[u].push(o) : (t._events[u] = o, t._eventsCount++), t
            }

            function u(t, e) {
                0 === --t._eventsCount ? t._events = new s : delete t._events[e]
            }

            function h() {
                this._events = new s, this._eventsCount = 0
            }
            Object.create && (s.prototype = Object.create(null), (new s).__proto__ || (i = !1)), h.prototype.eventNames = function() {
                var t, e, r = [];
                if (0 === this._eventsCount) return r;
                for (e in t = this._events) n.call(t, e) && r.push(i ? e.slice(1) : e);
                return Object.getOwnPropertySymbols ? r.concat(Object.getOwnPropertySymbols(t)) : r
            }, h.prototype.listeners = function(t) {
                var e = i ? i + t : t,
                    r = this._events[e];
                if (!r) return [];
                if (r.fn) return [r.fn];
                for (var n = 0, s = r.length, a = new Array(s); n < s; n++) a[n] = r[n].fn;
                return a
            }, h.prototype.listenerCount = function(t) {
                var e = i ? i + t : t,
                    r = this._events[e];
                return r ? r.fn ? 1 : r.length : 0
            }, h.prototype.emit = function(t, e, r, n, s, a) {
                var o = i ? i + t : t;
                if (!this._events[o]) return !1;
                var u, h, f = this._events[o],
                    c = arguments.length;
                if (f.fn) {
                    switch (f.once && this.removeListener(t, f.fn, void 0, !0), c) {
                        case 1:
                            return f.fn.call(f.context), !0;
                        case 2:
                            return f.fn.call(f.context, e), !0;
                        case 3:
                            return f.fn.call(f.context, e, r), !0;
                        case 4:
                            return f.fn.call(f.context, e, r, n), !0;
                        case 5:
                            return f.fn.call(f.context, e, r, n, s), !0;
                        case 6:
                            return f.fn.call(f.context, e, r, n, s, a), !0
                    }
                    for (h = 1, u = new Array(c - 1); h < c; h++) u[h - 1] = arguments[h];
                    f.fn.apply(f.context, u)
                } else {
                    var l, d = f.length;
                    for (h = 0; h < d; h++) switch (f[h].once && this.removeListener(t, f[h].fn, void 0, !0), c) {
                        case 1:
                            f[h].fn.call(f[h].context);
                            break;
                        case 2:
                            f[h].fn.call(f[h].context, e);
                            break;
                        case 3:
                            f[h].fn.call(f[h].context, e, r);
                            break;
                        case 4:
                            f[h].fn.call(f[h].context, e, r, n);
                            break;
                        default:
                            if (!u)
                                for (l = 1, u = new Array(c - 1); l < c; l++) u[l - 1] = arguments[l];
                            f[h].fn.apply(f[h].context, u)
                    }
                }
                return !0
            }, h.prototype.on = function(t, e, r) {
                return o(this, t, e, r, !1)
            }, h.prototype.once = function(t, e, r) {
                return o(this, t, e, r, !0)
            }, h.prototype.removeListener = function(t, e, r, n) {
                var s = i ? i + t : t;
                if (!this._events[s]) return this;
                if (!e) return u(this, s), this;
                var a = this._events[s];
                if (a.fn) a.fn !== e || n && !a.once || r && a.context !== r || u(this, s);
                else {
                    for (var o = 0, h = [], f = a.length; o < f; o++)(a[o].fn !== e || n && !a[o].once || r && a[o].context !== r) && h.push(a[o]);
                    h.length ? this._events[s] = 1 === h.length ? h[0] : h : u(this, s)
                }
                return this
            }, h.prototype.removeAllListeners = function(t) {
                var e;
                return t ? (e = i ? i + t : t, this._events[e] && u(this, e)) : (this._events = new s, this._eventsCount = 0), this
            }, h.prototype.off = h.prototype.removeListener, h.prototype.addListener = h.prototype.on, h.prefixed = i, h.EventEmitter = h, t.exports = h
        },
        bb34: function(t, e, r) {
            "use strict";
            var n = r("80af"),
                i = r("f3a3"),
                s = i.assert;

            function a(t, e) {
                this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc)
            }
            t.exports = a, a.fromPublic = function(t, e, r) {
                return e instanceof a ? e : new a(t, {
                    pub: e,
                    pubEnc: r
                })
            }, a.fromPrivate = function(t, e, r) {
                return e instanceof a ? e : new a(t, {
                    priv: e,
                    privEnc: r
                })
            }, a.prototype.validate = function() {
                var t = this.getPublic();
                return t.isInfinity() ? {
                    result: !1,
                    reason: "Invalid public key"
                } : t.validate() ? t.mul(this.ec.curve.n).isInfinity() ? {
                    result: !0,
                    reason: null
                } : {
                    result: !1,
                    reason: "Public key * N != O"
                } : {
                    result: !1,
                    reason: "Public key is not a point"
                }
            }, a.prototype.getPublic = function(t, e) {
                return "string" === typeof t && (e = t, t = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), e ? this.pub.encode(e, t) : this.pub
            }, a.prototype.getPrivate = function(t) {
                return "hex" === t ? this.priv.toString(16, 2) : this.priv
            }, a.prototype._importPrivate = function(t, e) {
                this.priv = new n(t, e || 16), this.priv = this.priv.umod(this.ec.curve.n)
            }, a.prototype._importPublic = function(t, e) {
                if (t.x || t.y) return "mont" === this.ec.curve.type ? s(t.x, "Need x coordinate") : "short" !== this.ec.curve.type && "edwards" !== this.ec.curve.type || s(t.x && t.y, "Need both x and y coordinate"), void(this.pub = this.ec.curve.point(t.x, t.y));
                this.pub = this.ec.curve.decodePoint(t, e)
            }, a.prototype.derive = function(t) {
                return t.validate() || s(t.validate(), "public point not validated"), t.mul(this.priv).getX()
            }, a.prototype.sign = function(t, e, r) {
                return this.ec.sign(t, this, e, r)
            }, a.prototype.verify = function(t, e) {
                return this.ec.verify(t, e, this)
            }, a.prototype.inspect = function() {
                return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >"
            }
        },
        bb44: function(t, e, r) {
            "use strict";
            var n = r("c3c0"),
                i = r("edc9"),
                s = n.rotl32,
                a = n.sum32,
                o = n.sum32_3,
                u = n.sum32_4,
                h = i.BlockHash;

            function f() {
                if (!(this instanceof f)) return new f;
                h.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little"
            }

            function c(t, e, r, n) {
                return t <= 15 ? e ^ r ^ n : t <= 31 ? e & r | ~e & n : t <= 47 ? (e | ~r) ^ n : t <= 63 ? e & n | r & ~n : e ^ (r | ~n)
            }

            function l(t) {
                return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838
            }

            function d(t) {
                return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0
            }
            n.inherits(f, h), e.ripemd160 = f, f.blockSize = 512, f.outSize = 160, f.hmacStrength = 192, f.padLength = 64, f.prototype._update = function(t, e) {
                for (var r = this.h[0], n = this.h[1], i = this.h[2], h = this.h[3], f = this.h[4], y = r, v = n, w = i, _ = h, M = f, A = 0; A < 80; A++) {
                    var S = a(s(u(r, c(A, n, i, h), t[p[A] + e], l(A)), b[A]), f);
                    r = f, f = h, h = s(i, 10), i = n, n = S, S = a(s(u(y, c(79 - A, v, w, _), t[m[A] + e], d(A)), g[A]), M), y = M, M = _, _ = s(w, 10), w = v, v = S
                }
                S = o(this.h[1], i, _), this.h[1] = o(this.h[2], h, M), this.h[2] = o(this.h[3], f, y), this.h[3] = o(this.h[4], r, v), this.h[4] = o(this.h[0], n, w), this.h[0] = S
            }, f.prototype._digest = function(t) {
                return "hex" === t ? n.toHex32(this.h, "little") : n.split32(this.h, "little")
            };
            var p = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13],
                m = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11],
                b = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6],
                g = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]
        },
        be09: function(t, e, r) {
            (function(e) {
                var r;
                r = "undefined" !== typeof window ? window : "undefined" !== typeof e ? e : "undefined" !== typeof self ? self : {}, t.exports = r
            }).call(this, r("c8ba"))
        },
        c030: function(t, e, r) {
            "use strict";
            r.r(e), r.d(e, "ethers", (function() {
                return o
            })), r.d(e, "Signer", (function() {
                return zt
            })), r.d(e, "Wallet", (function() {
                return Lt["a"]
            })), r.d(e, "VoidSigner", (function() {
                return Dt
            })), r.d(e, "getDefaultProvider", (function() {
                return Jt["getDefaultProvider"]
            })), r.d(e, "providers", (function() {
                return Jt
            })), r.d(e, "BaseContract", (function() {
                return u["a"]
            })), r.d(e, "Contract", (function() {
                return u["b"]
            })), r.d(e, "ContractFactory", (function() {
                return u["c"]
            })), r.d(e, "BigNumber", (function() {
                return Y
            })), r.d(e, "FixedNumber", (function() {
                return mt
            })), r.d(e, "constants", (function() {
                return n
            })), r.d(e, "errors", (function() {
                return w
            })), r.d(e, "logger", (function() {
                return Ni
            })), r.d(e, "utils", (function() {
                return a
            })), r.d(e, "wordlists", (function() {
                return Xt["a"]
            })), r.d(e, "version", (function() {
                return Ti
            })), r.d(e, "Wordlist", (function() {
                return Yt["a"]
            }));
            var n = {};
            r.r(n), r.d(n, "AddressZero", (function() {
                return Ft
            })), r.d(n, "NegativeOne", (function() {
                return Bt
            })), r.d(n, "Zero", (function() {
                return $t
            })), r.d(n, "One", (function() {
                return Ut
            })), r.d(n, "Two", (function() {
                return qt
            })), r.d(n, "WeiPerEther", (function() {
                return Kt
            })), r.d(n, "MaxUint256", (function() {
                return Vt
            })), r.d(n, "MinInt256", (function() {
                return Wt
            })), r.d(n, "MaxInt256", (function() {
                return Zt
            })), r.d(n, "HashZero", (function() {
                return Ht
            })), r.d(n, "EtherSymbol", (function() {
                return Gt
            }));
            var i = {};
            r.r(i), r.d(i, "encode", (function() {
                return de
            })), r.d(i, "decode", (function() {
                return be
            }));
            var s = {};
            r.r(s), r.d(s, "decode", (function() {
                return Kr
            })), r.d(s, "encode", (function() {
                return Vr
            }));
            var a = {};
            r.r(a), r.d(a, "AbiCoder", (function() {
                return Nr
            })), r.d(a, "defaultAbiCoder", (function() {
                return jr
            })), r.d(a, "Fragment", (function() {
                return br
            })), r.d(a, "ConstructorFragment", (function() {
                return _r
            })), r.d(a, "ErrorFragment", (function() {
                return Sr
            })), r.d(a, "EventFragment", (function() {
                return gr
            })), r.d(a, "FunctionFragment", (function() {
                return Mr
            })), r.d(a, "ParamType", (function() {
                return pr
            })), r.d(a, "FormatTypes", (function() {
                return lr
            })), r.d(a, "checkResultErrors", (function() {
                return ee
            })), r.d(a, "Logger", (function() {
                return M
            })), r.d(a, "RLP", (function() {
                return i
            })), r.d(a, "_fetchData", (function() {
                return Ri
            })), r.d(a, "fetchJson", (function() {
                return Oi
            })), r.d(a, "poll", (function() {
                return Ii
            })), r.d(a, "checkProperties", (function() {
                return St
            })), r.d(a, "deepCopy", (function() {
                return Ot
            })), r.d(a, "defineReadOnly", (function() {
                return _t
            })), r.d(a, "getStatic", (function() {
                return Mt
            })), r.d(a, "resolveProperties", (function() {
                return At
            })), r.d(a, "shallowCopy", (function() {
                return xt
            })), r.d(a, "arrayify", (function() {
                return I
            })), r.d(a, "concat", (function() {
                return P
            })), r.d(a, "stripZeros", (function() {
                return T
            })), r.d(a, "zeroPad", (function() {
                return N
            })), r.d(a, "isBytes", (function() {
                return O
            })), r.d(a, "isBytesLike", (function() {
                return k
            })), r.d(a, "defaultPath", (function() {
                return zn["b"]
            })), r.d(a, "HDNode", (function() {
                return zn["a"]
            })), r.d(a, "SigningKey", (function() {
                return Zn
            })), r.d(a, "Interface", (function() {
                return qr
            })), r.d(a, "LogDescription", (function() {
                return Dr
            })), r.d(a, "TransactionDescription", (function() {
                return Lr
            })), r.d(a, "base58", (function() {
                return Wr["a"]
            })), r.d(a, "base64", (function() {
                return s
            })), r.d(a, "hexlify", (function() {
                return z
            })), r.d(a, "isHexString", (function() {
                return j
            })), r.d(a, "hexConcat", (function() {
                return F
            })), r.d(a, "hexStripZeros", (function() {
                return $
            })), r.d(a, "hexValue", (function() {
                return B
            })), r.d(a, "hexZeroPad", (function() {
                return U
            })), r.d(a, "hexDataLength", (function() {
                return D
            })), r.d(a, "hexDataSlice", (function() {
                return L
            })), r.d(a, "nameprep", (function() {
                return hn
            })), r.d(a, "_toEscapedUtf8String", (function() {
                return Qe
            })), r.d(a, "toUtf8Bytes", (function() {
                return Xe
            })), r.d(a, "toUtf8CodePoints", (function() {
                return rr
            })), r.d(a, "toUtf8String", (function() {
                return er
            })), r.d(a, "Utf8ErrorFuncs", (function() {
                return Ge
            })), r.d(a, "formatBytes32String", (function() {
                return Jn
            })), r.d(a, "parseBytes32String", (function() {
                return Xn
            })), r.d(a, "dnsEncode", (function() {
                return bn
            })), r.d(a, "hashMessage", (function() {
                return yn
            })), r.d(a, "namehash", (function() {
                return mn
            })), r.d(a, "isValidName", (function() {
                return pn
            })), r.d(a, "id", (function() {
                return Cr
            })), r.d(a, "_TypedDataEncoder", (function() {
                return Cn
            })), r.d(a, "getAddress", (function() {
                return xe
            })), r.d(a, "getIcapAddress", (function() {
                return ke
            })), r.d(a, "getContractAddress", (function() {
                return Re
            })), r.d(a, "getCreate2Address", (function() {
                return Oe
            })), r.d(a, "isAddress", (function() {
                return Ee
            })), r.d(a, "formatEther", (function() {
                return wi["b"]
            })), r.d(a, "parseEther", (function() {
                return wi["d"]
            })), r.d(a, "formatUnits", (function() {
                return wi["c"]
            })), r.d(a, "parseUnits", (function() {
                return wi["e"]
            })), r.d(a, "commify", (function() {
                return wi["a"]
            })), r.d(a, "computeHmac", (function() {
                return Ln["a"]
            })), r.d(a, "keccak256", (function() {
                return oe
            })), r.d(a, "ripemd160", (function() {
                return Ln["b"]
            })), r.d(a, "sha256", (function() {
                return Ln["c"]
            })), r.d(a, "sha512", (function() {
                return Ln["d"]
            })), r.d(a, "randomBytes", (function() {
                return Bn["a"]
            })), r.d(a, "shuffled", (function() {
                return $n["a"]
            })), r.d(a, "solidityPack", (function() {
                return Fn["b"]
            })), r.d(a, "solidityKeccak256", (function() {
                return Fn["a"]
            })), r.d(a, "soliditySha256", (function() {
                return Fn["c"]
            })), r.d(a, "splitSignature", (function() {
                return q
            })), r.d(a, "joinSignature", (function() {
                return K
            })), r.d(a, "accessListify", (function() {
                return hi
            })), r.d(a, "parseTransaction", (function() {
                return vi
            })), r.d(a, "serializeTransaction", (function() {
                return pi
            })), r.d(a, "TransactionTypes", (function() {
                return ti
            })), r.d(a, "getJsonWalletAddress", (function() {
                return Dn["a"]
            })), r.d(a, "computeAddress", (function() {
                return si
            })), r.d(a, "recoverAddress", (function() {
                return ai
            })), r.d(a, "computePublicKey", (function() {
                return Gn
            })), r.d(a, "recoverPublicKey", (function() {
                return Hn
            })), r.d(a, "verifyMessage", (function() {
                return Lt["b"]
            })), r.d(a, "verifyTypedData", (function() {
                return Lt["c"]
            })), r.d(a, "getAccountPath", (function() {
                return zn["d"]
            })), r.d(a, "mnemonicToEntropy", (function() {
                return zn["f"]
            })), r.d(a, "entropyToMnemonic", (function() {
                return zn["c"]
            })), r.d(a, "isValidMnemonic", (function() {
                return zn["e"]
            })), r.d(a, "mnemonicToSeed", (function() {
                return zn["g"]
            })), r.d(a, "SupportedAlgorithm", (function() {
                return Pi["a"]
            })), r.d(a, "UnicodeNormalizationForm", (function() {
                return Ke
            })), r.d(a, "Utf8ErrorReason", (function() {
                return Ve
            })), r.d(a, "Indexed", (function() {
                return Br
            }));
            var o = {};
            r.r(o), r.d(o, "Signer", (function() {
                return zt
            })), r.d(o, "Wallet", (function() {
                return Lt["a"]
            })), r.d(o, "VoidSigner", (function() {
                return Dt
            })), r.d(o, "getDefaultProvider", (function() {
                return Jt["getDefaultProvider"]
            })), r.d(o, "providers", (function() {
                return Jt
            })), r.d(o, "BaseContract", (function() {
                return u["a"]
            })), r.d(o, "Contract", (function() {
                return u["b"]
            })), r.d(o, "ContractFactory", (function() {
                return u["c"]
            })), r.d(o, "BigNumber", (function() {
                return Y
            })), r.d(o, "FixedNumber", (function() {
                return mt
            })), r.d(o, "constants", (function() {
                return n
            })), r.d(o, "errors", (function() {
                return w
            })), r.d(o, "logger", (function() {
                return Ni
            })), r.d(o, "utils", (function() {
                return a
            })), r.d(o, "wordlists", (function() {
                return Xt["a"]
            })), r.d(o, "version", (function() {
                return Ti
            })), r.d(o, "Wordlist", (function() {
                return Yt["a"]
            }));
            var u = r("f179"),
                h = r("030a"),
                f = r.n(h);
            const c = "logger/5.6.0";
            let l = !1,
                d = !1;
            const p = {
                debug: 1,
                default: 2,
                info: 2,
                warning: 3,
                error: 4,
                off: 5
            };
            let m = p["default"],
                b = null;

            function g() {
                try {
                    const t = [];
                    if (["NFD", "NFC", "NFKD", "NFKC"].forEach(e => {
                            try {
                                if ("test" !== "test".normalize(e)) throw new Error("bad normalize")
                            } catch (r) {
                                t.push(e)
                            }
                        }), t.length) throw new Error("missing " + t.join(", "));
                    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) throw new Error("broken implementation")
                } catch (t) {
                    return t.message
                }
                return null
            }
            const y = g();
            var v, w;
            (function(t) {
                t["DEBUG"] = "DEBUG", t["INFO"] = "INFO", t["WARNING"] = "WARNING", t["ERROR"] = "ERROR", t["OFF"] = "OFF"
            })(v || (v = {})),
            function(t) {
                t["UNKNOWN_ERROR"] = "UNKNOWN_ERROR", t["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED", t["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION", t["NETWORK_ERROR"] = "NETWORK_ERROR", t["SERVER_ERROR"] = "SERVER_ERROR", t["TIMEOUT"] = "TIMEOUT", t["BUFFER_OVERRUN"] = "BUFFER_OVERRUN", t["NUMERIC_FAULT"] = "NUMERIC_FAULT", t["MISSING_NEW"] = "MISSING_NEW", t["INVALID_ARGUMENT"] = "INVALID_ARGUMENT", t["MISSING_ARGUMENT"] = "MISSING_ARGUMENT", t["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT", t["CALL_EXCEPTION"] = "CALL_EXCEPTION", t["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS", t["NONCE_EXPIRED"] = "NONCE_EXPIRED", t["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED", t["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT", t["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED"
            }(w || (w = {}));
            const _ = "0123456789abcdef";
            class M {
                constructor(t) {
                    Object.defineProperty(this, "version", {
                        enumerable: !0,
                        value: t,
                        writable: !1
                    })
                }
                _log(t, e) {
                    const r = t.toLowerCase();
                    null == p[r] && this.throwArgumentError("invalid log level name", "logLevel", t), m > p[r] || console.log.apply(console, e)
                }
                debug(...t) {
                    this._log(M.levels.DEBUG, t)
                }
                info(...t) {
                    this._log(M.levels.INFO, t)
                }
                warn(...t) {
                    this._log(M.levels.WARNING, t)
                }
                makeError(t, e, r) {
                    if (d) return this.makeError("censored error", e, {});
                    e || (e = M.errors.UNKNOWN_ERROR), r || (r = {});
                    const n = [];
                    Object.keys(r).forEach(t => {
                        const e = r[t];
                        try {
                            if (e instanceof Uint8Array) {
                                let r = "";
                                for (let t = 0; t < e.length; t++) r += _[e[t] >> 4], r += _[15 & e[t]];
                                n.push(t + "=Uint8Array(0x" + r + ")")
                            } else n.push(t + "=" + JSON.stringify(e))
                        } catch (a) {
                            n.push(t + "=" + JSON.stringify(r[t].toString()))
                        }
                    }), n.push("code=" + e), n.push("version=" + this.version);
                    const i = t;
                    let s = "";
                    switch (e) {
                        case w.NUMERIC_FAULT:
                            {
                                s = "NUMERIC_FAULT";
                                const e = t;
                                switch (e) {
                                    case "overflow":
                                    case "underflow":
                                    case "division-by-zero":
                                        s += "-" + e;
                                        break;
                                    case "negative-power":
                                    case "negative-width":
                                        s += "-unsupported";
                                        break;
                                    case "unbound-bitwise-result":
                                        s += "-unbound-result";
                                        break
                                }
                                break
                            }
                        case w.CALL_EXCEPTION:
                        case w.INSUFFICIENT_FUNDS:
                        case w.MISSING_NEW:
                        case w.NONCE_EXPIRED:
                        case w.REPLACEMENT_UNDERPRICED:
                        case w.TRANSACTION_REPLACED:
                        case w.UNPREDICTABLE_GAS_LIMIT:
                            s = e;
                            break
                    }
                    s && (t += " [ See: https://links.ethers.org/v5-errors-" + s + " ]"), n.length && (t += " (" + n.join(", ") + ")");
                    const a = new Error(t);
                    return a.reason = i, a.code = e, Object.keys(r).forEach((function(t) {
                        a[t] = r[t]
                    })), a
                }
                throwError(t, e, r) {
                    throw this.makeError(t, e, r)
                }
                throwArgumentError(t, e, r) {
                    return this.throwError(t, M.errors.INVALID_ARGUMENT, {
                        argument: e,
                        value: r
                    })
                }
                assert(t, e, r, n) {
                    t || this.throwError(e, r, n)
                }
                assertArgument(t, e, r, n) {
                    t || this.throwArgumentError(e, r, n)
                }
                checkNormalize(t) {
                    null == t && (t = "platform missing String.prototype.normalize"), y && this.throwError("platform missing String.prototype.normalize", M.errors.UNSUPPORTED_OPERATION, {
                        operation: "String.prototype.normalize",
                        form: y
                    })
                }
                checkSafeUint53(t, e) {
                    "number" === typeof t && (null == e && (e = "value not safe"), (t < 0 || t >= 9007199254740991) && this.throwError(e, M.errors.NUMERIC_FAULT, {
                        operation: "checkSafeInteger",
                        fault: "out-of-safe-range",
                        value: t
                    }), t % 1 && this.throwError(e, M.errors.NUMERIC_FAULT, {
                        operation: "checkSafeInteger",
                        fault: "non-integer",
                        value: t
                    }))
                }
                checkArgumentCount(t, e, r) {
                    r = r ? ": " + r : "", t < e && this.throwError("missing argument" + r, M.errors.MISSING_ARGUMENT, {
                        count: t,
                        expectedCount: e
                    }), t > e && this.throwError("too many arguments" + r, M.errors.UNEXPECTED_ARGUMENT, {
                        count: t,
                        expectedCount: e
                    })
                }
                checkNew(t, e) {
                    t !== Object && null != t || this.throwError("missing new", M.errors.MISSING_NEW, {
                        name: e.name
                    })
                }
                checkAbstract(t, e) {
                    t === e ? this.throwError("cannot instantiate abstract class " + JSON.stringify(e.name) + " directly; use a sub-class", M.errors.UNSUPPORTED_OPERATION, {
                        name: t.name,
                        operation: "new"
                    }) : t !== Object && null != t || this.throwError("missing new", M.errors.MISSING_NEW, {
                        name: e.name
                    })
                }
                static globalLogger() {
                    return b || (b = new M(c)), b
                }
                static setCensorship(t, e) {
                    if (!t && e && this.globalLogger().throwError("cannot permanently disable censorship", M.errors.UNSUPPORTED_OPERATION, {
                            operation: "setCensorship"
                        }), l) {
                        if (!t) return;
                        this.globalLogger().throwError("error censorship permanent", M.errors.UNSUPPORTED_OPERATION, {
                            operation: "setCensorship"
                        })
                    }
                    d = !!t, l = !!e
                }
                static setLogLevel(t) {
                    const e = p[t.toLowerCase()];
                    null != e ? m = e : M.globalLogger().warn("invalid log level - " + t)
                }
                static from(t) {
                    return new M(t)
                }
            }
            M.errors = w, M.levels = v;
            const A = "bytes/5.6.1",
                S = new M(A);

            function x(t) {
                return !!t.toHexString
            }

            function E(t) {
                return t.slice || (t.slice = function() {
                    const e = Array.prototype.slice.call(arguments);
                    return E(new Uint8Array(Array.prototype.slice.apply(t, e)))
                }), t
            }

            function k(t) {
                return j(t) && !(t.length % 2) || O(t)
            }

            function R(t) {
                return "number" === typeof t && t == t && t % 1 === 0
            }

            function O(t) {
                if (null == t) return !1;
                if (t.constructor === Uint8Array) return !0;
                if ("string" === typeof t) return !1;
                if (!R(t.length) || t.length < 0) return !1;
                for (let e = 0; e < t.length; e++) {
                    const r = t[e];
                    if (!R(r) || r < 0 || r >= 256) return !1
                }
                return !0
            }

            function I(t, e) {
                if (e || (e = {}), "number" === typeof t) {
                    S.checkSafeUint53(t, "invalid arrayify value");
                    const e = [];
                    while (t) e.unshift(255 & t), t = parseInt(String(t / 256));
                    return 0 === e.length && e.push(0), E(new Uint8Array(e))
                }
                if (e.allowMissingPrefix && "string" === typeof t && "0x" !== t.substring(0, 2) && (t = "0x" + t), x(t) && (t = t.toHexString()), j(t)) {
                    let r = t.substring(2);
                    r.length % 2 && ("left" === e.hexPad ? r = "0" + r : "right" === e.hexPad ? r += "0" : S.throwArgumentError("hex data is odd-length", "value", t));
                    const n = [];
                    for (let t = 0; t < r.length; t += 2) n.push(parseInt(r.substring(t, t + 2), 16));
                    return E(new Uint8Array(n))
                }
                return O(t) ? E(new Uint8Array(t)) : S.throwArgumentError("invalid arrayify value", "value", t)
            }

            function P(t) {
                const e = t.map(t => I(t)),
                    r = e.reduce((t, e) => t + e.length, 0),
                    n = new Uint8Array(r);
                return e.reduce((t, e) => (n.set(e, t), t + e.length), 0), E(n)
            }

            function T(t) {
                let e = I(t);
                if (0 === e.length) return e;
                let r = 0;
                while (r < e.length && 0 === e[r]) r++;
                return r && (e = e.slice(r)), e
            }

            function N(t, e) {
                t = I(t), t.length > e && S.throwArgumentError("value out of range", "value", arguments[0]);
                const r = new Uint8Array(e);
                return r.set(t, e - t.length), E(r)
            }

            function j(t, e) {
                return !("string" !== typeof t || !t.match(/^0x[0-9A-Fa-f]*$/)) && (!e || t.length === 2 + 2 * e)
            }
            const C = "0123456789abcdef";

            function z(t, e) {
                if (e || (e = {}), "number" === typeof t) {
                    S.checkSafeUint53(t, "invalid hexlify value");
                    let e = "";
                    while (t) e = C[15 & t] + e, t = Math.floor(t / 16);
                    return e.length ? (e.length % 2 && (e = "0" + e), "0x" + e) : "0x00"
                }
                if ("bigint" === typeof t) return t = t.toString(16), t.length % 2 ? "0x0" + t : "0x" + t;
                if (e.allowMissingPrefix && "string" === typeof t && "0x" !== t.substring(0, 2) && (t = "0x" + t), x(t)) return t.toHexString();
                if (j(t)) return t.length % 2 && ("left" === e.hexPad ? t = "0x0" + t.substring(2) : "right" === e.hexPad ? t += "0" : S.throwArgumentError("hex data is odd-length", "value", t)), t.toLowerCase();
                if (O(t)) {
                    let e = "0x";
                    for (let r = 0; r < t.length; r++) {
                        let n = t[r];
                        e += C[(240 & n) >> 4] + C[15 & n]
                    }
                    return e
                }
                return S.throwArgumentError("invalid hexlify value", "value", t)
            }

            function D(t) {
                if ("string" !== typeof t) t = z(t);
                else if (!j(t) || t.length % 2) return null;
                return (t.length - 2) / 2
            }

            function L(t, e, r) {
                return "string" !== typeof t ? t = z(t) : (!j(t) || t.length % 2) && S.throwArgumentError("invalid hexData", "value", t), e = 2 + 2 * e, null != r ? "0x" + t.substring(e, 2 + 2 * r) : "0x" + t.substring(e)
            }

            function F(t) {
                let e = "0x";
                return t.forEach(t => {
                    e += z(t).substring(2)
                }), e
            }

            function B(t) {
                const e = $(z(t, {
                    hexPad: "left"
                }));
                return "0x" === e ? "0x0" : e
            }

            function $(t) {
                "string" !== typeof t && (t = z(t)), j(t) || S.throwArgumentError("invalid hex string", "value", t), t = t.substring(2);
                let e = 0;
                while (e < t.length && "0" === t[e]) e++;
                return "0x" + t.substring(e)
            }

            function U(t, e) {
                "string" !== typeof t ? t = z(t) : j(t) || S.throwArgumentError("invalid hex string", "value", t), t.length > 2 * e + 2 && S.throwArgumentError("value out of range", "value", arguments[1]);
                while (t.length < 2 * e + 2) t = "0x0" + t.substring(2);
                return t
            }

            function q(t) {
                const e = {
                    r: "0x",
                    s: "0x",
                    _vs: "0x",
                    recoveryParam: 0,
                    v: 0,
                    yParityAndS: "0x",
                    compact: "0x"
                };
                if (k(t)) {
                    let r = I(t);
                    64 === r.length ? (e.v = 27 + (r[32] >> 7), r[32] &= 127, e.r = z(r.slice(0, 32)), e.s = z(r.slice(32, 64))) : 65 === r.length ? (e.r = z(r.slice(0, 32)), e.s = z(r.slice(32, 64)), e.v = r[64]) : S.throwArgumentError("invalid signature string", "signature", t), e.v < 27 && (0 === e.v || 1 === e.v ? e.v += 27 : S.throwArgumentError("signature invalid v byte", "signature", t)), e.recoveryParam = 1 - e.v % 2, e.recoveryParam && (r[32] |= 128), e._vs = z(r.slice(32, 64))
                } else {
                    if (e.r = t.r, e.s = t.s, e.v = t.v, e.recoveryParam = t.recoveryParam, e._vs = t._vs, null != e._vs) {
                        const r = N(I(e._vs), 32);
                        e._vs = z(r);
                        const n = r[0] >= 128 ? 1 : 0;
                        null == e.recoveryParam ? e.recoveryParam = n : e.recoveryParam !== n && S.throwArgumentError("signature recoveryParam mismatch _vs", "signature", t), r[0] &= 127;
                        const i = z(r);
                        null == e.s ? e.s = i : e.s !== i && S.throwArgumentError("signature v mismatch _vs", "signature", t)
                    }
                    if (null == e.recoveryParam) null == e.v ? S.throwArgumentError("signature missing v and recoveryParam", "signature", t) : 0 === e.v || 1 === e.v ? e.recoveryParam = e.v : e.recoveryParam = 1 - e.v % 2;
                    else if (null == e.v) e.v = 27 + e.recoveryParam;
                    else {
                        const r = 0 === e.v || 1 === e.v ? e.v : 1 - e.v % 2;
                        e.recoveryParam !== r && S.throwArgumentError("signature recoveryParam mismatch v", "signature", t)
                    }
                    null != e.r && j(e.r) ? e.r = U(e.r, 32) : S.throwArgumentError("signature missing or invalid r", "signature", t), null != e.s && j(e.s) ? e.s = U(e.s, 32) : S.throwArgumentError("signature missing or invalid s", "signature", t);
                    const r = I(e.s);
                    r[0] >= 128 && S.throwArgumentError("signature s out of range", "signature", t), e.recoveryParam && (r[0] |= 128);
                    const n = z(r);
                    e._vs && (j(e._vs) || S.throwArgumentError("signature invalid _vs", "signature", t), e._vs = U(e._vs, 32)), null == e._vs ? e._vs = n : e._vs !== n && S.throwArgumentError("signature _vs mismatch v and s", "signature", t)
                }
                return e.yParityAndS = e._vs, e.compact = e.r + e.yParityAndS.substring(2), e
            }

            function K(t) {
                return t = q(t), z(P([t.r, t.s, t.recoveryParam ? "0x1c" : "0x1b"]))
            }
            const V = "bignumber/5.6.0";
            var W = f.a.BN;
            const Z = new M(V),
                H = {},
                G = 9007199254740991;

            function J(t) {
                return null != t && (Y.isBigNumber(t) || "number" === typeof t && t % 1 === 0 || "string" === typeof t && !!t.match(/^-?[0-9]+$/) || j(t) || "bigint" === typeof t || O(t))
            }
            let X = !1;
            class Y {
                constructor(t, e) {
                    Z.checkNew(new.target, Y), t !== H && Z.throwError("cannot call constructor directly; use BigNumber.from", M.errors.UNSUPPORTED_OPERATION, {
                        operation: "new (BigNumber)"
                    }), this._hex = e, this._isBigNumber = !0, Object.freeze(this)
                }
                fromTwos(t) {
                    return tt(et(this).fromTwos(t))
                }
                toTwos(t) {
                    return tt(et(this).toTwos(t))
                }
                abs() {
                    return "-" === this._hex[0] ? Y.from(this._hex.substring(1)) : this
                }
                add(t) {
                    return tt(et(this).add(et(t)))
                }
                sub(t) {
                    return tt(et(this).sub(et(t)))
                }
                div(t) {
                    const e = Y.from(t);
                    return e.isZero() && rt("division-by-zero", "div"), tt(et(this).div(et(t)))
                }
                mul(t) {
                    return tt(et(this).mul(et(t)))
                }
                mod(t) {
                    const e = et(t);
                    return e.isNeg() && rt("division-by-zero", "mod"), tt(et(this).umod(e))
                }
                pow(t) {
                    const e = et(t);
                    return e.isNeg() && rt("negative-power", "pow"), tt(et(this).pow(e))
                }
                and(t) {
                    const e = et(t);
                    return (this.isNegative() || e.isNeg()) && rt("unbound-bitwise-result", "and"), tt(et(this).and(e))
                }
                or(t) {
                    const e = et(t);
                    return (this.isNegative() || e.isNeg()) && rt("unbound-bitwise-result", "or"), tt(et(this).or(e))
                }
                xor(t) {
                    const e = et(t);
                    return (this.isNegative() || e.isNeg()) && rt("unbound-bitwise-result", "xor"), tt(et(this).xor(e))
                }
                mask(t) {
                    return (this.isNegative() || t < 0) && rt("negative-width", "mask"), tt(et(this).maskn(t))
                }
                shl(t) {
                    return (this.isNegative() || t < 0) && rt("negative-width", "shl"), tt(et(this).shln(t))
                }
                shr(t) {
                    return (this.isNegative() || t < 0) && rt("negative-width", "shr"), tt(et(this).shrn(t))
                }
                eq(t) {
                    return et(this).eq(et(t))
                }
                lt(t) {
                    return et(this).lt(et(t))
                }
                lte(t) {
                    return et(this).lte(et(t))
                }
                gt(t) {
                    return et(this).gt(et(t))
                }
                gte(t) {
                    return et(this).gte(et(t))
                }
                isNegative() {
                    return "-" === this._hex[0]
                }
                isZero() {
                    return et(this).isZero()
                }
                toNumber() {
                    try {
                        return et(this).toNumber()
                    } catch (t) {
                        rt("overflow", "toNumber", this.toString())
                    }
                    return null
                }
                toBigInt() {
                    try {
                        return BigInt(this.toString())
                    } catch (t) {}
                    return Z.throwError("this platform does not support BigInt", M.errors.UNSUPPORTED_OPERATION, {
                        value: this.toString()
                    })
                }
                toString() {
                    return arguments.length > 0 && (10 === arguments[0] ? X || (X = !0, Z.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : 16 === arguments[0] ? Z.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", M.errors.UNEXPECTED_ARGUMENT, {}) : Z.throwError("BigNumber.toString does not accept parameters", M.errors.UNEXPECTED_ARGUMENT, {})), et(this).toString(10)
                }
                toHexString() {
                    return this._hex
                }
                toJSON(t) {
                    return {
                        type: "BigNumber",
                        hex: this.toHexString()
                    }
                }
                static from(t) {
                    if (t instanceof Y) return t;
                    if ("string" === typeof t) return t.match(/^-?0x[0-9a-f]+$/i) ? new Y(H, Q(t)) : t.match(/^-?[0-9]+$/) ? new Y(H, Q(new W(t))) : Z.throwArgumentError("invalid BigNumber string", "value", t);
                    if ("number" === typeof t) return t % 1 && rt("underflow", "BigNumber.from", t), (t >= G || t <= -G) && rt("overflow", "BigNumber.from", t), Y.from(String(t));
                    const e = t;
                    if ("bigint" === typeof e) return Y.from(e.toString());
                    if (O(e)) return Y.from(z(e));
                    if (e)
                        if (e.toHexString) {
                            const t = e.toHexString();
                            if ("string" === typeof t) return Y.from(t)
                        } else {
                            let t = e._hex;
                            if (null == t && "BigNumber" === e.type && (t = e.hex), "string" === typeof t && (j(t) || "-" === t[0] && j(t.substring(1)))) return Y.from(t)
                        }
                    return Z.throwArgumentError("invalid BigNumber value", "value", t)
                }
                static isBigNumber(t) {
                    return !(!t || !t._isBigNumber)
                }
            }

            function Q(t) {
                if ("string" !== typeof t) return Q(t.toString(16));
                if ("-" === t[0]) return t = t.substring(1), "-" === t[0] && Z.throwArgumentError("invalid hex", "value", t), t = Q(t), "0x00" === t ? t : "-" + t;
                if ("0x" !== t.substring(0, 2) && (t = "0x" + t), "0x" === t) return "0x00";
                t.length % 2 && (t = "0x0" + t.substring(2));
                while (t.length > 4 && "0x00" === t.substring(0, 4)) t = "0x" + t.substring(4);
                return t
            }

            function tt(t) {
                return Y.from(Q(t))
            }

            function et(t) {
                const e = Y.from(t).toHexString();
                return "-" === e[0] ? new W("-" + e.substring(3), 16) : new W(e.substring(2), 16)
            }

            function rt(t, e, r) {
                const n = {
                    fault: t,
                    operation: e
                };
                return null != r && (n.value = r), Z.throwError(t, M.errors.NUMERIC_FAULT, n)
            }

            function nt(t) {
                return new W(t, 36).toString(16)
            }

            function it(t) {
                return new W(t, 16).toString(36)
            }
            const st = new M(V),
                at = {},
                ot = Y.from(0),
                ut = Y.from(-1);

            function ht(t, e, r, n) {
                const i = {
                    fault: e,
                    operation: r
                };
                return void 0 !== n && (i.value = n), st.throwError(t, M.errors.NUMERIC_FAULT, i)
            }
            let ft = "0";
            while (ft.length < 256) ft += ft;

            function ct(t) {
                if ("number" !== typeof t) try {
                    t = Y.from(t).toNumber()
                } catch (e) {}
                return "number" === typeof t && t >= 0 && t <= 256 && !(t % 1) ? "1" + ft.substring(0, t) : st.throwArgumentError("invalid decimal size", "decimals", t)
            }

            function lt(t, e) {
                null == e && (e = 0);
                const r = ct(e);
                t = Y.from(t);
                const n = t.lt(ot);
                n && (t = t.mul(ut));
                let i = t.mod(r).toString();
                while (i.length < r.length - 1) i = "0" + i;
                i = i.match(/^([0-9]*[1-9]|0)(0*)/)[1];
                const s = t.div(r).toString();
                return t = 1 === r.length ? s : s + "." + i, n && (t = "-" + t), t
            }

            function dt(t, e) {
                null == e && (e = 0);
                const r = ct(e);
                "string" === typeof t && t.match(/^-?[0-9.]+$/) || st.throwArgumentError("invalid decimal value", "value", t);
                const n = "-" === t.substring(0, 1);
                n && (t = t.substring(1)), "." === t && st.throwArgumentError("missing value", "value", t);
                const i = t.split(".");
                i.length > 2 && st.throwArgumentError("too many decimal points", "value", t);
                let s = i[0],
                    a = i[1];
                s || (s = "0"), a || (a = "0");
                while ("0" === a[a.length - 1]) a = a.substring(0, a.length - 1);
                a.length > r.length - 1 && ht("fractional component exceeds decimals", "underflow", "parseFixed"), "" === a && (a = "0");
                while (a.length < r.length - 1) a += "0";
                const o = Y.from(s),
                    u = Y.from(a);
                let h = o.mul(r).add(u);
                return n && (h = h.mul(ut)), h
            }
            class pt {
                constructor(t, e, r, n) {
                    t !== at && st.throwError("cannot use FixedFormat constructor; use FixedFormat.from", M.errors.UNSUPPORTED_OPERATION, {
                        operation: "new FixedFormat"
                    }), this.signed = e, this.width = r, this.decimals = n, this.name = (e ? "" : "u") + "fixed" + String(r) + "x" + String(n), this._multiplier = ct(n), Object.freeze(this)
                }
                static from(t) {
                    if (t instanceof pt) return t;
                    "number" === typeof t && (t = "fixed128x" + t);
                    let e = !0,
                        r = 128,
                        n = 18;
                    if ("string" === typeof t)
                        if ("fixed" === t);
                        else if ("ufixed" === t) e = !1;
                    else {
                        const i = t.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
                        i || st.throwArgumentError("invalid fixed format", "format", t), e = "u" !== i[1], r = parseInt(i[2]), n = parseInt(i[3])
                    } else if (t) {
                        const i = (e, r, n) => null == t[e] ? n : (typeof t[e] !== r && st.throwArgumentError("invalid fixed format (" + e + " not " + r + ")", "format." + e, t[e]), t[e]);
                        e = i("signed", "boolean", e), r = i("width", "number", r), n = i("decimals", "number", n)
                    }
                    return r % 8 && st.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", r), n > 80 && st.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", n), new pt(at, e, r, n)
                }
            }
            class mt {
                constructor(t, e, r, n) {
                    st.checkNew(new.target, mt), t !== at && st.throwError("cannot use FixedNumber constructor; use FixedNumber.from", M.errors.UNSUPPORTED_OPERATION, {
                        operation: "new FixedFormat"
                    }), this.format = n, this._hex = e, this._value = r, this._isFixedNumber = !0, Object.freeze(this)
                }
                _checkFormat(t) {
                    this.format.name !== t.format.name && st.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", t)
                }
                addUnsafe(t) {
                    this._checkFormat(t);
                    const e = dt(this._value, this.format.decimals),
                        r = dt(t._value, t.format.decimals);
                    return mt.fromValue(e.add(r), this.format.decimals, this.format)
                }
                subUnsafe(t) {
                    this._checkFormat(t);
                    const e = dt(this._value, this.format.decimals),
                        r = dt(t._value, t.format.decimals);
                    return mt.fromValue(e.sub(r), this.format.decimals, this.format)
                }
                mulUnsafe(t) {
                    this._checkFormat(t);
                    const e = dt(this._value, this.format.decimals),
                        r = dt(t._value, t.format.decimals);
                    return mt.fromValue(e.mul(r).div(this.format._multiplier), this.format.decimals, this.format)
                }
                divUnsafe(t) {
                    this._checkFormat(t);
                    const e = dt(this._value, this.format.decimals),
                        r = dt(t._value, t.format.decimals);
                    return mt.fromValue(e.mul(this.format._multiplier).div(r), this.format.decimals, this.format)
                }
                floor() {
                    const t = this.toString().split(".");
                    1 === t.length && t.push("0");
                    let e = mt.from(t[0], this.format);
                    const r = !t[1].match(/^(0*)$/);
                    return this.isNegative() && r && (e = e.subUnsafe(bt.toFormat(e.format))), e
                }
                ceiling() {
                    const t = this.toString().split(".");
                    1 === t.length && t.push("0");
                    let e = mt.from(t[0], this.format);
                    const r = !t[1].match(/^(0*)$/);
                    return !this.isNegative() && r && (e = e.addUnsafe(bt.toFormat(e.format))), e
                }
                round(t) {
                    null == t && (t = 0);
                    const e = this.toString().split(".");
                    if (1 === e.length && e.push("0"), (t < 0 || t > 80 || t % 1) && st.throwArgumentError("invalid decimal count", "decimals", t), e[1].length <= t) return this;
                    const r = mt.from("1" + ft.substring(0, t), this.format),
                        n = gt.toFormat(this.format);
                    return this.mulUnsafe(r).addUnsafe(n).floor().divUnsafe(r)
                }
                isZero() {
                    return "0.0" === this._value || "0" === this._value
                }
                isNegative() {
                    return "-" === this._value[0]
                }
                toString() {
                    return this._value
                }
                toHexString(t) {
                    if (null == t) return this._hex;
                    t % 8 && st.throwArgumentError("invalid byte width", "width", t);
                    const e = Y.from(this._hex).fromTwos(this.format.width).toTwos(t).toHexString();
                    return U(e, t / 8)
                }
                toUnsafeFloat() {
                    return parseFloat(this.toString())
                }
                toFormat(t) {
                    return mt.fromString(this._value, t)
                }
                static fromValue(t, e, r) {
                    return null != r || null == e || J(e) || (r = e, e = null), null == e && (e = 0), null == r && (r = "fixed"), mt.fromString(lt(t, e), pt.from(r))
                }
                static fromString(t, e) {
                    null == e && (e = "fixed");
                    const r = pt.from(e),
                        n = dt(t, r.decimals);
                    !r.signed && n.lt(ot) && ht("unsigned value cannot be negative", "overflow", "value", t);
                    let i = null;
                    r.signed ? i = n.toTwos(r.width).toHexString() : (i = n.toHexString(), i = U(i, r.width / 8));
                    const s = lt(n, r.decimals);
                    return new mt(at, i, s, r)
                }
                static fromBytes(t, e) {
                    null == e && (e = "fixed");
                    const r = pt.from(e);
                    if (I(t).length > r.width / 8) throw new Error("overflow");
                    let n = Y.from(t);
                    r.signed && (n = n.fromTwos(r.width));
                    const i = n.toTwos((r.signed ? 0 : 1) + r.width).toHexString(),
                        s = lt(n, r.decimals);
                    return new mt(at, i, s, r)
                }
                static from(t, e) {
                    if ("string" === typeof t) return mt.fromString(t, e);
                    if (O(t)) return mt.fromBytes(t, e);
                    try {
                        return mt.fromValue(t, 0, e)
                    } catch (r) {
                        if (r.code !== M.errors.INVALID_ARGUMENT) throw r
                    }
                    return st.throwArgumentError("invalid FixedNumber value", "value", t)
                }
                static isFixedNumber(t) {
                    return !(!t || !t._isFixedNumber)
                }
            }
            const bt = mt.from(1),
                gt = mt.from("0.5"),
                yt = "properties/5.6.0";
            var vt = function(t, e, r, n) {
                function i(t) {
                    return t instanceof r ? t : new r((function(e) {
                        e(t)
                    }))
                }
                return new(r || (r = Promise))((function(r, s) {
                    function a(t) {
                        try {
                            u(n.next(t))
                        } catch (e) {
                            s(e)
                        }
                    }

                    function o(t) {
                        try {
                            u(n["throw"](t))
                        } catch (e) {
                            s(e)
                        }
                    }

                    function u(t) {
                        t.done ? r(t.value) : i(t.value).then(a, o)
                    }
                    u((n = n.apply(t, e || [])).next())
                }))
            };
            const wt = new M(yt);

            function _t(t, e, r) {
                Object.defineProperty(t, e, {
                    enumerable: !0,
                    value: r,
                    writable: !1
                })
            }

            function Mt(t, e) {
                for (let r = 0; r < 32; r++) {
                    if (t[e]) return t[e];
                    if (!t.prototype || "object" !== typeof t.prototype) break;
                    t = Object.getPrototypeOf(t.prototype).constructor
                }
                return null
            }

            function At(t) {
                return vt(this, void 0, void 0, (function*() {
                    const e = Object.keys(t).map(e => {
                            const r = t[e];
                            return Promise.resolve(r).then(t => ({
                                key: e,
                                value: t
                            }))
                        }),
                        r = yield Promise.all(e);
                    return r.reduce((t, e) => (t[e.key] = e.value, t), {})
                }))
            }

            function St(t, e) {
                t && "object" === typeof t || wt.throwArgumentError("invalid object", "object", t), Object.keys(t).forEach(r => {
                    e[r] || wt.throwArgumentError("invalid object key - " + r, "transaction:" + r, t)
                })
            }

            function xt(t) {
                const e = {};
                for (const r in t) e[r] = t[r];
                return e
            }
            const Et = {
                bigint: !0,
                boolean: !0,
                function: !0,
                number: !0,
                string: !0
            };

            function kt(t) {
                if (void 0 === t || null === t || Et[typeof t]) return !0;
                if (Array.isArray(t) || "object" === typeof t) {
                    if (!Object.isFrozen(t)) return !1;
                    const r = Object.keys(t);
                    for (let n = 0; n < r.length; n++) {
                        let i = null;
                        try {
                            i = t[r[n]]
                        } catch (e) {
                            continue
                        }
                        if (!kt(i)) return !1
                    }
                    return !0
                }
                return wt.throwArgumentError("Cannot deepCopy " + typeof t, "object", t)
            }

            function Rt(t) {
                if (kt(t)) return t;
                if (Array.isArray(t)) return Object.freeze(t.map(t => Ot(t)));
                if ("object" === typeof t) {
                    const e = {};
                    for (const r in t) {
                        const n = t[r];
                        void 0 !== n && _t(e, r, Ot(n))
                    }
                    return e
                }
                return wt.throwArgumentError("Cannot deepCopy " + typeof t, "object", t)
            }

            function Ot(t) {
                return Rt(t)
            }
            class It {
                constructor(t) {
                    for (const e in t) this[e] = Ot(t[e])
                }
            }
            const Pt = "abstract-signer/5.6.0";
            var Tt = function(t, e, r, n) {
                function i(t) {
                    return t instanceof r ? t : new r((function(e) {
                        e(t)
                    }))
                }
                return new(r || (r = Promise))((function(r, s) {
                    function a(t) {
                        try {
                            u(n.next(t))
                        } catch (e) {
                            s(e)
                        }
                    }

                    function o(t) {
                        try {
                            u(n["throw"](t))
                        } catch (e) {
                            s(e)
                        }
                    }

                    function u(t) {
                        t.done ? r(t.value) : i(t.value).then(a, o)
                    }
                    u((n = n.apply(t, e || [])).next())
                }))
            };
            const Nt = new M(Pt),
                jt = ["accessList", "ccipReadEnabled", "chainId", "customData", "data", "from", "gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "to", "type", "value"],
                Ct = [M.errors.INSUFFICIENT_FUNDS, M.errors.NONCE_EXPIRED, M.errors.REPLACEMENT_UNDERPRICED];
            class zt {
                constructor() {
                    Nt.checkAbstract(new.target, zt), _t(this, "_isSigner", !0)
                }
                getBalance(t) {
                    return Tt(this, void 0, void 0, (function*() {
                        return this._checkProvider("getBalance"), yield this.provider.getBalance(this.getAddress(), t)
                    }))
                }
                getTransactionCount(t) {
                    return Tt(this, void 0, void 0, (function*() {
                        return this._checkProvider("getTransactionCount"), yield this.provider.getTransactionCount(this.getAddress(), t)
                    }))
                }
                estimateGas(t) {
                    return Tt(this, void 0, void 0, (function*() {
                        this._checkProvider("estimateGas");
                        const e = yield At(this.checkTransaction(t));
                        return yield this.provider.estimateGas(e)
                    }))
                }
                call(t, e) {
                    return Tt(this, void 0, void 0, (function*() {
                        this._checkProvider("call");
                        const r = yield At(this.checkTransaction(t));
                        return yield this.provider.call(r, e)
                    }))
                }
                sendTransaction(t) {
                    return Tt(this, void 0, void 0, (function*() {
                        this._checkProvider("sendTransaction");
                        const e = yield this.populateTransaction(t), r = yield this.signTransaction(e);
                        return yield this.provider.sendTransaction(r)
                    }))
                }
                getChainId() {
                    return Tt(this, void 0, void 0, (function*() {
                        this._checkProvider("getChainId");
                        const t = yield this.provider.getNetwork();
                        return t.chainId
                    }))
                }
                getGasPrice() {
                    return Tt(this, void 0, void 0, (function*() {
                        return this._checkProvider("getGasPrice"), yield this.provider.getGasPrice()
                    }))
                }
                getFeeData() {
                    return Tt(this, void 0, void 0, (function*() {
                        return this._checkProvider("getFeeData"), yield this.provider.getFeeData()
                    }))
                }
                resolveName(t) {
                    return Tt(this, void 0, void 0, (function*() {
                        return this._checkProvider("resolveName"), yield this.provider.resolveName(t)
                    }))
                }
                checkTransaction(t) {
                    for (const r in t) - 1 === jt.indexOf(r) && Nt.throwArgumentError("invalid transaction key: " + r, "transaction", t);
                    const e = xt(t);
                    return null == e.from ? e.from = this.getAddress() : e.from = Promise.all([Promise.resolve(e.from), this.getAddress()]).then(e => (e[0].toLowerCase() !== e[1].toLowerCase() && Nt.throwArgumentError("from address mismatch", "transaction", t), e[0])), e
                }
                populateTransaction(t) {
                    return Tt(this, void 0, void 0, (function*() {
                        const e = yield At(this.checkTransaction(t));
                        null != e.to && (e.to = Promise.resolve(e.to).then(t => Tt(this, void 0, void 0, (function*() {
                            if (null == t) return null;
                            const e = yield this.resolveName(t);
                            return null == e && Nt.throwArgumentError("provided ENS name resolves to null", "tx.to", t), e
                        }))), e.to.catch(t => {}));
                        const r = null != e.maxFeePerGas || null != e.maxPriorityFeePerGas;
                        if (null == e.gasPrice || 2 !== e.type && !r ? 0 !== e.type && 1 !== e.type || !r || Nt.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", t) : Nt.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", t), 2 !== e.type && null != e.type || null == e.maxFeePerGas || null == e.maxPriorityFeePerGas)
                            if (0 === e.type || 1 === e.type) null == e.gasPrice && (e.gasPrice = this.getGasPrice());
                            else {
                                const t = yield this.getFeeData();
                                if (null == e.type)
                                    if (null != t.maxFeePerGas && null != t.maxPriorityFeePerGas)
                                        if (e.type = 2, null != e.gasPrice) {
                                            const t = e.gasPrice;
                                            delete e.gasPrice, e.maxFeePerGas = t, e.maxPriorityFeePerGas = t
                                        } else null == e.maxFeePerGas && (e.maxFeePerGas = t.maxFeePerGas), null == e.maxPriorityFeePerGas && (e.maxPriorityFeePerGas = t.maxPriorityFeePerGas);
                                else null != t.gasPrice ? (r && Nt.throwError("network does not support EIP-1559", M.errors.UNSUPPORTED_OPERATION, {
                                    operation: "populateTransaction"
                                }), null == e.gasPrice && (e.gasPrice = t.gasPrice), e.type = 0) : Nt.throwError("failed to get consistent fee data", M.errors.UNSUPPORTED_OPERATION, {
                                    operation: "signer.getFeeData"
                                });
                                else 2 === e.type && (null == e.maxFeePerGas && (e.maxFeePerGas = t.maxFeePerGas), null == e.maxPriorityFeePerGas && (e.maxPriorityFeePerGas = t.maxPriorityFeePerGas))
                            }
                        else e.type = 2;
                        return null == e.nonce && (e.nonce = this.getTransactionCount("pending")), null == e.gasLimit && (e.gasLimit = this.estimateGas(e).catch(t => {
                            if (Ct.indexOf(t.code) >= 0) throw t;
                            return Nt.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", M.errors.UNPREDICTABLE_GAS_LIMIT, {
                                error: t,
                                tx: e
                            })
                        })), null == e.chainId ? e.chainId = this.getChainId() : e.chainId = Promise.all([Promise.resolve(e.chainId), this.getChainId()]).then(e => (0 !== e[1] && e[0] !== e[1] && Nt.throwArgumentError("chainId address mismatch", "transaction", t), e[0])), yield At(e)
                    }))
                }
                _checkProvider(t) {
                    this.provider || Nt.throwError("missing provider", M.errors.UNSUPPORTED_OPERATION, {
                        operation: t || "_checkProvider"
                    })
                }
                static isSigner(t) {
                    return !(!t || !t._isSigner)
                }
            }
            class Dt extends zt {
                constructor(t, e) {
                    Nt.checkNew(new.target, Dt), super(), _t(this, "address", t), _t(this, "provider", e || null)
                }
                getAddress() {
                    return Promise.resolve(this.address)
                }
                _fail(t, e) {
                    return Promise.resolve().then(() => {
                        Nt.throwError(t, M.errors.UNSUPPORTED_OPERATION, {
                            operation: e
                        })
                    })
                }
                signMessage(t) {
                    return this._fail("VoidSigner cannot sign messages", "signMessage")
                }
                signTransaction(t) {
                    return this._fail("VoidSigner cannot sign transactions", "signTransaction")
                }
                _signTypedData(t, e, r) {
                    return this._fail("VoidSigner cannot sign typed data", "signTypedData")
                }
                connect(t) {
                    return new Dt(this.address, t)
                }
            }
            var Lt = r("288a");
            const Ft = "0x0000000000000000000000000000000000000000",
                Bt = Y.from(-1),
                $t = Y.from(0),
                Ut = Y.from(1),
                qt = Y.from(2),
                Kt = Y.from("1000000000000000000"),
                Vt = Y.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
                Wt = Y.from("-0x8000000000000000000000000000000000000000000000000000000000000000"),
                Zt = Y.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
                Ht = "0x0000000000000000000000000000000000000000000000000000000000000000",
                Gt = "Ξ";
            var Jt = r("2606"),
                Xt = r("5605"),
                Yt = r("bd9b");
            const Qt = "abi/5.6.1",
                te = new M(Qt);

            function ee(t) {
                const e = [],
                    r = function(t, n) {
                        if (Array.isArray(n))
                            for (let s in n) {
                                const a = t.slice();
                                a.push(s);
                                try {
                                    r(a, n[s])
                                } catch (i) {
                                    e.push({
                                        path: a,
                                        error: i
                                    })
                                }
                            }
                    };
                return r([], t), e
            }
            class re {
                constructor(t, e, r, n) {
                    this.name = t, this.type = e, this.localName = r, this.dynamic = n
                }
                _throwError(t, e) {
                    te.throwArgumentError(t, this.localName, e)
                }
            }
            class ne {
                constructor(t) {
                    _t(this, "wordSize", t || 32), this._data = [], this._dataLength = 0, this._padding = new Uint8Array(t)
                }
                get data() {
                    return F(this._data)
                }
                get length() {
                    return this._dataLength
                }
                _writeData(t) {
                    return this._data.push(t), this._dataLength += t.length, t.length
                }
                appendWriter(t) {
                    return this._writeData(P(t._data))
                }
                writeBytes(t) {
                    let e = I(t);
                    const r = e.length % this.wordSize;
                    return r && (e = P([e, this._padding.slice(r)])), this._writeData(e)
                }
                _getValue(t) {
                    let e = I(Y.from(t));
                    return e.length > this.wordSize && te.throwError("value out-of-bounds", M.errors.BUFFER_OVERRUN, {
                        length: this.wordSize,
                        offset: e.length
                    }), e.length % this.wordSize && (e = P([this._padding.slice(e.length % this.wordSize), e])), e
                }
                writeValue(t) {
                    return this._writeData(this._getValue(t))
                }
                writeUpdatableValue() {
                    const t = this._data.length;
                    return this._data.push(this._padding), this._dataLength += this.wordSize, e => {
                        this._data[t] = this._getValue(e)
                    }
                }
            }
            class ie {
                constructor(t, e, r, n) {
                    _t(this, "_data", I(t)), _t(this, "wordSize", e || 32), _t(this, "_coerceFunc", r), _t(this, "allowLoose", n), this._offset = 0
                }
                get data() {
                    return z(this._data)
                }
                get consumed() {
                    return this._offset
                }
                static coerce(t, e) {
                    let r = t.match("^u?int([0-9]+)$");
                    return r && parseInt(r[1]) <= 48 && (e = e.toNumber()), e
                }
                coerce(t, e) {
                    return this._coerceFunc ? this._coerceFunc(t, e) : ie.coerce(t, e)
                }
                _peekBytes(t, e, r) {
                    let n = Math.ceil(e / this.wordSize) * this.wordSize;
                    return this._offset + n > this._data.length && (this.allowLoose && r && this._offset + e <= this._data.length ? n = e : te.throwError("data out-of-bounds", M.errors.BUFFER_OVERRUN, {
                        length: this._data.length,
                        offset: this._offset + n
                    })), this._data.slice(this._offset, this._offset + n)
                }
                subReader(t) {
                    return new ie(this._data.slice(this._offset + t), this.wordSize, this._coerceFunc, this.allowLoose)
                }
                readBytes(t, e) {
                    let r = this._peekBytes(0, t, !!e);
                    return this._offset += r.length, r.slice(0, t)
                }
                readValue() {
                    return Y.from(this.readBytes(this.wordSize))
                }
            }
            var se = r("1c55"),
                ae = r.n(se);

            function oe(t) {
                return "0x" + ae.a.keccak_256(I(t))
            }
            const ue = "rlp/5.6.0",
                he = new M(ue);

            function fe(t) {
                const e = [];
                while (t) e.unshift(255 & t), t >>= 8;
                return e
            }

            function ce(t, e, r) {
                let n = 0;
                for (let i = 0; i < r; i++) n = 256 * n + t[e + i];
                return n
            }

            function le(t) {
                if (Array.isArray(t)) {
                    let e = [];
                    if (t.forEach((function(t) {
                            e = e.concat(le(t))
                        })), e.length <= 55) return e.unshift(192 + e.length), e;
                    const r = fe(e.length);
                    return r.unshift(247 + r.length), r.concat(e)
                }
                k(t) || he.throwArgumentError("RLP object must be BytesLike", "object", t);
                const e = Array.prototype.slice.call(I(t));
                if (1 === e.length && e[0] <= 127) return e;
                if (e.length <= 55) return e.unshift(128 + e.length), e;
                const r = fe(e.length);
                return r.unshift(183 + r.length), r.concat(e)
            }

            function de(t) {
                return z(le(t))
            }

            function pe(t, e, r, n) {
                const i = [];
                while (r < e + 1 + n) {
                    const s = me(t, r);
                    i.push(s.result), r += s.consumed, r > e + 1 + n && he.throwError("child data too short", M.errors.BUFFER_OVERRUN, {})
                }
                return {
                    consumed: 1 + n,
                    result: i
                }
            }

            function me(t, e) {
                if (0 === t.length && he.throwError("data too short", M.errors.BUFFER_OVERRUN, {}), t[e] >= 248) {
                    const r = t[e] - 247;
                    e + 1 + r > t.length && he.throwError("data short segment too short", M.errors.BUFFER_OVERRUN, {});
                    const n = ce(t, e + 1, r);
                    return e + 1 + r + n > t.length && he.throwError("data long segment too short", M.errors.BUFFER_OVERRUN, {}), pe(t, e, e + 1 + r, r + n)
                }
                if (t[e] >= 192) {
                    const r = t[e] - 192;
                    return e + 1 + r > t.length && he.throwError("data array too short", M.errors.BUFFER_OVERRUN, {}), pe(t, e, e + 1, r)
                }
                if (t[e] >= 184) {
                    const r = t[e] - 183;
                    e + 1 + r > t.length && he.throwError("data array too short", M.errors.BUFFER_OVERRUN, {});
                    const n = ce(t, e + 1, r);
                    e + 1 + r + n > t.length && he.throwError("data array too short", M.errors.BUFFER_OVERRUN, {});
                    const i = z(t.slice(e + 1 + r, e + 1 + r + n));
                    return {
                        consumed: 1 + r + n,
                        result: i
                    }
                }
                if (t[e] >= 128) {
                    const r = t[e] - 128;
                    e + 1 + r > t.length && he.throwError("data too short", M.errors.BUFFER_OVERRUN, {});
                    const n = z(t.slice(e + 1, e + 1 + r));
                    return {
                        consumed: 1 + r,
                        result: n
                    }
                }
                return {
                    consumed: 1,
                    result: z(t[e])
                }
            }

            function be(t) {
                const e = I(t),
                    r = me(e, 0);
                return r.consumed !== e.length && he.throwArgumentError("invalid rlp data", "data", t), r.result
            }
            const ge = "address/5.6.0",
                ye = new M(ge);

            function ve(t) {
                j(t, 20) || ye.throwArgumentError("invalid address", "address", t), t = t.toLowerCase();
                const e = t.substring(2).split(""),
                    r = new Uint8Array(40);
                for (let i = 0; i < 40; i++) r[i] = e[i].charCodeAt(0);
                const n = I(oe(r));
                for (let i = 0; i < 40; i += 2) n[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()), (15 & n[i >> 1]) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
                return "0x" + e.join("")
            }
            const we = 9007199254740991;

            function _e(t) {
                return Math.log10 ? Math.log10(t) : Math.log(t) / Math.LN10
            }
            const Me = {};
            for (let Ci = 0; Ci < 10; Ci++) Me[String(Ci)] = String(Ci);
            for (let Ci = 0; Ci < 26; Ci++) Me[String.fromCharCode(65 + Ci)] = String(10 + Ci);
            const Ae = Math.floor(_e(we));

            function Se(t) {
                t = t.toUpperCase(), t = t.substring(4) + t.substring(0, 2) + "00";
                let e = t.split("").map(t => Me[t]).join("");
                while (e.length >= Ae) {
                    let t = e.substring(0, Ae);
                    e = parseInt(t, 10) % 97 + e.substring(t.length)
                }
                let r = String(98 - parseInt(e, 10) % 97);
                while (r.length < 2) r = "0" + r;
                return r
            }

            function xe(t) {
                let e = null;
                if ("string" !== typeof t && ye.throwArgumentError("invalid address", "address", t), t.match(/^(0x)?[0-9a-fA-F]{40}$/)) "0x" !== t.substring(0, 2) && (t = "0x" + t), e = ve(t), t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && e !== t && ye.throwArgumentError("bad address checksum", "address", t);
                else if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
                    t.substring(2, 4) !== Se(t) && ye.throwArgumentError("bad icap checksum", "address", t), e = nt(t.substring(4));
                    while (e.length < 40) e = "0" + e;
                    e = ve("0x" + e)
                } else ye.throwArgumentError("invalid address", "address", t);
                return e
            }

            function Ee(t) {
                try {
                    return xe(t), !0
                } catch (e) {}
                return !1
            }

            function ke(t) {
                let e = it(xe(t).substring(2)).toUpperCase();
                while (e.length < 30) e = "0" + e;
                return "XE" + Se("XE00" + e) + e
            }

            function Re(t) {
                let e = null;
                try {
                    e = xe(t.from)
                } catch (n) {
                    ye.throwArgumentError("missing from address", "transaction", t)
                }
                const r = T(I(Y.from(t.nonce).toHexString()));
                return xe(L(oe(de([e, r])), 12))
            }

            function Oe(t, e, r) {
                return 32 !== D(e) && ye.throwArgumentError("salt must be 32 bytes", "salt", e), 32 !== D(r) && ye.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", r), xe(L(oe(P(["0xff", xe(t), e, r])), 12))
            }
            class Ie extends re {
                constructor(t) {
                    super("address", "address", t, !1)
                }
                defaultValue() {
                    return "0x0000000000000000000000000000000000000000"
                }
                encode(t, e) {
                    try {
                        e = xe(e)
                    } catch (r) {
                        this._throwError(r.message, e)
                    }
                    return t.writeValue(e)
                }
                decode(t) {
                    return xe(U(t.readValue().toHexString(), 20))
                }
            }
            class Pe extends re {
                constructor(t) {
                    super(t.name, t.type, void 0, t.dynamic), this.coder = t
                }
                defaultValue() {
                    return this.coder.defaultValue()
                }
                encode(t, e) {
                    return this.coder.encode(t, e)
                }
                decode(t) {
                    return this.coder.decode(t)
                }
            }
            const Te = new M(Qt);

            function Ne(t, e, r) {
                let n = null;
                if (Array.isArray(r)) n = r;
                else if (r && "object" === typeof r) {
                    let t = {};
                    n = e.map(e => {
                        const n = e.localName;
                        return n || Te.throwError("cannot encode object for signature with missing names", M.errors.INVALID_ARGUMENT, {
                            argument: "values",
                            coder: e,
                            value: r
                        }), t[n] && Te.throwError("cannot encode object for signature with duplicate names", M.errors.INVALID_ARGUMENT, {
                            argument: "values",
                            coder: e,
                            value: r
                        }), t[n] = !0, r[n]
                    })
                } else Te.throwArgumentError("invalid tuple value", "tuple", r);
                e.length !== n.length && Te.throwArgumentError("types/value length mismatch", "tuple", r);
                let i = new ne(t.wordSize),
                    s = new ne(t.wordSize),
                    a = [];
                e.forEach((t, e) => {
                    let r = n[e];
                    if (t.dynamic) {
                        let e = s.length;
                        t.encode(s, r);
                        let n = i.writeUpdatableValue();
                        a.push(t => {
                            n(t + e)
                        })
                    } else t.encode(i, r)
                }), a.forEach(t => {
                    t(i.length)
                });
                let o = t.appendWriter(i);
                return o += t.appendWriter(s), o
            }

            function je(t, e) {
                let r = [],
                    n = t.subReader(0);
                e.forEach(e => {
                    let i = null;
                    if (e.dynamic) {
                        let r = t.readValue(),
                            a = n.subReader(r.toNumber());
                        try {
                            i = e.decode(a)
                        } catch (s) {
                            if (s.code === M.errors.BUFFER_OVERRUN) throw s;
                            i = s, i.baseType = e.name, i.name = e.localName, i.type = e.type
                        }
                    } else try {
                        i = e.decode(t)
                    } catch (s) {
                        if (s.code === M.errors.BUFFER_OVERRUN) throw s;
                        i = s, i.baseType = e.name, i.name = e.localName, i.type = e.type
                    }
                    void 0 != i && r.push(i)
                });
                const i = e.reduce((t, e) => {
                    const r = e.localName;
                    return r && (t[r] || (t[r] = 0), t[r]++), t
                }, {});
                e.forEach((t, e) => {
                    let n = t.localName;
                    if (!n || 1 !== i[n]) return;
                    if ("length" === n && (n = "_length"), null != r[n]) return;
                    const s = r[e];
                    s instanceof Error ? Object.defineProperty(r, n, {
                        enumerable: !0,
                        get: () => {
                            throw s
                        }
                    }) : r[n] = s
                });
                for (let s = 0; s < r.length; s++) {
                    const t = r[s];
                    t instanceof Error && Object.defineProperty(r, s, {
                        enumerable: !0,
                        get: () => {
                            throw t
                        }
                    })
                }
                return Object.freeze(r)
            }
            class Ce extends re {
                constructor(t, e, r) {
                    const n = t.type + "[" + (e >= 0 ? e : "") + "]",
                        i = -1 === e || t.dynamic;
                    super("array", n, r, i), this.coder = t, this.length = e
                }
                defaultValue() {
                    const t = this.coder.defaultValue(),
                        e = [];
                    for (let r = 0; r < this.length; r++) e.push(t);
                    return e
                }
                encode(t, e) {
                    Array.isArray(e) || this._throwError("expected array value", e);
                    let r = this.length; - 1 === r && (r = e.length, t.writeValue(e.length)), Te.checkArgumentCount(e.length, r, "coder array" + (this.localName ? " " + this.localName : ""));
                    let n = [];
                    for (let i = 0; i < e.length; i++) n.push(this.coder);
                    return Ne(t, n, e)
                }
                decode(t) {
                    let e = this.length; - 1 === e && (e = t.readValue().toNumber(), 32 * e > t._data.length && Te.throwError("insufficient data length", M.errors.BUFFER_OVERRUN, {
                        length: t._data.length,
                        count: e
                    }));
                    let r = [];
                    for (let n = 0; n < e; n++) r.push(new Pe(this.coder));
                    return t.coerce(this.name, je(t, r))
                }
            }
            class ze extends re {
                constructor(t) {
                    super("bool", "bool", t, !1)
                }
                defaultValue() {
                    return !1
                }
                encode(t, e) {
                    return t.writeValue(e ? 1 : 0)
                }
                decode(t) {
                    return t.coerce(this.type, !t.readValue().isZero())
                }
            }
            class De extends re {
                constructor(t, e) {
                    super(t, t, e, !0)
                }
                defaultValue() {
                    return "0x"
                }
                encode(t, e) {
                    e = I(e);
                    let r = t.writeValue(e.length);
                    return r += t.writeBytes(e), r
                }
                decode(t) {
                    return t.readBytes(t.readValue().toNumber(), !0)
                }
            }
            class Le extends De {
                constructor(t) {
                    super("bytes", t)
                }
                decode(t) {
                    return t.coerce(this.name, z(super.decode(t)))
                }
            }
            class Fe extends re {
                constructor(t, e) {
                    let r = "bytes" + String(t);
                    super(r, r, e, !1), this.size = t
                }
                defaultValue() {
                    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + 2 * this.size)
                }
                encode(t, e) {
                    let r = I(e);
                    return r.length !== this.size && this._throwError("incorrect data length", e), t.writeBytes(r)
                }
                decode(t) {
                    return t.coerce(this.name, z(t.readBytes(this.size)))
                }
            }
            class Be extends re {
                constructor(t) {
                    super("null", "", t, !1)
                }
                defaultValue() {
                    return null
                }
                encode(t, e) {
                    return null != e && this._throwError("not null", e), t.writeBytes([])
                }
                decode(t) {
                    return t.readBytes(0), t.coerce(this.name, null)
                }
            }
            class $e extends re {
                constructor(t, e, r) {
                    const n = (e ? "int" : "uint") + 8 * t;
                    super(n, n, r, !1), this.size = t, this.signed = e
                }
                defaultValue() {
                    return 0
                }
                encode(t, e) {
                    let r = Y.from(e),
                        n = Vt.mask(8 * t.wordSize);
                    if (this.signed) {
                        let t = n.mask(8 * this.size - 1);
                        (r.gt(t) || r.lt(t.add(Ut).mul(Bt))) && this._throwError("value out-of-bounds", e)
                    } else(r.lt($t) || r.gt(n.mask(8 * this.size))) && this._throwError("value out-of-bounds", e);
                    return r = r.toTwos(8 * this.size).mask(8 * this.size), this.signed && (r = r.fromTwos(8 * this.size).toTwos(8 * t.wordSize)), t.writeValue(r)
                }
                decode(t) {
                    let e = t.readValue().mask(8 * this.size);
                    return this.signed && (e = e.fromTwos(8 * this.size)), t.coerce(this.name, e)
                }
            }
            const Ue = "strings/5.6.0",
                qe = new M(Ue);
            var Ke, Ve;

            function We(t, e, r, n, i) {
                return qe.throwArgumentError(`invalid codepoint at offset ${e}; ${t}`, "bytes", r)
            }

            function Ze(t, e, r, n, i) {
                if (t === Ve.BAD_PREFIX || t === Ve.UNEXPECTED_CONTINUE) {
                    let t = 0;
                    for (let n = e + 1; n < r.length; n++) {
                        if (r[n] >> 6 !== 2) break;
                        t++
                    }
                    return t
                }
                return t === Ve.OVERRUN ? r.length - e - 1 : 0
            }

            function He(t, e, r, n, i) {
                return t === Ve.OVERLONG ? (n.push(i), 0) : (n.push(65533), Ze(t, e, r, n, i))
            }(function(t) {
                t["current"] = "", t["NFC"] = "NFC", t["NFD"] = "NFD", t["NFKC"] = "NFKC", t["NFKD"] = "NFKD"
            })(Ke || (Ke = {})),
            function(t) {
                t["UNEXPECTED_CONTINUE"] = "unexpected continuation byte", t["BAD_PREFIX"] = "bad codepoint prefix", t["OVERRUN"] = "string overrun", t["MISSING_CONTINUE"] = "missing continuation byte", t["OUT_OF_RANGE"] = "out of UTF-8 range", t["UTF16_SURROGATE"] = "UTF-16 surrogate", t["OVERLONG"] = "overlong representation"
            }(Ve || (Ve = {}));
            const Ge = Object.freeze({
                error: We,
                ignore: Ze,
                replace: He
            });

            function Je(t, e) {
                null == e && (e = Ge.error), t = I(t);
                const r = [];
                let n = 0;
                while (n < t.length) {
                    const i = t[n++];
                    if (i >> 7 === 0) {
                        r.push(i);
                        continue
                    }
                    let s = null,
                        a = null;
                    if (192 === (224 & i)) s = 1, a = 127;
                    else if (224 === (240 & i)) s = 2, a = 2047;
                    else {
                        if (240 !== (248 & i)) {
                            n += e(128 === (192 & i) ? Ve.UNEXPECTED_CONTINUE : Ve.BAD_PREFIX, n - 1, t, r);
                            continue
                        }
                        s = 3, a = 65535
                    }
                    if (n - 1 + s >= t.length) {
                        n += e(Ve.OVERRUN, n - 1, t, r);
                        continue
                    }
                    let o = i & (1 << 8 - s - 1) - 1;
                    for (let u = 0; u < s; u++) {
                        let i = t[n];
                        if (128 != (192 & i)) {
                            n += e(Ve.MISSING_CONTINUE, n, t, r), o = null;
                            break
                        }
                        o = o << 6 | 63 & i, n++
                    }
                    null !== o && (o > 1114111 ? n += e(Ve.OUT_OF_RANGE, n - 1 - s, t, r, o) : o >= 55296 && o <= 57343 ? n += e(Ve.UTF16_SURROGATE, n - 1 - s, t, r, o) : o <= a ? n += e(Ve.OVERLONG, n - 1 - s, t, r, o) : r.push(o))
                }
                return r
            }

            function Xe(t, e = Ke.current) {
                e != Ke.current && (qe.checkNormalize(), t = t.normalize(e));
                let r = [];
                for (let n = 0; n < t.length; n++) {
                    const e = t.charCodeAt(n);
                    if (e < 128) r.push(e);
                    else if (e < 2048) r.push(e >> 6 | 192), r.push(63 & e | 128);
                    else if (55296 == (64512 & e)) {
                        n++;
                        const i = t.charCodeAt(n);
                        if (n >= t.length || 56320 !== (64512 & i)) throw new Error("invalid utf-8 string");
                        const s = 65536 + ((1023 & e) << 10) + (1023 & i);
                        r.push(s >> 18 | 240), r.push(s >> 12 & 63 | 128), r.push(s >> 6 & 63 | 128), r.push(63 & s | 128)
                    } else r.push(e >> 12 | 224), r.push(e >> 6 & 63 | 128), r.push(63 & e | 128)
                }
                return I(r)
            }

            function Ye(t) {
                const e = "0000" + t.toString(16);
                return "\\u" + e.substring(e.length - 4)
            }

            function Qe(t, e) {
                return '"' + Je(t, e).map(t => {
                    if (t < 256) {
                        switch (t) {
                            case 8:
                                return "\\b";
                            case 9:
                                return "\\t";
                            case 10:
                                return "\\n";
                            case 13:
                                return "\\r";
                            case 34:
                                return '\\"';
                            case 92:
                                return "\\\\"
                        }
                        if (t >= 32 && t < 127) return String.fromCharCode(t)
                    }
                    return t <= 65535 ? Ye(t) : (t -= 65536, Ye(55296 + (t >> 10 & 1023)) + Ye(56320 + (1023 & t)))
                }).join("") + '"'
            }

            function tr(t) {
                return t.map(t => t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode(55296 + (t >> 10 & 1023), 56320 + (1023 & t)))).join("")
            }

            function er(t, e) {
                return tr(Je(t, e))
            }

            function rr(t, e = Ke.current) {
                return Je(Xe(t, e))
            }
            class nr extends De {
                constructor(t) {
                    super("string", t)
                }
                defaultValue() {
                    return ""
                }
                encode(t, e) {
                    return super.encode(t, Xe(e))
                }
                decode(t) {
                    return er(super.decode(t))
                }
            }
            class ir extends re {
                constructor(t, e) {
                    let r = !1;
                    const n = [];
                    t.forEach(t => {
                        t.dynamic && (r = !0), n.push(t.type)
                    });
                    const i = "tuple(" + n.join(",") + ")";
                    super("tuple", i, e, r), this.coders = t
                }
                defaultValue() {
                    const t = [];
                    this.coders.forEach(e => {
                        t.push(e.defaultValue())
                    });
                    const e = this.coders.reduce((t, e) => {
                        const r = e.localName;
                        return r && (t[r] || (t[r] = 0), t[r]++), t
                    }, {});
                    return this.coders.forEach((r, n) => {
                        let i = r.localName;
                        i && 1 === e[i] && ("length" === i && (i = "_length"), null == t[i] && (t[i] = t[n]))
                    }), Object.freeze(t)
                }
                encode(t, e) {
                    return Ne(t, this.coders, e)
                }
                decode(t) {
                    return t.coerce(this.name, je(t, this.coders))
                }
            }
            const sr = new M(Qt),
                ar = {};
            let or = {
                    calldata: !0,
                    memory: !0,
                    storage: !0
                },
                ur = {
                    calldata: !0,
                    memory: !0
                };

            function hr(t, e) {
                if ("bytes" === t || "string" === t) {
                    if (or[e]) return !0
                } else if ("address" === t) {
                    if ("payable" === e) return !0
                } else if ((t.indexOf("[") >= 0 || "tuple" === t) && ur[e]) return !0;
                return (or[e] || "payable" === e) && sr.throwArgumentError("invalid modifier", "name", e), !1
            }

            function fr(t, e) {
                let r = t;

                function n(e) {
                    sr.throwArgumentError("unexpected character at position " + e, "param", t)
                }

                function i(t) {
                    let r = {
                        type: "",
                        name: "",
                        parent: t,
                        state: {
                            allowType: !0
                        }
                    };
                    return e && (r.indexed = !1), r
                }
                t = t.replace(/\s/g, " ");
                let s = {
                        type: "",
                        name: "",
                        state: {
                            allowType: !0
                        }
                    },
                    a = s;
                for (let o = 0; o < t.length; o++) {
                    let r = t[o];
                    switch (r) {
                        case "(":
                            a.state.allowType && "" === a.type ? a.type = "tuple" : a.state.allowParams || n(o), a.state.allowType = !1, a.type = xr(a.type), a.components = [i(a)], a = a.components[0];
                            break;
                        case ")":
                            delete a.state, "indexed" === a.name && (e || n(o), a.indexed = !0, a.name = ""), hr(a.type, a.name) && (a.name = ""), a.type = xr(a.type);
                            let t = a;
                            a = a.parent, a || n(o), delete t.parent, a.state.allowParams = !1, a.state.allowName = !0, a.state.allowArray = !0;
                            break;
                        case ",":
                            delete a.state, "indexed" === a.name && (e || n(o), a.indexed = !0, a.name = ""), hr(a.type, a.name) && (a.name = ""), a.type = xr(a.type);
                            let s = i(a.parent);
                            a.parent.components.push(s), delete a.parent, a = s;
                            break;
                        case " ":
                            a.state.allowType && "" !== a.type && (a.type = xr(a.type), delete a.state.allowType, a.state.allowName = !0, a.state.allowParams = !0), a.state.allowName && "" !== a.name && ("indexed" === a.name ? (e || n(o), a.indexed && n(o), a.indexed = !0, a.name = "") : hr(a.type, a.name) ? a.name = "" : a.state.allowName = !1);
                            break;
                        case "[":
                            a.state.allowArray || n(o), a.type += r, a.state.allowArray = !1, a.state.allowName = !1, a.state.readArray = !0;
                            break;
                        case "]":
                            a.state.readArray || n(o), a.type += r, a.state.readArray = !1, a.state.allowArray = !0, a.state.allowName = !0;
                            break;
                        default:
                            a.state.allowType ? (a.type += r, a.state.allowParams = !0, a.state.allowArray = !0) : a.state.allowName ? (a.name += r, delete a.state.allowArray) : a.state.readArray ? a.type += r : n(o)
                    }
                }
                return a.parent && sr.throwArgumentError("unexpected eof", "param", t), delete s.state, "indexed" === a.name ? (e || n(r.length - 7), a.indexed && n(r.length - 7), a.indexed = !0, a.name = "") : hr(a.type, a.name) && (a.name = ""), s.type = xr(s.type), s
            }

            function cr(t, e) {
                for (let r in e) _t(t, r, e[r])
            }
            const lr = Object.freeze({
                    sighash: "sighash",
                    minimal: "minimal",
                    full: "full",
                    json: "json"
                }),
                dr = new RegExp(/^(.*)\[([0-9]*)\]$/);
            class pr {
                constructor(t, e) {
                    t !== ar && sr.throwError("use fromString", M.errors.UNSUPPORTED_OPERATION, {
                        operation: "new ParamType()"
                    }), cr(this, e);
                    let r = this.type.match(dr);
                    cr(this, r ? {
                        arrayLength: parseInt(r[2] || "-1"),
                        arrayChildren: pr.fromObject({
                            type: r[1],
                            components: this.components
                        }),
                        baseType: "array"
                    } : {
                        arrayLength: null,
                        arrayChildren: null,
                        baseType: null != this.components ? "tuple" : this.type
                    }), this._isParamType = !0, Object.freeze(this)
                }
                format(t) {
                    if (t || (t = lr.sighash), lr[t] || sr.throwArgumentError("invalid format type", "format", t), t === lr.json) {
                        let e = {
                            type: "tuple" === this.baseType ? "tuple" : this.type,
                            name: this.name || void 0
                        };
                        return "boolean" === typeof this.indexed && (e.indexed = this.indexed), this.components && (e.components = this.components.map(e => JSON.parse(e.format(t)))), JSON.stringify(e)
                    }
                    let e = "";
                    return "array" === this.baseType ? (e += this.arrayChildren.format(t), e += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]") : "tuple" === this.baseType ? (t !== lr.sighash && (e += this.type), e += "(" + this.components.map(e => e.format(t)).join(t === lr.full ? ", " : ",") + ")") : e += this.type, t !== lr.sighash && (!0 === this.indexed && (e += " indexed"), t === lr.full && this.name && (e += " " + this.name)), e
                }
                static from(t, e) {
                    return "string" === typeof t ? pr.fromString(t, e) : pr.fromObject(t)
                }
                static fromObject(t) {
                    return pr.isParamType(t) ? t : new pr(ar, {
                        name: t.name || null,
                        type: xr(t.type),
                        indexed: null == t.indexed ? null : !!t.indexed,
                        components: t.components ? t.components.map(pr.fromObject) : null
                    })
                }
                static fromString(t, e) {
                    function r(t) {
                        return pr.fromObject({
                            name: t.name,
                            type: t.type,
                            indexed: t.indexed,
                            components: t.components
                        })
                    }
                    return r(fr(t, !!e))
                }
                static isParamType(t) {
                    return !(null == t || !t._isParamType)
                }
            }

            function mr(t, e) {
                return Or(t).map(t => pr.fromString(t, e))
            }
            class br {
                constructor(t, e) {
                    t !== ar && sr.throwError("use a static from method", M.errors.UNSUPPORTED_OPERATION, {
                        operation: "new Fragment()"
                    }), cr(this, e), this._isFragment = !0, Object.freeze(this)
                }
                static from(t) {
                    return br.isFragment(t) ? t : "string" === typeof t ? br.fromString(t) : br.fromObject(t)
                }
                static fromObject(t) {
                    if (br.isFragment(t)) return t;
                    switch (t.type) {
                        case "function":
                            return Mr.fromObject(t);
                        case "event":
                            return gr.fromObject(t);
                        case "constructor":
                            return _r.fromObject(t);
                        case "error":
                            return Sr.fromObject(t);
                        case "fallback":
                        case "receive":
                            return null
                    }
                    return sr.throwArgumentError("invalid fragment object", "value", t)
                }
                static fromString(t) {
                    return t = t.replace(/\s/g, " "), t = t.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " "), t = t.trim(), "event" === t.split(" ")[0] ? gr.fromString(t.substring(5).trim()) : "function" === t.split(" ")[0] ? Mr.fromString(t.substring(8).trim()) : "constructor" === t.split("(")[0].trim() ? _r.fromString(t.trim()) : "error" === t.split(" ")[0] ? Sr.fromString(t.substring(5).trim()) : sr.throwArgumentError("unsupported fragment", "value", t)
                }
                static isFragment(t) {
                    return !(!t || !t._isFragment)
                }
            }
            class gr extends br {
                format(t) {
                    if (t || (t = lr.sighash), lr[t] || sr.throwArgumentError("invalid format type", "format", t), t === lr.json) return JSON.stringify({
                        type: "event",
                        anonymous: this.anonymous,
                        name: this.name,
                        inputs: this.inputs.map(e => JSON.parse(e.format(t)))
                    });
                    let e = "";
                    return t !== lr.sighash && (e += "event "), e += this.name + "(" + this.inputs.map(e => e.format(t)).join(t === lr.full ? ", " : ",") + ") ", t !== lr.sighash && this.anonymous && (e += "anonymous "), e.trim()
                }
                static from(t) {
                    return "string" === typeof t ? gr.fromString(t) : gr.fromObject(t)
                }
                static fromObject(t) {
                    if (gr.isEventFragment(t)) return t;
                    "event" !== t.type && sr.throwArgumentError("invalid event object", "value", t);
                    const e = {
                        name: kr(t.name),
                        anonymous: t.anonymous,
                        inputs: t.inputs ? t.inputs.map(pr.fromObject) : [],
                        type: "event"
                    };
                    return new gr(ar, e)
                }
                static fromString(t) {
                    let e = t.match(Rr);
                    e || sr.throwArgumentError("invalid event string", "value", t);
                    let r = !1;
                    return e[3].split(" ").forEach(t => {
                        switch (t.trim()) {
                            case "anonymous":
                                r = !0;
                                break;
                            case "":
                                break;
                            default:
                                sr.warn("unknown modifier: " + t)
                        }
                    }), gr.fromObject({
                        name: e[1].trim(),
                        anonymous: r,
                        inputs: mr(e[2], !0),
                        type: "event"
                    })
                }
                static isEventFragment(t) {
                    return t && t._isFragment && "event" === t.type
                }
            }

            function yr(t, e) {
                e.gas = null;
                let r = t.split("@");
                return 1 !== r.length ? (r.length > 2 && sr.throwArgumentError("invalid human-readable ABI signature", "value", t), r[1].match(/^[0-9]+$/) || sr.throwArgumentError("invalid human-readable ABI signature gas", "value", t), e.gas = Y.from(r[1]), r[0]) : t
            }

            function vr(t, e) {
                e.constant = !1, e.payable = !1, e.stateMutability = "nonpayable", t.split(" ").forEach(t => {
                    switch (t.trim()) {
                        case "constant":
                            e.constant = !0;
                            break;
                        case "payable":
                            e.payable = !0, e.stateMutability = "payable";
                            break;
                        case "nonpayable":
                            e.payable = !1, e.stateMutability = "nonpayable";
                            break;
                        case "pure":
                            e.constant = !0, e.stateMutability = "pure";
                            break;
                        case "view":
                            e.constant = !0, e.stateMutability = "view";
                            break;
                        case "external":
                        case "public":
                        case "":
                            break;
                        default:
                            console.log("unknown modifier: " + t)
                    }
                })
            }

            function wr(t) {
                let e = {
                    constant: !1,
                    payable: !0,
                    stateMutability: "payable"
                };
                return null != t.stateMutability ? (e.stateMutability = t.stateMutability, e.constant = "view" === e.stateMutability || "pure" === e.stateMutability, null != t.constant && !!t.constant !== e.constant && sr.throwArgumentError("cannot have constant function with mutability " + e.stateMutability, "value", t), e.payable = "payable" === e.stateMutability, null != t.payable && !!t.payable !== e.payable && sr.throwArgumentError("cannot have payable function with mutability " + e.stateMutability, "value", t)) : null != t.payable ? (e.payable = !!t.payable, null != t.constant || e.payable || "constructor" === t.type || sr.throwArgumentError("unable to determine stateMutability", "value", t), e.constant = !!t.constant, e.constant ? e.stateMutability = "view" : e.stateMutability = e.payable ? "payable" : "nonpayable", e.payable && e.constant && sr.throwArgumentError("cannot have constant payable function", "value", t)) : null != t.constant ? (e.constant = !!t.constant, e.payable = !e.constant, e.stateMutability = e.constant ? "view" : "payable") : "constructor" !== t.type && sr.throwArgumentError("unable to determine stateMutability", "value", t), e
            }
            class _r extends br {
                format(t) {
                    if (t || (t = lr.sighash), lr[t] || sr.throwArgumentError("invalid format type", "format", t), t === lr.json) return JSON.stringify({
                        type: "constructor",
                        stateMutability: "nonpayable" !== this.stateMutability ? this.stateMutability : void 0,
                        payable: this.payable,
                        gas: this.gas ? this.gas.toNumber() : void 0,
                        inputs: this.inputs.map(e => JSON.parse(e.format(t)))
                    });
                    t === lr.sighash && sr.throwError("cannot format a constructor for sighash", M.errors.UNSUPPORTED_OPERATION, {
                        operation: "format(sighash)"
                    });
                    let e = "constructor(" + this.inputs.map(e => e.format(t)).join(t === lr.full ? ", " : ",") + ") ";
                    return this.stateMutability && "nonpayable" !== this.stateMutability && (e += this.stateMutability + " "), e.trim()
                }
                static from(t) {
                    return "string" === typeof t ? _r.fromString(t) : _r.fromObject(t)
                }
                static fromObject(t) {
                    if (_r.isConstructorFragment(t)) return t;
                    "constructor" !== t.type && sr.throwArgumentError("invalid constructor object", "value", t);
                    let e = wr(t);
                    e.constant && sr.throwArgumentError("constructor cannot be constant", "value", t);
                    const r = {
                        name: null,
                        type: t.type,
                        inputs: t.inputs ? t.inputs.map(pr.fromObject) : [],
                        payable: e.payable,
                        stateMutability: e.stateMutability,
                        gas: t.gas ? Y.from(t.gas) : null
                    };
                    return new _r(ar, r)
                }
                static fromString(t) {
                    let e = {
                        type: "constructor"
                    };
                    t = yr(t, e);
                    let r = t.match(Rr);
                    return r && "constructor" === r[1].trim() || sr.throwArgumentError("invalid constructor string", "value", t), e.inputs = mr(r[2].trim(), !1), vr(r[3].trim(), e), _r.fromObject(e)
                }
                static isConstructorFragment(t) {
                    return t && t._isFragment && "constructor" === t.type
                }
            }
            class Mr extends _r {
                format(t) {
                    if (t || (t = lr.sighash), lr[t] || sr.throwArgumentError("invalid format type", "format", t), t === lr.json) return JSON.stringify({
                        type: "function",
                        name: this.name,
                        constant: this.constant,
                        stateMutability: "nonpayable" !== this.stateMutability ? this.stateMutability : void 0,
                        payable: this.payable,
                        gas: this.gas ? this.gas.toNumber() : void 0,
                        inputs: this.inputs.map(e => JSON.parse(e.format(t))),
                        outputs: this.outputs.map(e => JSON.parse(e.format(t)))
                    });
                    let e = "";
                    return t !== lr.sighash && (e += "function "), e += this.name + "(" + this.inputs.map(e => e.format(t)).join(t === lr.full ? ", " : ",") + ") ", t !== lr.sighash && (this.stateMutability ? "nonpayable" !== this.stateMutability && (e += this.stateMutability + " ") : this.constant && (e += "view "), this.outputs && this.outputs.length && (e += "returns (" + this.outputs.map(e => e.format(t)).join(", ") + ") "), null != this.gas && (e += "@" + this.gas.toString() + " ")), e.trim()
                }
                static from(t) {
                    return "string" === typeof t ? Mr.fromString(t) : Mr.fromObject(t)
                }
                static fromObject(t) {
                    if (Mr.isFunctionFragment(t)) return t;
                    "function" !== t.type && sr.throwArgumentError("invalid function object", "value", t);
                    let e = wr(t);
                    const r = {
                        type: t.type,
                        name: kr(t.name),
                        constant: e.constant,
                        inputs: t.inputs ? t.inputs.map(pr.fromObject) : [],
                        outputs: t.outputs ? t.outputs.map(pr.fromObject) : [],
                        payable: e.payable,
                        stateMutability: e.stateMutability,
                        gas: t.gas ? Y.from(t.gas) : null
                    };
                    return new Mr(ar, r)
                }
                static fromString(t) {
                    let e = {
                        type: "function"
                    };
                    t = yr(t, e);
                    let r = t.split(" returns ");
                    r.length > 2 && sr.throwArgumentError("invalid function string", "value", t);
                    let n = r[0].match(Rr);
                    if (n || sr.throwArgumentError("invalid function signature", "value", t), e.name = n[1].trim(), e.name && kr(e.name), e.inputs = mr(n[2], !1), vr(n[3].trim(), e), r.length > 1) {
                        let n = r[1].match(Rr);
                        "" == n[1].trim() && "" == n[3].trim() || sr.throwArgumentError("unexpected tokens", "value", t), e.outputs = mr(n[2], !1)
                    } else e.outputs = [];
                    return Mr.fromObject(e)
                }
                static isFunctionFragment(t) {
                    return t && t._isFragment && "function" === t.type
                }
            }

            function Ar(t) {
                const e = t.format();
                return "Error(string)" !== e && "Panic(uint256)" !== e || sr.throwArgumentError(`cannot specify user defined ${e} error`, "fragment", t), t
            }
            class Sr extends br {
                format(t) {
                    if (t || (t = lr.sighash), lr[t] || sr.throwArgumentError("invalid format type", "format", t), t === lr.json) return JSON.stringify({
                        type: "error",
                        name: this.name,
                        inputs: this.inputs.map(e => JSON.parse(e.format(t)))
                    });
                    let e = "";
                    return t !== lr.sighash && (e += "error "), e += this.name + "(" + this.inputs.map(e => e.format(t)).join(t === lr.full ? ", " : ",") + ") ", e.trim()
                }
                static from(t) {
                    return "string" === typeof t ? Sr.fromString(t) : Sr.fromObject(t)
                }
                static fromObject(t) {
                    if (Sr.isErrorFragment(t)) return t;
                    "error" !== t.type && sr.throwArgumentError("invalid error object", "value", t);
                    const e = {
                        type: t.type,
                        name: kr(t.name),
                        inputs: t.inputs ? t.inputs.map(pr.fromObject) : []
                    };
                    return Ar(new Sr(ar, e))
                }
                static fromString(t) {
                    let e = {
                            type: "error"
                        },
                        r = t.match(Rr);
                    return r || sr.throwArgumentError("invalid error signature", "value", t), e.name = r[1].trim(), e.name && kr(e.name), e.inputs = mr(r[2], !1), Ar(Sr.fromObject(e))
                }
                static isErrorFragment(t) {
                    return t && t._isFragment && "error" === t.type
                }
            }

            function xr(t) {
                return t.match(/^uint($|[^1-9])/) ? t = "uint256" + t.substring(4) : t.match(/^int($|[^1-9])/) && (t = "int256" + t.substring(3)), t
            }
            const Er = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");

            function kr(t) {
                return t && t.match(Er) || sr.throwArgumentError(`invalid identifier "${t}"`, "value", t), t
            }
            const Rr = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");

            function Or(t) {
                t = t.trim();
                let e = [],
                    r = "",
                    n = 0;
                for (let i = 0; i < t.length; i++) {
                    let s = t[i];
                    "," === s && 0 === n ? (e.push(r), r = "") : (r += s, "(" === s ? n++ : ")" === s && (n--, -1 === n && sr.throwArgumentError("unbalanced parenthesis", "value", t)))
                }
                return r && e.push(r), e
            }
            const Ir = new M(Qt),
                Pr = new RegExp(/^bytes([0-9]*)$/),
                Tr = new RegExp(/^(u?int)([0-9]*)$/);
            class Nr {
                constructor(t) {
                    Ir.checkNew(new.target, Nr), _t(this, "coerceFunc", t || null)
                }
                _getCoder(t) {
                    switch (t.baseType) {
                        case "address":
                            return new Ie(t.name);
                        case "bool":
                            return new ze(t.name);
                        case "string":
                            return new nr(t.name);
                        case "bytes":
                            return new Le(t.name);
                        case "array":
                            return new Ce(this._getCoder(t.arrayChildren), t.arrayLength, t.name);
                        case "tuple":
                            return new ir((t.components || []).map(t => this._getCoder(t)), t.name);
                        case "":
                            return new Be(t.name)
                    }
                    let e = t.type.match(Tr);
                    if (e) {
                        let r = parseInt(e[2] || "256");
                        return (0 === r || r > 256 || r % 8 !== 0) && Ir.throwArgumentError("invalid " + e[1] + " bit length", "param", t), new $e(r / 8, "int" === e[1], t.name)
                    }
                    if (e = t.type.match(Pr), e) {
                        let r = parseInt(e[1]);
                        return (0 === r || r > 32) && Ir.throwArgumentError("invalid bytes length", "param", t), new Fe(r, t.name)
                    }
                    return Ir.throwArgumentError("invalid type", "type", t.type)
                }
                _getWordSize() {
                    return 32
                }
                _getReader(t, e) {
                    return new ie(t, this._getWordSize(), this.coerceFunc, e)
                }
                _getWriter() {
                    return new ne(this._getWordSize())
                }
                getDefaultValue(t) {
                    const e = t.map(t => this._getCoder(pr.from(t))),
                        r = new ir(e, "_");
                    return r.defaultValue()
                }
                encode(t, e) {
                    t.length !== e.length && Ir.throwError("types/values length mismatch", M.errors.INVALID_ARGUMENT, {
                        count: {
                            types: t.length,
                            values: e.length
                        },
                        value: {
                            types: t,
                            values: e
                        }
                    });
                    const r = t.map(t => this._getCoder(pr.from(t))),
                        n = new ir(r, "_"),
                        i = this._getWriter();
                    return n.encode(i, e), i.data
                }
                decode(t, e, r) {
                    const n = t.map(t => this._getCoder(pr.from(t))),
                        i = new ir(n, "_");
                    return i.decode(this._getReader(I(e), r))
                }
            }
            const jr = new Nr;

            function Cr(t) {
                return oe(Xe(t))
            }
            const zr = new M(Qt);
            class Dr extends It {}
            class Lr extends It {}
            class Fr extends It {}
            class Br extends It {
                static isIndexed(t) {
                    return !(!t || !t._isIndexed)
                }
            }
            const $r = {
                "0x08c379a0": {
                    signature: "Error(string)",
                    name: "Error",
                    inputs: ["string"],
                    reason: !0
                },
                "0x4e487b71": {
                    signature: "Panic(uint256)",
                    name: "Panic",
                    inputs: ["uint256"]
                }
            };

            function Ur(t, e) {
                const r = new Error("deferred error during ABI decoding triggered accessing " + t);
                return r.error = e, r
            }
            class qr {
                constructor(t) {
                    zr.checkNew(new.target, qr);
                    let e = [];
                    e = "string" === typeof t ? JSON.parse(t) : t, _t(this, "fragments", e.map(t => br.from(t)).filter(t => null != t)), _t(this, "_abiCoder", Mt(new.target, "getAbiCoder")()), _t(this, "functions", {}), _t(this, "errors", {}), _t(this, "events", {}), _t(this, "structs", {}), this.fragments.forEach(t => {
                        let e = null;
                        switch (t.type) {
                            case "constructor":
                                return this.deploy ? void zr.warn("duplicate definition - constructor") : void _t(this, "deploy", t);
                            case "function":
                                e = this.functions;
                                break;
                            case "event":
                                e = this.events;
                                break;
                            case "error":
                                e = this.errors;
                                break;
                            default:
                                return
                        }
                        let r = t.format();
                        e[r] ? zr.warn("duplicate definition - " + r) : e[r] = t
                    }), this.deploy || _t(this, "deploy", _r.from({
                        payable: !1,
                        type: "constructor"
                    })), _t(this, "_isInterface", !0)
                }
                format(t) {
                    t || (t = lr.full), t === lr.sighash && zr.throwArgumentError("interface does not support formatting sighash", "format", t);
                    const e = this.fragments.map(e => e.format(t));
                    return t === lr.json ? JSON.stringify(e.map(t => JSON.parse(t))) : e
                }
                static getAbiCoder() {
                    return jr
                }
                static getAddress(t) {
                    return xe(t)
                }
                static getSighash(t) {
                    return L(Cr(t.format()), 0, 4)
                }
                static getEventTopic(t) {
                    return Cr(t.format())
                }
                getFunction(t) {
                    if (j(t)) {
                        for (const e in this.functions)
                            if (t === this.getSighash(e)) return this.functions[e];
                        zr.throwArgumentError("no matching function", "sighash", t)
                    }
                    if (-1 === t.indexOf("(")) {
                        const e = t.trim(),
                            r = Object.keys(this.functions).filter(t => t.split("(")[0] === e);
                        return 0 === r.length ? zr.throwArgumentError("no matching function", "name", e) : r.length > 1 && zr.throwArgumentError("multiple matching functions", "name", e), this.functions[r[0]]
                    }
                    const e = this.functions[Mr.fromString(t).format()];
                    return e || zr.throwArgumentError("no matching function", "signature", t), e
                }
                getEvent(t) {
                    if (j(t)) {
                        const e = t.toLowerCase();
                        for (const t in this.events)
                            if (e === this.getEventTopic(t)) return this.events[t];
                        zr.throwArgumentError("no matching event", "topichash", e)
                    }
                    if (-1 === t.indexOf("(")) {
                        const e = t.trim(),
                            r = Object.keys(this.events).filter(t => t.split("(")[0] === e);
                        return 0 === r.length ? zr.throwArgumentError("no matching event", "name", e) : r.length > 1 && zr.throwArgumentError("multiple matching events", "name", e), this.events[r[0]]
                    }
                    const e = this.events[gr.fromString(t).format()];
                    return e || zr.throwArgumentError("no matching event", "signature", t), e
                }
                getError(t) {
                    if (j(t)) {
                        const e = Mt(this.constructor, "getSighash");
                        for (const r in this.errors) {
                            const n = this.errors[r];
                            if (t === e(n)) return this.errors[r]
                        }
                        zr.throwArgumentError("no matching error", "sighash", t)
                    }
                    if (-1 === t.indexOf("(")) {
                        const e = t.trim(),
                            r = Object.keys(this.errors).filter(t => t.split("(")[0] === e);
                        return 0 === r.length ? zr.throwArgumentError("no matching error", "name", e) : r.length > 1 && zr.throwArgumentError("multiple matching errors", "name", e), this.errors[r[0]]
                    }
                    const e = this.errors[Mr.fromString(t).format()];
                    return e || zr.throwArgumentError("no matching error", "signature", t), e
                }
                getSighash(t) {
                    if ("string" === typeof t) try {
                        t = this.getFunction(t)
                    } catch (e) {
                        try {
                            t = this.getError(t)
                        } catch (r) {
                            throw e
                        }
                    }
                    return Mt(this.constructor, "getSighash")(t)
                }
                getEventTopic(t) {
                    return "string" === typeof t && (t = this.getEvent(t)), Mt(this.constructor, "getEventTopic")(t)
                }
                _decodeParams(t, e) {
                    return this._abiCoder.decode(t, e)
                }
                _encodeParams(t, e) {
                    return this._abiCoder.encode(t, e)
                }
                encodeDeploy(t) {
                    return this._encodeParams(this.deploy.inputs, t || [])
                }
                decodeErrorResult(t, e) {
                    "string" === typeof t && (t = this.getError(t));
                    const r = I(e);
                    return z(r.slice(0, 4)) !== this.getSighash(t) && zr.throwArgumentError(`data signature does not match error ${t.name}.`, "data", z(r)), this._decodeParams(t.inputs, r.slice(4))
                }
                encodeErrorResult(t, e) {
                    return "string" === typeof t && (t = this.getError(t)), z(P([this.getSighash(t), this._encodeParams(t.inputs, e || [])]))
                }
                decodeFunctionData(t, e) {
                    "string" === typeof t && (t = this.getFunction(t));
                    const r = I(e);
                    return z(r.slice(0, 4)) !== this.getSighash(t) && zr.throwArgumentError(`data signature does not match function ${t.name}.`, "data", z(r)), this._decodeParams(t.inputs, r.slice(4))
                }
                encodeFunctionData(t, e) {
                    return "string" === typeof t && (t = this.getFunction(t)), z(P([this.getSighash(t), this._encodeParams(t.inputs, e || [])]))
                }
                decodeFunctionResult(t, e) {
                    "string" === typeof t && (t = this.getFunction(t));
                    let r = I(e),
                        n = null,
                        i = "",
                        s = null,
                        a = null,
                        o = null;
                    switch (r.length % this._abiCoder._getWordSize()) {
                        case 0:
                            try {
                                return this._abiCoder.decode(t.outputs, r)
                            } catch (u) {}
                            break;
                        case 4:
                            {
                                const t = z(r.slice(0, 4)),
                                    e = $r[t];
                                if (e) s = this._abiCoder.decode(e.inputs, r.slice(4)),
                                a = e.name,
                                o = e.signature,
                                e.reason && (n = s[0]),
                                "Error" === a ? i = "; VM Exception while processing transaction: reverted with reason string " + JSON.stringify(s[0]) : "Panic" === a && (i = "; VM Exception while processing transaction: reverted with panic code " + s[0]);
                                else try {
                                    const e = this.getError(t);
                                    s = this._abiCoder.decode(e.inputs, r.slice(4)), a = e.name, o = e.format()
                                } catch (u) {}
                                break
                            }
                    }
                    return zr.throwError("call revert exception" + i, M.errors.CALL_EXCEPTION, {
                        method: t.format(),
                        data: z(e),
                        errorArgs: s,
                        errorName: a,
                        errorSignature: o,
                        reason: n
                    })
                }
                encodeFunctionResult(t, e) {
                    return "string" === typeof t && (t = this.getFunction(t)), z(this._abiCoder.encode(t.outputs, e || []))
                }
                encodeFilterTopics(t, e) {
                    "string" === typeof t && (t = this.getEvent(t)), e.length > t.inputs.length && zr.throwError("too many arguments for " + t.format(), M.errors.UNEXPECTED_ARGUMENT, {
                        argument: "values",
                        value: e
                    });
                    let r = [];
                    t.anonymous || r.push(this.getEventTopic(t));
                    const n = (t, e) => "string" === t.type ? Cr(e) : "bytes" === t.type ? oe(z(e)) : ("address" === t.type && this._abiCoder.encode(["address"], [e]), U(z(e), 32));
                    e.forEach((e, i) => {
                        let s = t.inputs[i];
                        s.indexed ? null == e ? r.push(null) : "array" === s.baseType || "tuple" === s.baseType ? zr.throwArgumentError("filtering with tuples or arrays not supported", "contract." + s.name, e) : Array.isArray(e) ? r.push(e.map(t => n(s, t))) : r.push(n(s, e)) : null != e && zr.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + s.name, e)
                    });
                    while (r.length && null === r[r.length - 1]) r.pop();
                    return r
                }
                encodeEventLog(t, e) {
                    "string" === typeof t && (t = this.getEvent(t));
                    const r = [],
                        n = [],
                        i = [];
                    return t.anonymous || r.push(this.getEventTopic(t)), e.length !== t.inputs.length && zr.throwArgumentError("event arguments/values mismatch", "values", e), t.inputs.forEach((t, s) => {
                        const a = e[s];
                        if (t.indexed)
                            if ("string" === t.type) r.push(Cr(a));
                            else if ("bytes" === t.type) r.push(oe(a));
                        else {
                            if ("tuple" === t.baseType || "array" === t.baseType) throw new Error("not implemented");
                            r.push(this._abiCoder.encode([t.type], [a]))
                        } else n.push(t), i.push(a)
                    }), {
                        data: this._abiCoder.encode(n, i),
                        topics: r
                    }
                }
                decodeEventLog(t, e, r) {
                    if ("string" === typeof t && (t = this.getEvent(t)), null != r && !t.anonymous) {
                        let e = this.getEventTopic(t);
                        j(r[0], 32) && r[0].toLowerCase() === e || zr.throwError("fragment/topic mismatch", M.errors.INVALID_ARGUMENT, {
                            argument: "topics[0]",
                            expected: e,
                            value: r[0]
                        }), r = r.slice(1)
                    }
                    let n = [],
                        i = [],
                        s = [];
                    t.inputs.forEach((t, e) => {
                        t.indexed ? "string" === t.type || "bytes" === t.type || "tuple" === t.baseType || "array" === t.baseType ? (n.push(pr.fromObject({
                            type: "bytes32",
                            name: t.name
                        })), s.push(!0)) : (n.push(t), s.push(!1)) : (i.push(t), s.push(!1))
                    });
                    let a = null != r ? this._abiCoder.decode(n, P(r)) : null,
                        o = this._abiCoder.decode(i, e, !0),
                        u = [],
                        h = 0,
                        f = 0;
                    t.inputs.forEach((t, e) => {
                        if (t.indexed)
                            if (null == a) u[e] = new Br({
                                _isIndexed: !0,
                                hash: null
                            });
                            else if (s[e]) u[e] = new Br({
                            _isIndexed: !0,
                            hash: a[f++]
                        });
                        else try {
                            u[e] = a[f++]
                        } catch (r) {
                            u[e] = r
                        } else try {
                            u[e] = o[h++]
                        } catch (r) {
                            u[e] = r
                        }
                        if (t.name && null == u[t.name]) {
                            const r = u[e];
                            r instanceof Error ? Object.defineProperty(u, t.name, {
                                enumerable: !0,
                                get: () => {
                                    throw Ur("property " + JSON.stringify(t.name), r)
                                }
                            }) : u[t.name] = r
                        }
                    });
                    for (let c = 0; c < u.length; c++) {
                        const t = u[c];
                        t instanceof Error && Object.defineProperty(u, c, {
                            enumerable: !0,
                            get: () => {
                                throw Ur("index " + c, t)
                            }
                        })
                    }
                    return Object.freeze(u)
                }
                parseTransaction(t) {
                    let e = this.getFunction(t.data.substring(0, 10).toLowerCase());
                    return e ? new Lr({
                        args: this._abiCoder.decode(e.inputs, "0x" + t.data.substring(10)),
                        functionFragment: e,
                        name: e.name,
                        signature: e.format(),
                        sighash: this.getSighash(e),
                        value: Y.from(t.value || "0")
                    }) : null
                }
                parseLog(t) {
                    let e = this.getEvent(t.topics[0]);
                    return !e || e.anonymous ? null : new Dr({
                        eventFragment: e,
                        name: e.name,
                        signature: e.format(),
                        topic: this.getEventTopic(e),
                        args: this.decodeEventLog(e, t.data, t.topics)
                    })
                }
                parseError(t) {
                    const e = z(t);
                    let r = this.getError(e.substring(0, 10).toLowerCase());
                    return r ? new Fr({
                        args: this._abiCoder.decode(r.inputs, "0x" + e.substring(10)),
                        errorFragment: r,
                        name: r.name,
                        signature: r.format(),
                        sighash: this.getSighash(r)
                    }) : null
                }
                static isInterface(t) {
                    return !(!t || !t._isInterface)
                }
            }

            function Kr(t) {
                t = atob(t);
                const e = [];
                for (let r = 0; r < t.length; r++) e.push(t.charCodeAt(r));
                return I(e)
            }

            function Vr(t) {
                t = I(t);
                let e = "";
                for (let r = 0; r < t.length; r++) e += String.fromCharCode(t[r]);
                return btoa(e)
            }
            var Wr = r("2cf2");

            function Zr(t) {
                if (t.length % 4 !== 0) throw new Error("bad data");
                let e = [];
                for (let r = 0; r < t.length; r += 4) e.push(parseInt(t.substring(r, r + 4), 16));
                return e
            }

            function Hr(t, e) {
                e || (e = function(t) {
                    return [parseInt(t, 16)]
                });
                let r = 0,
                    n = {};
                return t.split(",").forEach(t => {
                    let i = t.split(":");
                    r += parseInt(i[0], 16), n[r] = e(i[1])
                }), n
            }

            function Gr(t) {
                let e = 0;
                return t.split(",").map(t => {
                    let r = t.split("-");
                    1 === r.length ? r[1] = "0" : "" === r[1] && (r[1] = "1");
                    let n = e + parseInt(r[0], 16);
                    return e = parseInt(r[1], 16), {
                        l: n,
                        h: e
                    }
                })
            }

            function Jr(t, e) {
                let r = 0;
                for (let n = 0; n < e.length; n++) {
                    let i = e[n];
                    if (r += i.l, t >= r && t <= r + i.h && (t - r) % (i.d || 1) === 0) {
                        if (i.e && -1 !== i.e.indexOf(t - r)) continue;
                        return i
                    }
                }
                return null
            }
            const Xr = Gr("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d"),
                Yr = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map(t => parseInt(t, 16)),
                Qr = [{
                    h: 25,
                    s: 32,
                    l: 65
                }, {
                    h: 30,
                    s: 32,
                    e: [23],
                    l: 127
                }, {
                    h: 54,
                    s: 1,
                    e: [48],
                    l: 64,
                    d: 2
                }, {
                    h: 14,
                    s: 1,
                    l: 57,
                    d: 2
                }, {
                    h: 44,
                    s: 1,
                    l: 17,
                    d: 2
                }, {
                    h: 10,
                    s: 1,
                    e: [2, 6, 8],
                    l: 61,
                    d: 2
                }, {
                    h: 16,
                    s: 1,
                    l: 68,
                    d: 2
                }, {
                    h: 84,
                    s: 1,
                    e: [18, 24, 66],
                    l: 19,
                    d: 2
                }, {
                    h: 26,
                    s: 32,
                    e: [17],
                    l: 435
                }, {
                    h: 22,
                    s: 1,
                    l: 71,
                    d: 2
                }, {
                    h: 15,
                    s: 80,
                    l: 40
                }, {
                    h: 31,
                    s: 32,
                    l: 16
                }, {
                    h: 32,
                    s: 1,
                    l: 80,
                    d: 2
                }, {
                    h: 52,
                    s: 1,
                    l: 42,
                    d: 2
                }, {
                    h: 12,
                    s: 1,
                    l: 55,
                    d: 2
                }, {
                    h: 40,
                    s: 1,
                    e: [38],
                    l: 15,
                    d: 2
                }, {
                    h: 14,
                    s: 1,
                    l: 48,
                    d: 2
                }, {
                    h: 37,
                    s: 48,
                    l: 49
                }, {
                    h: 148,
                    s: 1,
                    l: 6351,
                    d: 2
                }, {
                    h: 88,
                    s: 1,
                    l: 160,
                    d: 2
                }, {
                    h: 15,
                    s: 16,
                    l: 704
                }, {
                    h: 25,
                    s: 26,
                    l: 854
                }, {
                    h: 25,
                    s: 32,
                    l: 55915
                }, {
                    h: 37,
                    s: 40,
                    l: 1247
                }, {
                    h: 25,
                    s: -119711,
                    l: 53248
                }, {
                    h: 25,
                    s: -119763,
                    l: 52
                }, {
                    h: 25,
                    s: -119815,
                    l: 52
                }, {
                    h: 25,
                    s: -119867,
                    e: [1, 4, 5, 7, 8, 11, 12, 17],
                    l: 52
                }, {
                    h: 25,
                    s: -119919,
                    l: 52
                }, {
                    h: 24,
                    s: -119971,
                    e: [2, 7, 8, 17],
                    l: 52
                }, {
                    h: 24,
                    s: -120023,
                    e: [2, 7, 13, 15, 16, 17],
                    l: 52
                }, {
                    h: 25,
                    s: -120075,
                    l: 52
                }, {
                    h: 25,
                    s: -120127,
                    l: 52
                }, {
                    h: 25,
                    s: -120179,
                    l: 52
                }, {
                    h: 25,
                    s: -120231,
                    l: 52
                }, {
                    h: 25,
                    s: -120283,
                    l: 52
                }, {
                    h: 25,
                    s: -120335,
                    l: 52
                }, {
                    h: 24,
                    s: -119543,
                    e: [17],
                    l: 56
                }, {
                    h: 24,
                    s: -119601,
                    e: [17],
                    l: 58
                }, {
                    h: 24,
                    s: -119659,
                    e: [17],
                    l: 58
                }, {
                    h: 24,
                    s: -119717,
                    e: [17],
                    l: 58
                }, {
                    h: 24,
                    s: -119775,
                    e: [17],
                    l: 58
                }],
                tn = Hr("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3"),
                en = Hr("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7"),
                rn = Hr("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", Zr),
                nn = Gr("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");

            function sn(t) {
                return t.reduce((t, e) => (e.forEach(e => {
                    t.push(e)
                }), t), [])
            }

            function an(t) {
                return !!Jr(t, Xr)
            }

            function on(t) {
                let e = Jr(t, Qr);
                if (e) return [t + e.s];
                let r = tn[t];
                if (r) return r;
                let n = en[t];
                if (n) return [t + n[0]];
                let i = rn[t];
                return i || null
            }

            function un(t) {
                return !!Jr(t, nn)
            }

            function hn(t) {
                if (t.match(/^[a-z0-9-]*$/i) && t.length <= 59) return t.toLowerCase();
                let e = rr(t);
                e = sn(e.map(t => {
                    if (Yr.indexOf(t) >= 0) return [];
                    if (t >= 65024 && t <= 65039) return [];
                    let e = on(t);
                    return e || [t]
                })), e = rr(tr(e), Ke.NFKC), e.forEach(t => {
                    if (un(t)) throw new Error("STRINGPREP_CONTAINS_PROHIBITED")
                }), e.forEach(t => {
                    if (an(t)) throw new Error("STRINGPREP_CONTAINS_UNASSIGNED")
                });
                let r = tr(e);
                if ("-" === r.substring(0, 1) || "--" === r.substring(2, 4) || "-" === r.substring(r.length - 1)) throw new Error("invalid hyphen");
                if (r.length > 63) throw new Error("too long");
                return r
            }
            const fn = "hash/5.6.0",
                cn = new M(fn),
                ln = new Uint8Array(32);
            ln.fill(0);
            const dn = new RegExp("^((.*)\\.)?([^.]+)$");

            function pn(t) {
                try {
                    const e = t.split(".");
                    for (let t = 0; t < e.length; t++)
                        if (0 === hn(e[t]).length) throw new Error("empty");
                    return !0
                } catch (e) {}
                return !1
            }

            function mn(t) {
                "string" !== typeof t && cn.throwArgumentError("invalid ENS name; not a string", "name", t);
                let e = t,
                    r = ln;
                while (e.length) {
                    const n = e.match(dn);
                    null != n && "" !== n[2] || cn.throwArgumentError("invalid ENS address; missing component", "name", t);
                    const i = Xe(hn(n[3]));
                    r = oe(P([r, oe(i)])), e = n[2] || ""
                }
                return z(r)
            }

            function bn(t) {
                return z(P(t.split(".").map(t => {
                    const e = Xe("_" + hn(t));
                    return e[0] = e.length - 1, e
                }))) + "00"
            }
            const gn = "Ethereum Signed Message:\n";

            function yn(t) {
                return "string" === typeof t && (t = Xe(t)), oe(P([Xe(gn), Xe(String(t.length)), t]))
            }
            var vn = function(t, e, r, n) {
                function i(t) {
                    return t instanceof r ? t : new r((function(e) {
                        e(t)
                    }))
                }
                return new(r || (r = Promise))((function(r, s) {
                    function a(t) {
                        try {
                            u(n.next(t))
                        } catch (e) {
                            s(e)
                        }
                    }

                    function o(t) {
                        try {
                            u(n["throw"](t))
                        } catch (e) {
                            s(e)
                        }
                    }

                    function u(t) {
                        t.done ? r(t.value) : i(t.value).then(a, o)
                    }
                    u((n = n.apply(t, e || [])).next())
                }))
            };
            const wn = new M(fn),
                _n = new Uint8Array(32);
            _n.fill(0);
            const Mn = Y.from(-1),
                An = Y.from(0),
                Sn = Y.from(1),
                xn = Y.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

            function En(t) {
                const e = I(t),
                    r = e.length % 32;
                return r ? F([e, _n.slice(r)]) : z(e)
            }
            const kn = U(Sn.toHexString(), 32),
                Rn = U(An.toHexString(), 32),
                On = {
                    name: "string",
                    version: "string",
                    chainId: "uint256",
                    verifyingContract: "address",
                    salt: "bytes32"
                },
                In = ["name", "version", "chainId", "verifyingContract", "salt"];

            function Pn(t) {
                return function(e) {
                    return "string" !== typeof e && wn.throwArgumentError("invalid domain value for " + JSON.stringify(t), "domain." + t, e), e
                }
            }
            const Tn = {
                name: Pn("name"),
                version: Pn("version"),
                chainId: function(t) {
                    try {
                        return Y.from(t).toString()
                    } catch (e) {}
                    return wn.throwArgumentError('invalid domain value for "chainId"', "domain.chainId", t)
                },
                verifyingContract: function(t) {
                    try {
                        return xe(t).toLowerCase()
                    } catch (e) {}
                    return wn.throwArgumentError('invalid domain value "verifyingContract"', "domain.verifyingContract", t)
                },
                salt: function(t) {
                    try {
                        const e = I(t);
                        if (32 !== e.length) throw new Error("bad length");
                        return z(e)
                    } catch (e) {}
                    return wn.throwArgumentError('invalid domain value "salt"', "domain.salt", t)
                }
            };

            function Nn(t) {
                {
                    const e = t.match(/^(u?)int(\d*)$/);
                    if (e) {
                        const r = "" === e[1],
                            n = parseInt(e[2] || "256");
                        (n % 8 !== 0 || n > 256 || e[2] && e[2] !== String(n)) && wn.throwArgumentError("invalid numeric width", "type", t);
                        const i = xn.mask(r ? n - 1 : n),
                            s = r ? i.add(Sn).mul(Mn) : An;
                        return function(e) {
                            const r = Y.from(e);
                            return (r.lt(s) || r.gt(i)) && wn.throwArgumentError("value out-of-bounds for " + t, "value", e), U(r.toTwos(256).toHexString(), 32)
                        }
                    }
                } {
                    const e = t.match(/^bytes(\d+)$/);
                    if (e) {
                        const r = parseInt(e[1]);
                        return (0 === r || r > 32 || e[1] !== String(r)) && wn.throwArgumentError("invalid bytes width", "type", t),
                            function(e) {
                                const n = I(e);
                                return n.length !== r && wn.throwArgumentError("invalid length for " + t, "value", e), En(e)
                            }
                    }
                }
                switch (t) {
                    case "address":
                        return function(t) {
                            return U(xe(t), 32)
                        };
                    case "bool":
                        return function(t) {
                            return t ? kn : Rn
                        };
                    case "bytes":
                        return function(t) {
                            return oe(t)
                        };
                    case "string":
                        return function(t) {
                            return Cr(t)
                        }
                }
                return null
            }

            function jn(t, e) {
                return `${t}(${e.map(({name:t,type:e})=>e+" "+t).join(",")})`
            }
            class Cn {
                constructor(t) {
                    _t(this, "types", Object.freeze(Ot(t))), _t(this, "_encoderCache", {}), _t(this, "_types", {});
                    const e = {},
                        r = {},
                        n = {};
                    Object.keys(t).forEach(t => {
                        e[t] = {}, r[t] = [], n[t] = {}
                    });
                    for (const a in t) {
                        const n = {};
                        t[a].forEach(i => {
                            n[i.name] && wn.throwArgumentError(`duplicate variable name ${JSON.stringify(i.name)} in ${JSON.stringify(a)}`, "types", t), n[i.name] = !0;
                            const s = i.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
                            s === a && wn.throwArgumentError("circular type reference to " + JSON.stringify(s), "types", t);
                            const o = Nn(s);
                            o || (r[s] || wn.throwArgumentError("unknown type " + JSON.stringify(s), "types", t), r[s].push(a), e[a][s] = !0)
                        })
                    }
                    const i = Object.keys(r).filter(t => 0 === r[t].length);

                    function s(i, a) {
                        a[i] && wn.throwArgumentError("circular type reference to " + JSON.stringify(i), "types", t), a[i] = !0, Object.keys(e[i]).forEach(t => {
                            r[t] && (s(t, a), Object.keys(a).forEach(e => {
                                n[e][t] = !0
                            }))
                        }), delete a[i]
                    }
                    0 === i.length ? wn.throwArgumentError("missing primary type", "types", t) : i.length > 1 && wn.throwArgumentError("ambiguous primary types or unused types: " + i.map(t => JSON.stringify(t)).join(", "), "types", t), _t(this, "primaryType", i[0]), s(this.primaryType, {});
                    for (const a in n) {
                        const e = Object.keys(n[a]);
                        e.sort(), this._types[a] = jn(a, t[a]) + e.map(e => jn(e, t[e])).join("")
                    }
                }
                getEncoder(t) {
                    let e = this._encoderCache[t];
                    return e || (e = this._encoderCache[t] = this._getEncoder(t)), e
                }
                _getEncoder(t) {
                    {
                        const e = Nn(t);
                        if (e) return e
                    }
                    const e = t.match(/^(.*)(\x5b(\d*)\x5d)$/);
                    if (e) {
                        const t = e[1],
                            r = this.getEncoder(t),
                            n = parseInt(e[3]);
                        return e => {
                            n >= 0 && e.length !== n && wn.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", e);
                            let i = e.map(r);
                            return this._types[t] && (i = i.map(oe)), oe(F(i))
                        }
                    }
                    const r = this.types[t];
                    if (r) {
                        const e = Cr(this._types[t]);
                        return t => {
                            const n = r.map(({
                                name: e,
                                type: r
                            }) => {
                                const n = this.getEncoder(r)(t[e]);
                                return this._types[r] ? oe(n) : n
                            });
                            return n.unshift(e), F(n)
                        }
                    }
                    return wn.throwArgumentError("unknown type: " + t, "type", t)
                }
                encodeType(t) {
                    const e = this._types[t];
                    return e || wn.throwArgumentError("unknown type: " + JSON.stringify(t), "name", t), e
                }
                encodeData(t, e) {
                    return this.getEncoder(t)(e)
                }
                hashStruct(t, e) {
                    return oe(this.encodeData(t, e))
                }
                encode(t) {
                    return this.encodeData(this.primaryType, t)
                }
                hash(t) {
                    return this.hashStruct(this.primaryType, t)
                }
                _visit(t, e, r) {
                    {
                        const n = Nn(t);
                        if (n) return r(t, e)
                    }
                    const n = t.match(/^(.*)(\x5b(\d*)\x5d)$/);
                    if (n) {
                        const t = n[1],
                            i = parseInt(n[3]);
                        return i >= 0 && e.length !== i && wn.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", e), e.map(e => this._visit(t, e, r))
                    }
                    const i = this.types[t];
                    return i ? i.reduce((t, {
                        name: n,
                        type: i
                    }) => (t[n] = this._visit(i, e[n], r), t), {}) : wn.throwArgumentError("unknown type: " + t, "type", t)
                }
                visit(t, e) {
                    return this._visit(this.primaryType, t, e)
                }
                static from(t) {
                    return new Cn(t)
                }
                static getPrimaryType(t) {
                    return Cn.from(t).primaryType
                }
                static hashStruct(t, e, r) {
                    return Cn.from(e).hashStruct(t, r)
                }
                static hashDomain(t) {
                    const e = [];
                    for (const r in t) {
                        const n = On[r];
                        n || wn.throwArgumentError("invalid typed-data domain key: " + JSON.stringify(r), "domain", t), e.push({
                            name: r,
                            type: n
                        })
                    }
                    return e.sort((t, e) => In.indexOf(t.name) - In.indexOf(e.name)), Cn.hashStruct("EIP712Domain", {
                        EIP712Domain: e
                    }, t)
                }
                static encode(t, e, r) {
                    return F(["0x1901", Cn.hashDomain(t), Cn.from(e).hash(r)])
                }
                static hash(t, e, r) {
                    return oe(Cn.encode(t, e, r))
                }
                static resolveNames(t, e, r, n) {
                    return vn(this, void 0, void 0, (function*() {
                        t = xt(t);
                        const i = {};
                        t.verifyingContract && !j(t.verifyingContract, 20) && (i[t.verifyingContract] = "0x");
                        const s = Cn.from(e);
                        s.visit(r, (t, e) => ("address" !== t || j(e, 20) || (i[e] = "0x"), e));
                        for (const t in i) i[t] = yield n(t);
                        return t.verifyingContract && i[t.verifyingContract] && (t.verifyingContract = i[t.verifyingContract]), r = s.visit(r, (t, e) => "address" === t && i[e] ? i[e] : e), {
                            domain: t,
                            value: r
                        }
                    }))
                }
                static getPayload(t, e, r) {
                    Cn.hashDomain(t);
                    const n = {},
                        i = [];
                    In.forEach(e => {
                        const r = t[e];
                        null != r && (n[e] = Tn[e](r), i.push({
                            name: e,
                            type: On[e]
                        }))
                    });
                    const s = Cn.from(e),
                        a = xt(e);
                    return a.EIP712Domain ? wn.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", e) : a.EIP712Domain = i, s.encode(r), {
                        types: a,
                        domain: n,
                        primaryType: s.primaryType,
                        message: s.visit(r, (t, e) => {
                            if (t.match(/^bytes(\d*)/)) return z(I(e));
                            if (t.match(/^u?int/)) return Y.from(e).toString();
                            switch (t) {
                                case "address":
                                    return e.toLowerCase();
                                case "bool":
                                    return !!e;
                                case "string":
                                    return "string" !== typeof e && wn.throwArgumentError("invalid string", "value", e), e
                            }
                            return wn.throwArgumentError("unsupported type", "type", t)
                        })
                    }
                }
            }
            var zn = r("f002"),
                Dn = r("6b5b"),
                Ln = r("3796"),
                Fn = r("ed62"),
                Bn = r("6e45"),
                $n = r("5553"),
                Un = r("0e4c");
            const qn = "signing-key/5.6.0",
                Kn = new M(qn);
            let Vn = null;

            function Wn() {
                return Vn || (Vn = new Un["a"]("secp256k1")), Vn
            }
            class Zn {
                constructor(t) {
                    _t(this, "curve", "secp256k1"), _t(this, "privateKey", z(t));
                    const e = Wn().keyFromPrivate(I(this.privateKey));
                    _t(this, "publicKey", "0x" + e.getPublic(!1, "hex")), _t(this, "compressedPublicKey", "0x" + e.getPublic(!0, "hex")), _t(this, "_isSigningKey", !0)
                }
                _addPoint(t) {
                    const e = Wn().keyFromPublic(I(this.publicKey)),
                        r = Wn().keyFromPublic(I(t));
                    return "0x" + e.pub.add(r.pub).encodeCompressed("hex")
                }
                signDigest(t) {
                    const e = Wn().keyFromPrivate(I(this.privateKey)),
                        r = I(t);
                    32 !== r.length && Kn.throwArgumentError("bad digest length", "digest", t);
                    const n = e.sign(r, {
                        canonical: !0
                    });
                    return q({
                        recoveryParam: n.recoveryParam,
                        r: U("0x" + n.r.toString(16), 32),
                        s: U("0x" + n.s.toString(16), 32)
                    })
                }
                computeSharedSecret(t) {
                    const e = Wn().keyFromPrivate(I(this.privateKey)),
                        r = Wn().keyFromPublic(I(Gn(t)));
                    return U("0x" + e.derive(r.getPublic()).toString(16), 32)
                }
                static isSigningKey(t) {
                    return !(!t || !t._isSigningKey)
                }
            }

            function Hn(t, e) {
                const r = q(e),
                    n = {
                        r: I(r.r),
                        s: I(r.s)
                    };
                return "0x" + Wn().recoverPubKey(I(t), n, r.recoveryParam).encode("hex", !1)
            }

            function Gn(t, e) {
                const r = I(t);
                if (32 === r.length) {
                    const t = new Zn(r);
                    return e ? "0x" + Wn().keyFromPrivate(r).getPublic(!0, "hex") : t.publicKey
                }
                return 33 === r.length ? e ? z(r) : "0x" + Wn().keyFromPublic(r).getPublic(!1, "hex") : 65 === r.length ? e ? "0x" + Wn().keyFromPublic(r).getPublic(!0, "hex") : z(r) : Kn.throwArgumentError("invalid public or private key", "key", "[REDACTED]")
            }

            function Jn(t) {
                const e = Xe(t);
                if (e.length > 31) throw new Error("bytes32 string must be less than 32 bytes");
                return z(P([e, Ht]).slice(0, 32))
            }

            function Xn(t) {
                const e = I(t);
                if (32 !== e.length) throw new Error("invalid bytes32 - not 32 bytes long");
                if (0 !== e[31]) throw new Error("invalid bytes32 string - no null terminator");
                let r = 31;
                while (0 === e[r - 1]) r--;
                return er(e.slice(0, r))
            }
            const Yn = "transactions/5.6.0",
                Qn = new M(Yn);
            var ti;

            function ei(t) {
                return "0x" === t ? null : xe(t)
            }

            function ri(t) {
                return "0x" === t ? $t : Y.from(t)
            }(function(t) {
                t[t["legacy"] = 0] = "legacy", t[t["eip2930"] = 1] = "eip2930", t[t["eip1559"] = 2] = "eip1559"
            })(ti || (ti = {}));
            const ni = [{
                    name: "nonce",
                    maxLength: 32,
                    numeric: !0
                }, {
                    name: "gasPrice",
                    maxLength: 32,
                    numeric: !0
                }, {
                    name: "gasLimit",
                    maxLength: 32,
                    numeric: !0
                }, {
                    name: "to",
                    length: 20
                }, {
                    name: "value",
                    maxLength: 32,
                    numeric: !0
                }, {
                    name: "data"
                }],
                ii = {
                    chainId: !0,
                    data: !0,
                    gasLimit: !0,
                    gasPrice: !0,
                    nonce: !0,
                    to: !0,
                    type: !0,
                    value: !0
                };

            function si(t) {
                const e = Gn(t);
                return xe(L(oe(L(e, 1)), 12))
            }

            function ai(t, e) {
                return si(Hn(I(t), e))
            }

            function oi(t, e) {
                const r = T(Y.from(t).toHexString());
                return r.length > 32 && Qn.throwArgumentError("invalid length for " + e, "transaction:" + e, t), r
            }

            function ui(t, e) {
                return {
                    address: xe(t),
                    storageKeys: (e || []).map((e, r) => (32 !== D(e) && Qn.throwArgumentError("invalid access list storageKey", `accessList[${t}:${r}]`, e), e.toLowerCase()))
                }
            }

            function hi(t) {
                if (Array.isArray(t)) return t.map((t, e) => Array.isArray(t) ? (t.length > 2 && Qn.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${e}]`, t), ui(t[0], t[1])) : ui(t.address, t.storageKeys));
                const e = Object.keys(t).map(e => {
                    const r = t[e].reduce((t, e) => (t[e] = !0, t), {});
                    return ui(e, Object.keys(r).sort())
                });
                return e.sort((t, e) => t.address.localeCompare(e.address)), e
            }

            function fi(t) {
                return hi(t).map(t => [t.address, t.storageKeys])
            }

            function ci(t, e) {
                if (null != t.gasPrice) {
                    const e = Y.from(t.gasPrice),
                        r = Y.from(t.maxFeePerGas || 0);
                    e.eq(r) || Qn.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
                        gasPrice: e,
                        maxFeePerGas: r
                    })
                }
                const r = [oi(t.chainId || 0, "chainId"), oi(t.nonce || 0, "nonce"), oi(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), oi(t.maxFeePerGas || 0, "maxFeePerGas"), oi(t.gasLimit || 0, "gasLimit"), null != t.to ? xe(t.to) : "0x", oi(t.value || 0, "value"), t.data || "0x", fi(t.accessList || [])];
                if (e) {
                    const t = q(e);
                    r.push(oi(t.recoveryParam, "recoveryParam")), r.push(T(t.r)), r.push(T(t.s))
                }
                return F(["0x02", de(r)])
            }

            function li(t, e) {
                const r = [oi(t.chainId || 0, "chainId"), oi(t.nonce || 0, "nonce"), oi(t.gasPrice || 0, "gasPrice"), oi(t.gasLimit || 0, "gasLimit"), null != t.to ? xe(t.to) : "0x", oi(t.value || 0, "value"), t.data || "0x", fi(t.accessList || [])];
                if (e) {
                    const t = q(e);
                    r.push(oi(t.recoveryParam, "recoveryParam")), r.push(T(t.r)), r.push(T(t.s))
                }
                return F(["0x01", de(r)])
            }

            function di(t, e) {
                St(t, ii);
                const r = [];
                ni.forEach((function(e) {
                    let n = t[e.name] || [];
                    const i = {};
                    e.numeric && (i.hexPad = "left"), n = I(z(n, i)), e.length && n.length !== e.length && n.length > 0 && Qn.throwArgumentError("invalid length for " + e.name, "transaction:" + e.name, n), e.maxLength && (n = T(n), n.length > e.maxLength && Qn.throwArgumentError("invalid length for " + e.name, "transaction:" + e.name, n)), r.push(z(n))
                }));
                let n = 0;
                if (null != t.chainId ? (n = t.chainId, "number" !== typeof n && Qn.throwArgumentError("invalid transaction.chainId", "transaction", t)) : e && !k(e) && e.v > 28 && (n = Math.floor((e.v - 35) / 2)), 0 !== n && (r.push(z(n)), r.push("0x"), r.push("0x")), !e) return de(r);
                const i = q(e);
                let s = 27 + i.recoveryParam;
                return 0 !== n ? (r.pop(), r.pop(), r.pop(), s += 2 * n + 8, i.v > 28 && i.v !== s && Qn.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", e)) : i.v !== s && Qn.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", e), r.push(z(s)), r.push(T(I(i.r))), r.push(T(I(i.s))), de(r)
            }

            function pi(t, e) {
                if (null == t.type || 0 === t.type) return null != t.accessList && Qn.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", t), di(t, e);
                switch (t.type) {
                    case 1:
                        return li(t, e);
                    case 2:
                        return ci(t, e);
                    default:
                        break
                }
                return Qn.throwError("unsupported transaction type: " + t.type, M.errors.UNSUPPORTED_OPERATION, {
                    operation: "serializeTransaction",
                    transactionType: t.type
                })
            }

            function mi(t, e, r) {
                try {
                    const r = ri(e[0]).toNumber();
                    if (0 !== r && 1 !== r) throw new Error("bad recid");
                    t.v = r
                } catch (n) {
                    Qn.throwArgumentError("invalid v for transaction type: 1", "v", e[0])
                }
                t.r = U(e[1], 32), t.s = U(e[2], 32);
                try {
                    const e = oe(r(t));
                    t.from = ai(e, {
                        r: t.r,
                        s: t.s,
                        recoveryParam: t.v
                    })
                } catch (n) {
                    console.log(n)
                }
            }

            function bi(t) {
                const e = be(t.slice(1));
                9 !== e.length && 12 !== e.length && Qn.throwArgumentError("invalid component count for transaction type: 2", "payload", z(t));
                const r = ri(e[2]),
                    n = ri(e[3]),
                    i = {
                        type: 2,
                        chainId: ri(e[0]).toNumber(),
                        nonce: ri(e[1]).toNumber(),
                        maxPriorityFeePerGas: r,
                        maxFeePerGas: n,
                        gasPrice: null,
                        gasLimit: ri(e[4]),
                        to: ei(e[5]),
                        value: ri(e[6]),
                        data: e[7],
                        accessList: hi(e[8])
                    };
                return 9 === e.length || (i.hash = oe(t), mi(i, e.slice(9), ci)), i
            }

            function gi(t) {
                const e = be(t.slice(1));
                8 !== e.length && 11 !== e.length && Qn.throwArgumentError("invalid component count for transaction type: 1", "payload", z(t));
                const r = {
                    type: 1,
                    chainId: ri(e[0]).toNumber(),
                    nonce: ri(e[1]).toNumber(),
                    gasPrice: ri(e[2]),
                    gasLimit: ri(e[3]),
                    to: ei(e[4]),
                    value: ri(e[5]),
                    data: e[6],
                    accessList: hi(e[7])
                };
                return 8 === e.length || (r.hash = oe(t), mi(r, e.slice(8), li)), r
            }

            function yi(t) {
                const e = be(t);
                9 !== e.length && 6 !== e.length && Qn.throwArgumentError("invalid raw transaction", "rawTransaction", t);
                const r = {
                    nonce: ri(e[0]).toNumber(),
                    gasPrice: ri(e[1]),
                    gasLimit: ri(e[2]),
                    to: ei(e[3]),
                    value: ri(e[4]),
                    data: e[5],
                    chainId: 0
                };
                if (6 === e.length) return r;
                try {
                    r.v = Y.from(e[6]).toNumber()
                } catch (n) {
                    return console.log(n), r
                }
                if (r.r = U(e[7], 32), r.s = U(e[8], 32), Y.from(r.r).isZero() && Y.from(r.s).isZero()) r.chainId = r.v, r.v = 0;
                else {
                    r.chainId = Math.floor((r.v - 35) / 2), r.chainId < 0 && (r.chainId = 0);
                    let i = r.v - 27;
                    const s = e.slice(0, 6);
                    0 !== r.chainId && (s.push(z(r.chainId)), s.push("0x"), s.push("0x"), i -= 2 * r.chainId + 8);
                    const a = oe(de(s));
                    try {
                        r.from = ai(a, {
                            r: z(r.r),
                            s: z(r.s),
                            recoveryParam: i
                        })
                    } catch (n) {
                        console.log(n)
                    }
                    r.hash = oe(t)
                }
                return r.type = null, r
            }

            function vi(t) {
                const e = I(t);
                if (e[0] > 127) return yi(e);
                switch (e[0]) {
                    case 1:
                        return gi(e);
                    case 2:
                        return bi(e);
                    default:
                        break
                }
                return Qn.throwError("unsupported transaction type: " + e[0], M.errors.UNSUPPORTED_OPERATION, {
                    operation: "parseTransaction",
                    transactionType: e[0]
                })
            }
            var wi = r("7149");
            const _i = "web/5.6.0";
            var Mi = function(t, e, r, n) {
                function i(t) {
                    return t instanceof r ? t : new r((function(e) {
                        e(t)
                    }))
                }
                return new(r || (r = Promise))((function(r, s) {
                    function a(t) {
                        try {
                            u(n.next(t))
                        } catch (e) {
                            s(e)
                        }
                    }

                    function o(t) {
                        try {
                            u(n["throw"](t))
                        } catch (e) {
                            s(e)
                        }
                    }

                    function u(t) {
                        t.done ? r(t.value) : i(t.value).then(a, o)
                    }
                    u((n = n.apply(t, e || [])).next())
                }))
            };

            function Ai(t, e) {
                return Mi(this, void 0, void 0, (function*() {
                    null == e && (e = {});
                    const r = {
                        method: e.method || "GET",
                        headers: e.headers || {},
                        body: e.body || void 0
                    };
                    !0 !== e.skipFetchSetup && (r.mode = "cors", r.cache = "no-cache", r.credentials = "same-origin", r.redirect = "follow", r.referrer = "client");
                    const n = yield fetch(t, r), i = yield n.arrayBuffer(), s = {};
                    return n.headers.forEach ? n.headers.forEach((t, e) => {
                        s[e.toLowerCase()] = t
                    }) : n.headers.keys().forEach(t => {
                        s[t.toLowerCase()] = n.headers.get(t)
                    }), {
                        headers: s,
                        statusCode: n.status,
                        statusMessage: n.statusText,
                        body: I(new Uint8Array(i))
                    }
                }))
            }
            var Si = function(t, e, r, n) {
                function i(t) {
                    return t instanceof r ? t : new r((function(e) {
                        e(t)
                    }))
                }
                return new(r || (r = Promise))((function(r, s) {
                    function a(t) {
                        try {
                            u(n.next(t))
                        } catch (e) {
                            s(e)
                        }
                    }

                    function o(t) {
                        try {
                            u(n["throw"](t))
                        } catch (e) {
                            s(e)
                        }
                    }

                    function u(t) {
                        t.done ? r(t.value) : i(t.value).then(a, o)
                    }
                    u((n = n.apply(t, e || [])).next())
                }))
            };
            const xi = new M(_i);

            function Ei(t) {
                return new Promise(e => {
                    setTimeout(e, t)
                })
            }

            function ki(t, e) {
                if (null == t) return null;
                if ("string" === typeof t) return t;
                if (k(t)) {
                    if (e && ("text" === e.split("/")[0] || "application/json" === e.split(";")[0].trim())) try {
                        return er(t)
                    } catch (r) {}
                    return z(t)
                }
                return t
            }

            function Ri(t, e, r) {
                const n = "object" === typeof t && null != t.throttleLimit ? t.throttleLimit : 12;
                xi.assertArgument(n > 0 && n % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", n);
                const i = "object" === typeof t ? t.throttleCallback : null,
                    s = "object" === typeof t && "number" === typeof t.throttleSlotInterval ? t.throttleSlotInterval : 100;
                xi.assertArgument(s > 0 && s % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", s);
                const a = "object" === typeof t && !!t.errorPassThrough,
                    o = {};
                let u = null;
                const h = {
                    method: "GET"
                };
                let f = !1,
                    c = 12e4;
                if ("string" === typeof t) u = t;
                else if ("object" === typeof t) {
                    if (null != t && null != t.url || xi.throwArgumentError("missing URL", "connection.url", t), u = t.url, "number" === typeof t.timeout && t.timeout > 0 && (c = t.timeout), t.headers)
                        for (const e in t.headers) o[e.toLowerCase()] = {
                            key: e,
                            value: String(t.headers[e])
                        }, ["if-none-match", "if-modified-since"].indexOf(e.toLowerCase()) >= 0 && (f = !0);
                    if (h.allowGzip = !!t.allowGzip, null != t.user && null != t.password) {
                        "https:" !== u.substring(0, 6) && !0 !== t.allowInsecureAuthentication && xi.throwError("basic authentication requires a secure https url", M.errors.INVALID_ARGUMENT, {
                            argument: "url",
                            url: u,
                            user: t.user,
                            password: "[REDACTED]"
                        });
                        const e = t.user + ":" + t.password;
                        o["authorization"] = {
                            key: "Authorization",
                            value: "Basic " + Vr(Xe(e))
                        }
                    }
                    null != t.skipFetchSetup && (h.skipFetchSetup = !!t.skipFetchSetup)
                }
                const l = new RegExp("^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$", "i"),
                    d = u ? u.match(l) : null;
                if (d) try {
                    const t = {
                        statusCode: 200,
                        statusMessage: "OK",
                        headers: {
                            "content-type": d[1]
                        },
                        body: Kr(d[2])
                    };
                    let e = t.body;
                    return r && (e = r(t.body, t)), Promise.resolve(e)
                } catch (g) {
                    xi.throwError("processing response error", M.errors.SERVER_ERROR, {
                        body: ki(d[1], d[2]),
                        error: g,
                        requestBody: null,
                        requestMethod: "GET",
                        url: u
                    })
                }
                e && (h.method = "POST", h.body = e, null == o["content-type"] && (o["content-type"] = {
                    key: "Content-Type",
                    value: "application/octet-stream"
                }), null == o["content-length"] && (o["content-length"] = {
                    key: "Content-Length",
                    value: String(e.length)
                }));
                const p = {};
                Object.keys(o).forEach(t => {
                    const e = o[t];
                    p[e.key] = e.value
                }), h.headers = p;
                const m = function() {
                        let t = null;
                        const e = new Promise((function(e, r) {
                                c && (t = setTimeout(() => {
                                    null != t && (t = null, r(xi.makeError("timeout", M.errors.TIMEOUT, {
                                        requestBody: ki(h.body, p["content-type"]),
                                        requestMethod: h.method,
                                        timeout: c,
                                        url: u
                                    })))
                                }, c))
                            })),
                            r = function() {
                                null != t && (clearTimeout(t), t = null)
                            };
                        return {
                            promise: e,
                            cancel: r
                        }
                    }(),
                    b = function() {
                        return Si(this, void 0, void 0, (function*() {
                            for (let t = 0; t < n; t++) {
                                let e = null;
                                try {
                                    if (e = yield Ai(u, h), t < n)
                                        if (301 === e.statusCode || 302 === e.statusCode) {
                                            const t = e.headers.location || "";
                                            if ("GET" === h.method && t.match(/^https:/)) {
                                                u = e.headers.location;
                                                continue
                                            }
                                        } else if (429 === e.statusCode) {
                                        let r = !0;
                                        if (i && (r = yield i(t, u)), r) {
                                            let r = 0;
                                            const n = e.headers["retry-after"];
                                            r = "string" === typeof n && n.match(/^[1-9][0-9]*$/) ? 1e3 * parseInt(n) : s * parseInt(String(Math.random() * Math.pow(2, t))), yield Ei(r);
                                            continue
                                        }
                                    }
                                } catch (g) {
                                    e = g.response, null == e && (m.cancel(), xi.throwError("missing response", M.errors.SERVER_ERROR, {
                                        requestBody: ki(h.body, p["content-type"]),
                                        requestMethod: h.method,
                                        serverError: g,
                                        url: u
                                    }))
                                }
                                let o = e.body;
                                if (f && 304 === e.statusCode ? o = null : !a && (e.statusCode < 200 || e.statusCode >= 300) && (m.cancel(), xi.throwError("bad response", M.errors.SERVER_ERROR, {
                                        status: e.statusCode,
                                        headers: e.headers,
                                        body: ki(o, e.headers ? e.headers["content-type"] : null),
                                        requestBody: ki(h.body, p["content-type"]),
                                        requestMethod: h.method,
                                        url: u
                                    })), r) try {
                                    const t = yield r(o, e);
                                    return m.cancel(), t
                                } catch (g) {
                                    if (g.throttleRetry && t < n) {
                                        let e = !0;
                                        if (i && (e = yield i(t, u)), e) {
                                            const e = s * parseInt(String(Math.random() * Math.pow(2, t)));
                                            yield Ei(e);
                                            continue
                                        }
                                    }
                                    m.cancel(), xi.throwError("processing response error", M.errors.SERVER_ERROR, {
                                        body: ki(o, e.headers ? e.headers["content-type"] : null),
                                        error: g,
                                        requestBody: ki(h.body, p["content-type"]),
                                        requestMethod: h.method,
                                        url: u
                                    })
                                }
                                return m.cancel(), o
                            }
                            return xi.throwError("failed response", M.errors.SERVER_ERROR, {
                                requestBody: ki(h.body, p["content-type"]),
                                requestMethod: h.method,
                                url: u
                            })
                        }))
                    }();
                return Promise.race([m.promise, b])
            }

            function Oi(t, e, r) {
                let n = (t, e) => {
                        let n = null;
                        if (null != t) try {
                            n = JSON.parse(er(t))
                        } catch (i) {
                            xi.throwError("invalid JSON", M.errors.SERVER_ERROR, {
                                body: t,
                                error: i
                            })
                        }
                        return r && (n = r(n, e)), n
                    },
                    i = null;
                if (null != e) {
                    i = Xe(e);
                    const r = "string" === typeof t ? {
                        url: t
                    } : xt(t);
                    if (r.headers) {
                        const t = 0 !== Object.keys(r.headers).filter(t => "content-type" === t.toLowerCase()).length;
                        t || (r.headers = xt(r.headers), r.headers["content-type"] = "application/json")
                    } else r.headers = {
                        "content-type": "application/json"
                    };
                    t = r
                }
                return Ri(t, i, n)
            }

            function Ii(t, e) {
                return e || (e = {}), e = xt(e), null == e.floor && (e.floor = 0), null == e.ceiling && (e.ceiling = 1e4), null == e.interval && (e.interval = 250), new Promise((function(r, n) {
                    let i = null,
                        s = !1;
                    const a = () => !s && (s = !0, i && clearTimeout(i), !0);
                    e.timeout && (i = setTimeout(() => {
                        a() && n(new Error("timeout"))
                    }, e.timeout));
                    const o = e.retryLimit;
                    let u = 0;

                    function h() {
                        return t().then((function(t) {
                            if (void 0 !== t) a() && r(t);
                            else if (e.oncePoll) e.oncePoll.once("poll", h);
                            else if (e.onceBlock) e.onceBlock.once("block", h);
                            else if (!s) {
                                if (u++, u > o) return void(a() && n(new Error("retry limit reached")));
                                let t = e.interval * parseInt(String(Math.random() * Math.pow(2, u)));
                                t < e.floor && (t = e.floor), t > e.ceiling && (t = e.ceiling), setTimeout(h, t)
                            }
                            return null
                        }), (function(t) {
                            a() && n(t)
                        }))
                    }
                    h()
                }))
            }
            var Pi = r("d457");
            const Ti = "ethers/5.6.4",
                Ni = new M(Ti);
            try {
                const t = window;
                null == t._ethers && (t._ethers = o)
            } catch (ji) {}
        },
        c24d: function(t) {
            t.exports = JSON.parse('{"modp1":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"},"modp2":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"},"modp5":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"},"modp14":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"},"modp15":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"},"modp16":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"},"modp17":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"},"modp18":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"}}')
        },
        c3c0: function(t, e, r) {
            "use strict";
            var n = r("da3e"),
                i = r("3fb5");

            function s(t, e) {
                return 55296 === (64512 & t.charCodeAt(e)) && (!(e < 0 || e + 1 >= t.length) && 56320 === (64512 & t.charCodeAt(e + 1)))
            }

            function a(t, e) {
                if (Array.isArray(t)) return t.slice();
                if (!t) return [];
                var r = [];
                if ("string" === typeof t)
                    if (e) {
                        if ("hex" === e)
                            for (t = t.replace(/[^a-z0-9]+/gi, ""), t.length % 2 !== 0 && (t = "0" + t), i = 0; i < t.length; i += 2) r.push(parseInt(t[i] + t[i + 1], 16))
                    } else
                        for (var n = 0, i = 0; i < t.length; i++) {
                            var a = t.charCodeAt(i);
                            a < 128 ? r[n++] = a : a < 2048 ? (r[n++] = a >> 6 | 192, r[n++] = 63 & a | 128) : s(t, i) ? (a = 65536 + ((1023 & a) << 10) + (1023 & t.charCodeAt(++i)), r[n++] = a >> 18 | 240, r[n++] = a >> 12 & 63 | 128, r[n++] = a >> 6 & 63 | 128, r[n++] = 63 & a | 128) : (r[n++] = a >> 12 | 224, r[n++] = a >> 6 & 63 | 128, r[n++] = 63 & a | 128)
                        } else
                            for (i = 0; i < t.length; i++) r[i] = 0 | t[i];
                return r
            }

            function o(t) {
                for (var e = "", r = 0; r < t.length; r++) e += f(t[r].toString(16));
                return e
            }

            function u(t) {
                var e = t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (255 & t) << 24;
                return e >>> 0
            }

            function h(t, e) {
                for (var r = "", n = 0; n < t.length; n++) {
                    var i = t[n];
                    "little" === e && (i = u(i)), r += c(i.toString(16))
                }
                return r
            }

            function f(t) {
                return 1 === t.length ? "0" + t : t
            }

            function c(t) {
                return 7 === t.length ? "0" + t : 6 === t.length ? "00" + t : 5 === t.length ? "000" + t : 4 === t.length ? "0000" + t : 3 === t.length ? "00000" + t : 2 === t.length ? "000000" + t : 1 === t.length ? "0000000" + t : t
            }

            function l(t, e, r, i) {
                var s = r - e;
                n(s % 4 === 0);
                for (var a = new Array(s / 4), o = 0, u = e; o < a.length; o++, u += 4) {
                    var h;
                    h = "big" === i ? t[u] << 24 | t[u + 1] << 16 | t[u + 2] << 8 | t[u + 3] : t[u + 3] << 24 | t[u + 2] << 16 | t[u + 1] << 8 | t[u], a[o] = h >>> 0
                }
                return a
            }

            function d(t, e) {
                for (var r = new Array(4 * t.length), n = 0, i = 0; n < t.length; n++, i += 4) {
                    var s = t[n];
                    "big" === e ? (r[i] = s >>> 24, r[i + 1] = s >>> 16 & 255, r[i + 2] = s >>> 8 & 255, r[i + 3] = 255 & s) : (r[i + 3] = s >>> 24, r[i + 2] = s >>> 16 & 255, r[i + 1] = s >>> 8 & 255, r[i] = 255 & s)
                }
                return r
            }

            function p(t, e) {
                return t >>> e | t << 32 - e
            }

            function m(t, e) {
                return t << e | t >>> 32 - e
            }

            function b(t, e) {
                return t + e >>> 0
            }

            function g(t, e, r) {
                return t + e + r >>> 0
            }

            function y(t, e, r, n) {
                return t + e + r + n >>> 0
            }

            function v(t, e, r, n, i) {
                return t + e + r + n + i >>> 0
            }

            function w(t, e, r, n) {
                var i = t[e],
                    s = t[e + 1],
                    a = n + s >>> 0,
                    o = (a < n ? 1 : 0) + r + i;
                t[e] = o >>> 0, t[e + 1] = a
            }

            function _(t, e, r, n) {
                var i = e + n >>> 0,
                    s = (i < e ? 1 : 0) + t + r;
                return s >>> 0
            }

            function M(t, e, r, n) {
                var i = e + n;
                return i >>> 0
            }

            function A(t, e, r, n, i, s, a, o) {
                var u = 0,
                    h = e;
                h = h + n >>> 0, u += h < e ? 1 : 0, h = h + s >>> 0, u += h < s ? 1 : 0, h = h + o >>> 0, u += h < o ? 1 : 0;
                var f = t + r + i + a + u;
                return f >>> 0
            }

            function S(t, e, r, n, i, s, a, o) {
                var u = e + n + s + o;
                return u >>> 0
            }

            function x(t, e, r, n, i, s, a, o, u, h) {
                var f = 0,
                    c = e;
                c = c + n >>> 0, f += c < e ? 1 : 0, c = c + s >>> 0, f += c < s ? 1 : 0, c = c + o >>> 0, f += c < o ? 1 : 0, c = c + h >>> 0, f += c < h ? 1 : 0;
                var l = t + r + i + a + u + f;
                return l >>> 0
            }

            function E(t, e, r, n, i, s, a, o, u, h) {
                var f = e + n + s + o + h;
                return f >>> 0
            }

            function k(t, e, r) {
                var n = e << 32 - r | t >>> r;
                return n >>> 0
            }

            function R(t, e, r) {
                var n = t << 32 - r | e >>> r;
                return n >>> 0
            }

            function O(t, e, r) {
                return t >>> r
            }

            function I(t, e, r) {
                var n = t << 32 - r | e >>> r;
                return n >>> 0
            }
            e.inherits = i, e.toArray = a, e.toHex = o, e.htonl = u, e.toHex32 = h, e.zero2 = f, e.zero8 = c, e.join32 = l, e.split32 = d, e.rotr32 = p, e.rotl32 = m, e.sum32 = b, e.sum32_3 = g, e.sum32_4 = y, e.sum32_5 = v, e.sum64 = w, e.sum64_hi = _, e.sum64_lo = M, e.sum64_4_hi = A, e.sum64_4_lo = S, e.sum64_5_hi = x, e.sum64_5_lo = E, e.rotr64_hi = k, e.rotr64_lo = R, e.shr64_hi = O, e.shr64_lo = I
        },
        d101: function(t, e, r) {
            "use strict";
            (function(t) {
                /**
                 * @file Web Cryptography API shim
                 * @author Artem S Vybornov <vybornov@gmail.com>
                 * @license MIT
                 */
                (function(e, n) {
                    "function" === typeof define && r("3c35") ? define([], (function() {
                        return n(e)
                    })) : t.exports ? t.exports = n(e) : n(e)
                })("undefined" !== typeof self ? self : void 0, (function(t) {
                    if ("function" !== typeof Promise) throw "Promise support required";
                    var e = t.crypto || t.msCrypto;
                    if (e) {
                        var r = e.subtle || e.webkitSubtle;
                        if (r) {
                            var n = t.Crypto || e.constructor || Object,
                                i = t.SubtleCrypto || r.constructor || Object,
                                s = (t.CryptoKey || t.Key, t.navigator.userAgent.indexOf("Edge/") > -1),
                                a = !!t.msCrypto && !s,
                                o = !e.subtle && !!e.webkitSubtle;
                            if (a || o) {
                                var u = {
                                        KoZIhvcNAQEB: "1.2.840.113549.1.1.1"
                                    },
                                    h = {
                                        "1.2.840.113549.1.1.1": "KoZIhvcNAQEB"
                                    };
                                if (["generateKey", "importKey", "unwrapKey"].forEach((function(t) {
                                        var n = r[t];
                                        r[t] = function(i, s, u) {
                                            var h, f, c, p, w = [].slice.call(arguments);
                                            switch (t) {
                                                case "generateKey":
                                                    h = m(i), f = s, c = u;
                                                    break;
                                                case "importKey":
                                                    h = m(u), f = w[3], c = w[4], "jwk" === i && (s = g(s), s.alg || (s.alg = b(h)), s.key_ops || (s.key_ops = "oct" !== s.kty ? "d" in s ? c.filter(x) : c.filter(S) : c.slice()), w[1] = y(s));
                                                    break;
                                                case "unwrapKey":
                                                    h = w[4], f = w[5], c = w[6], w[2] = u._key;
                                                    break
                                            }
                                            if ("generateKey" === t && "HMAC" === h.name && h.hash) return h.length = h.length || {
                                                "SHA-1": 512,
                                                "SHA-256": 512,
                                                "SHA-384": 1024,
                                                "SHA-512": 1024
                                            }[h.hash.name], r.importKey("raw", e.getRandomValues(new Uint8Array(h.length + 7 >> 3)), h, f, c);
                                            if (o && "generateKey" === t && "RSASSA-PKCS1-v1_5" === h.name && (!h.modulusLength || h.modulusLength >= 2048)) return i = m(i), i.name = "RSAES-PKCS1-v1_5", delete i.hash, r.generateKey(i, !0, ["encrypt", "decrypt"]).then((function(t) {
                                                return Promise.all([r.exportKey("jwk", t.publicKey), r.exportKey("jwk", t.privateKey)])
                                            })).then((function(t) {
                                                return t[0].alg = t[1].alg = b(h), t[0].key_ops = c.filter(S), t[1].key_ops = c.filter(x), Promise.all([r.importKey("jwk", t[0], h, !0, t[0].key_ops), r.importKey("jwk", t[1], h, f, t[1].key_ops)])
                                            })).then((function(t) {
                                                return {
                                                    publicKey: t[0],
                                                    privateKey: t[1]
                                                }
                                            }));
                                            if ((o || a && "SHA-1" === (h.hash || {}).name) && "importKey" === t && "jwk" === i && "HMAC" === h.name && "oct" === s.kty) return r.importKey("raw", d(l(s.k)), u, w[3], w[4]);
                                            if (o && "importKey" === t && ("spki" === i || "pkcs8" === i)) return r.importKey("jwk", v(s), u, w[3], w[4]);
                                            if (a && "unwrapKey" === t) return r.decrypt(w[3], u, s).then((function(t) {
                                                return r.importKey(i, t, w[4], w[5], w[6])
                                            }));
                                            try {
                                                p = n.apply(r, w)
                                            } catch (_) {
                                                return Promise.reject(_)
                                            }
                                            return a && (p = new Promise((function(t, e) {
                                                p.onabort = p.onerror = function(t) {
                                                    e(t)
                                                }, p.oncomplete = function(e) {
                                                    t(e.target.result)
                                                }
                                            }))), p = p.then((function(t) {
                                                return "HMAC" === h.name && (h.length || (h.length = 8 * t.algorithm.length)), 0 == h.name.search("RSA") && (h.modulusLength || (h.modulusLength = (t.publicKey || t).algorithm.modulusLength), h.publicExponent || (h.publicExponent = (t.publicKey || t).algorithm.publicExponent)), t = t.publicKey && t.privateKey ? {
                                                    publicKey: new A(t.publicKey, h, f, c.filter(S)),
                                                    privateKey: new A(t.privateKey, h, f, c.filter(x))
                                                } : new A(t, h, f, c), t
                                            })), p
                                        }
                                    })), ["exportKey", "wrapKey"].forEach((function(t) {
                                        var e = r[t];
                                        r[t] = function(n, i, s) {
                                            var u, h = [].slice.call(arguments);
                                            switch (t) {
                                                case "exportKey":
                                                    h[1] = i._key;
                                                    break;
                                                case "wrapKey":
                                                    h[1] = i._key, h[2] = s._key;
                                                    break
                                            }
                                            if ((o || a && "SHA-1" === (i.algorithm.hash || {}).name) && "exportKey" === t && "jwk" === n && "HMAC" === i.algorithm.name && (h[0] = "raw"), !o || "exportKey" !== t || "spki" !== n && "pkcs8" !== n || (h[0] = "jwk"), a && "wrapKey" === t) return r.exportKey(n, i).then((function(t) {
                                                return "jwk" === n && (t = d(unescape(encodeURIComponent(JSON.stringify(g(t)))))), r.encrypt(h[3], s, t)
                                            }));
                                            try {
                                                u = e.apply(r, h)
                                            } catch (f) {
                                                return Promise.reject(f)
                                            }
                                            return a && (u = new Promise((function(t, e) {
                                                u.onabort = u.onerror = function(t) {
                                                    e(t)
                                                }, u.oncomplete = function(e) {
                                                    t(e.target.result)
                                                }
                                            }))), "exportKey" === t && "jwk" === n && (u = u.then((function(t) {
                                                return (o || a && "SHA-1" === (i.algorithm.hash || {}).name) && "HMAC" === i.algorithm.name ? {
                                                    kty: "oct",
                                                    alg: b(i.algorithm),
                                                    key_ops: i.usages.slice(),
                                                    ext: !0,
                                                    k: c(p(t))
                                                } : (t = g(t), t.alg || (t["alg"] = b(i.algorithm)), t.key_ops || (t["key_ops"] = "public" === i.type ? i.usages.filter(S) : "private" === i.type ? i.usages.filter(x) : i.usages.slice()), t)
                                            }))), !o || "exportKey" !== t || "spki" !== n && "pkcs8" !== n || (u = u.then((function(t) {
                                                return t = w(g(t)), t
                                            }))), u
                                        }
                                    })), ["encrypt", "decrypt", "sign", "verify"].forEach((function(t) {
                                        var e = r[t];
                                        r[t] = function(n, i, s, o) {
                                            if (a && (!s.byteLength || o && !o.byteLength)) throw new Error("Empy input is not allowed");
                                            var u, h = [].slice.call(arguments),
                                                f = m(n);
                                            if (a && "decrypt" === t && "AES-GCM" === f.name) {
                                                var c = n.tagLength >> 3;
                                                h[2] = (s.buffer || s).slice(0, s.byteLength - c), n.tag = (s.buffer || s).slice(s.byteLength - c)
                                            }
                                            h[1] = i._key;
                                            try {
                                                u = e.apply(r, h)
                                            } catch (l) {
                                                return Promise.reject(l)
                                            }
                                            return a && (u = new Promise((function(e, r) {
                                                u.onabort = u.onerror = function(t) {
                                                    r(t)
                                                }, u.oncomplete = function(r) {
                                                    r = r.target.result;
                                                    if ("encrypt" === t && r instanceof AesGcmEncryptResult) {
                                                        var n = r.ciphertext,
                                                            i = r.tag;
                                                        r = new Uint8Array(n.byteLength + i.byteLength), r.set(new Uint8Array(n), 0), r.set(new Uint8Array(i), n.byteLength), r = r.buffer
                                                    }
                                                    e(r)
                                                }
                                            }))), u
                                        }
                                    })), a) {
                                    var f = r.digest;
                                    r["digest"] = function(t, e) {
                                        if (!e.byteLength) throw new Error("Empy input is not allowed");
                                        var n;
                                        try {
                                            n = f.call(r, t, e)
                                        } catch (i) {
                                            return Promise.reject(i)
                                        }
                                        return n = new Promise((function(t, e) {
                                            n.onabort = n.onerror = function(t) {
                                                e(t)
                                            }, n.oncomplete = function(e) {
                                                t(e.target.result)
                                            }
                                        })), n
                                    }, t.crypto = Object.create(e, {
                                        getRandomValues: {
                                            value: function(t) {
                                                return e.getRandomValues(t)
                                            }
                                        },
                                        subtle: {
                                            value: r
                                        }
                                    }), t.CryptoKey = A
                                }
                                o && (e.subtle = r, t.Crypto = n, t.SubtleCrypto = i, t.CryptoKey = A)
                            }
                        }
                    }

                    function c(t) {
                        return btoa(t).replace(/\=+$/, "").replace(/\+/g, "-").replace(/\//g, "_")
                    }

                    function l(t) {
                        return t += "===", t = t.slice(0, -t.length % 4), atob(t.replace(/-/g, "+").replace(/_/g, "/"))
                    }

                    function d(t) {
                        for (var e = new Uint8Array(t.length), r = 0; r < t.length; r++) e[r] = t.charCodeAt(r);
                        return e
                    }

                    function p(t) {
                        return t instanceof ArrayBuffer && (t = new Uint8Array(t)), String.fromCharCode.apply(String, t)
                    }

                    function m(t) {
                        var e = {
                            name: (t.name || t || "").toUpperCase().replace("V", "v")
                        };
                        switch (e.name) {
                            case "SHA-1":
                            case "SHA-256":
                            case "SHA-384":
                            case "SHA-512":
                                break;
                            case "AES-CBC":
                            case "AES-GCM":
                            case "AES-KW":
                                t.length && (e["length"] = t.length);
                                break;
                            case "HMAC":
                                t.hash && (e["hash"] = m(t.hash)), t.length && (e["length"] = t.length);
                                break;
                            case "RSAES-PKCS1-v1_5":
                                t.publicExponent && (e["publicExponent"] = new Uint8Array(t.publicExponent)), t.modulusLength && (e["modulusLength"] = t.modulusLength);
                                break;
                            case "RSASSA-PKCS1-v1_5":
                            case "RSA-OAEP":
                                t.hash && (e["hash"] = m(t.hash)), t.publicExponent && (e["publicExponent"] = new Uint8Array(t.publicExponent)), t.modulusLength && (e["modulusLength"] = t.modulusLength);
                                break;
                            default:
                                throw new SyntaxError("Bad algorithm name")
                        }
                        return e
                    }

                    function b(t) {
                        return {
                            HMAC: {
                                "SHA-1": "HS1",
                                "SHA-256": "HS256",
                                "SHA-384": "HS384",
                                "SHA-512": "HS512"
                            },
                            "RSASSA-PKCS1-v1_5": {
                                "SHA-1": "RS1",
                                "SHA-256": "RS256",
                                "SHA-384": "RS384",
                                "SHA-512": "RS512"
                            },
                            "RSAES-PKCS1-v1_5": {
                                "": "RSA1_5"
                            },
                            "RSA-OAEP": {
                                "SHA-1": "RSA-OAEP",
                                "SHA-256": "RSA-OAEP-256"
                            },
                            "AES-KW": {
                                128: "A128KW",
                                192: "A192KW",
                                256: "A256KW"
                            },
                            "AES-GCM": {
                                128: "A128GCM",
                                192: "A192GCM",
                                256: "A256GCM"
                            },
                            "AES-CBC": {
                                128: "A128CBC",
                                192: "A192CBC",
                                256: "A256CBC"
                            }
                        }[t.name][(t.hash || {}).name || t.length || ""]
                    }

                    function g(t) {
                        (t instanceof ArrayBuffer || t instanceof Uint8Array) && (t = JSON.parse(decodeURIComponent(escape(p(t)))));
                        var e = {
                            kty: t.kty,
                            alg: t.alg,
                            ext: t.ext || t.extractable
                        };
                        switch (e.kty) {
                            case "oct":
                                e.k = t.k;
                            case "RSA":
                                ["n", "e", "d", "p", "q", "dp", "dq", "qi", "oth"].forEach((function(r) {
                                    r in t && (e[r] = t[r])
                                }));
                                break;
                            default:
                                throw new TypeError("Unsupported key type")
                        }
                        return e
                    }

                    function y(t) {
                        var e = g(t);
                        return a && (e["extractable"] = e.ext, delete e.ext), d(unescape(encodeURIComponent(JSON.stringify(e)))).buffer
                    }

                    function v(t) {
                        var e = _(t),
                            r = !1;
                        e.length > 2 && (r = !0, e.shift());
                        var n = {
                            ext: !0
                        };
                        switch (e[0][0]) {
                            case "1.2.840.113549.1.1.1":
                                var i = ["n", "e", "d", "p", "q", "dp", "dq", "qi"],
                                    s = _(e[1]);
                                r && s.shift();
                                for (var a = 0; a < s.length; a++) s[a][0] || (s[a] = s[a].subarray(1)), n[i[a]] = c(p(s[a]));
                                n["kty"] = "RSA";
                                break;
                            default:
                                throw new TypeError("Unsupported key type")
                        }
                        return n
                    }

                    function w(t) {
                        var e, r = [
                                ["", null]
                            ],
                            n = !1;
                        switch (t.kty) {
                            case "RSA":
                                for (var i = ["n", "e", "d", "p", "q", "dp", "dq", "qi"], s = [], a = 0; a < i.length; a++) {
                                    if (!(i[a] in t)) break;
                                    var o = s[a] = d(l(t[i[a]]));
                                    128 & o[0] && (s[a] = new Uint8Array(o.length + 1), s[a].set(o, 1))
                                }
                                s.length > 2 && (n = !0, s.unshift(new Uint8Array([0]))), r[0][0] = "1.2.840.113549.1.1.1", e = s;
                                break;
                            default:
                                throw new TypeError("Unsupported key type")
                        }
                        return r.push(new Uint8Array(M(e)).buffer), n ? r.unshift(new Uint8Array([0])) : r[1] = {
                            tag: 3,
                            value: r[1]
                        }, new Uint8Array(M(r)).buffer
                    }

                    function _(t, e) {
                        if (t instanceof ArrayBuffer && (t = new Uint8Array(t)), e || (e = {
                                pos: 0,
                                end: t.length
                            }), e.end - e.pos < 2 || e.end > t.length) throw new RangeError("Malformed DER");
                        var r, n = t[e.pos++],
                            i = t[e.pos++];
                        if (i >= 128) {
                            if (i &= 127, e.end - e.pos < i) throw new RangeError("Malformed DER");
                            for (var s = 0; i--;) s <<= 8, s |= t[e.pos++];
                            i = s
                        }
                        if (e.end - e.pos < i) throw new RangeError("Malformed DER");
                        switch (n) {
                            case 2:
                                r = t.subarray(e.pos, e.pos += i);
                                break;
                            case 3:
                                if (t[e.pos++]) throw new Error("Unsupported bit string");
                                i--;
                            case 4:
                                r = new Uint8Array(t.subarray(e.pos, e.pos += i)).buffer;
                                break;
                            case 5:
                                r = null;
                                break;
                            case 6:
                                var a = btoa(p(t.subarray(e.pos, e.pos += i)));
                                if (!(a in u)) throw new Error("Unsupported OBJECT ID " + a);
                                r = u[a];
                                break;
                            case 48:
                                r = [];
                                for (var o = e.pos + i; e.pos < o;) r.push(_(t, e));
                                break;
                            default:
                                throw new Error("Unsupported DER tag 0x" + n.toString(16))
                        }
                        return r
                    }

                    function M(t, e) {
                        e || (e = []);
                        var r = 0,
                            n = 0,
                            i = e.length + 2;
                        if (e.push(0, 0), t instanceof Uint8Array) {
                            r = 2, n = t.length;
                            for (var s = 0; s < n; s++) e.push(t[s])
                        } else if (t instanceof ArrayBuffer) {
                            r = 4, n = t.byteLength, t = new Uint8Array(t);
                            for (s = 0; s < n; s++) e.push(t[s])
                        } else if (null === t) r = 5, n = 0;
                        else if ("string" === typeof t && t in h) {
                            var a = d(atob(h[t]));
                            r = 6, n = a.length;
                            for (s = 0; s < n; s++) e.push(a[s])
                        } else if (t instanceof Array) {
                            for (s = 0; s < t.length; s++) M(t[s], e);
                            r = 48, n = e.length - i
                        } else {
                            if (!("object" === typeof t && 3 === t.tag && t.value instanceof ArrayBuffer)) throw new Error("Unsupported DER value " + t);
                            t = new Uint8Array(t.value), r = 3, n = t.byteLength, e.push(0);
                            for (s = 0; s < n; s++) e.push(t[s]);
                            n++
                        }
                        if (n >= 128) {
                            var o = n;
                            n = 4;
                            e.splice(i, 0, o >> 24 & 255, o >> 16 & 255, o >> 8 & 255, 255 & o);
                            while (n > 1 && !(o >> 24)) o <<= 8, n--;
                            n < 4 && e.splice(i, 4 - n), n |= 128
                        }
                        return e.splice(i - 2, 2, r, n), e
                    }

                    function A(t, e, r, n) {
                        Object.defineProperties(this, {
                            _key: {
                                value: t
                            },
                            type: {
                                value: t.type,
                                enumerable: !0
                            },
                            extractable: {
                                value: void 0 === r ? t.extractable : r,
                                enumerable: !0
                            },
                            algorithm: {
                                value: void 0 === e ? t.algorithm : e,
                                enumerable: !0
                            },
                            usages: {
                                value: void 0 === n ? t.usages : n,
                                enumerable: !0
                            }
                        })
                    }

                    function S(t) {
                        return "verify" === t || "encrypt" === t || "wrapKey" === t
                    }

                    function x(t) {
                        return "sign" === t || "decrypt" === t || "unwrapKey" === t
                    }
                }))
            }).call(this, r("dd40")(t))
        },
        d370: function(t, e, r) {
            ! function(e, r) {
                t.exports = r()
            }(self, (function() {
                return t = {
                        1238: t => {
                            "use strict";
                            t.exports = {
                                version: "17.6.0"
                            }
                        },
                        7629: (t, e, r) => {
                            "use strict";
                            const n = r(375),
                                i = r(8571),
                                s = r(9474),
                                a = r(1687),
                                o = r(8652),
                                u = r(8160),
                                h = r(3292),
                                f = r(6354),
                                c = r(8901),
                                l = r(9708),
                                d = r(6914),
                                p = r(2294),
                                m = r(6133),
                                b = r(1152),
                                g = r(8863),
                                y = r(2036),
                                v = {
                                    Base: class {
                                        constructor(t) {
                                            this.type = t, this.$_root = null, this._definition = {}, this._reset()
                                        }
                                        _reset() {
                                            this._ids = new p.Ids, this._preferences = null, this._refs = new m.Manager, this._cache = null, this._valids = null, this._invalids = null, this._flags = {}, this._rules = [], this._singleRules = new Map, this.$_terms = {}, this.$_temp = {
                                                ruleset: null,
                                                whens: {}
                                            }
                                        }
                                        describe() {
                                            return n("function" == typeof l.describe, "Manifest functionality disabled"), l.describe(this)
                                        }
                                        allow(...t) {
                                            return u.verifyFlat(t, "allow"), this._values(t, "_valids")
                                        }
                                        alter(t) {
                                            n(t && "object" == typeof t && !Array.isArray(t), "Invalid targets argument"), n(!this._inRuleset(), "Cannot set alterations inside a ruleset");
                                            const e = this.clone();
                                            e.$_terms.alterations = e.$_terms.alterations || [];
                                            for (const r in t) {
                                                const i = t[r];
                                                n("function" == typeof i, "Alteration adjuster for", r, "must be a function"), e.$_terms.alterations.push({
                                                    target: r,
                                                    adjuster: i
                                                })
                                            }
                                            return e.$_temp.ruleset = !1, e
                                        }
                                        artifact(t) {
                                            return n(void 0 !== t, "Artifact cannot be undefined"), n(!this._cache, "Cannot set an artifact with a rule cache"), this.$_setFlag("artifact", t)
                                        }
                                        cast(t) {
                                            return n(!1 === t || "string" == typeof t, "Invalid to value"), n(!1 === t || this._definition.cast[t], "Type", this.type, "does not support casting to", t), this.$_setFlag("cast", !1 === t ? void 0 : t)
                                        }
                                        default (t, e) {
                                            return this._default("default", t, e)
                                        }
                                        description(t) {
                                            return n(t && "string" == typeof t, "Description must be a non-empty string"), this.$_setFlag("description", t)
                                        }
                                        empty(t) {
                                            const e = this.clone();
                                            return void 0 !== t && (t = e.$_compile(t, {
                                                override: !1
                                            })), e.$_setFlag("empty", t, {
                                                clone: !1
                                            })
                                        }
                                        error(t) {
                                            return n(t, "Missing error"), n(t instanceof Error || "function" == typeof t, "Must provide a valid Error object or a function"), this.$_setFlag("error", t)
                                        }
                                        example(t, e = {}) {
                                            return n(void 0 !== t, "Missing example"), u.assertOptions(e, ["override"]), this._inner("examples", t, {
                                                single: !0,
                                                override: e.override
                                            })
                                        }
                                        external(t, e) {
                                            return "object" == typeof t && (n(!e, "Cannot combine options with description"), e = t.description, t = t.method), n("function" == typeof t, "Method must be a function"), n(void 0 === e || e && "string" == typeof e, "Description must be a non-empty string"), this._inner("externals", {
                                                method: t,
                                                description: e
                                            }, {
                                                single: !0
                                            })
                                        }
                                        failover(t, e) {
                                            return this._default("failover", t, e)
                                        }
                                        forbidden() {
                                            return this.presence("forbidden")
                                        }
                                        id(t) {
                                            return t ? (n("string" == typeof t, "id must be a non-empty string"), n(/^[^\.]+$/.test(t), "id cannot contain period character"), this.$_setFlag("id", t)) : this.$_setFlag("id", void 0)
                                        }
                                        invalid(...t) {
                                            return this._values(t, "_invalids")
                                        }
                                        label(t) {
                                            return n(t && "string" == typeof t, "Label name must be a non-empty string"), this.$_setFlag("label", t)
                                        }
                                        meta(t) {
                                            return n(void 0 !== t, "Meta cannot be undefined"), this._inner("metas", t, {
                                                single: !0
                                            })
                                        }
                                        note(...t) {
                                            n(t.length, "Missing notes");
                                            for (const e of t) n(e && "string" == typeof e, "Notes must be non-empty strings");
                                            return this._inner("notes", t)
                                        }
                                        only(t = !0) {
                                            return n("boolean" == typeof t, "Invalid mode:", t), this.$_setFlag("only", t)
                                        }
                                        optional() {
                                            return this.presence("optional")
                                        }
                                        prefs(t) {
                                            n(t, "Missing preferences"), n(void 0 === t.context, "Cannot override context"), n(void 0 === t.externals, "Cannot override externals"), n(void 0 === t.warnings, "Cannot override warnings"), n(void 0 === t.debug, "Cannot override debug"), u.checkPreferences(t);
                                            const e = this.clone();
                                            return e._preferences = u.preferences(e._preferences, t), e
                                        }
                                        presence(t) {
                                            return n(["optional", "required", "forbidden"].includes(t), "Unknown presence mode", t), this.$_setFlag("presence", t)
                                        }
                                        raw(t = !0) {
                                            return this.$_setFlag("result", t ? "raw" : void 0)
                                        }
                                        result(t) {
                                            return n(["raw", "strip"].includes(t), "Unknown result mode", t), this.$_setFlag("result", t)
                                        }
                                        required() {
                                            return this.presence("required")
                                        }
                                        strict(t) {
                                            const e = this.clone(),
                                                r = void 0 !== t && !t;
                                            return e._preferences = u.preferences(e._preferences, {
                                                convert: r
                                            }), e
                                        }
                                        strip(t = !0) {
                                            return this.$_setFlag("result", t ? "strip" : void 0)
                                        }
                                        tag(...t) {
                                            n(t.length, "Missing tags");
                                            for (const e of t) n(e && "string" == typeof e, "Tags must be non-empty strings");
                                            return this._inner("tags", t)
                                        }
                                        unit(t) {
                                            return n(t && "string" == typeof t, "Unit name must be a non-empty string"), this.$_setFlag("unit", t)
                                        }
                                        valid(...t) {
                                            u.verifyFlat(t, "valid");
                                            const e = this.allow(...t);
                                            return e.$_setFlag("only", !!e._valids, {
                                                clone: !1
                                            }), e
                                        }
                                        when(t, e) {
                                            const r = this.clone();
                                            r.$_terms.whens || (r.$_terms.whens = []);
                                            const i = h.when(r, t, e);
                                            if (!["any", "link"].includes(r.type)) {
                                                const t = i.is ? [i] : i.switch;
                                                for (const e of t) n(!e.then || "any" === e.then.type || e.then.type === r.type, "Cannot combine", r.type, "with", e.then && e.then.type), n(!e.otherwise || "any" === e.otherwise.type || e.otherwise.type === r.type, "Cannot combine", r.type, "with", e.otherwise && e.otherwise.type)
                                            }
                                            return r.$_terms.whens.push(i), r.$_mutateRebuild()
                                        }
                                        cache(t) {
                                            n(!this._inRuleset(), "Cannot set caching inside a ruleset"), n(!this._cache, "Cannot override schema cache"), n(void 0 === this._flags.artifact, "Cannot cache a rule with an artifact");
                                            const e = this.clone();
                                            return e._cache = t || o.provider.provision(), e.$_temp.ruleset = !1, e
                                        }
                                        clone() {
                                            const t = Object.create(Object.getPrototypeOf(this));
                                            return this._assign(t)
                                        }
                                        concat(t) {
                                            n(u.isSchema(t), "Invalid schema object"), n("any" === this.type || "any" === t.type || t.type === this.type, "Cannot merge type", this.type, "with another type:", t.type), n(!this._inRuleset(), "Cannot concatenate onto a schema with open ruleset"), n(!t._inRuleset(), "Cannot concatenate a schema with open ruleset");
                                            let e = this.clone();
                                            if ("any" === this.type && "any" !== t.type) {
                                                const r = t.clone();
                                                for (const t of Object.keys(e)) "type" !== t && (r[t] = e[t]);
                                                e = r
                                            }
                                            e._ids.concat(t._ids), e._refs.register(t, m.toSibling), e._preferences = e._preferences ? u.preferences(e._preferences, t._preferences) : t._preferences, e._valids = y.merge(e._valids, t._valids, t._invalids), e._invalids = y.merge(e._invalids, t._invalids, t._valids);
                                            for (const r of t._singleRules.keys()) e._singleRules.has(r) && (e._rules = e._rules.filter(t => t.keep || t.name !== r), e._singleRules.delete(r));
                                            for (const r of t._rules) t._definition.rules[r.method].multi || e._singleRules.set(r.name, r), e._rules.push(r);
                                            if (e._flags.empty && t._flags.empty) {
                                                e._flags.empty = e._flags.empty.concat(t._flags.empty);
                                                const r = Object.assign({}, t._flags);
                                                delete r.empty, a(e._flags, r)
                                            } else if (t._flags.empty) {
                                                e._flags.empty = t._flags.empty;
                                                const r = Object.assign({}, t._flags);
                                                delete r.empty, a(e._flags, r)
                                            } else a(e._flags, t._flags);
                                            for (const r in t.$_terms) {
                                                const n = t.$_terms[r];
                                                n ? e.$_terms[r] ? e.$_terms[r] = e.$_terms[r].concat(n) : e.$_terms[r] = n.slice() : e.$_terms[r] || (e.$_terms[r] = n)
                                            }
                                            return this.$_root._tracer && this.$_root._tracer._combine(e, [this, t]), e.$_mutateRebuild()
                                        }
                                        extend(t) {
                                            return n(!t.base, "Cannot extend type with another base"), c.type(this, t)
                                        }
                                        extract(t) {
                                            return t = Array.isArray(t) ? t : t.split("."), this._ids.reach(t)
                                        }
                                        fork(t, e) {
                                            n(!this._inRuleset(), "Cannot fork inside a ruleset");
                                            let r = this;
                                            for (let n of [].concat(t)) n = Array.isArray(n) ? n : n.split("."), r = r._ids.fork(n, e, r);
                                            return r.$_temp.ruleset = !1, r
                                        }
                                        rule(t) {
                                            const e = this._definition;
                                            u.assertOptions(t, Object.keys(e.modifiers)), n(!1 !== this.$_temp.ruleset, "Cannot apply rules to empty ruleset or the last rule added does not support rule properties");
                                            const r = null === this.$_temp.ruleset ? this._rules.length - 1 : this.$_temp.ruleset;
                                            n(r >= 0 && r < this._rules.length, "Cannot apply rules to empty ruleset");
                                            const s = this.clone();
                                            for (let a = r; a < s._rules.length; ++a) {
                                                const r = s._rules[a],
                                                    o = i(r);
                                                for (const i in t) e.modifiers[i](o, t[i]), n(o.name === r.name, "Cannot change rule name");
                                                s._rules[a] = o, s._singleRules.get(o.name) === r && s._singleRules.set(o.name, o)
                                            }
                                            return s.$_temp.ruleset = !1, s.$_mutateRebuild()
                                        }
                                        get ruleset() {
                                            n(!this._inRuleset(), "Cannot start a new ruleset without closing the previous one");
                                            const t = this.clone();
                                            return t.$_temp.ruleset = t._rules.length, t
                                        }
                                        get $() {
                                            return this.ruleset
                                        }
                                        tailor(t) {
                                            t = [].concat(t), n(!this._inRuleset(), "Cannot tailor inside a ruleset");
                                            let e = this;
                                            if (this.$_terms.alterations)
                                                for (const {
                                                        target: r,
                                                        adjuster: i
                                                    } of this.$_terms.alterations) t.includes(r) && (e = i(e), n(u.isSchema(e), "Alteration adjuster for", r, "failed to return a schema object"));
                                            return e = e.$_modify({
                                                each: e => e.tailor(t),
                                                ref: !1
                                            }), e.$_temp.ruleset = !1, e.$_mutateRebuild()
                                        }
                                        tracer() {
                                            return b.location ? b.location(this) : this
                                        }
                                        validate(t, e) {
                                            return g.entry(t, this, e)
                                        }
                                        validateAsync(t, e) {
                                            return g.entryAsync(t, this, e)
                                        }
                                        $_addRule(t) {
                                            "string" == typeof t && (t = {
                                                name: t
                                            }), n(t && "object" == typeof t, "Invalid options"), n(t.name && "string" == typeof t.name, "Invalid rule name");
                                            for (const a in t) n("_" !== a[0], "Cannot set private rule properties");
                                            const e = Object.assign({}, t);
                                            e._resolve = [], e.method = e.method || e.name;
                                            const r = this._definition.rules[e.method],
                                                i = e.args;
                                            n(r, "Unknown rule", e.method);
                                            const s = this.clone();
                                            if (i) {
                                                n(1 === Object.keys(i).length || Object.keys(i).length === this._definition.rules[e.name].args.length, "Invalid rule definition for", this.type, e.name);
                                                for (const t in i) {
                                                    let a = i[t];
                                                    if (void 0 !== a) {
                                                        if (r.argsByName) {
                                                            const o = r.argsByName.get(t);
                                                            if (o.ref && u.isResolvable(a)) e._resolve.push(t), s.$_mutateRegister(a);
                                                            else if (o.normalize && (a = o.normalize(a), i[t] = a), o.assert) {
                                                                const e = u.validateArg(a, t, o);
                                                                n(!e, e, "or reference")
                                                            }
                                                        }
                                                        i[t] = a
                                                    } else delete i[t]
                                                }
                                            }
                                            return r.multi || (s._ruleRemove(e.name, {
                                                clone: !1
                                            }), s._singleRules.set(e.name, e)), !1 === s.$_temp.ruleset && (s.$_temp.ruleset = null), r.priority ? s._rules.unshift(e) : s._rules.push(e), s
                                        }
                                        $_compile(t, e) {
                                            return h.schema(this.$_root, t, e)
                                        }
                                        $_createError(t, e, r, n, i, s = {}) {
                                            const a = !1 !== s.flags ? this._flags : {},
                                                o = s.messages ? d.merge(this._definition.messages, s.messages) : this._definition.messages;
                                            return new f.Report(t, e, r, a, o, n, i)
                                        }
                                        $_getFlag(t) {
                                            return this._flags[t]
                                        }
                                        $_getRule(t) {
                                            return this._singleRules.get(t)
                                        }
                                        $_mapLabels(t) {
                                            return t = Array.isArray(t) ? t : t.split("."), this._ids.labels(t)
                                        }
                                        $_match(t, e, r, n) {
                                            (r = Object.assign({}, r)).abortEarly = !0, r._externals = !1, e.snapshot();
                                            const i = !g.validate(t, this, e, r, n).errors;
                                            return e.restore(), i
                                        }
                                        $_modify(t) {
                                            return u.assertOptions(t, ["each", "once", "ref", "schema"]), p.schema(this, t) || this
                                        }
                                        $_mutateRebuild() {
                                            return n(!this._inRuleset(), "Cannot add this rule inside a ruleset"), this._refs.reset(), this._ids.reset(), this.$_modify({
                                                each: (t, {
                                                    source: e,
                                                    name: r,
                                                    path: n,
                                                    key: i
                                                }) => {
                                                    const s = this._definition[e][r] && this._definition[e][r].register;
                                                    !1 !== s && this.$_mutateRegister(t, {
                                                        family: s,
                                                        key: i
                                                    })
                                                }
                                            }), this._definition.rebuild && this._definition.rebuild(this), this.$_temp.ruleset = !1, this
                                        }
                                        $_mutateRegister(t, {
                                            family: e,
                                            key: r
                                        } = {}) {
                                            this._refs.register(t, e), this._ids.register(t, {
                                                key: r
                                            })
                                        }
                                        $_property(t) {
                                            return this._definition.properties[t]
                                        }
                                        $_reach(t) {
                                            return this._ids.reach(t)
                                        }
                                        $_rootReferences() {
                                            return this._refs.roots()
                                        }
                                        $_setFlag(t, e, r = {}) {
                                            n("_" === t[0] || !this._inRuleset(), "Cannot set flag inside a ruleset");
                                            const i = this._definition.flags[t] || {};
                                            if (s(e, i.default) && (e = void 0), s(e, this._flags[t])) return this;
                                            const a = !1 !== r.clone ? this.clone() : this;
                                            return void 0 !== e ? (a._flags[t] = e, a.$_mutateRegister(e)) : delete a._flags[t], "_" !== t[0] && (a.$_temp.ruleset = !1), a
                                        }
                                        $_parent(t, ...e) {
                                            return this[t][u.symbols.parent].call(this, ...e)
                                        }
                                        $_validate(t, e, r) {
                                            return g.validate(t, this, e, r)
                                        }
                                        _assign(t) {
                                            t.type = this.type, t.$_root = this.$_root, t.$_temp = Object.assign({}, this.$_temp), t.$_temp.whens = {}, t._ids = this._ids.clone(), t._preferences = this._preferences, t._valids = this._valids && this._valids.clone(), t._invalids = this._invalids && this._invalids.clone(), t._rules = this._rules.slice(), t._singleRules = i(this._singleRules, {
                                                shallow: !0
                                            }), t._refs = this._refs.clone(), t._flags = Object.assign({}, this._flags), t._cache = null, t.$_terms = {};
                                            for (const e in this.$_terms) t.$_terms[e] = this.$_terms[e] ? this.$_terms[e].slice() : null;
                                            t.$_super = {};
                                            for (const e in this.$_super) t.$_super[e] = this._super[e].bind(t);
                                            return t
                                        }
                                        _bare() {
                                            const t = this.clone();
                                            t._reset();
                                            const e = t._definition.terms;
                                            for (const r in e) {
                                                const n = e[r];
                                                t.$_terms[r] = n.init
                                            }
                                            return t.$_mutateRebuild()
                                        }
                                        _default(t, e, r = {}) {
                                            return u.assertOptions(r, "literal"), n(void 0 !== e, "Missing", t, "value"), n("function" == typeof e || !r.literal, "Only function value supports literal option"), "function" == typeof e && r.literal && (e = {
                                                [u.symbols.literal]: !0,
                                                literal: e
                                            }), this.$_setFlag(t, e)
                                        }
                                        _generate(t, e, r) {
                                            if (!this.$_terms.whens) return {
                                                schema: this
                                            };
                                            const n = [],
                                                i = [];
                                            for (let o = 0; o < this.$_terms.whens.length; ++o) {
                                                const s = this.$_terms.whens[o];
                                                if (s.concat) {
                                                    n.push(s.concat), i.push("".concat(o, ".concat"));
                                                    continue
                                                }
                                                const a = s.ref ? s.ref.resolve(t, e, r) : t,
                                                    u = s.is ? [s] : s.switch,
                                                    h = i.length;
                                                for (let f = 0; f < u.length; ++f) {
                                                    const {
                                                        is: h,
                                                        then: c,
                                                        otherwise: l
                                                    } = u[f], d = "".concat(o).concat(s.switch ? "." + f : "");
                                                    if (h.$_match(a, e.nest(h, "".concat(d, ".is")), r)) {
                                                        if (c) {
                                                            const s = e.localize([...e.path, "".concat(d, ".then")], e.ancestors, e.schemas),
                                                                {
                                                                    schema: a,
                                                                    id: o
                                                                } = c._generate(t, s, r);
                                                            n.push(a), i.push("".concat(d, ".then").concat(o ? "(".concat(o, ")") : ""));
                                                            break
                                                        }
                                                    } else if (l) {
                                                        const s = e.localize([...e.path, "".concat(d, ".otherwise")], e.ancestors, e.schemas),
                                                            {
                                                                schema: a,
                                                                id: o
                                                            } = l._generate(t, s, r);
                                                        n.push(a), i.push("".concat(d, ".otherwise").concat(o ? "(".concat(o, ")") : ""));
                                                        break
                                                    }
                                                }
                                                if (s.break && i.length > h) break
                                            }
                                            const s = i.join(", ");
                                            if (e.mainstay.tracer.debug(e, "rule", "when", s), !s) return {
                                                schema: this
                                            };
                                            if (!e.mainstay.tracer.active && this.$_temp.whens[s]) return {
                                                schema: this.$_temp.whens[s],
                                                id: s
                                            };
                                            let a = this;
                                            this._definition.generate && (a = this._definition.generate(this, t, e, r));
                                            for (const o of n) a = a.concat(o);
                                            return this.$_root._tracer && this.$_root._tracer._combine(a, [this, ...n]), this.$_temp.whens[s] = a, {
                                                schema: a,
                                                id: s
                                            }
                                        }
                                        _inner(t, e, r = {}) {
                                            n(!this._inRuleset(), "Cannot set ".concat(t, " inside a ruleset"));
                                            const i = this.clone();
                                            return i.$_terms[t] && !r.override || (i.$_terms[t] = []), r.single ? i.$_terms[t].push(e) : i.$_terms[t].push(...e), i.$_temp.ruleset = !1, i
                                        }
                                        _inRuleset() {
                                            return null !== this.$_temp.ruleset && !1 !== this.$_temp.ruleset
                                        }
                                        _ruleRemove(t, e = {}) {
                                            if (!this._singleRules.has(t)) return this;
                                            const r = !1 !== e.clone ? this.clone() : this;
                                            r._singleRules.delete(t);
                                            const n = [];
                                            for (let i = 0; i < r._rules.length; ++i) {
                                                const e = r._rules[i];
                                                e.name !== t || e.keep ? n.push(e) : r._inRuleset() && i < r.$_temp.ruleset && --r.$_temp.ruleset
                                            }
                                            return r._rules = n, r
                                        }
                                        _values(t, e) {
                                            u.verifyFlat(t, e.slice(1, -1));
                                            const r = this.clone(),
                                                i = t[0] === u.symbols.override;
                                            if (i && (t = t.slice(1)), !r[e] && t.length ? r[e] = new y : i && (r[e] = t.length ? new y : null, r.$_mutateRebuild()), !r[e]) return r;
                                            i && r[e].override();
                                            for (const s of t) {
                                                n(void 0 !== s, "Cannot call allow/valid/invalid with undefined"), n(s !== u.symbols.override, "Override must be the first value");
                                                const t = "_invalids" === e ? "_valids" : "_invalids";
                                                r[t] && (r[t].remove(s), r[t].length || (n("_valids" === e || !r._flags.only, "Setting invalid value", s, "leaves schema rejecting all values due to previous valid rule"), r[t] = null)), r[e].add(s, r._refs)
                                            }
                                            return r
                                        }
                                    }
                                };
                            v.Base.prototype[u.symbols.any] = {
                                version: u.version,
                                compile: h.compile,
                                root: "$_root"
                            }, v.Base.prototype.isImmutable = !0, v.Base.prototype.deny = v.Base.prototype.invalid, v.Base.prototype.disallow = v.Base.prototype.invalid, v.Base.prototype.equal = v.Base.prototype.valid, v.Base.prototype.exist = v.Base.prototype.required, v.Base.prototype.not = v.Base.prototype.invalid, v.Base.prototype.options = v.Base.prototype.prefs, v.Base.prototype.preferences = v.Base.prototype.prefs, t.exports = new v.Base
                        },
                        8652: (t, e, r) => {
                            "use strict";
                            const n = r(375),
                                i = r(8571),
                                s = r(8160),
                                a = {
                                    max: 1e3,
                                    supported: new Set(["undefined", "boolean", "number", "string"])
                                };
                            e.provider = {
                                provision: t => new a.Cache(t)
                            }, a.Cache = class {
                                constructor(t = {}) {
                                    s.assertOptions(t, ["max"]), n(void 0 === t.max || t.max && t.max > 0 && isFinite(t.max), "Invalid max cache size"), this._max = t.max || a.max, this._map = new Map, this._list = new a.List
                                }
                                get length() {
                                    return this._map.size
                                }
                                set(t, e) {
                                    if (null !== t && !a.supported.has(typeof t)) return;
                                    let r = this._map.get(t);
                                    if (r) return r.value = e, void this._list.first(r);
                                    r = this._list.unshift({
                                        key: t,
                                        value: e
                                    }), this._map.set(t, r), this._compact()
                                }
                                get(t) {
                                    const e = this._map.get(t);
                                    if (e) return this._list.first(e), i(e.value)
                                }
                                _compact() {
                                    if (this._map.size > this._max) {
                                        const t = this._list.pop();
                                        this._map.delete(t.key)
                                    }
                                }
                            }, a.List = class {
                                constructor() {
                                    this.tail = null, this.head = null
                                }
                                unshift(t) {
                                    return t.next = null, t.prev = this.head, this.head && (this.head.next = t), this.head = t, this.tail || (this.tail = t), t
                                }
                                first(t) {
                                    t !== this.head && (this._remove(t), this.unshift(t))
                                }
                                pop() {
                                    return this._remove(this.tail)
                                }
                                _remove(t) {
                                    const {
                                        next: e,
                                        prev: r
                                    } = t;
                                    return e.prev = r, r && (r.next = e), t === this.tail && (this.tail = e), t.prev = null, t.next = null, t
                                }
                            }
                        },
                        8160: (t, e, r) => {
                            "use strict";
                            const n = r(375),
                                i = r(7916),
                                s = r(1238);
                            let a, o;
                            const u = {
                                isoDate: /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/
                            };
                            e.version = s.version, e.defaults = {
                                abortEarly: !0,
                                allowUnknown: !1,
                                artifacts: !1,
                                cache: !0,
                                context: null,
                                convert: !0,
                                dateFormat: "iso",
                                errors: {
                                    escapeHtml: !1,
                                    label: "path",
                                    language: null,
                                    render: !0,
                                    stack: !1,
                                    wrap: {
                                        label: '"',
                                        array: "[]"
                                    }
                                },
                                externals: !0,
                                messages: {},
                                nonEnumerables: !1,
                                noDefaults: !1,
                                presence: "optional",
                                skipFunctions: !1,
                                stripUnknown: !1,
                                warnings: !1
                            }, e.symbols = {
                                any: Symbol.for("@hapi/joi/schema"),
                                arraySingle: Symbol("arraySingle"),
                                deepDefault: Symbol("deepDefault"),
                                errors: Symbol("errors"),
                                literal: Symbol("literal"),
                                override: Symbol("override"),
                                parent: Symbol("parent"),
                                prefs: Symbol("prefs"),
                                ref: Symbol("ref"),
                                template: Symbol("template"),
                                values: Symbol("values")
                            }, e.assertOptions = function(t, e, r = "Options") {
                                n(t && "object" == typeof t && !Array.isArray(t), "Options must be of type object");
                                const i = Object.keys(t).filter(t => !e.includes(t));
                                n(0 === i.length, "".concat(r, " contain unknown keys: ").concat(i))
                            }, e.checkPreferences = function(t) {
                                o = o || r(3378);
                                const e = o.preferences.validate(t);
                                if (e.error) throw new i([e.error.details[0].message])
                            }, e.compare = function(t, e, r) {
                                switch (r) {
                                    case "=":
                                        return t === e;
                                    case ">":
                                        return t > e;
                                    case "<":
                                        return t < e;
                                    case ">=":
                                        return t >= e;
                                    case "<=":
                                        return t <= e
                                }
                            }, e.default = function(t, e) {
                                return void 0 === t ? e : t
                            }, e.isIsoDate = function(t) {
                                return u.isoDate.test(t)
                            }, e.isNumber = function(t) {
                                return "number" == typeof t && !isNaN(t)
                            }, e.isResolvable = function(t) {
                                return !!t && (t[e.symbols.ref] || t[e.symbols.template])
                            }, e.isSchema = function(t, r = {}) {
                                const i = t && t[e.symbols.any];
                                return !!i && (n(r.legacy || i.version === e.version, "Cannot mix different versions of joi schemas"), !0)
                            }, e.isValues = function(t) {
                                return t[e.symbols.values]
                            }, e.limit = function(t) {
                                return Number.isSafeInteger(t) && t >= 0
                            }, e.preferences = function(t, n) {
                                a = a || r(6914), t = t || {}, n = n || {};
                                const i = Object.assign({}, t, n);
                                return n.errors && t.errors && (i.errors = Object.assign({}, t.errors, n.errors), i.errors.wrap = Object.assign({}, t.errors.wrap, n.errors.wrap)), n.messages && (i.messages = a.compile(n.messages, t.messages)), delete i[e.symbols.prefs], i
                            }, e.tryWithPath = function(t, e, r = {}) {
                                try {
                                    return t()
                                } catch (t) {
                                    throw void 0 !== t.path ? t.path = e + "." + t.path : t.path = e, r.append && (t.message = "".concat(t.message, " (").concat(t.path, ")")), t
                                }
                            }, e.validateArg = function(t, r, {
                                assert: n,
                                message: i
                            }) {
                                if (e.isSchema(n)) {
                                    const e = n.validate(t);
                                    if (!e.error) return;
                                    return e.error.message
                                }
                                if (!n(t)) return r ? "".concat(r, " ").concat(i) : i
                            }, e.verifyFlat = function(t, e) {
                                for (const r of t) n(!Array.isArray(r), "Method no longer accepts array arguments:", e)
                            }
                        },
                        3292: (t, e, r) => {
                            "use strict";
                            const n = r(375),
                                i = r(8160),
                                s = r(6133),
                                a = {};
                            e.schema = function(t, e, r = {}) {
                                i.assertOptions(r, ["appendPath", "override"]);
                                try {
                                    return a.schema(t, e, r)
                                } catch (t) {
                                    throw r.appendPath && void 0 !== t.path && (t.message = "".concat(t.message, " (").concat(t.path, ")")), t
                                }
                            }, a.schema = function(t, e, r) {
                                n(void 0 !== e, "Invalid undefined schema"), Array.isArray(e) && (n(e.length, "Invalid empty array schema"), 1 === e.length && (e = e[0]));
                                const s = (e, ...n) => !1 !== r.override ? e.valid(t.override, ...n) : e.valid(...n);
                                if (a.simple(e)) return s(t, e);
                                if ("function" == typeof e) return t.custom(e);
                                if (n("object" == typeof e, "Invalid schema content:", typeof e), i.isResolvable(e)) return s(t, e);
                                if (i.isSchema(e)) return e;
                                if (Array.isArray(e)) {
                                    for (const r of e)
                                        if (!a.simple(r)) return t.alternatives().try(...e);
                                    return s(t, ...e)
                                }
                                return e instanceof RegExp ? t.string().regex(e) : e instanceof Date ? s(t.date(), e) : (n(Object.getPrototypeOf(e) === Object.getPrototypeOf({}), "Schema can only contain plain objects"), t.object().keys(e))
                            }, e.ref = function(t, e) {
                                return s.isRef(t) ? t : s.create(t, e)
                            }, e.compile = function(t, r, s = {}) {
                                i.assertOptions(s, ["legacy"]);
                                const o = r && r[i.symbols.any];
                                if (o) return n(s.legacy || o.version === i.version, "Cannot mix different versions of joi schemas:", o.version, i.version), r;
                                if ("object" != typeof r || !s.legacy) return e.schema(t, r, {
                                    appendPath: !0
                                });
                                const u = a.walk(r);
                                return u ? u.compile(u.root, r) : e.schema(t, r, {
                                    appendPath: !0
                                })
                            }, a.walk = function(t) {
                                if ("object" != typeof t) return null;
                                if (Array.isArray(t)) {
                                    for (const e of t) {
                                        const t = a.walk(e);
                                        if (t) return t
                                    }
                                    return null
                                }
                                const e = t[i.symbols.any];
                                if (e) return {
                                    root: t[e.root],
                                    compile: e.compile
                                };
                                n(Object.getPrototypeOf(t) === Object.getPrototypeOf({}), "Schema can only contain plain objects");
                                for (const r in t) {
                                    const e = a.walk(t[r]);
                                    if (e) return e
                                }
                                return null
                            }, a.simple = function(t) {
                                return null === t || ["boolean", "string", "number"].includes(typeof t)
                            }, e.when = function(t, r, o) {
                                if (void 0 === o && (n(r && "object" == typeof r, "Missing options"), o = r, r = s.create(".")), Array.isArray(o) && (o = {
                                        switch: o
                                    }), i.assertOptions(o, ["is", "not", "then", "otherwise", "switch", "break"]), i.isSchema(r)) return n(void 0 === o.is, '"is" can not be used with a schema condition'), n(void 0 === o.not, '"not" can not be used with a schema condition'), n(void 0 === o.switch, '"switch" can not be used with a schema condition'), a.condition(t, {
                                    is: r,
                                    then: o.then,
                                    otherwise: o.otherwise,
                                    break: o.break
                                });
                                if (n(s.isRef(r) || "string" == typeof r, "Invalid condition:", r), n(void 0 === o.not || void 0 === o.is, 'Cannot combine "is" with "not"'), void 0 === o.switch) {
                                    let u = o;
                                    void 0 !== o.not && (u = {
                                        is: o.not,
                                        then: o.otherwise,
                                        otherwise: o.then,
                                        break: o.break
                                    });
                                    let h = void 0 !== u.is ? t.$_compile(u.is) : t.$_root.invalid(null, !1, 0, "").required();
                                    return n(void 0 !== u.then || void 0 !== u.otherwise, 'options must have at least one of "then", "otherwise", or "switch"'), n(void 0 === u.break || void 0 === u.then || void 0 === u.otherwise, "Cannot specify then, otherwise, and break all together"), void 0 === o.is || s.isRef(o.is) || i.isSchema(o.is) || (h = h.required()), a.condition(t, {
                                        ref: e.ref(r),
                                        is: h,
                                        then: u.then,
                                        otherwise: u.otherwise,
                                        break: u.break
                                    })
                                }
                                n(Array.isArray(o.switch), '"switch" must be an array'), n(void 0 === o.is, 'Cannot combine "switch" with "is"'), n(void 0 === o.not, 'Cannot combine "switch" with "not"'), n(void 0 === o.then, 'Cannot combine "switch" with "then"');
                                const u = {
                                    ref: e.ref(r),
                                    switch: [],
                                    break: o.break
                                };
                                for (let e = 0; e < o.switch.length; ++e) {
                                    const r = o.switch[e],
                                        a = e === o.switch.length - 1;
                                    i.assertOptions(r, a ? ["is", "then", "otherwise"] : ["is", "then"]), n(void 0 !== r.is, 'Switch statement missing "is"'), n(void 0 !== r.then, 'Switch statement missing "then"');
                                    const h = {
                                        is: t.$_compile(r.is),
                                        then: t.$_compile(r.then)
                                    };
                                    if (s.isRef(r.is) || i.isSchema(r.is) || (h.is = h.is.required()), a) {
                                        n(void 0 === o.otherwise || void 0 === r.otherwise, 'Cannot specify "otherwise" inside and outside a "switch"');
                                        const e = void 0 !== o.otherwise ? o.otherwise : r.otherwise;
                                        void 0 !== e && (n(void 0 === u.break, "Cannot specify both otherwise and break"), h.otherwise = t.$_compile(e))
                                    }
                                    u.switch.push(h)
                                }
                                return u
                            }, a.condition = function(t, e) {
                                for (const r of ["then", "otherwise"]) void 0 === e[r] ? delete e[r] : e[r] = t.$_compile(e[r]);
                                return e
                            }
                        },
                        6354: (t, e, r) => {
                            "use strict";
                            const n = r(5688),
                                i = r(8160),
                                s = r(3328);
                            e.Report = class {
                                constructor(t, r, n, i, s, a, o) {
                                    if (this.code = t, this.flags = i, this.messages = s, this.path = a.path, this.prefs = o, this.state = a, this.value = r, this.message = null, this.template = null, this.local = n || {}, this.local.label = e.label(this.flags, this.state, this.prefs, this.messages), void 0 === this.value || this.local.hasOwnProperty("value") || (this.local.value = this.value), this.path.length) {
                                        const t = this.path[this.path.length - 1];
                                        "object" != typeof t && (this.local.key = t)
                                    }
                                }
                                _setTemplate(t) {
                                    if (this.template = t, !this.flags.label && 0 === this.path.length) {
                                        const t = this._template(this.template, "root");
                                        t && (this.local.label = t)
                                    }
                                }
                                toString() {
                                    if (this.message) return this.message;
                                    const t = this.code;
                                    if (!this.prefs.errors.render) return this.code;
                                    const e = this._template(this.template) || this._template(this.prefs.messages) || this._template(this.messages);
                                    return void 0 === e ? 'Error code "'.concat(t, '" is not defined, your custom type is missing the correct messages definition') : (this.message = e.render(this.value, this.state, this.prefs, this.local, {
                                        errors: this.prefs.errors,
                                        messages: [this.prefs.messages, this.messages]
                                    }), this.prefs.errors.label || (this.message = this.message.replace(/^"" /, "").trim()), this.message)
                                }
                                _template(t, r) {
                                    return e.template(this.value, t, r || this.code, this.state, this.prefs)
                                }
                            }, e.path = function(t) {
                                let e = "";
                                for (const r of t) "object" != typeof r && ("string" == typeof r ? (e && (e += "."), e += r) : e += "[".concat(r, "]"));
                                return e
                            }, e.template = function(t, e, r, n, a) {
                                if (!e) return;
                                if (s.isTemplate(e)) return "root" !== r ? e : null;
                                let o = a.errors.language;
                                if (i.isResolvable(o) && (o = o.resolve(t, n, a)), o && e[o]) {
                                    if (void 0 !== e[o][r]) return e[o][r];
                                    if (void 0 !== e[o]["*"]) return e[o]["*"]
                                }
                                return e[r] ? e[r] : e["*"]
                            }, e.label = function(t, r, n, i) {
                                if (t.label) return t.label;
                                if (!n.errors.label) return "";
                                let s = r.path;
                                return "key" === n.errors.label && r.path.length > 1 && (s = r.path.slice(-1)), e.path(s) || e.template(null, n.messages, "root", r, n) || i && e.template(null, i, "root", r, n) || "value"
                            }, e.process = function(t, r, n) {
                                if (!t) return null;
                                const {
                                    override: i,
                                    message: s,
                                    details: a
                                } = e.details(t);
                                if (i) return i;
                                if (n.errors.stack) return new e.ValidationError(s, a, r);
                                const o = Error.stackTraceLimit;
                                Error.stackTraceLimit = 0;
                                const u = new e.ValidationError(s, a, r);
                                return Error.stackTraceLimit = o, u
                            }, e.details = function(t, e = {}) {
                                let r = [];
                                const n = [];
                                for (const i of t) {
                                    if (i instanceof Error) {
                                        if (!1 !== e.override) return {
                                            override: i
                                        };
                                        const t = i.toString();
                                        r.push(t), n.push({
                                            message: t,
                                            type: "override",
                                            context: {
                                                error: i
                                            }
                                        });
                                        continue
                                    }
                                    const t = i.toString();
                                    r.push(t), n.push({
                                        message: t,
                                        path: i.path.filter(t => "object" != typeof t),
                                        type: i.code,
                                        context: i.local
                                    })
                                }
                                return r.length > 1 && (r = [...new Set(r)]), {
                                    message: r.join(". "),
                                    details: n
                                }
                            }, e.ValidationError = class extends Error {
                                constructor(t, e, r) {
                                    super(t), this._original = r, this.details = e
                                }
                                static isError(t) {
                                    return t instanceof e.ValidationError
                                }
                            }, e.ValidationError.prototype.isJoi = !0, e.ValidationError.prototype.name = "ValidationError", e.ValidationError.prototype.annotate = n.error
                        },
                        8901: (t, e, r) => {
                            "use strict";
                            const n = r(375),
                                i = r(8571),
                                s = r(8160),
                                a = r(6914),
                                o = {};
                            e.type = function(t, e) {
                                const r = Object.getPrototypeOf(t),
                                    u = i(r),
                                    h = t._assign(Object.create(u)),
                                    f = Object.assign({}, e);
                                delete f.base, u._definition = f;
                                const c = r._definition || {};
                                f.messages = a.merge(c.messages, f.messages), f.properties = Object.assign({}, c.properties, f.properties), h.type = f.type, f.flags = Object.assign({}, c.flags, f.flags);
                                const l = Object.assign({}, c.terms);
                                if (f.terms)
                                    for (const i in f.terms) {
                                        const t = f.terms[i];
                                        n(void 0 === h.$_terms[i], "Invalid term override for", f.type, i), h.$_terms[i] = t.init, l[i] = t
                                    }
                                f.terms = l, f.args || (f.args = c.args), f.prepare = o.prepare(f.prepare, c.prepare), f.coerce && ("function" == typeof f.coerce && (f.coerce = {
                                    method: f.coerce
                                }), f.coerce.from && !Array.isArray(f.coerce.from) && (f.coerce = {
                                    method: f.coerce.method,
                                    from: [].concat(f.coerce.from)
                                })), f.coerce = o.coerce(f.coerce, c.coerce), f.validate = o.validate(f.validate, c.validate);
                                const d = Object.assign({}, c.rules);
                                if (f.rules)
                                    for (const i in f.rules) {
                                        const t = f.rules[i];
                                        n("object" == typeof t, "Invalid rule definition for", f.type, i);
                                        let e = t.method;
                                        if (void 0 === e && (e = function() {
                                                return this.$_addRule(i)
                                            }), e && (n(!u[i], "Rule conflict in", f.type, i), u[i] = e), n(!d[i], "Rule conflict in", f.type, i), d[i] = t, t.alias) {
                                            const e = [].concat(t.alias);
                                            for (const r of e) u[r] = t.method
                                        }
                                        t.args && (t.argsByName = new Map, t.args = t.args.map(e => ("string" == typeof e && (e = {
                                            name: e
                                        }), n(!t.argsByName.has(e.name), "Duplicated argument name", e.name), s.isSchema(e.assert) && (e.assert = e.assert.strict().label(e.name)), t.argsByName.set(e.name, e), e)))
                                    }
                                f.rules = d;
                                const p = Object.assign({}, c.modifiers);
                                if (f.modifiers)
                                    for (const i in f.modifiers) {
                                        n(!u[i], "Rule conflict in", f.type, i);
                                        const t = f.modifiers[i];
                                        n("function" == typeof t, "Invalid modifier definition for", f.type, i);
                                        const e = function(t) {
                                            return this.rule({
                                                [i]: t
                                            })
                                        };
                                        u[i] = e, p[i] = t
                                    }
                                if (f.modifiers = p, f.overrides) {
                                    u._super = r, h.$_super = {};
                                    for (const t in f.overrides) n(r[t], "Cannot override missing", t), f.overrides[t][s.symbols.parent] = r[t], h.$_super[t] = r[t].bind(h);
                                    Object.assign(u, f.overrides)
                                }
                                f.cast = Object.assign({}, c.cast, f.cast);
                                const m = Object.assign({}, c.manifest, f.manifest);
                                return m.build = o.build(f.manifest && f.manifest.build, c.manifest && c.manifest.build), f.manifest = m, f.rebuild = o.rebuild(f.rebuild, c.rebuild), h
                            }, o.build = function(t, e) {
                                return t && e ? function(r, n) {
                                    return e(t(r, n), n)
                                } : t || e
                            }, o.coerce = function(t, e) {
                                return t && e ? {
                                    from: t.from && e.from ? [...new Set([...t.from, ...e.from])] : null,
                                    method(r, n) {
                                        let i;
                                        if ((!e.from || e.from.includes(typeof r)) && (i = e.method(r, n), i)) {
                                            if (i.errors || void 0 === i.value) return i;
                                            r = i.value
                                        }
                                        if (!t.from || t.from.includes(typeof r)) {
                                            const e = t.method(r, n);
                                            if (e) return e
                                        }
                                        return i
                                    }
                                } : t || e
                            }, o.prepare = function(t, e) {
                                return t && e ? function(r, n) {
                                    const i = t(r, n);
                                    if (i) {
                                        if (i.errors || void 0 === i.value) return i;
                                        r = i.value
                                    }
                                    return e(r, n) || i
                                } : t || e
                            }, o.rebuild = function(t, e) {
                                return t && e ? function(r) {
                                    e(r), t(r)
                                } : t || e
                            }, o.validate = function(t, e) {
                                return t && e ? function(r, n) {
                                    const i = e(r, n);
                                    if (i) {
                                        if (i.errors && (!Array.isArray(i.errors) || i.errors.length)) return i;
                                        r = i.value
                                    }
                                    return t(r, n) || i
                                } : t || e
                            }
                        },
                        5107: (t, e, r) => {
                            "use strict";
                            const n = r(375),
                                i = r(8571),
                                s = r(8652),
                                a = r(8160),
                                o = r(3292),
                                u = r(6354),
                                h = r(8901),
                                f = r(9708),
                                c = r(6133),
                                l = r(3328),
                                d = r(1152);
                            let p;
                            const m = {
                                types: {
                                    alternatives: r(4946),
                                    any: r(8068),
                                    array: r(546),
                                    boolean: r(4937),
                                    date: r(7500),
                                    function: r(390),
                                    link: r(8785),
                                    number: r(3832),
                                    object: r(8966),
                                    string: r(7417),
                                    symbol: r(8826)
                                },
                                aliases: {
                                    alt: "alternatives",
                                    bool: "boolean",
                                    func: "function"
                                },
                                root: function() {
                                    const t = {
                                        _types: new Set(Object.keys(m.types))
                                    };
                                    for (const e of t._types) t[e] = function(...t) {
                                        return n(!t.length || ["alternatives", "link", "object"].includes(e), "The", e, "type does not allow arguments"), m.generate(this, m.types[e], t)
                                    };
                                    for (const e of ["allow", "custom", "disallow", "equal", "exist", "forbidden", "invalid", "not", "only", "optional", "options", "prefs", "preferences", "required", "strip", "valid", "when"]) t[e] = function(...t) {
                                        return this.any()[e](...t)
                                    };
                                    Object.assign(t, m.methods);
                                    for (const e in m.aliases) {
                                        const r = m.aliases[e];
                                        t[e] = t[r]
                                    }
                                    return t.x = t.expression, d.setup && d.setup(t), t
                                }
                            };
                            m.methods = {
                                ValidationError: u.ValidationError,
                                version: a.version,
                                cache: s.provider,
                                assert(t, e, ...r) {
                                    m.assert(t, e, !0, r)
                                },
                                attempt: (t, e, ...r) => m.assert(t, e, !1, r),
                                build(t) {
                                    return n("function" == typeof f.build, "Manifest functionality disabled"), f.build(this, t)
                                },
                                checkPreferences(t) {
                                    a.checkPreferences(t)
                                },
                                compile(t, e) {
                                    return o.compile(this, t, e)
                                },
                                defaults(t) {
                                    n("function" == typeof t, "modifier must be a function");
                                    const e = Object.assign({}, this);
                                    for (const r of e._types) {
                                        const i = t(e[r]());
                                        n(a.isSchema(i), "modifier must return a valid schema object"), e[r] = function(...t) {
                                            return m.generate(this, i, t)
                                        }
                                    }
                                    return e
                                },
                                expression: (...t) => new l(...t),
                                extend(...t) {
                                    a.verifyFlat(t, "extend"), p = p || r(3378), n(t.length, "You need to provide at least one extension"), this.assert(t, p.extensions);
                                    const e = Object.assign({}, this);
                                    e._types = new Set(e._types);
                                    for (let r of t) {
                                        "function" == typeof r && (r = r(e)), this.assert(r, p.extension);
                                        const t = m.expandExtension(r, e);
                                        for (const r of t) {
                                            n(void 0 === e[r.type] || e._types.has(r.type), "Cannot override name", r.type);
                                            const t = r.base || this.any(),
                                                i = h.type(t, r);
                                            e._types.add(r.type), e[r.type] = function(...t) {
                                                return m.generate(this, i, t)
                                            }
                                        }
                                    }
                                    return e
                                },
                                isError: u.ValidationError.isError,
                                isExpression: l.isTemplate,
                                isRef: c.isRef,
                                isSchema: a.isSchema,
                                in: (...t) => c.in(...t),
                                override: a.symbols.override,
                                ref: (...t) => c.create(...t),
                                types() {
                                    const t = {};
                                    for (const e of this._types) t[e] = this[e]();
                                    for (const e in m.aliases) t[e] = this[e]();
                                    return t
                                }
                            }, m.assert = function(t, e, r, n) {
                                const s = n[0] instanceof Error || "string" == typeof n[0] ? n[0] : null,
                                    o = s ? n[1] : n[0],
                                    h = e.validate(t, a.preferences({
                                        errors: {
                                            stack: !0
                                        }
                                    }, o || {}));
                                let f = h.error;
                                if (!f) return h.value;
                                if (s instanceof Error) throw s;
                                const c = r && "function" == typeof f.annotate ? f.annotate() : f.message;
                                throw f instanceof u.ValidationError == 0 && (f = i(f)), f.message = s ? "".concat(s, " ").concat(c) : c, f
                            }, m.generate = function(t, e, r) {
                                return n(t, "Must be invoked on a Joi instance."), e.$_root = t, e._definition.args && r.length ? e._definition.args(e, ...r) : e
                            }, m.expandExtension = function(t, e) {
                                if ("string" == typeof t.type) return [t];
                                const r = [];
                                for (const n of e._types)
                                    if (t.type.test(n)) {
                                        const i = Object.assign({}, t);
                                        i.type = n, i.base = e[n](), r.push(i)
                                    }
                                return r
                            }, t.exports = m.root()
                        },
                        6914: (t, e, r) => {
                            "use strict";
                            const n = r(375),
                                i = r(8571),
                                s = r(3328);
                            e.compile = function(t, e) {
                                if ("string" == typeof t) return n(!e, "Cannot set single message string"), new s(t);
                                if (s.isTemplate(t)) return n(!e, "Cannot set single message template"), t;
                                n("object" == typeof t && !Array.isArray(t), "Invalid message options"), e = e ? i(e) : {};
                                for (let r in t) {
                                    const i = t[r];
                                    if ("root" === r || s.isTemplate(i)) {
                                        e[r] = i;
                                        continue
                                    }
                                    if ("string" == typeof i) {
                                        e[r] = new s(i);
                                        continue
                                    }
                                    n("object" == typeof i && !Array.isArray(i), "Invalid message for", r);
                                    const a = r;
                                    for (r in e[a] = e[a] || {}, i) {
                                        const t = i[r];
                                        "root" === r || s.isTemplate(t) ? e[a][r] = t : (n("string" == typeof t, "Invalid message for", r, "in", a), e[a][r] = new s(t))
                                    }
                                }
                                return e
                            }, e.decompile = function(t) {
                                const e = {};
                                for (let r in t) {
                                    const n = t[r];
                                    if ("root" === r) {
                                        e.root = n;
                                        continue
                                    }
                                    if (s.isTemplate(n)) {
                                        e[r] = n.describe({
                                            compact: !0
                                        });
                                        continue
                                    }
                                    const i = r;
                                    for (r in e[i] = {}, n) {
                                        const t = n[r];
                                        "root" !== r ? e[i][r] = t.describe({
                                            compact: !0
                                        }) : e[i].root = t
                                    }
                                }
                                return e
                            }, e.merge = function(t, r) {
                                if (!t) return e.compile(r);
                                if (!r) return t;
                                if ("string" == typeof r) return new s(r);
                                if (s.isTemplate(r)) return r;
                                const a = i(t);
                                for (let e in r) {
                                    const t = r[e];
                                    if ("root" === e || s.isTemplate(t)) {
                                        a[e] = t;
                                        continue
                                    }
                                    if ("string" == typeof t) {
                                        a[e] = new s(t);
                                        continue
                                    }
                                    n("object" == typeof t && !Array.isArray(t), "Invalid message for", e);
                                    const i = e;
                                    for (e in a[i] = a[i] || {}, t) {
                                        const r = t[e];
                                        "root" === e || s.isTemplate(r) ? a[i][e] = r : (n("string" == typeof r, "Invalid message for", e, "in", i), a[i][e] = new s(r))
                                    }
                                }
                                return a
                            }
                        },
                        2294: (t, e, r) => {
                            "use strict";

                            function n(t, e) {
                                var r = Object.keys(t);
                                if (Object.getOwnPropertySymbols) {
                                    var n = Object.getOwnPropertySymbols(t);
                                    e && (n = n.filter((function(e) {
                                        return Object.getOwnPropertyDescriptor(t, e).enumerable
                                    }))), r.push.apply(r, n)
                                }
                                return r
                            }

                            function i(t) {
                                for (var e = 1; e < arguments.length; e++) {
                                    var r = null != arguments[e] ? arguments[e] : {};
                                    e % 2 ? n(Object(r), !0).forEach((function(e) {
                                        s(t, e, r[e])
                                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : n(Object(r)).forEach((function(e) {
                                        Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(r, e))
                                    }))
                                }
                                return t
                            }

                            function s(t, e, r) {
                                return e in t ? Object.defineProperty(t, e, {
                                    value: r,
                                    enumerable: !0,
                                    configurable: !0,
                                    writable: !0
                                }) : t[e] = r, t
                            }
                            const a = r(375),
                                o = r(8160),
                                u = r(6133),
                                h = {};
                            e.Ids = h.Ids = class {
                                constructor() {
                                    this._byId = new Map, this._byKey = new Map, this._schemaChain = !1
                                }
                                clone() {
                                    const t = new h.Ids;
                                    return t._byId = new Map(this._byId), t._byKey = new Map(this._byKey), t._schemaChain = this._schemaChain, t
                                }
                                concat(t) {
                                    t._schemaChain && (this._schemaChain = !0);
                                    for (const [e, r] of t._byId.entries()) a(!this._byKey.has(e), "Schema id conflicts with existing key:", e), this._byId.set(e, r);
                                    for (const [e, r] of t._byKey.entries()) a(!this._byId.has(e), "Schema key conflicts with existing id:", e), this._byKey.set(e, r)
                                }
                                fork(t, e, r) {
                                    const n = this._collect(t);
                                    n.push({
                                        schema: r
                                    });
                                    const i = n.shift();
                                    let s = {
                                        id: i.id,
                                        schema: e(i.schema)
                                    };
                                    a(o.isSchema(s.schema), "adjuster function failed to return a joi schema type");
                                    for (const a of n) s = {
                                        id: a.id,
                                        schema: h.fork(a.schema, s.id, s.schema)
                                    };
                                    return s.schema
                                }
                                labels(t, e = []) {
                                    const r = t[0],
                                        n = this._get(r);
                                    if (!n) return [...e, ...t].join(".");
                                    const i = t.slice(1);
                                    return e = [...e, n.schema._flags.label || r], i.length ? n.schema._ids.labels(i, e) : e.join(".")
                                }
                                reach(t, e = []) {
                                    const r = t[0],
                                        n = this._get(r);
                                    a(n, "Schema does not contain path", [...e, ...t].join("."));
                                    const i = t.slice(1);
                                    return i.length ? n.schema._ids.reach(i, [...e, r]) : n.schema
                                }
                                register(t, {
                                    key: e
                                } = {}) {
                                    if (!t || !o.isSchema(t)) return;
                                    (t.$_property("schemaChain") || t._ids._schemaChain) && (this._schemaChain = !0);
                                    const r = t._flags.id;
                                    if (r) {
                                        const e = this._byId.get(r);
                                        a(!e || e.schema === t, "Cannot add different schemas with the same id:", r), a(!this._byKey.has(r), "Schema id conflicts with existing key:", r), this._byId.set(r, {
                                            schema: t,
                                            id: r
                                        })
                                    }
                                    e && (a(!this._byKey.has(e), "Schema already contains key:", e), a(!this._byId.has(e), "Schema key conflicts with existing id:", e), this._byKey.set(e, {
                                        schema: t,
                                        id: e
                                    }))
                                }
                                reset() {
                                    this._byId = new Map, this._byKey = new Map, this._schemaChain = !1
                                }
                                _collect(t, e = [], r = []) {
                                    const n = t[0],
                                        i = this._get(n);
                                    a(i, "Schema does not contain path", [...e, ...t].join(".")), r = [i, ...r];
                                    const s = t.slice(1);
                                    return s.length ? i.schema._ids._collect(s, [...e, n], r) : r
                                }
                                _get(t) {
                                    return this._byId.get(t) || this._byKey.get(t)
                                }
                            }, h.fork = function(t, r, n) {
                                const i = e.schema(t, {
                                    each: (t, {
                                        key: e
                                    }) => {
                                        if (r === (t._flags.id || e)) return n
                                    },
                                    ref: !1
                                });
                                return i ? i.$_mutateRebuild() : t
                            }, e.schema = function(t, e) {
                                let r;
                                for (const n in t._flags) {
                                    if ("_" === n[0]) continue;
                                    const i = h.scan(t._flags[n], {
                                        source: "flags",
                                        name: n
                                    }, e);
                                    void 0 !== i && (r = r || t.clone(), r._flags[n] = i)
                                }
                                for (let n = 0; n < t._rules.length; ++n) {
                                    const i = t._rules[n],
                                        s = h.scan(i.args, {
                                            source: "rules",
                                            name: i.name
                                        }, e);
                                    if (void 0 !== s) {
                                        r = r || t.clone();
                                        const e = Object.assign({}, i);
                                        e.args = s, r._rules[n] = e, r._singleRules.get(i.name) === i && r._singleRules.set(i.name, e)
                                    }
                                }
                                for (const n in t.$_terms) {
                                    if ("_" === n[0]) continue;
                                    const i = h.scan(t.$_terms[n], {
                                        source: "terms",
                                        name: n
                                    }, e);
                                    void 0 !== i && (r = r || t.clone(), r.$_terms[n] = i)
                                }
                                return r
                            }, h.scan = function(t, e, r, n, s) {
                                const a = n || [];
                                if (null === t || "object" != typeof t) return;
                                let f;
                                if (Array.isArray(t)) {
                                    for (let n = 0; n < t.length; ++n) {
                                        const i = "terms" === e.source && "keys" === e.name && t[n].key,
                                            s = h.scan(t[n], e, r, [n, ...a], i);
                                        void 0 !== s && (f = f || t.slice(), f[n] = s)
                                    }
                                    return f
                                }
                                if (!1 !== r.schema && o.isSchema(t) || !1 !== r.ref && u.isRef(t)) {
                                    const n = r.each(t, i(i({}, e), {}, {
                                        path: a,
                                        key: s
                                    }));
                                    if (n === t) return;
                                    return n
                                }
                                for (const i in t) {
                                    if ("_" === i[0]) continue;
                                    const n = h.scan(t[i], e, r, [i, ...a], s);
                                    void 0 !== n && (f = f || Object.assign({}, t), f[i] = n)
                                }
                                return f
                            }
                        },
                        6133: (t, e, r) => {
                            "use strict";

                            function n(t, e) {
                                var r = Object.keys(t);
                                if (Object.getOwnPropertySymbols) {
                                    var n = Object.getOwnPropertySymbols(t);
                                    e && (n = n.filter((function(e) {
                                        return Object.getOwnPropertyDescriptor(t, e).enumerable
                                    }))), r.push.apply(r, n)
                                }
                                return r
                            }

                            function i(t) {
                                for (var e = 1; e < arguments.length; e++) {
                                    var r = null != arguments[e] ? arguments[e] : {};
                                    e % 2 ? n(Object(r), !0).forEach((function(e) {
                                        s(t, e, r[e])
                                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : n(Object(r)).forEach((function(e) {
                                        Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(r, e))
                                    }))
                                }
                                return t
                            }

                            function s(t, e, r) {
                                return e in t ? Object.defineProperty(t, e, {
                                    value: r,
                                    enumerable: !0,
                                    configurable: !0,
                                    writable: !0
                                }) : t[e] = r, t
                            }
                            const a = r(375),
                                o = r(8571),
                                u = r(9621),
                                h = r(8160);
                            let f;
                            const c = {
                                symbol: Symbol("ref"),
                                defaults: {
                                    adjust: null,
                                    in: !1,
                                    iterables: null,
                                    map: null,
                                    separator: ".",
                                    type: "value"
                                }
                            };
                            e.create = function(t, e = {}) {
                                a("string" == typeof t, "Invalid reference key:", t), h.assertOptions(e, ["adjust", "ancestor", "in", "iterables", "map", "prefix", "render", "separator"]), a(!e.prefix || "object" == typeof e.prefix, "options.prefix must be of type object");
                                const r = Object.assign({}, c.defaults, e);
                                delete r.prefix;
                                const n = r.separator,
                                    i = c.context(t, n, e.prefix);
                                if (r.type = i.type, t = i.key, "value" === r.type)
                                    if (i.root && (a(!n || t[0] !== n, "Cannot specify relative path with root prefix"), r.ancestor = "root", t || (t = null)), n && n === t) t = null, r.ancestor = 0;
                                    else if (void 0 !== r.ancestor) a(!n || !t || t[0] !== n, "Cannot combine prefix with ancestor option");
                                else {
                                    const [e, i] = c.ancestor(t, n);
                                    i && "" === (t = t.slice(i)) && (t = null), r.ancestor = e
                                }
                                return r.path = n ? null === t ? [] : t.split(n) : [t], new c.Ref(r)
                            }, e.in = function(t, r = {}) {
                                return e.create(t, i(i({}, r), {}, { in: !0
                                }))
                            }, e.isRef = function(t) {
                                return !!t && !!t[h.symbols.ref]
                            }, c.Ref = class {
                                constructor(t) {
                                    a("object" == typeof t, "Invalid reference construction"), h.assertOptions(t, ["adjust", "ancestor", "in", "iterables", "map", "path", "render", "separator", "type", "depth", "key", "root", "display"]), a([!1, void 0].includes(t.separator) || "string" == typeof t.separator && 1 === t.separator.length, "Invalid separator"), a(!t.adjust || "function" == typeof t.adjust, "options.adjust must be a function"), a(!t.map || Array.isArray(t.map), "options.map must be an array"), a(!t.map || !t.adjust, "Cannot set both map and adjust options"), Object.assign(this, c.defaults, t), a("value" === this.type || void 0 === this.ancestor, "Non-value references cannot reference ancestors"), Array.isArray(this.map) && (this.map = new Map(this.map)), this.depth = this.path.length, this.key = this.path.length ? this.path.join(this.separator) : null, this.root = this.path[0], this.updateDisplay()
                                }
                                resolve(t, e, r, n, i = {}) {
                                    return a(!this.in || i.in, "Invalid in() reference usage"), "global" === this.type ? this._resolve(r.context, e, i) : "local" === this.type ? this._resolve(n, e, i) : this.ancestor ? "root" === this.ancestor ? this._resolve(e.ancestors[e.ancestors.length - 1], e, i) : (a(this.ancestor <= e.ancestors.length, "Invalid reference exceeds the schema root:", this.display), this._resolve(e.ancestors[this.ancestor - 1], e, i)) : this._resolve(t, e, i)
                                }
                                _resolve(t, e, r) {
                                    let n;
                                    if ("value" === this.type && e.mainstay.shadow && !1 !== r.shadow && (n = e.mainstay.shadow.get(this.absolute(e))), void 0 === n && (n = u(t, this.path, {
                                            iterables: this.iterables,
                                            functions: !0
                                        })), this.adjust && (n = this.adjust(n)), this.map) {
                                        const t = this.map.get(n);
                                        void 0 !== t && (n = t)
                                    }
                                    return e.mainstay && e.mainstay.tracer.resolve(e, this, n), n
                                }
                                toString() {
                                    return this.display
                                }
                                absolute(t) {
                                    return [...t.path.slice(0, -this.ancestor), ...this.path]
                                }
                                clone() {
                                    return new c.Ref(this)
                                }
                                describe() {
                                    const t = {
                                        path: this.path
                                    };
                                    "value" !== this.type && (t.type = this.type), "." !== this.separator && (t.separator = this.separator), "value" === this.type && 1 !== this.ancestor && (t.ancestor = this.ancestor), this.map && (t.map = [...this.map]);
                                    for (const e of ["adjust", "iterables", "render"]) null !== this[e] && void 0 !== this[e] && (t[e] = this[e]);
                                    return !1 !== this.in && (t.in = !0), {
                                        ref: t
                                    }
                                }
                                updateDisplay() {
                                    const t = null !== this.key ? this.key : "";
                                    if ("value" !== this.type) return void(this.display = "ref:".concat(this.type, ":").concat(t));
                                    if (!this.separator) return void(this.display = "ref:".concat(t));
                                    if (!this.ancestor) return void(this.display = "ref:".concat(this.separator).concat(t));
                                    if ("root" === this.ancestor) return void(this.display = "ref:root:".concat(t));
                                    if (1 === this.ancestor) return void(this.display = "ref:".concat(t || ".."));
                                    const e = new Array(this.ancestor + 1).fill(this.separator).join("");
                                    this.display = "ref:".concat(e).concat(t || "")
                                }
                            }, c.Ref.prototype[h.symbols.ref] = !0, e.build = function(t) {
                                return "value" === (t = Object.assign({}, c.defaults, t)).type && void 0 === t.ancestor && (t.ancestor = 1), new c.Ref(t)
                            }, c.context = function(t, e, r = {}) {
                                if (t = t.trim(), r) {
                                    const n = void 0 === r.global ? "$" : r.global;
                                    if (n !== e && t.startsWith(n)) return {
                                        key: t.slice(n.length),
                                        type: "global"
                                    };
                                    const i = void 0 === r.local ? "#" : r.local;
                                    if (i !== e && t.startsWith(i)) return {
                                        key: t.slice(i.length),
                                        type: "local"
                                    };
                                    const s = void 0 === r.root ? "/" : r.root;
                                    if (s !== e && t.startsWith(s)) return {
                                        key: t.slice(s.length),
                                        type: "value",
                                        root: !0
                                    }
                                }
                                return {
                                    key: t,
                                    type: "value"
                                }
                            }, c.ancestor = function(t, e) {
                                if (!e) return [1, 0];
                                if (t[0] !== e) return [1, 0];
                                if (t[1] !== e) return [0, 1];
                                let r = 2;
                                for (; t[r] === e;) ++r;
                                return [r - 1, r]
                            }, e.toSibling = 0, e.toParent = 1, e.Manager = class {
                                constructor() {
                                    this.refs = []
                                }
                                register(t, n) {
                                    if (t)
                                        if (n = void 0 === n ? e.toParent : n, Array.isArray(t))
                                            for (const e of t) this.register(e, n);
                                        else if (h.isSchema(t))
                                        for (const e of t._refs.refs) e.ancestor - n >= 0 && this.refs.push({
                                            ancestor: e.ancestor - n,
                                            root: e.root
                                        });
                                    else e.isRef(t) && "value" === t.type && t.ancestor - n >= 0 && this.refs.push({
                                        ancestor: t.ancestor - n,
                                        root: t.root
                                    }), f = f || r(3328), f.isTemplate(t) && this.register(t.refs(), n)
                                }
                                get length() {
                                    return this.refs.length
                                }
                                clone() {
                                    const t = new e.Manager;
                                    return t.refs = o(this.refs), t
                                }
                                reset() {
                                    this.refs = []
                                }
                                roots() {
                                    return this.refs.filter(t => !t.ancestor).map(t => t.root)
                                }
                            }
                        },
                        3378: (t, e, r) => {
                            "use strict";
                            const n = r(5107),
                                i = {};
                            i.wrap = n.string().min(1).max(2).allow(!1), e.preferences = n.object({
                                allowUnknown: n.boolean(),
                                abortEarly: n.boolean(),
                                artifacts: n.boolean(),
                                cache: n.boolean(),
                                context: n.object(),
                                convert: n.boolean(),
                                dateFormat: n.valid("date", "iso", "string", "time", "utc"),
                                debug: n.boolean(),
                                errors: {
                                    escapeHtml: n.boolean(),
                                    label: n.valid("path", "key", !1),
                                    language: [n.string(), n.object().ref()],
                                    render: n.boolean(),
                                    stack: n.boolean(),
                                    wrap: {
                                        label: i.wrap,
                                        array: i.wrap,
                                        string: i.wrap
                                    }
                                },
                                externals: n.boolean(),
                                messages: n.object(),
                                noDefaults: n.boolean(),
                                nonEnumerables: n.boolean(),
                                presence: n.valid("required", "optional", "forbidden"),
                                skipFunctions: n.boolean(),
                                stripUnknown: n.object({
                                    arrays: n.boolean(),
                                    objects: n.boolean()
                                }).or("arrays", "objects").allow(!0, !1),
                                warnings: n.boolean()
                            }).strict(), i.nameRx = /^[a-zA-Z0-9]\w*$/, i.rule = n.object({
                                alias: n.array().items(n.string().pattern(i.nameRx)).single(),
                                args: n.array().items(n.string(), n.object({
                                    name: n.string().pattern(i.nameRx).required(),
                                    ref: n.boolean(),
                                    assert: n.alternatives([n.function(), n.object().schema()]).conditional("ref", {
                                        is: !0,
                                        then: n.required()
                                    }),
                                    normalize: n.function(),
                                    message: n.string().when("assert", {
                                        is: n.function(),
                                        then: n.required()
                                    })
                                })),
                                convert: n.boolean(),
                                manifest: n.boolean(),
                                method: n.function().allow(!1),
                                multi: n.boolean(),
                                validate: n.function()
                            }), e.extension = n.object({
                                type: n.alternatives([n.string(), n.object().regex()]).required(),
                                args: n.function(),
                                cast: n.object().pattern(i.nameRx, n.object({
                                    from: n.function().maxArity(1).required(),
                                    to: n.function().minArity(1).maxArity(2).required()
                                })),
                                base: n.object().schema().when("type", {
                                    is: n.object().regex(),
                                    then: n.forbidden()
                                }),
                                coerce: [n.function().maxArity(3), n.object({
                                    method: n.function().maxArity(3).required(),
                                    from: n.array().items(n.string()).single()
                                })],
                                flags: n.object().pattern(i.nameRx, n.object({
                                    setter: n.string(),
                                    default: n.any()
                                })),
                                manifest: {
                                    build: n.function().arity(2)
                                },
                                messages: [n.object(), n.string()],
                                modifiers: n.object().pattern(i.nameRx, n.function().minArity(1).maxArity(2)),
                                overrides: n.object().pattern(i.nameRx, n.function()),
                                prepare: n.function().maxArity(3),
                                rebuild: n.function().arity(1),
                                rules: n.object().pattern(i.nameRx, i.rule),
                                terms: n.object().pattern(i.nameRx, n.object({
                                    init: n.array().allow(null).required(),
                                    manifest: n.object().pattern(/.+/, [n.valid("schema", "single"), n.object({
                                        mapped: n.object({
                                            from: n.string().required(),
                                            to: n.string().required()
                                        }).required()
                                    })])
                                })),
                                validate: n.function().maxArity(3)
                            }).strict(), e.extensions = n.array().items(n.object(), n.function().arity(1)).strict(), i.desc = {
                                buffer: n.object({
                                    buffer: n.string()
                                }),
                                func: n.object({
                                    function: n.function().required(),
                                    options: {
                                        literal: !0
                                    }
                                }),
                                override: n.object({
                                    override: !0
                                }),
                                ref: n.object({
                                    ref: n.object({
                                        type: n.valid("value", "global", "local"),
                                        path: n.array().required(),
                                        separator: n.string().length(1).allow(!1),
                                        ancestor: n.number().min(0).integer().allow("root"),
                                        map: n.array().items(n.array().length(2)).min(1),
                                        adjust: n.function(),
                                        iterables: n.boolean(),
                                        in: n.boolean(),
                                        render: n.boolean()
                                    }).required()
                                }),
                                regex: n.object({
                                    regex: n.string().min(3)
                                }),
                                special: n.object({
                                    special: n.valid("deep").required()
                                }),
                                template: n.object({
                                    template: n.string().required(),
                                    options: n.object()
                                }),
                                value: n.object({
                                    value: n.alternatives([n.object(), n.array()]).required()
                                })
                            }, i.desc.entity = n.alternatives([n.array().items(n.link("...")), n.boolean(), n.function(), n.number(), n.string(), i.desc.buffer, i.desc.func, i.desc.ref, i.desc.regex, i.desc.special, i.desc.template, i.desc.value, n.link("/")]), i.desc.values = n.array().items(null, n.boolean(), n.function(), n.number().allow(1 / 0, -1 / 0), n.string().allow(""), n.symbol(), i.desc.buffer, i.desc.func, i.desc.override, i.desc.ref, i.desc.regex, i.desc.template, i.desc.value), i.desc.messages = n.object().pattern(/.+/, [n.string(), i.desc.template, n.object().pattern(/.+/, [n.string(), i.desc.template])]), e.description = n.object({
                                type: n.string().required(),
                                flags: n.object({
                                    cast: n.string(),
                                    default: n.any(),
                                    description: n.string(),
                                    empty: n.link("/"),
                                    failover: i.desc.entity,
                                    id: n.string(),
                                    label: n.string(),
                                    only: !0,
                                    presence: ["optional", "required", "forbidden"],
                                    result: ["raw", "strip"],
                                    strip: n.boolean(),
                                    unit: n.string()
                                }).unknown(),
                                preferences: {
                                    allowUnknown: n.boolean(),
                                    abortEarly: n.boolean(),
                                    artifacts: n.boolean(),
                                    cache: n.boolean(),
                                    convert: n.boolean(),
                                    dateFormat: ["date", "iso", "string", "time", "utc"],
                                    errors: {
                                        escapeHtml: n.boolean(),
                                        label: ["path", "key"],
                                        language: [n.string(), i.desc.ref],
                                        wrap: {
                                            label: i.wrap,
                                            array: i.wrap
                                        }
                                    },
                                    externals: n.boolean(),
                                    messages: i.desc.messages,
                                    noDefaults: n.boolean(),
                                    nonEnumerables: n.boolean(),
                                    presence: ["required", "optional", "forbidden"],
                                    skipFunctions: n.boolean(),
                                    stripUnknown: n.object({
                                        arrays: n.boolean(),
                                        objects: n.boolean()
                                    }).or("arrays", "objects").allow(!0, !1),
                                    warnings: n.boolean()
                                },
                                allow: i.desc.values,
                                invalid: i.desc.values,
                                rules: n.array().min(1).items({
                                    name: n.string().required(),
                                    args: n.object().min(1),
                                    keep: n.boolean(),
                                    message: [n.string(), i.desc.messages],
                                    warn: n.boolean()
                                }),
                                keys: n.object().pattern(/.*/, n.link("/")),
                                link: i.desc.ref
                            }).pattern(/^[a-z]\w*$/, n.any())
                        },
                        493: (t, e, r) => {
                            "use strict";
                            const n = r(8571),
                                i = r(9621),
                                s = r(8160),
                                a = {
                                    value: Symbol("value")
                                };
                            t.exports = a.State = class {
                                constructor(t, e, r) {
                                    this.path = t, this.ancestors = e, this.mainstay = r.mainstay, this.schemas = r.schemas, this.debug = null
                                }
                                localize(t, e = null, r = null) {
                                    const n = new a.State(t, e, this);
                                    return r && n.schemas && (n.schemas = [a.schemas(r), ...n.schemas]), n
                                }
                                nest(t, e) {
                                    const r = new a.State(this.path, this.ancestors, this);
                                    return r.schemas = r.schemas && [a.schemas(t), ...r.schemas], r.debug = e, r
                                }
                                shadow(t, e) {
                                    this.mainstay.shadow = this.mainstay.shadow || new a.Shadow, this.mainstay.shadow.set(this.path, t, e)
                                }
                                snapshot() {
                                    this.mainstay.shadow && (this._snapshot = n(this.mainstay.shadow.node(this.path)))
                                }
                                restore() {
                                    this.mainstay.shadow && (this.mainstay.shadow.override(this.path, this._snapshot), this._snapshot = void 0)
                                }
                            }, a.schemas = function(t) {
                                return s.isSchema(t) ? {
                                    schema: t
                                } : t
                            }, a.Shadow = class {
                                constructor() {
                                    this._values = null
                                }
                                set(t, e, r) {
                                    if (!t.length) return;
                                    if ("strip" === r && "number" == typeof t[t.length - 1]) return;
                                    this._values = this._values || new Map;
                                    let n = this._values;
                                    for (let i = 0; i < t.length; ++i) {
                                        const e = t[i];
                                        let r = n.get(e);
                                        r || (r = new Map, n.set(e, r)), n = r
                                    }
                                    n[a.value] = e
                                }
                                get(t) {
                                    const e = this.node(t);
                                    if (e) return e[a.value]
                                }
                                node(t) {
                                    if (this._values) return i(this._values, t, {
                                        iterables: !0
                                    })
                                }
                                override(t, e) {
                                    if (!this._values) return;
                                    const r = t.slice(0, -1),
                                        n = t[t.length - 1],
                                        s = i(this._values, r, {
                                            iterables: !0
                                        });
                                    e ? s.set(n, e) : s && s.delete(n)
                                }
                            }
                        },
                        3328: (t, e, r) => {
                            "use strict";

                            function n(t, e) {
                                var r = Object.keys(t);
                                if (Object.getOwnPropertySymbols) {
                                    var n = Object.getOwnPropertySymbols(t);
                                    e && (n = n.filter((function(e) {
                                        return Object.getOwnPropertyDescriptor(t, e).enumerable
                                    }))), r.push.apply(r, n)
                                }
                                return r
                            }

                            function i(t) {
                                for (var e = 1; e < arguments.length; e++) {
                                    var r = null != arguments[e] ? arguments[e] : {};
                                    e % 2 ? n(Object(r), !0).forEach((function(e) {
                                        s(t, e, r[e])
                                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : n(Object(r)).forEach((function(e) {
                                        Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(r, e))
                                    }))
                                }
                                return t
                            }

                            function s(t, e, r) {
                                return e in t ? Object.defineProperty(t, e, {
                                    value: r,
                                    enumerable: !0,
                                    configurable: !0,
                                    writable: !0
                                }) : t[e] = r, t
                            }
                            const a = r(375),
                                o = r(8571),
                                u = r(5277),
                                h = r(1447),
                                f = r(8160),
                                c = r(6354),
                                l = r(6133),
                                d = {
                                    symbol: Symbol("template"),
                                    opens: new Array(1e3).join("\0"),
                                    closes: new Array(1e3).join(""),
                                    dateFormat: {
                                        date: Date.prototype.toDateString,
                                        iso: Date.prototype.toISOString,
                                        string: Date.prototype.toString,
                                        time: Date.prototype.toTimeString,
                                        utc: Date.prototype.toUTCString
                                    }
                                };
                            t.exports = d.Template = class {
                                constructor(t, e) {
                                    a("string" == typeof t, "Template source must be a string"), a(!t.includes("\0") && !t.includes(""), "Template source cannot contain reserved control characters"), this.source = t, this.rendered = t, this._template = null, this._settings = o(e), this._parse()
                                }
                                _parse() {
                                    if (!this.source.includes("{")) return;
                                    const t = d.encode(this.source),
                                        e = d.split(t);
                                    let r = !1;
                                    const n = [],
                                        i = e.shift();
                                    i && n.push(i);
                                    for (const s of e) {
                                        const t = "{" !== s[0],
                                            e = t ? "}" : "}}",
                                            i = s.indexOf(e);
                                        if (-1 === i || "{" === s[1]) {
                                            n.push("{".concat(d.decode(s)));
                                            continue
                                        }
                                        let a = s.slice(t ? 0 : 1, i);
                                        const o = ":" === a[0];
                                        o && (a = a.slice(1));
                                        const u = this._ref(d.decode(a), {
                                            raw: t,
                                            wrapped: o
                                        });
                                        n.push(u), "string" != typeof u && (r = !0);
                                        const h = s.slice(i + e.length);
                                        h && n.push(d.decode(h))
                                    }
                                    r ? this._template = n : this.rendered = n.join("")
                                }
                                static date(t, e) {
                                    return d.dateFormat[e.dateFormat].call(t)
                                }
                                describe(t = {}) {
                                    if (!this._settings && t.compact) return this.source;
                                    const e = {
                                        template: this.source
                                    };
                                    return this._settings && (e.options = this._settings), e
                                }
                                static build(t) {
                                    return new d.Template(t.template, t.options)
                                }
                                isDynamic() {
                                    return !!this._template
                                }
                                static isTemplate(t) {
                                    return !!t && !!t[f.symbols.template]
                                }
                                refs() {
                                    if (!this._template) return;
                                    const t = [];
                                    for (const e of this._template) "string" != typeof e && t.push(...e.refs);
                                    return t
                                }
                                resolve(t, e, r, n) {
                                    return this._template && 1 === this._template.length ? this._part(this._template[0], t, e, r, n, {}) : this.render(t, e, r, n)
                                }
                                _part(t, ...e) {
                                    return t.ref ? t.ref.resolve(...e) : t.formula.evaluate(e)
                                }
                                render(t, e, r, n, i = {}) {
                                    if (!this.isDynamic()) return this.rendered;
                                    const s = [];
                                    for (const a of this._template)
                                        if ("string" == typeof a) s.push(a);
                                        else {
                                            const o = this._part(a, t, e, r, n, i),
                                                h = d.stringify(o, t, e, r, n, i);
                                            if (void 0 !== h) {
                                                const t = a.raw || !1 === (i.errors && i.errors.escapeHtml) ? h : u(h);
                                                s.push(d.wrap(t, a.wrapped && r.errors.wrap.label))
                                            }
                                        }
                                    return s.join("")
                                }
                                _ref(t, {
                                    raw: e,
                                    wrapped: r
                                }) {
                                    const n = [],
                                        i = t => {
                                            const e = l.create(t, this._settings);
                                            return n.push(e), t => e.resolve(...t)
                                        };
                                    try {
                                        var s = new h.Parser(t, {
                                            reference: i,
                                            functions: d.functions,
                                            constants: d.constants
                                        })
                                    } catch (e) {
                                        throw e.message = 'Invalid template variable "'.concat(t, '" fails due to: ').concat(e.message), e
                                    }
                                    if (s.single) {
                                        if ("reference" === s.single.type) {
                                            const t = n[0];
                                            return {
                                                ref: t,
                                                raw: e,
                                                refs: n,
                                                wrapped: r || "local" === t.type && "label" === t.key
                                            }
                                        }
                                        return d.stringify(s.single.value)
                                    }
                                    return {
                                        formula: s,
                                        raw: e,
                                        refs: n
                                    }
                                }
                                toString() {
                                    return this.source
                                }
                            }, d.Template.prototype[f.symbols.template] = !0, d.Template.prototype.isImmutable = !0, d.encode = function(t) {
                                return t.replace(/\\(\{+)/g, (t, e) => d.opens.slice(0, e.length)).replace(/\\(\}+)/g, (t, e) => d.closes.slice(0, e.length))
                            }, d.decode = function(t) {
                                return t.replace(/\u0000/g, "{").replace(/\u0001/g, "}")
                            }, d.split = function(t) {
                                const e = [];
                                let r = "";
                                for (let n = 0; n < t.length; ++n) {
                                    const i = t[n];
                                    if ("{" === i) {
                                        let i = "";
                                        for (; n + 1 < t.length && "{" === t[n + 1];) i += "{", ++n;
                                        e.push(r), r = i
                                    } else r += i
                                }
                                return e.push(r), e
                            }, d.wrap = function(t, e) {
                                return e ? 1 === e.length ? "".concat(e).concat(t).concat(e) : "".concat(e[0]).concat(t).concat(e[1]) : t
                            }, d.stringify = function(t, e, r, n, s, a = {}) {
                                const o = typeof t,
                                    u = n && n.errors && n.errors.wrap || {};
                                let h = !1;
                                if (l.isRef(t) && t.render && (h = t.in, t = t.resolve(e, r, n, s, i({ in: t.in
                                    }, a))), null === t) return "null";
                                if ("string" === o) return d.wrap(t, a.arrayItems && u.string);
                                if ("number" === o || "function" === o || "symbol" === o) return t.toString();
                                if ("object" !== o) return JSON.stringify(t);
                                if (t instanceof Date) return d.Template.date(t, n);
                                if (t instanceof Map) {
                                    const e = [];
                                    for (const [r, n] of t.entries()) e.push("".concat(r.toString(), " -> ").concat(n.toString()));
                                    t = e
                                }
                                if (!Array.isArray(t)) return t.toString();
                                const f = [];
                                for (const c of t) f.push(d.stringify(c, e, r, n, s, i({
                                    arrayItems: !0
                                }, a)));
                                return d.wrap(f.join(", "), !h && u.array)
                            }, d.constants = {
                                true: !0,
                                false: !1,
                                null: null,
                                second: 1e3,
                                minute: 6e4,
                                hour: 36e5,
                                day: 864e5
                            }, d.functions = {
                                if: (t, e, r) => t ? e : r,
                                length: t => "string" == typeof t ? t.length : t && "object" == typeof t ? Array.isArray(t) ? t.length : Object.keys(t).length : null,
                                msg(t) {
                                    const [e, r, n, i, s] = this, a = s.messages;
                                    if (!a) return "";
                                    const o = c.template(e, a[0], t, r, n) || c.template(e, a[1], t, r, n);
                                    return o ? o.render(e, r, n, i, s) : ""
                                },
                                number: t => "number" == typeof t ? t : "string" == typeof t ? parseFloat(t) : "boolean" == typeof t ? t ? 1 : 0 : t instanceof Date ? t.getTime() : null
                            }
                        },
                        4946: (t, e, r) => {
                            "use strict";
                            const n = r(375),
                                i = r(1687),
                                s = r(8068),
                                a = r(8160),
                                o = r(3292),
                                u = r(6354),
                                h = r(6133),
                                f = {};
                            t.exports = s.extend({
                                type: "alternatives",
                                flags: {
                                    match: {
                                        default: "any"
                                    }
                                },
                                terms: {
                                    matches: {
                                        init: [],
                                        register: h.toSibling
                                    }
                                },
                                args: (t, ...e) => 1 === e.length && Array.isArray(e[0]) ? t.try(...e[0]) : t.try(...e),
                                validate(t, e) {
                                    const {
                                        schema: r,
                                        error: n,
                                        state: s,
                                        prefs: a
                                    } = e;
                                    if (r._flags.match) {
                                        const e = [],
                                            o = [];
                                        for (let n = 0; n < r.$_terms.matches.length; ++n) {
                                            const i = r.$_terms.matches[n],
                                                u = s.nest(i.schema, "match.".concat(n));
                                            u.snapshot();
                                            const h = i.schema.$_validate(t, u, a);
                                            h.errors ? (o.push(h.errors), u.restore()) : e.push(h.value)
                                        }
                                        if (0 === e.length) return {
                                            errors: n("alternatives.any", {
                                                details: o.map(t => u.details(t, {
                                                    override: !1
                                                }))
                                            })
                                        };
                                        if ("one" === r._flags.match) return 1 === e.length ? {
                                            value: e[0]
                                        } : {
                                            errors: n("alternatives.one")
                                        };
                                        if (e.length !== r.$_terms.matches.length) return {
                                            errors: n("alternatives.all", {
                                                details: o.map(t => u.details(t, {
                                                    override: !1
                                                }))
                                            })
                                        };
                                        const h = t => t.$_terms.matches.some(t => "object" === t.schema.type || "alternatives" === t.schema.type && h(t.schema));
                                        return h(r) ? {
                                            value: e.reduce((t, e) => i(t, e, {
                                                mergeArrays: !1
                                            }))
                                        } : {
                                            value: e[e.length - 1]
                                        }
                                    }
                                    const o = [];
                                    for (let i = 0; i < r.$_terms.matches.length; ++i) {
                                        const e = r.$_terms.matches[i];
                                        if (e.schema) {
                                            const r = s.nest(e.schema, "match.".concat(i));
                                            r.snapshot();
                                            const n = e.schema.$_validate(t, r, a);
                                            if (!n.errors) return n;
                                            r.restore(), o.push({
                                                schema: e.schema,
                                                reports: n.errors
                                            });
                                            continue
                                        }
                                        const n = e.ref ? e.ref.resolve(t, s, a) : t,
                                            u = e.is ? [e] : e.switch;
                                        for (let r = 0; r < u.length; ++r) {
                                            const o = u[r],
                                                {
                                                    is: h,
                                                    then: f,
                                                    otherwise: c
                                                } = o,
                                                l = "match.".concat(i).concat(e.switch ? "." + r : "");
                                            if (h.$_match(n, s.nest(h, "".concat(l, ".is")), a)) {
                                                if (f) return f.$_validate(t, s.nest(f, "".concat(l, ".then")), a)
                                            } else if (c) return c.$_validate(t, s.nest(c, "".concat(l, ".otherwise")), a)
                                        }
                                    }
                                    return f.errors(o, e)
                                },
                                rules: {
                                    conditional: {
                                        method(t, e) {
                                            n(!this._flags._endedSwitch, "Unreachable condition"), n(!this._flags.match, "Cannot combine match mode", this._flags.match, "with conditional rule"), n(void 0 === e.break, "Cannot use break option with alternatives conditional");
                                            const r = this.clone(),
                                                i = o.when(r, t, e),
                                                s = i.is ? [i] : i.switch;
                                            for (const n of s)
                                                if (n.then && n.otherwise) {
                                                    r.$_setFlag("_endedSwitch", !0, {
                                                        clone: !1
                                                    });
                                                    break
                                                }
                                            return r.$_terms.matches.push(i), r.$_mutateRebuild()
                                        }
                                    },
                                    match: {
                                        method(t) {
                                            if (n(["any", "one", "all"].includes(t), "Invalid alternatives match mode", t), "any" !== t)
                                                for (const e of this.$_terms.matches) n(e.schema, "Cannot combine match mode", t, "with conditional rules");
                                            return this.$_setFlag("match", t)
                                        }
                                    },
                                    try: {
                                        method(...t) {
                                            n(t.length, "Missing alternative schemas"), a.verifyFlat(t, "try"), n(!this._flags._endedSwitch, "Unreachable condition");
                                            const e = this.clone();
                                            for (const r of t) e.$_terms.matches.push({
                                                schema: e.$_compile(r)
                                            });
                                            return e.$_mutateRebuild()
                                        }
                                    }
                                },
                                overrides: {
                                    label(t) {
                                        return this.$_parent("label", t).$_modify({
                                            each: (e, r) => "is" !== r.path[0] ? e.label(t) : void 0,
                                            ref: !1
                                        })
                                    }
                                },
                                rebuild(t) {
                                    t.$_modify({
                                        each: e => {
                                            a.isSchema(e) && "array" === e.type && t.$_setFlag("_arrayItems", !0, {
                                                clone: !1
                                            })
                                        }
                                    })
                                },
                                manifest: {
                                    build(t, e) {
                                        if (e.matches)
                                            for (const r of e.matches) {
                                                const {
                                                    schema: e,
                                                    ref: n,
                                                    is: i,
                                                    not: s,
                                                    then: a,
                                                    otherwise: o
                                                } = r;
                                                t = e ? t.try(e) : n ? t.conditional(n, {
                                                    is: i,
                                                    then: a,
                                                    not: s,
                                                    otherwise: o,
                                                    switch: r.switch
                                                }) : t.conditional(i, {
                                                    then: a,
                                                    otherwise: o
                                                })
                                            }
                                        return t
                                    }
                                },
                                messages: {
                                    "alternatives.all": "{{#label}} does not match all of the required types",
                                    "alternatives.any": "{{#label}} does not match any of the allowed types",
                                    "alternatives.match": "{{#label}} does not match any of the allowed types",
                                    "alternatives.one": "{{#label}} matches more than one allowed type",
                                    "alternatives.types": "{{#label}} must be one of {{#types}}"
                                }
                            }), f.errors = function(t, {
                                error: e,
                                state: r
                            }) {
                                if (!t.length) return {
                                    errors: e("alternatives.any")
                                };
                                if (1 === t.length) return {
                                    errors: t[0].reports
                                };
                                const n = new Set,
                                    i = [];
                                for (const {
                                        reports: s,
                                        schema: a
                                    } of t) {
                                    if (s.length > 1) return f.unmatched(t, e);
                                    const o = s[0];
                                    if (o instanceof u.Report == 0) return f.unmatched(t, e);
                                    if (o.state.path.length !== r.path.length) {
                                        i.push({
                                            type: a.type,
                                            report: o
                                        });
                                        continue
                                    }
                                    if ("any.only" === o.code) {
                                        for (const t of o.local.valids) n.add(t);
                                        continue
                                    }
                                    const [h, c] = o.code.split(".");
                                    "base" === c ? n.add(h) : i.push({
                                        type: a.type,
                                        report: o
                                    })
                                }
                                return i.length ? 1 === i.length ? {
                                    errors: i[0].report
                                } : f.unmatched(t, e) : {
                                    errors: e("alternatives.types", {
                                        types: [...n]
                                    })
                                }
                            }, f.unmatched = function(t, e) {
                                const r = [];
                                for (const n of t) r.push(...n.reports);
                                return {
                                    errors: e("alternatives.match", u.details(r, {
                                        override: !1
                                    }))
                                }
                            }
                        },
                        8068: (t, e, r) => {
                            "use strict";
                            const n = r(375),
                                i = r(7629),
                                s = r(8160),
                                a = r(6914);
                            t.exports = i.extend({
                                type: "any",
                                flags: {
                                    only: {
                                        default: !1
                                    }
                                },
                                terms: {
                                    alterations: {
                                        init: null
                                    },
                                    examples: {
                                        init: null
                                    },
                                    externals: {
                                        init: null
                                    },
                                    metas: {
                                        init: []
                                    },
                                    notes: {
                                        init: []
                                    },
                                    shared: {
                                        init: null
                                    },
                                    tags: {
                                        init: []
                                    },
                                    whens: {
                                        init: null
                                    }
                                },
                                rules: {
                                    custom: {
                                        method(t, e) {
                                            return n("function" == typeof t, "Method must be a function"), n(void 0 === e || e && "string" == typeof e, "Description must be a non-empty string"), this.$_addRule({
                                                name: "custom",
                                                args: {
                                                    method: t,
                                                    description: e
                                                }
                                            })
                                        },
                                        validate(t, e, {
                                            method: r
                                        }) {
                                            try {
                                                return r(t, e)
                                            } catch (t) {
                                                return e.error("any.custom", {
                                                    error: t
                                                })
                                            }
                                        },
                                        args: ["method", "description"],
                                        multi: !0
                                    },
                                    messages: {
                                        method(t) {
                                            return this.prefs({
                                                messages: t
                                            })
                                        }
                                    },
                                    shared: {
                                        method(t) {
                                            n(s.isSchema(t) && t._flags.id, "Schema must be a schema with an id");
                                            const e = this.clone();
                                            return e.$_terms.shared = e.$_terms.shared || [], e.$_terms.shared.push(t), e.$_mutateRegister(t), e
                                        }
                                    },
                                    warning: {
                                        method(t, e) {
                                            return n(t && "string" == typeof t, "Invalid warning code"), this.$_addRule({
                                                name: "warning",
                                                args: {
                                                    code: t,
                                                    local: e
                                                },
                                                warn: !0
                                            })
                                        },
                                        validate: (t, e, {
                                            code: r,
                                            local: n
                                        }) => e.error(r, n),
                                        args: ["code", "local"],
                                        multi: !0
                                    }
                                },
                                modifiers: {
                                    keep(t, e = !0) {
                                        t.keep = e
                                    },
                                    message(t, e) {
                                        t.message = a.compile(e)
                                    },
                                    warn(t, e = !0) {
                                        t.warn = e
                                    }
                                },
                                manifest: {
                                    build(t, e) {
                                        for (const r in e) {
                                            const n = e[r];
                                            if (["examples", "externals", "metas", "notes", "tags"].includes(r))
                                                for (const e of n) t = t[r.slice(0, -1)](e);
                                            else if ("alterations" !== r)
                                                if ("whens" !== r) {
                                                    if ("shared" === r)
                                                        for (const e of n) t = t.shared(e)
                                                } else
                                                    for (const e of n) {
                                                        const {
                                                            ref: r,
                                                            is: n,
                                                            not: i,
                                                            then: s,
                                                            otherwise: a,
                                                            concat: o
                                                        } = e;
                                                        t = o ? t.concat(o) : r ? t.when(r, {
                                                            is: n,
                                                            not: i,
                                                            then: s,
                                                            otherwise: a,
                                                            switch: e.switch,
                                                            break: e.break
                                                        }) : t.when(n, {
                                                            then: s,
                                                            otherwise: a,
                                                            break: e.break
                                                        })
                                                    } else {
                                                        const e = {};
                                                        for (const {
                                                                target: t,
                                                                adjuster: r
                                                            } of n) e[t] = r;
                                                        t = t.alter(e)
                                                    }
                                        }
                                        return t
                                    }
                                },
                                messages: {
                                    "any.custom": "{{#label}} failed custom validation because {{#error.message}}",
                                    "any.default": "{{#label}} threw an error when running default method",
                                    "any.failover": "{{#label}} threw an error when running failover method",
                                    "any.invalid": "{{#label}} contains an invalid value",
                                    "any.only": '{{#label}} must be {if(#valids.length == 1, "", "one of ")}{{#valids}}',
                                    "any.ref": "{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}",
                                    "any.required": "{{#label}} is required",
                                    "any.unknown": "{{#label}} is not allowed"
                                }
                            })
                        },
                        546: (t, e, r) => {
                            "use strict";
                            const n = r(375),
                                i = r(9474),
                                s = r(9621),
                                a = r(8068),
                                o = r(8160),
                                u = r(3292),
                                h = {};
                            t.exports = a.extend({
                                type: "array",
                                flags: {
                                    single: {
                                        default: !1
                                    },
                                    sparse: {
                                        default: !1
                                    }
                                },
                                terms: {
                                    items: {
                                        init: [],
                                        manifest: "schema"
                                    },
                                    ordered: {
                                        init: [],
                                        manifest: "schema"
                                    },
                                    _exclusions: {
                                        init: []
                                    },
                                    _inclusions: {
                                        init: []
                                    },
                                    _requireds: {
                                        init: []
                                    }
                                },
                                coerce: {
                                    from: "object",
                                    method(t, {
                                        schema: e,
                                        state: r,
                                        prefs: n
                                    }) {
                                        if (!Array.isArray(t)) return;
                                        const i = e.$_getRule("sort");
                                        return i ? h.sort(e, t, i.args.options, r, n) : void 0
                                    }
                                },
                                validate(t, {
                                    schema: e,
                                    error: r
                                }) {
                                    if (!Array.isArray(t)) {
                                        if (e._flags.single) {
                                            const e = [t];
                                            return e[o.symbols.arraySingle] = !0, {
                                                value: e
                                            }
                                        }
                                        return {
                                            errors: r("array.base")
                                        }
                                    }
                                    if (e.$_getRule("items") || e.$_terms.externals) return {
                                        value: t.slice()
                                    }
                                },
                                rules: {
                                    has: {
                                        method(t) {
                                            t = this.$_compile(t, {
                                                appendPath: !0
                                            });
                                            const e = this.$_addRule({
                                                name: "has",
                                                args: {
                                                    schema: t
                                                }
                                            });
                                            return e.$_mutateRegister(t), e
                                        },
                                        validate(t, {
                                            state: e,
                                            prefs: r,
                                            error: n
                                        }, {
                                            schema: i
                                        }) {
                                            const s = [t, ...e.ancestors];
                                            for (let o = 0; o < t.length; ++o) {
                                                const n = e.localize([...e.path, o], s, i);
                                                if (i.$_match(t[o], n, r)) return t
                                            }
                                            const a = i._flags.label;
                                            return a ? n("array.hasKnown", {
                                                patternLabel: a
                                            }) : n("array.hasUnknown", null)
                                        },
                                        multi: !0
                                    },
                                    items: {
                                        method(...t) {
                                            o.verifyFlat(t, "items");
                                            const e = this.$_addRule("items");
                                            for (let r = 0; r < t.length; ++r) {
                                                const n = o.tryWithPath(() => this.$_compile(t[r]), r, {
                                                    append: !0
                                                });
                                                e.$_terms.items.push(n)
                                            }
                                            return e.$_mutateRebuild()
                                        },
                                        validate(t, {
                                            schema: e,
                                            error: r,
                                            state: n,
                                            prefs: i,
                                            errorsArray: s
                                        }) {
                                            const a = e.$_terms._requireds.slice(),
                                                u = e.$_terms.ordered.slice(),
                                                f = [...e.$_terms._inclusions, ...a],
                                                c = !t[o.symbols.arraySingle];
                                            delete t[o.symbols.arraySingle];
                                            const l = s();
                                            let d = t.length;
                                            for (let o = 0; o < d; ++o) {
                                                const s = t[o];
                                                let p = !1,
                                                    m = !1;
                                                const b = c ? o : new Number(o),
                                                    g = [...n.path, b];
                                                if (!e._flags.sparse && void 0 === s) {
                                                    if (l.push(r("array.sparse", {
                                                            key: b,
                                                            path: g,
                                                            pos: o,
                                                            value: void 0
                                                        }, n.localize(g))), i.abortEarly) return l;
                                                    u.shift();
                                                    continue
                                                }
                                                const y = [t, ...n.ancestors];
                                                for (const t of e.$_terms._exclusions)
                                                    if (t.$_match(s, n.localize(g, y, t), i, {
                                                            presence: "ignore"
                                                        })) {
                                                        if (l.push(r("array.excludes", {
                                                                pos: o,
                                                                value: s
                                                            }, n.localize(g))), i.abortEarly) return l;
                                                        p = !0, u.shift();
                                                        break
                                                    }
                                                if (p) continue;
                                                if (e.$_terms.ordered.length) {
                                                    if (u.length) {
                                                        const a = u.shift(),
                                                            f = a.$_validate(s, n.localize(g, y, a), i);
                                                        if (f.errors) {
                                                            if (l.push(...f.errors), i.abortEarly) return l
                                                        } else if ("strip" === a._flags.result) h.fastSplice(t, o), --o, --d;
                                                        else {
                                                            if (!e._flags.sparse && void 0 === f.value) {
                                                                if (l.push(r("array.sparse", {
                                                                        key: b,
                                                                        path: g,
                                                                        pos: o,
                                                                        value: void 0
                                                                    }, n.localize(g))), i.abortEarly) return l;
                                                                continue
                                                            }
                                                            t[o] = f.value
                                                        }
                                                        continue
                                                    }
                                                    if (!e.$_terms.items.length) {
                                                        if (l.push(r("array.orderedLength", {
                                                                pos: o,
                                                                limit: e.$_terms.ordered.length
                                                            })), i.abortEarly) return l;
                                                        break
                                                    }
                                                }
                                                const v = [];
                                                let w = a.length;
                                                for (let u = 0; u < w; ++u) {
                                                    const f = n.localize(g, y, a[u]);
                                                    f.snapshot();
                                                    const c = a[u].$_validate(s, f, i);
                                                    if (v[u] = c, !c.errors) {
                                                        if (t[o] = c.value, m = !0, h.fastSplice(a, u), --u, --w, !e._flags.sparse && void 0 === c.value && (l.push(r("array.sparse", {
                                                                key: b,
                                                                path: g,
                                                                pos: o,
                                                                value: void 0
                                                            }, n.localize(g))), i.abortEarly)) return l;
                                                        break
                                                    }
                                                    f.restore()
                                                }
                                                if (m) continue;
                                                const _ = i.stripUnknown && !!i.stripUnknown.arrays || !1;
                                                w = f.length;
                                                for (const u of f) {
                                                    let f;
                                                    const c = a.indexOf(u);
                                                    if (-1 !== c) f = v[c];
                                                    else {
                                                        const a = n.localize(g, y, u);
                                                        if (a.snapshot(), f = u.$_validate(s, a, i), !f.errors) {
                                                            "strip" === u._flags.result ? (h.fastSplice(t, o), --o, --d) : e._flags.sparse || void 0 !== f.value ? t[o] = f.value : (l.push(r("array.sparse", {
                                                                key: b,
                                                                path: g,
                                                                pos: o,
                                                                value: void 0
                                                            }, n.localize(g))), p = !0), m = !0;
                                                            break
                                                        }
                                                        a.restore()
                                                    }
                                                    if (1 === w) {
                                                        if (_) {
                                                            h.fastSplice(t, o), --o, --d, m = !0;
                                                            break
                                                        }
                                                        if (l.push(...f.errors), i.abortEarly) return l;
                                                        p = !0;
                                                        break
                                                    }
                                                }
                                                if (!p && (e.$_terms._inclusions.length || e.$_terms._requireds.length) && !m) {
                                                    if (_) {
                                                        h.fastSplice(t, o), --o, --d;
                                                        continue
                                                    }
                                                    if (l.push(r("array.includes", {
                                                            pos: o,
                                                            value: s
                                                        }, n.localize(g))), i.abortEarly) return l
                                                }
                                            }
                                            return a.length && h.fillMissedErrors(e, l, a, t, n, i), u.length && (h.fillOrderedErrors(e, l, u, t, n, i), l.length || h.fillDefault(u, t, n, i)), l.length ? l : t
                                        },
                                        priority: !0,
                                        manifest: !1
                                    },
                                    length: {
                                        method(t) {
                                            return this.$_addRule({
                                                name: "length",
                                                args: {
                                                    limit: t
                                                },
                                                operator: "="
                                            })
                                        },
                                        validate: (t, e, {
                                            limit: r
                                        }, {
                                            name: n,
                                            operator: i,
                                            args: s
                                        }) => o.compare(t.length, r, i) ? t : e.error("array." + n, {
                                            limit: s.limit,
                                            value: t
                                        }),
                                        args: [{
                                            name: "limit",
                                            ref: !0,
                                            assert: o.limit,
                                            message: "must be a positive integer"
                                        }]
                                    },
                                    max: {
                                        method(t) {
                                            return this.$_addRule({
                                                name: "max",
                                                method: "length",
                                                args: {
                                                    limit: t
                                                },
                                                operator: "<="
                                            })
                                        }
                                    },
                                    min: {
                                        method(t) {
                                            return this.$_addRule({
                                                name: "min",
                                                method: "length",
                                                args: {
                                                    limit: t
                                                },
                                                operator: ">="
                                            })
                                        }
                                    },
                                    ordered: {
                                        method(...t) {
                                            o.verifyFlat(t, "ordered");
                                            const e = this.$_addRule("items");
                                            for (let r = 0; r < t.length; ++r) {
                                                const n = o.tryWithPath(() => this.$_compile(t[r]), r, {
                                                    append: !0
                                                });
                                                h.validateSingle(n, e), e.$_mutateRegister(n), e.$_terms.ordered.push(n)
                                            }
                                            return e.$_mutateRebuild()
                                        }
                                    },
                                    single: {
                                        method(t) {
                                            const e = void 0 === t || !!t;
                                            return n(!e || !this._flags._arrayItems, "Cannot specify single rule when array has array items"), this.$_setFlag("single", e)
                                        }
                                    },
                                    sort: {
                                        method(t = {}) {
                                            o.assertOptions(t, ["by", "order"]);
                                            const e = {
                                                order: t.order || "ascending"
                                            };
                                            return t.by && (e.by = u.ref(t.by, {
                                                ancestor: 0
                                            }), n(!e.by.ancestor, "Cannot sort by ancestor")), this.$_addRule({
                                                name: "sort",
                                                args: {
                                                    options: e
                                                }
                                            })
                                        },
                                        validate(t, {
                                            error: e,
                                            state: r,
                                            prefs: n,
                                            schema: i
                                        }, {
                                            options: s
                                        }) {
                                            const {
                                                value: a,
                                                errors: o
                                            } = h.sort(i, t, s, r, n);
                                            if (o) return o;
                                            for (let u = 0; u < t.length; ++u)
                                                if (t[u] !== a[u]) return e("array.sort", {
                                                    order: s.order,
                                                    by: s.by ? s.by.key : "value"
                                                });
                                            return t
                                        },
                                        convert: !0
                                    },
                                    sparse: {
                                        method(t) {
                                            const e = void 0 === t || !!t;
                                            return this._flags.sparse === e ? this : (e ? this.clone() : this.$_addRule("items")).$_setFlag("sparse", e, {
                                                clone: !1
                                            })
                                        }
                                    },
                                    unique: {
                                        method(t, e = {}) {
                                            n(!t || "function" == typeof t || "string" == typeof t, "comparator must be a function or a string"), o.assertOptions(e, ["ignoreUndefined", "separator"]);
                                            const r = {
                                                name: "unique",
                                                args: {
                                                    options: e,
                                                    comparator: t
                                                }
                                            };
                                            if (t)
                                                if ("string" == typeof t) {
                                                    const n = o.default(e.separator, ".");
                                                    r.path = n ? t.split(n) : [t]
                                                } else r.comparator = t;
                                            return this.$_addRule(r)
                                        },
                                        validate(t, {
                                            state: e,
                                            error: r,
                                            schema: a
                                        }, {
                                            comparator: o,
                                            options: u
                                        }, {
                                            comparator: h,
                                            path: f
                                        }) {
                                            const c = {
                                                    string: Object.create(null),
                                                    number: Object.create(null),
                                                    undefined: Object.create(null),
                                                    boolean: Object.create(null),
                                                    object: new Map,
                                                    function: new Map,
                                                    custom: new Map
                                                },
                                                l = h || i,
                                                d = u.ignoreUndefined;
                                            for (let i = 0; i < t.length; ++i) {
                                                const a = f ? s(t[i], f) : t[i],
                                                    u = h ? c.custom : c[typeof a];
                                                if (n(u, "Failed to find unique map container for type", typeof a), u instanceof Map) {
                                                    const n = u.entries();
                                                    let s;
                                                    for (; !(s = n.next()).done;)
                                                        if (l(s.value[0], a)) {
                                                            const n = e.localize([...e.path, i], [t, ...e.ancestors]),
                                                                a = {
                                                                    pos: i,
                                                                    value: t[i],
                                                                    dupePos: s.value[1],
                                                                    dupeValue: t[s.value[1]]
                                                                };
                                                            return f && (a.path = o), r("array.unique", a, n)
                                                        }
                                                    u.set(a, i)
                                                } else {
                                                    if ((!d || void 0 !== a) && void 0 !== u[a]) {
                                                        const n = {
                                                            pos: i,
                                                            value: t[i],
                                                            dupePos: u[a],
                                                            dupeValue: t[u[a]]
                                                        };
                                                        return f && (n.path = o), r("array.unique", n, e.localize([...e.path, i], [t, ...e.ancestors]))
                                                    }
                                                    u[a] = i
                                                }
                                            }
                                            return t
                                        },
                                        args: ["comparator", "options"],
                                        multi: !0
                                    }
                                },
                                cast: {
                                    set: {
                                        from: Array.isArray,
                                        to: (t, e) => new Set(t)
                                    }
                                },
                                rebuild(t) {
                                    t.$_terms._inclusions = [], t.$_terms._exclusions = [], t.$_terms._requireds = [];
                                    for (const e of t.$_terms.items) h.validateSingle(e, t), "required" === e._flags.presence ? t.$_terms._requireds.push(e) : "forbidden" === e._flags.presence ? t.$_terms._exclusions.push(e) : t.$_terms._inclusions.push(e);
                                    for (const e of t.$_terms.ordered) h.validateSingle(e, t)
                                },
                                manifest: {
                                    build: (t, e) => (e.items && (t = t.items(...e.items)), e.ordered && (t = t.ordered(...e.ordered)), t)
                                },
                                messages: {
                                    "array.base": "{{#label}} must be an array",
                                    "array.excludes": "{{#label}} contains an excluded value",
                                    "array.hasKnown": "{{#label}} does not contain at least one required match for type {:#patternLabel}",
                                    "array.hasUnknown": "{{#label}} does not contain at least one required match",
                                    "array.includes": "{{#label}} does not match any of the allowed types",
                                    "array.includesRequiredBoth": "{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)",
                                    "array.includesRequiredKnowns": "{{#label}} does not contain {{#knownMisses}}",
                                    "array.includesRequiredUnknowns": "{{#label}} does not contain {{#unknownMisses}} required value(s)",
                                    "array.length": "{{#label}} must contain {{#limit}} items",
                                    "array.max": "{{#label}} must contain less than or equal to {{#limit}} items",
                                    "array.min": "{{#label}} must contain at least {{#limit}} items",
                                    "array.orderedLength": "{{#label}} must contain at most {{#limit}} items",
                                    "array.sort": "{{#label}} must be sorted in {#order} order by {{#by}}",
                                    "array.sort.mismatching": "{{#label}} cannot be sorted due to mismatching types",
                                    "array.sort.unsupported": "{{#label}} cannot be sorted due to unsupported type {#type}",
                                    "array.sparse": "{{#label}} must not be a sparse array item",
                                    "array.unique": "{{#label}} contains a duplicate value"
                                }
                            }), h.fillMissedErrors = function(t, e, r, n, i, s) {
                                const a = [];
                                let o = 0;
                                for (const u of r) {
                                    const t = u._flags.label;
                                    t ? a.push(t) : ++o
                                }
                                a.length ? o ? e.push(t.$_createError("array.includesRequiredBoth", n, {
                                    knownMisses: a,
                                    unknownMisses: o
                                }, i, s)) : e.push(t.$_createError("array.includesRequiredKnowns", n, {
                                    knownMisses: a
                                }, i, s)) : e.push(t.$_createError("array.includesRequiredUnknowns", n, {
                                    unknownMisses: o
                                }, i, s))
                            }, h.fillOrderedErrors = function(t, e, r, n, i, s) {
                                const a = [];
                                for (const o of r) "required" === o._flags.presence && a.push(o);
                                a.length && h.fillMissedErrors(t, e, a, n, i, s)
                            }, h.fillDefault = function(t, e, r, n) {
                                const i = [];
                                let s = !0;
                                for (let a = t.length - 1; a >= 0; --a) {
                                    const o = t[a],
                                        u = [e, ...r.ancestors],
                                        h = o.$_validate(void 0, r.localize(r.path, u, o), n).value;
                                    if (s) {
                                        if (void 0 === h) continue;
                                        s = !1
                                    }
                                    i.unshift(h)
                                }
                                i.length && e.push(...i)
                            }, h.fastSplice = function(t, e) {
                                let r = e;
                                for (; r < t.length;) t[r++] = t[r];
                                --t.length
                            }, h.validateSingle = function(t, e) {
                                ("array" === t.type || t._flags._arrayItems) && (n(!e._flags.single, "Cannot specify array item with single rule enabled"), e.$_setFlag("_arrayItems", !0, {
                                    clone: !1
                                }))
                            }, h.sort = function(t, e, r, n, i) {
                                const s = "ascending" === r.order ? 1 : -1,
                                    a = -1 * s,
                                    o = s,
                                    u = (u, f) => {
                                        let c = h.compare(u, f, a, o);
                                        if (null !== c) return c;
                                        if (r.by && (u = r.by.resolve(u, n, i), f = r.by.resolve(f, n, i)), c = h.compare(u, f, a, o), null !== c) return c;
                                        const l = typeof u;
                                        if (l !== typeof f) throw t.$_createError("array.sort.mismatching", e, null, n, i);
                                        if ("number" !== l && "string" !== l) throw t.$_createError("array.sort.unsupported", e, {
                                            type: l
                                        }, n, i);
                                        return "number" === l ? (u - f) * s : u < f ? a : o
                                    };
                                try {
                                    return {
                                        value: e.slice().sort(u)
                                    }
                                } catch (t) {
                                    return {
                                        errors: t
                                    }
                                }
                            }, h.compare = function(t, e, r, n) {
                                return t === e ? 0 : void 0 === t ? 1 : void 0 === e ? -1 : null === t ? n : null === e ? r : null
                            }
                        },
                        4937: (t, e, r) => {
                            "use strict";
                            const n = r(375),
                                i = r(8068),
                                s = r(8160),
                                a = r(2036),
                                o = {
                                    isBool: function(t) {
                                        return "boolean" == typeof t
                                    }
                                };
                            t.exports = i.extend({
                                type: "boolean",
                                flags: {
                                    sensitive: {
                                        default: !1
                                    }
                                },
                                terms: {
                                    falsy: {
                                        init: null,
                                        manifest: "values"
                                    },
                                    truthy: {
                                        init: null,
                                        manifest: "values"
                                    }
                                },
                                coerce(t, {
                                    schema: e
                                }) {
                                    if ("boolean" != typeof t) {
                                        if ("string" == typeof t) {
                                            const r = e._flags.sensitive ? t : t.toLowerCase();
                                            t = "true" === r || "false" !== r && t
                                        }
                                        return "boolean" != typeof t && (t = e.$_terms.truthy && e.$_terms.truthy.has(t, null, null, !e._flags.sensitive) || (!e.$_terms.falsy || !e.$_terms.falsy.has(t, null, null, !e._flags.sensitive)) && t), {
                                            value: t
                                        }
                                    }
                                },
                                validate(t, {
                                    error: e
                                }) {
                                    if ("boolean" != typeof t) return {
                                        value: t,
                                        errors: e("boolean.base")
                                    }
                                },
                                rules: {
                                    truthy: {
                                        method(...t) {
                                            s.verifyFlat(t, "truthy");
                                            const e = this.clone();
                                            e.$_terms.truthy = e.$_terms.truthy || new a;
                                            for (let r = 0; r < t.length; ++r) {
                                                const i = t[r];
                                                n(void 0 !== i, "Cannot call truthy with undefined"), e.$_terms.truthy.add(i)
                                            }
                                            return e
                                        }
                                    },
                                    falsy: {
                                        method(...t) {
                                            s.verifyFlat(t, "falsy");
                                            const e = this.clone();
                                            e.$_terms.falsy = e.$_terms.falsy || new a;
                                            for (let r = 0; r < t.length; ++r) {
                                                const i = t[r];
                                                n(void 0 !== i, "Cannot call falsy with undefined"), e.$_terms.falsy.add(i)
                                            }
                                            return e
                                        }
                                    },
                                    sensitive: {
                                        method(t = !0) {
                                            return this.$_setFlag("sensitive", t)
                                        }
                                    }
                                },
                                cast: {
                                    number: {
                                        from: o.isBool,
                                        to: (t, e) => t ? 1 : 0
                                    },
                                    string: {
                                        from: o.isBool,
                                        to: (t, e) => t ? "true" : "false"
                                    }
                                },
                                manifest: {
                                    build: (t, e) => (e.truthy && (t = t.truthy(...e.truthy)), e.falsy && (t = t.falsy(...e.falsy)), t)
                                },
                                messages: {
                                    "boolean.base": "{{#label}} must be a boolean"
                                }
                            })
                        },
                        7500: (t, e, r) => {
                            "use strict";
                            const n = r(375),
                                i = r(8068),
                                s = r(8160),
                                a = r(3328),
                                o = {
                                    isDate: function(t) {
                                        return t instanceof Date
                                    }
                                };
                            t.exports = i.extend({
                                type: "date",
                                coerce: {
                                    from: ["number", "string"],
                                    method: (t, {
                                        schema: e
                                    }) => ({
                                        value: o.parse(t, e._flags.format) || t
                                    })
                                },
                                validate(t, {
                                    schema: e,
                                    error: r,
                                    prefs: n
                                }) {
                                    if (t instanceof Date && !isNaN(t.getTime())) return;
                                    const i = e._flags.format;
                                    return n.convert && i && "string" == typeof t ? {
                                        value: t,
                                        errors: r("date.format", {
                                            format: i
                                        })
                                    } : {
                                        value: t,
                                        errors: r("date.base")
                                    }
                                },
                                rules: {
                                    compare: {
                                        method: !1,
                                        validate(t, e, {
                                            date: r
                                        }, {
                                            name: n,
                                            operator: i,
                                            args: a
                                        }) {
                                            const o = "now" === r ? Date.now() : r.getTime();
                                            return s.compare(t.getTime(), o, i) ? t : e.error("date." + n, {
                                                limit: a.date,
                                                value: t
                                            })
                                        },
                                        args: [{
                                            name: "date",
                                            ref: !0,
                                            normalize: t => "now" === t ? t : o.parse(t),
                                            assert: t => null !== t,
                                            message: "must have a valid date format"
                                        }]
                                    },
                                    format: {
                                        method(t) {
                                            return n(["iso", "javascript", "unix"].includes(t), "Unknown date format", t), this.$_setFlag("format", t)
                                        }
                                    },
                                    greater: {
                                        method(t) {
                                            return this.$_addRule({
                                                name: "greater",
                                                method: "compare",
                                                args: {
                                                    date: t
                                                },
                                                operator: ">"
                                            })
                                        }
                                    },
                                    iso: {
                                        method() {
                                            return this.format("iso")
                                        }
                                    },
                                    less: {
                                        method(t) {
                                            return this.$_addRule({
                                                name: "less",
                                                method: "compare",
                                                args: {
                                                    date: t
                                                },
                                                operator: "<"
                                            })
                                        }
                                    },
                                    max: {
                                        method(t) {
                                            return this.$_addRule({
                                                name: "max",
                                                method: "compare",
                                                args: {
                                                    date: t
                                                },
                                                operator: "<="
                                            })
                                        }
                                    },
                                    min: {
                                        method(t) {
                                            return this.$_addRule({
                                                name: "min",
                                                method: "compare",
                                                args: {
                                                    date: t
                                                },
                                                operator: ">="
                                            })
                                        }
                                    },
                                    timestamp: {
                                        method(t = "javascript") {
                                            return n(["javascript", "unix"].includes(t), '"type" must be one of "javascript, unix"'), this.format(t)
                                        }
                                    }
                                },
                                cast: {
                                    number: {
                                        from: o.isDate,
                                        to: (t, e) => t.getTime()
                                    },
                                    string: {
                                        from: o.isDate,
                                        to: (t, {
                                            prefs: e
                                        }) => a.date(t, e)
                                    }
                                },
                                messages: {
                                    "date.base": "{{#label}} must be a valid date",
                                    "date.format": '{{#label}} must be in {msg("date.format." + #format) || #format} format',
                                    "date.greater": "{{#label}} must be greater than {{:#limit}}",
                                    "date.less": "{{#label}} must be less than {{:#limit}}",
                                    "date.max": "{{#label}} must be less than or equal to {{:#limit}}",
                                    "date.min": "{{#label}} must be greater than or equal to {{:#limit}}",
                                    "date.format.iso": "ISO 8601 date",
                                    "date.format.javascript": "timestamp or number of milliseconds",
                                    "date.format.unix": "timestamp or number of seconds"
                                }
                            }), o.parse = function(t, e) {
                                if (t instanceof Date) return t;
                                if ("string" != typeof t && (isNaN(t) || !isFinite(t))) return null;
                                if (/^\s*$/.test(t)) return null;
                                if ("iso" === e) return s.isIsoDate(t) ? o.date(t.toString()) : null;
                                const r = t;
                                if ("string" == typeof t && /^[+-]?\d+(\.\d+)?$/.test(t) && (t = parseFloat(t)), e) {
                                    if ("javascript" === e) return o.date(1 * t);
                                    if ("unix" === e) return o.date(1e3 * t);
                                    if ("string" == typeof r) return null
                                }
                                return o.date(t)
                            }, o.date = function(t) {
                                const e = new Date(t);
                                return isNaN(e.getTime()) ? null : e
                            }
                        },
                        390: (t, e, r) => {
                            "use strict";
                            const n = r(375),
                                i = r(7824);
                            t.exports = i.extend({
                                type: "function",
                                properties: {
                                    typeof: "function"
                                },
                                rules: {
                                    arity: {
                                        method(t) {
                                            return n(Number.isSafeInteger(t) && t >= 0, "n must be a positive integer"), this.$_addRule({
                                                name: "arity",
                                                args: {
                                                    n: t
                                                }
                                            })
                                        },
                                        validate: (t, e, {
                                            n: r
                                        }) => t.length === r ? t : e.error("function.arity", {
                                            n: r
                                        })
                                    },
                                    class: {
                                        method() {
                                            return this.$_addRule("class")
                                        },
                                        validate: (t, e) => /^\s*class\s/.test(t.toString()) ? t : e.error("function.class", {
                                            value: t
                                        })
                                    },
                                    minArity: {
                                        method(t) {
                                            return n(Number.isSafeInteger(t) && t > 0, "n must be a strict positive integer"), this.$_addRule({
                                                name: "minArity",
                                                args: {
                                                    n: t
                                                }
                                            })
                                        },
                                        validate: (t, e, {
                                            n: r
                                        }) => t.length >= r ? t : e.error("function.minArity", {
                                            n: r
                                        })
                                    },
                                    maxArity: {
                                        method(t) {
                                            return n(Number.isSafeInteger(t) && t >= 0, "n must be a positive integer"), this.$_addRule({
                                                name: "maxArity",
                                                args: {
                                                    n: t
                                                }
                                            })
                                        },
                                        validate: (t, e, {
                                            n: r
                                        }) => t.length <= r ? t : e.error("function.maxArity", {
                                            n: r
                                        })
                                    }
                                },
                                messages: {
                                    "function.arity": "{{#label}} must have an arity of {{#n}}",
                                    "function.class": "{{#label}} must be a class",
                                    "function.maxArity": "{{#label}} must have an arity lesser or equal to {{#n}}",
                                    "function.minArity": "{{#label}} must have an arity greater or equal to {{#n}}"
                                }
                            })
                        },
                        7824: (t, e, r) => {
                            "use strict";
                            const n = r(978),
                                i = r(375),
                                s = r(8571),
                                a = r(3652),
                                o = r(8068),
                                u = r(8160),
                                h = r(3292),
                                f = r(6354),
                                c = r(6133),
                                l = r(3328),
                                d = {
                                    renameDefaults: {
                                        alias: !1,
                                        multiple: !1,
                                        override: !1
                                    }
                                };
                            t.exports = o.extend({
                                type: "_keys",
                                properties: {
                                    typeof: "object"
                                },
                                flags: {
                                    unknown: {
                                        default: !1
                                    }
                                },
                                terms: {
                                    dependencies: {
                                        init: null
                                    },
                                    keys: {
                                        init: null,
                                        manifest: {
                                            mapped: {
                                                from: "schema",
                                                to: "key"
                                            }
                                        }
                                    },
                                    patterns: {
                                        init: null
                                    },
                                    renames: {
                                        init: null
                                    }
                                },
                                args: (t, e) => t.keys(e),
                                validate(t, {
                                    schema: e,
                                    error: r,
                                    state: n,
                                    prefs: i
                                }) {
                                    if (!t || typeof t !== e.$_property("typeof") || Array.isArray(t)) return {
                                        value: t,
                                        errors: r("object.base", {
                                            type: e.$_property("typeof")
                                        })
                                    };
                                    if (!(e.$_terms.renames || e.$_terms.dependencies || e.$_terms.keys || e.$_terms.patterns || e.$_terms.externals)) return;
                                    t = d.clone(t, i);
                                    const s = [];
                                    if (e.$_terms.renames && !d.rename(e, t, n, i, s)) return {
                                        value: t,
                                        errors: s
                                    };
                                    if (!e.$_terms.keys && !e.$_terms.patterns && !e.$_terms.dependencies) return {
                                        value: t,
                                        errors: s
                                    };
                                    const a = new Set(Object.keys(t));
                                    if (e.$_terms.keys) {
                                        const r = [t, ...n.ancestors];
                                        for (const o of e.$_terms.keys) {
                                            const e = o.key,
                                                u = t[e];
                                            a.delete(e);
                                            const h = n.localize([...n.path, e], r, o),
                                                f = o.schema.$_validate(u, h, i);
                                            if (f.errors) {
                                                if (i.abortEarly) return {
                                                    value: t,
                                                    errors: f.errors
                                                };
                                                void 0 !== f.value && (t[e] = f.value), s.push(...f.errors)
                                            } else "strip" === o.schema._flags.result || void 0 === f.value && void 0 !== u ? delete t[e] : void 0 !== f.value && (t[e] = f.value)
                                        }
                                    }
                                    if (a.size || e._flags._hasPatternMatch) {
                                        const r = d.unknown(e, t, a, s, n, i);
                                        if (r) return r
                                    }
                                    if (e.$_terms.dependencies)
                                        for (const o of e.$_terms.dependencies) {
                                            if (o.key && void 0 === o.key.resolve(t, n, i, null, {
                                                    shadow: !1
                                                })) continue;
                                            const r = d.dependencies[o.rel](e, o, t, n, i);
                                            if (r) {
                                                const a = e.$_createError(r.code, t, r.context, n, i);
                                                if (i.abortEarly) return {
                                                    value: t,
                                                    errors: a
                                                };
                                                s.push(a)
                                            }
                                        }
                                    return {
                                        value: t,
                                        errors: s
                                    }
                                },
                                rules: {
                                    and: {
                                        method(...t) {
                                            return u.verifyFlat(t, "and"), d.dependency(this, "and", null, t)
                                        }
                                    },
                                    append: {
                                        method(t) {
                                            return null == t || 0 === Object.keys(t).length ? this : this.keys(t)
                                        }
                                    },
                                    assert: {
                                        method(t, e, r) {
                                            l.isTemplate(t) || (t = h.ref(t)), i(void 0 === r || "string" == typeof r, "Message must be a string"), e = this.$_compile(e, {
                                                appendPath: !0
                                            });
                                            const n = this.$_addRule({
                                                name: "assert",
                                                args: {
                                                    subject: t,
                                                    schema: e,
                                                    message: r
                                                }
                                            });
                                            return n.$_mutateRegister(t), n.$_mutateRegister(e), n
                                        },
                                        validate(t, {
                                            error: e,
                                            prefs: r,
                                            state: n
                                        }, {
                                            subject: i,
                                            schema: s,
                                            message: a
                                        }) {
                                            const o = i.resolve(t, n, r),
                                                u = c.isRef(i) ? i.absolute(n) : [];
                                            return s.$_match(o, n.localize(u, [t, ...n.ancestors], s), r) ? t : e("object.assert", {
                                                subject: i,
                                                message: a
                                            })
                                        },
                                        args: ["subject", "schema", "message"],
                                        multi: !0
                                    },
                                    instance: {
                                        method(t, e) {
                                            return i("function" == typeof t, "constructor must be a function"), e = e || t.name, this.$_addRule({
                                                name: "instance",
                                                args: {
                                                    constructor: t,
                                                    name: e
                                                }
                                            })
                                        },
                                        validate: (t, e, {
                                            constructor: r,
                                            name: n
                                        }) => t instanceof r ? t : e.error("object.instance", {
                                            type: n,
                                            value: t
                                        }),
                                        args: ["constructor", "name"]
                                    },
                                    keys: {
                                        method(t) {
                                            i(void 0 === t || "object" == typeof t, "Object schema must be a valid object"), i(!u.isSchema(t), "Object schema cannot be a joi schema");
                                            const e = this.clone();
                                            if (t)
                                                if (Object.keys(t).length) {
                                                    e.$_terms.keys = e.$_terms.keys ? e.$_terms.keys.filter(e => !t.hasOwnProperty(e.key)) : new d.Keys;
                                                    for (const r in t) u.tryWithPath(() => e.$_terms.keys.push({
                                                        key: r,
                                                        schema: this.$_compile(t[r])
                                                    }), r)
                                                } else e.$_terms.keys = new d.Keys;
                                            else e.$_terms.keys = null;
                                            return e.$_mutateRebuild()
                                        }
                                    },
                                    length: {
                                        method(t) {
                                            return this.$_addRule({
                                                name: "length",
                                                args: {
                                                    limit: t
                                                },
                                                operator: "="
                                            })
                                        },
                                        validate: (t, e, {
                                            limit: r
                                        }, {
                                            name: n,
                                            operator: i,
                                            args: s
                                        }) => u.compare(Object.keys(t).length, r, i) ? t : e.error("object." + n, {
                                            limit: s.limit,
                                            value: t
                                        }),
                                        args: [{
                                            name: "limit",
                                            ref: !0,
                                            assert: u.limit,
                                            message: "must be a positive integer"
                                        }]
                                    },
                                    max: {
                                        method(t) {
                                            return this.$_addRule({
                                                name: "max",
                                                method: "length",
                                                args: {
                                                    limit: t
                                                },
                                                operator: "<="
                                            })
                                        }
                                    },
                                    min: {
                                        method(t) {
                                            return this.$_addRule({
                                                name: "min",
                                                method: "length",
                                                args: {
                                                    limit: t
                                                },
                                                operator: ">="
                                            })
                                        }
                                    },
                                    nand: {
                                        method(...t) {
                                            return u.verifyFlat(t, "nand"), d.dependency(this, "nand", null, t)
                                        }
                                    },
                                    or: {
                                        method(...t) {
                                            return u.verifyFlat(t, "or"), d.dependency(this, "or", null, t)
                                        }
                                    },
                                    oxor: {
                                        method(...t) {
                                            return d.dependency(this, "oxor", null, t)
                                        }
                                    },
                                    pattern: {
                                        method(t, e, r = {}) {
                                            const n = t instanceof RegExp;
                                            n || (t = this.$_compile(t, {
                                                appendPath: !0
                                            })), i(void 0 !== e, "Invalid rule"), u.assertOptions(r, ["fallthrough", "matches"]), n && i(!t.flags.includes("g") && !t.flags.includes("y"), "pattern should not use global or sticky mode"), e = this.$_compile(e, {
                                                appendPath: !0
                                            });
                                            const s = this.clone();
                                            s.$_terms.patterns = s.$_terms.patterns || [];
                                            const a = {
                                                [n ? "regex" : "schema"]: t,
                                                rule: e
                                            };
                                            return r.matches && (a.matches = this.$_compile(r.matches), "array" !== a.matches.type && (a.matches = a.matches.$_root.array().items(a.matches)), s.$_mutateRegister(a.matches), s.$_setFlag("_hasPatternMatch", !0, {
                                                clone: !1
                                            })), r.fallthrough && (a.fallthrough = !0), s.$_terms.patterns.push(a), s.$_mutateRegister(e), s
                                        }
                                    },
                                    ref: {
                                        method() {
                                            return this.$_addRule("ref")
                                        },
                                        validate: (t, e) => c.isRef(t) ? t : e.error("object.refType", {
                                            value: t
                                        })
                                    },
                                    regex: {
                                        method() {
                                            return this.$_addRule("regex")
                                        },
                                        validate: (t, e) => t instanceof RegExp ? t : e.error("object.regex", {
                                            value: t
                                        })
                                    },
                                    rename: {
                                        method(t, e, r = {}) {
                                            i("string" == typeof t || t instanceof RegExp, "Rename missing the from argument"), i("string" == typeof e || e instanceof l, "Invalid rename to argument"), i(e !== t, "Cannot rename key to same name:", t), u.assertOptions(r, ["alias", "ignoreUndefined", "override", "multiple"]);
                                            const s = this.clone();
                                            s.$_terms.renames = s.$_terms.renames || [];
                                            for (const n of s.$_terms.renames) i(n.from !== t, "Cannot rename the same key multiple times");
                                            return e instanceof l && s.$_mutateRegister(e), s.$_terms.renames.push({
                                                from: t,
                                                to: e,
                                                options: n(d.renameDefaults, r)
                                            }), s
                                        }
                                    },
                                    schema: {
                                        method(t = "any") {
                                            return this.$_addRule({
                                                name: "schema",
                                                args: {
                                                    type: t
                                                }
                                            })
                                        },
                                        validate: (t, e, {
                                            type: r
                                        }) => !u.isSchema(t) || "any" !== r && t.type !== r ? e.error("object.schema", {
                                            type: r
                                        }) : t
                                    },
                                    unknown: {
                                        method(t) {
                                            return this.$_setFlag("unknown", !1 !== t)
                                        }
                                    },
                                    with: {
                                        method(t, e, r = {}) {
                                            return d.dependency(this, "with", t, e, r)
                                        }
                                    },
                                    without: {
                                        method(t, e, r = {}) {
                                            return d.dependency(this, "without", t, e, r)
                                        }
                                    },
                                    xor: {
                                        method(...t) {
                                            return u.verifyFlat(t, "xor"), d.dependency(this, "xor", null, t)
                                        }
                                    }
                                },
                                overrides: {
                                    default (t, e) {
                                        return void 0 === t && (t = u.symbols.deepDefault), this.$_parent("default", t, e)
                                    }
                                },
                                rebuild(t) {
                                    if (t.$_terms.keys) {
                                        const e = new a.Sorter;
                                        for (const r of t.$_terms.keys) u.tryWithPath(() => e.add(r, {
                                            after: r.schema.$_rootReferences(),
                                            group: r.key
                                        }), r.key);
                                        t.$_terms.keys = new d.Keys(...e.nodes)
                                    }
                                },
                                manifest: {
                                    build(t, e) {
                                        if (e.keys && (t = t.keys(e.keys)), e.dependencies)
                                            for (const {
                                                    rel: r,
                                                    key: n = null,
                                                    peers: i,
                                                    options: s
                                                } of e.dependencies) t = d.dependency(t, r, n, i, s);
                                        if (e.patterns)
                                            for (const {
                                                    regex: r,
                                                    schema: n,
                                                    rule: i,
                                                    fallthrough: s,
                                                    matches: a
                                                } of e.patterns) t = t.pattern(r || n, i, {
                                                fallthrough: s,
                                                matches: a
                                            });
                                        if (e.renames)
                                            for (const {
                                                    from: r,
                                                    to: n,
                                                    options: i
                                                } of e.renames) t = t.rename(r, n, i);
                                        return t
                                    }
                                },
                                messages: {
                                    "object.and": "{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}",
                                    "object.assert": '{{#label}} is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}',
                                    "object.base": "{{#label}} must be of type {{#type}}",
                                    "object.instance": "{{#label}} must be an instance of {{:#type}}",
                                    "object.length": '{{#label}} must have {{#limit}} key{if(#limit == 1, "", "s")}',
                                    "object.max": '{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}',
                                    "object.min": '{{#label}} must have at least {{#limit}} key{if(#limit == 1, "", "s")}',
                                    "object.missing": "{{#label}} must contain at least one of {{#peersWithLabels}}",
                                    "object.nand": "{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}",
                                    "object.oxor": "{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}",
                                    "object.pattern.match": "{{#label}} keys failed to match pattern requirements",
                                    "object.refType": "{{#label}} must be a Joi reference",
                                    "object.regex": "{{#label}} must be a RegExp object",
                                    "object.rename.multiple": "{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}",
                                    "object.rename.override": "{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists",
                                    "object.schema": "{{#label}} must be a Joi schema of {{#type}} type",
                                    "object.unknown": "{{#label}} is not allowed",
                                    "object.with": "{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}",
                                    "object.without": "{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}",
                                    "object.xor": "{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}"
                                }
                            }), d.clone = function(t, e) {
                                if ("object" == typeof t) {
                                    if (e.nonEnumerables) return s(t, {
                                        shallow: !0
                                    });
                                    const r = Object.create(Object.getPrototypeOf(t));
                                    return Object.assign(r, t), r
                                }
                                const r = function(...e) {
                                    return t.apply(this, e)
                                };
                                return r.prototype = s(t.prototype), Object.defineProperty(r, "name", {
                                    value: t.name,
                                    writable: !1
                                }), Object.defineProperty(r, "length", {
                                    value: t.length,
                                    writable: !1
                                }), Object.assign(r, t), r
                            }, d.dependency = function(t, e, r, n, s) {
                                i(null === r || "string" == typeof r, e, "key must be a strings"), s || (s = n.length > 1 && "object" == typeof n[n.length - 1] ? n.pop() : {}), u.assertOptions(s, ["separator"]), n = [].concat(n);
                                const a = u.default(s.separator, "."),
                                    o = [];
                                for (const u of n) i("string" == typeof u, e, "peers must be strings"), o.push(h.ref(u, {
                                    separator: a,
                                    ancestor: 0,
                                    prefix: !1
                                }));
                                null !== r && (r = h.ref(r, {
                                    separator: a,
                                    ancestor: 0,
                                    prefix: !1
                                }));
                                const f = t.clone();
                                return f.$_terms.dependencies = f.$_terms.dependencies || [], f.$_terms.dependencies.push(new d.Dependency(e, r, o, n)), f
                            }, d.dependencies = {
                                and(t, e, r, n, i) {
                                    const s = [],
                                        a = [],
                                        o = e.peers.length;
                                    for (const u of e.peers) void 0 === u.resolve(r, n, i, null, {
                                        shadow: !1
                                    }) ? s.push(u.key) : a.push(u.key);
                                    if (s.length !== o && a.length !== o) return {
                                        code: "object.and",
                                        context: {
                                            present: a,
                                            presentWithLabels: d.keysToLabels(t, a),
                                            missing: s,
                                            missingWithLabels: d.keysToLabels(t, s)
                                        }
                                    }
                                },
                                nand(t, e, r, n, i) {
                                    const s = [];
                                    for (const u of e.peers) void 0 !== u.resolve(r, n, i, null, {
                                        shadow: !1
                                    }) && s.push(u.key);
                                    if (s.length !== e.peers.length) return;
                                    const a = e.paths[0],
                                        o = e.paths.slice(1);
                                    return {
                                        code: "object.nand",
                                        context: {
                                            main: a,
                                            mainWithLabel: d.keysToLabels(t, a),
                                            peers: o,
                                            peersWithLabels: d.keysToLabels(t, o)
                                        }
                                    }
                                },
                                or(t, e, r, n, i) {
                                    for (const s of e.peers)
                                        if (void 0 !== s.resolve(r, n, i, null, {
                                                shadow: !1
                                            })) return;
                                    return {
                                        code: "object.missing",
                                        context: {
                                            peers: e.paths,
                                            peersWithLabels: d.keysToLabels(t, e.paths)
                                        }
                                    }
                                },
                                oxor(t, e, r, n, i) {
                                    const s = [];
                                    for (const o of e.peers) void 0 !== o.resolve(r, n, i, null, {
                                        shadow: !1
                                    }) && s.push(o.key);
                                    if (!s.length || 1 === s.length) return;
                                    const a = {
                                        peers: e.paths,
                                        peersWithLabels: d.keysToLabels(t, e.paths)
                                    };
                                    return a.present = s, a.presentWithLabels = d.keysToLabels(t, s), {
                                        code: "object.oxor",
                                        context: a
                                    }
                                },
                                with(t, e, r, n, i) {
                                    for (const s of e.peers)
                                        if (void 0 === s.resolve(r, n, i, null, {
                                                shadow: !1
                                            })) return {
                                            code: "object.with",
                                            context: {
                                                main: e.key.key,
                                                mainWithLabel: d.keysToLabels(t, e.key.key),
                                                peer: s.key,
                                                peerWithLabel: d.keysToLabels(t, s.key)
                                            }
                                        }
                                },
                                without(t, e, r, n, i) {
                                    for (const s of e.peers)
                                        if (void 0 !== s.resolve(r, n, i, null, {
                                                shadow: !1
                                            })) return {
                                            code: "object.without",
                                            context: {
                                                main: e.key.key,
                                                mainWithLabel: d.keysToLabels(t, e.key.key),
                                                peer: s.key,
                                                peerWithLabel: d.keysToLabels(t, s.key)
                                            }
                                        }
                                },
                                xor(t, e, r, n, i) {
                                    const s = [];
                                    for (const o of e.peers) void 0 !== o.resolve(r, n, i, null, {
                                        shadow: !1
                                    }) && s.push(o.key);
                                    if (1 === s.length) return;
                                    const a = {
                                        peers: e.paths,
                                        peersWithLabels: d.keysToLabels(t, e.paths)
                                    };
                                    return 0 === s.length ? {
                                        code: "object.missing",
                                        context: a
                                    } : (a.present = s, a.presentWithLabels = d.keysToLabels(t, s), {
                                        code: "object.xor",
                                        context: a
                                    })
                                }
                            }, d.keysToLabels = function(t, e) {
                                return Array.isArray(e) ? e.map(e => t.$_mapLabels(e)) : t.$_mapLabels(e)
                            }, d.rename = function(t, e, r, n, i) {
                                const s = {};
                                for (const a of t.$_terms.renames) {
                                    const o = [],
                                        u = "string" != typeof a.from;
                                    if (u)
                                        for (const t in e) {
                                            if (void 0 === e[t] && a.options.ignoreUndefined) continue;
                                            if (t === a.to) continue;
                                            const r = a.from.exec(t);
                                            r && o.push({
                                                from: t,
                                                to: a.to,
                                                match: r
                                            })
                                        } else !Object.prototype.hasOwnProperty.call(e, a.from) || void 0 === e[a.from] && a.options.ignoreUndefined || o.push(a);
                                    for (const h of o) {
                                        const o = h.from;
                                        let f = h.to;
                                        if (f instanceof l && (f = f.render(e, r, n, h.match)), o !== f) {
                                            if (!a.options.multiple && s[f] && (i.push(t.$_createError("object.rename.multiple", e, {
                                                    from: o,
                                                    to: f,
                                                    pattern: u
                                                }, r, n)), n.abortEarly)) return !1;
                                            if (Object.prototype.hasOwnProperty.call(e, f) && !a.options.override && !s[f] && (i.push(t.$_createError("object.rename.override", e, {
                                                    from: o,
                                                    to: f,
                                                    pattern: u
                                                }, r, n)), n.abortEarly)) return !1;
                                            void 0 === e[o] ? delete e[f] : e[f] = e[o], s[f] = !0, a.options.alias || delete e[o]
                                        }
                                    }
                                }
                                return !0
                            }, d.unknown = function(t, e, r, n, i, s) {
                                if (t.$_terms.patterns) {
                                    let a = !1;
                                    const o = t.$_terms.patterns.map(t => {
                                            if (t.matches) return a = !0, []
                                        }),
                                        u = [e, ...i.ancestors];
                                    for (const h of r) {
                                        const a = e[h],
                                            f = [...i.path, h];
                                        for (let c = 0; c < t.$_terms.patterns.length; ++c) {
                                            const l = t.$_terms.patterns[c];
                                            if (l.regex) {
                                                const t = l.regex.test(h);
                                                if (i.mainstay.tracer.debug(i, "rule", "pattern.".concat(c), t ? "pass" : "error"), !t) continue
                                            } else if (!l.schema.$_match(h, i.nest(l.schema, "pattern.".concat(c)), s)) continue;
                                            r.delete(h);
                                            const d = i.localize(f, u, {
                                                    schema: l.rule,
                                                    key: h
                                                }),
                                                p = l.rule.$_validate(a, d, s);
                                            if (p.errors) {
                                                if (s.abortEarly) return {
                                                    value: e,
                                                    errors: p.errors
                                                };
                                                n.push(...p.errors)
                                            }
                                            if (l.matches && o[c].push(h), e[h] = p.value, !l.fallthrough) break
                                        }
                                    }
                                    if (a)
                                        for (let r = 0; r < o.length; ++r) {
                                            const a = o[r];
                                            if (!a) continue;
                                            const h = t.$_terms.patterns[r].matches,
                                                c = i.localize(i.path, u, h),
                                                l = h.$_validate(a, c, s);
                                            if (l.errors) {
                                                const r = f.details(l.errors, {
                                                    override: !1
                                                });
                                                r.matches = a;
                                                const o = t.$_createError("object.pattern.match", e, r, i, s);
                                                if (s.abortEarly) return {
                                                    value: e,
                                                    errors: o
                                                };
                                                n.push(o)
                                            }
                                        }
                                }
                                if (r.size && (t.$_terms.keys || t.$_terms.patterns)) {
                                    if (s.stripUnknown && !t._flags.unknown || s.skipFunctions) {
                                        const t = !(!s.stripUnknown || !0 !== s.stripUnknown && !s.stripUnknown.objects);
                                        for (const n of r) t ? (delete e[n], r.delete(n)) : "function" == typeof e[n] && r.delete(n)
                                    }
                                    if (!u.default(t._flags.unknown, s.allowUnknown))
                                        for (const a of r) {
                                            const r = i.localize([...i.path, a], []),
                                                o = t.$_createError("object.unknown", e[a], {
                                                    child: a
                                                }, r, s, {
                                                    flags: !1
                                                });
                                            if (s.abortEarly) return {
                                                value: e,
                                                errors: o
                                            };
                                            n.push(o)
                                        }
                                }
                            }, d.Dependency = class {
                                constructor(t, e, r, n) {
                                    this.rel = t, this.key = e, this.peers = r, this.paths = n
                                }
                                describe() {
                                    const t = {
                                        rel: this.rel,
                                        peers: this.paths
                                    };
                                    return null !== this.key && (t.key = this.key.key), "." !== this.peers[0].separator && (t.options = {
                                        separator: this.peers[0].separator
                                    }), t
                                }
                            }, d.Keys = class extends Array {
                                concat(t) {
                                    const e = this.slice(),
                                        r = new Map;
                                    for (let n = 0; n < e.length; ++n) r.set(e[n].key, n);
                                    for (const n of t) {
                                        const t = n.key,
                                            i = r.get(t);
                                        void 0 !== i ? e[i] = {
                                            key: t,
                                            schema: e[i].schema.concat(n.schema)
                                        } : e.push(n)
                                    }
                                    return e
                                }
                            }
                        },
                        8785: (t, e, r) => {
                            "use strict";
                            const n = r(375),
                                i = r(8068),
                                s = r(8160),
                                a = r(3292),
                                o = r(6354),
                                u = {};
                            t.exports = i.extend({
                                type: "link",
                                properties: {
                                    schemaChain: !0
                                },
                                terms: {
                                    link: {
                                        init: null,
                                        manifest: "single",
                                        register: !1
                                    }
                                },
                                args: (t, e) => t.ref(e),
                                validate(t, {
                                    schema: e,
                                    state: r,
                                    prefs: i
                                }) {
                                    n(e.$_terms.link, "Uninitialized link schema");
                                    const s = u.generate(e, t, r, i),
                                        a = e.$_terms.link[0].ref;
                                    return s.$_validate(t, r.nest(s, "link:".concat(a.display, ":").concat(s.type)), i)
                                },
                                generate: (t, e, r, n) => u.generate(t, e, r, n),
                                rules: {
                                    ref: {
                                        method(t) {
                                            n(!this.$_terms.link, "Cannot reinitialize schema"), t = a.ref(t), n("value" === t.type || "local" === t.type, "Invalid reference type:", t.type), n("local" === t.type || "root" === t.ancestor || t.ancestor > 0, "Link cannot reference itself");
                                            const e = this.clone();
                                            return e.$_terms.link = [{
                                                ref: t
                                            }], e
                                        }
                                    },
                                    relative: {
                                        method(t = !0) {
                                            return this.$_setFlag("relative", t)
                                        }
                                    }
                                },
                                overrides: {
                                    concat(t) {
                                        n(this.$_terms.link, "Uninitialized link schema"), n(s.isSchema(t), "Invalid schema object"), n("link" !== t.type, "Cannot merge type link with another link");
                                        const e = this.clone();
                                        return e.$_terms.whens || (e.$_terms.whens = []), e.$_terms.whens.push({
                                            concat: t
                                        }), e.$_mutateRebuild()
                                    }
                                },
                                manifest: {
                                    build: (t, e) => (n(e.link, "Invalid link description missing link"), t.ref(e.link))
                                }
                            }), u.generate = function(t, e, r, n) {
                                let i = r.mainstay.links.get(t);
                                if (i) return i._generate(e, r, n).schema;
                                const s = t.$_terms.link[0].ref,
                                    {
                                        perspective: a,
                                        path: o
                                    } = u.perspective(s, r);
                                u.assert(a, "which is outside of schema boundaries", s, t, r, n);
                                try {
                                    i = o.length ? a.$_reach(o) : a
                                } catch (e) {
                                    u.assert(!1, "to non-existing schema", s, t, r, n)
                                }
                                return u.assert("link" !== i.type, "which is another link", s, t, r, n), t._flags.relative || r.mainstay.links.set(t, i), i._generate(e, r, n).schema
                            }, u.perspective = function(t, e) {
                                if ("local" === t.type) {
                                    for (const {
                                            schema: r,
                                            key: n
                                        } of e.schemas) {
                                        if ((r._flags.id || n) === t.path[0]) return {
                                            perspective: r,
                                            path: t.path.slice(1)
                                        };
                                        if (r.$_terms.shared)
                                            for (const e of r.$_terms.shared)
                                                if (e._flags.id === t.path[0]) return {
                                                    perspective: e,
                                                    path: t.path.slice(1)
                                                }
                                    }
                                    return {
                                        perspective: null,
                                        path: null
                                    }
                                }
                                return "root" === t.ancestor ? {
                                    perspective: e.schemas[e.schemas.length - 1].schema,
                                    path: t.path
                                } : {
                                    perspective: e.schemas[t.ancestor] && e.schemas[t.ancestor].schema,
                                    path: t.path
                                }
                            }, u.assert = function(t, e, r, i, s, a) {
                                t || n(!1, '"'.concat(o.label(i._flags, s, a), '" contains link reference "').concat(r.display, '" ').concat(e))
                            }
                        },
                        3832: (t, e, r) => {
                            "use strict";
                            const n = r(375),
                                i = r(8068),
                                s = r(8160),
                                a = {
                                    numberRx: /^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,
                                    precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/
                                };
                            t.exports = i.extend({
                                type: "number",
                                flags: {
                                    unsafe: {
                                        default: !1
                                    }
                                },
                                coerce: {
                                    from: "string",
                                    method(t, {
                                        schema: e,
                                        error: r
                                    }) {
                                        const n = t.match(a.numberRx);
                                        if (!n) return;
                                        t = t.trim();
                                        const i = {
                                            value: parseFloat(t)
                                        };
                                        if (0 === i.value && (i.value = 0), !e._flags.unsafe)
                                            if (t.match(/e/i)) {
                                                if (a.normalizeExponent("".concat(i.value / Math.pow(10, n[1]), "e").concat(n[1])) !== a.normalizeExponent(t)) return i.errors = r("number.unsafe"), i
                                            } else {
                                                const e = i.value.toString();
                                                if (e.match(/e/i)) return i;
                                                if (e !== a.normalizeDecimal(t)) return i.errors = r("number.unsafe"), i
                                            }
                                        return i
                                    }
                                },
                                validate(t, {
                                    schema: e,
                                    error: r,
                                    prefs: n
                                }) {
                                    if (t === 1 / 0 || t === -1 / 0) return {
                                        value: t,
                                        errors: r("number.infinity")
                                    };
                                    if (!s.isNumber(t)) return {
                                        value: t,
                                        errors: r("number.base")
                                    };
                                    const i = {
                                        value: t
                                    };
                                    if (n.convert) {
                                        const t = e.$_getRule("precision");
                                        if (t) {
                                            const e = Math.pow(10, t.args.limit);
                                            i.value = Math.round(i.value * e) / e
                                        }
                                    }
                                    return 0 === i.value && (i.value = 0), !e._flags.unsafe && (t > Number.MAX_SAFE_INTEGER || t < Number.MIN_SAFE_INTEGER) && (i.errors = r("number.unsafe")), i
                                },
                                rules: {
                                    compare: {
                                        method: !1,
                                        validate: (t, e, {
                                            limit: r
                                        }, {
                                            name: n,
                                            operator: i,
                                            args: a
                                        }) => s.compare(t, r, i) ? t : e.error("number." + n, {
                                            limit: a.limit,
                                            value: t
                                        }),
                                        args: [{
                                            name: "limit",
                                            ref: !0,
                                            assert: s.isNumber,
                                            message: "must be a number"
                                        }]
                                    },
                                    greater: {
                                        method(t) {
                                            return this.$_addRule({
                                                name: "greater",
                                                method: "compare",
                                                args: {
                                                    limit: t
                                                },
                                                operator: ">"
                                            })
                                        }
                                    },
                                    integer: {
                                        method() {
                                            return this.$_addRule("integer")
                                        },
                                        validate: (t, e) => Math.trunc(t) - t == 0 ? t : e.error("number.integer")
                                    },
                                    less: {
                                        method(t) {
                                            return this.$_addRule({
                                                name: "less",
                                                method: "compare",
                                                args: {
                                                    limit: t
                                                },
                                                operator: "<"
                                            })
                                        }
                                    },
                                    max: {
                                        method(t) {
                                            return this.$_addRule({
                                                name: "max",
                                                method: "compare",
                                                args: {
                                                    limit: t
                                                },
                                                operator: "<="
                                            })
                                        }
                                    },
                                    min: {
                                        method(t) {
                                            return this.$_addRule({
                                                name: "min",
                                                method: "compare",
                                                args: {
                                                    limit: t
                                                },
                                                operator: ">="
                                            })
                                        }
                                    },
                                    multiple: {
                                        method(t) {
                                            return this.$_addRule({
                                                name: "multiple",
                                                args: {
                                                    base: t
                                                }
                                            })
                                        },
                                        validate: (t, e, {
                                            base: r
                                        }, n) => t * (1 / r) % 1 == 0 ? t : e.error("number.multiple", {
                                            multiple: n.args.base,
                                            value: t
                                        }),
                                        args: [{
                                            name: "base",
                                            ref: !0,
                                            assert: t => "number" == typeof t && isFinite(t) && t > 0,
                                            message: "must be a positive number"
                                        }],
                                        multi: !0
                                    },
                                    negative: {
                                        method() {
                                            return this.sign("negative")
                                        }
                                    },
                                    port: {
                                        method() {
                                            return this.$_addRule("port")
                                        },
                                        validate: (t, e) => Number.isSafeInteger(t) && t >= 0 && t <= 65535 ? t : e.error("number.port")
                                    },
                                    positive: {
                                        method() {
                                            return this.sign("positive")
                                        }
                                    },
                                    precision: {
                                        method(t) {
                                            return n(Number.isSafeInteger(t), "limit must be an integer"), this.$_addRule({
                                                name: "precision",
                                                args: {
                                                    limit: t
                                                }
                                            })
                                        },
                                        validate(t, e, {
                                            limit: r
                                        }) {
                                            const n = t.toString().match(a.precisionRx);
                                            return Math.max((n[1] ? n[1].length : 0) - (n[2] ? parseInt(n[2], 10) : 0), 0) <= r ? t : e.error("number.precision", {
                                                limit: r,
                                                value: t
                                            })
                                        },
                                        convert: !0
                                    },
                                    sign: {
                                        method(t) {
                                            return n(["negative", "positive"].includes(t), "Invalid sign", t), this.$_addRule({
                                                name: "sign",
                                                args: {
                                                    sign: t
                                                }
                                            })
                                        },
                                        validate: (t, e, {
                                            sign: r
                                        }) => "negative" === r && t < 0 || "positive" === r && t > 0 ? t : e.error("number.".concat(r))
                                    },
                                    unsafe: {
                                        method(t = !0) {
                                            return n("boolean" == typeof t, "enabled must be a boolean"), this.$_setFlag("unsafe", t)
                                        }
                                    }
                                },
                                cast: {
                                    string: {
                                        from: t => "number" == typeof t,
                                        to: (t, e) => t.toString()
                                    }
                                },
                                messages: {
                                    "number.base": "{{#label}} must be a number",
                                    "number.greater": "{{#label}} must be greater than {{#limit}}",
                                    "number.infinity": "{{#label}} cannot be infinity",
                                    "number.integer": "{{#label}} must be an integer",
                                    "number.less": "{{#label}} must be less than {{#limit}}",
                                    "number.max": "{{#label}} must be less than or equal to {{#limit}}",
                                    "number.min": "{{#label}} must be greater than or equal to {{#limit}}",
                                    "number.multiple": "{{#label}} must be a multiple of {{#multiple}}",
                                    "number.negative": "{{#label}} must be a negative number",
                                    "number.port": "{{#label}} must be a valid port",
                                    "number.positive": "{{#label}} must be a positive number",
                                    "number.precision": "{{#label}} must have no more than {{#limit}} decimal places",
                                    "number.unsafe": "{{#label}} must be a safe number"
                                }
                            }), a.normalizeExponent = function(t) {
                                return t.replace(/E/, "e").replace(/\.(\d*[1-9])?0+e/, ".$1e").replace(/\.e/, "e").replace(/e\+/, "e").replace(/^\+/, "").replace(/^(-?)0+([1-9])/, "$1$2")
                            }, a.normalizeDecimal = function(t) {
                                return (t = t.replace(/^\+/, "").replace(/\.0*$/, "").replace(/^(-?)\.([^\.]*)$/, "$10.$2").replace(/^(-?)0+([0-9])/, "$1$2")).includes(".") && t.endsWith("0") && (t = t.replace(/0+$/, "")), "-0" === t ? "0" : t
                            }
                        },
                        8966: (t, e, r) => {
                            "use strict";
                            const n = r(7824);
                            t.exports = n.extend({
                                type: "object",
                                cast: {
                                    map: {
                                        from: t => t && "object" == typeof t,
                                        to: (t, e) => new Map(Object.entries(t))
                                    }
                                }
                            })
                        },
                        7417: (t, e, r) => {
                            "use strict";

                            function n(t, e) {
                                var r = Object.keys(t);
                                if (Object.getOwnPropertySymbols) {
                                    var n = Object.getOwnPropertySymbols(t);
                                    e && (n = n.filter((function(e) {
                                        return Object.getOwnPropertyDescriptor(t, e).enumerable
                                    }))), r.push.apply(r, n)
                                }
                                return r
                            }

                            function i(t) {
                                for (var e = 1; e < arguments.length; e++) {
                                    var r = null != arguments[e] ? arguments[e] : {};
                                    e % 2 ? n(Object(r), !0).forEach((function(e) {
                                        s(t, e, r[e])
                                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : n(Object(r)).forEach((function(e) {
                                        Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(r, e))
                                    }))
                                }
                                return t
                            }

                            function s(t, e, r) {
                                return e in t ? Object.defineProperty(t, e, {
                                    value: r,
                                    enumerable: !0,
                                    configurable: !0,
                                    writable: !0
                                }) : t[e] = r, t
                            }
                            const a = r(375),
                                o = r(5380),
                                u = r(1745),
                                h = r(9959),
                                f = r(6064),
                                c = r(9926),
                                l = r(5752),
                                d = r(8068),
                                p = r(8160),
                                m = {
                                    tlds: c instanceof Set && {
                                        tlds: {
                                            allow: c,
                                            deny: null
                                        }
                                    },
                                    base64Regex: {
                                        true: {
                                            true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/,
                                            false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/
                                        },
                                        false: {
                                            true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/,
                                            false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/
                                        }
                                    },
                                    dataUriRegex: /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,
                                    hexRegex: /^[a-f0-9]+$/i,
                                    ipRegex: h.regex({
                                        cidr: "forbidden"
                                    }).regex,
                                    isoDurationRegex: /^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,
                                    guidBrackets: {
                                        "{": "}",
                                        "[": "]",
                                        "(": ")",
                                        "": ""
                                    },
                                    guidVersions: {
                                        uuidv1: "1",
                                        uuidv2: "2",
                                        uuidv3: "3",
                                        uuidv4: "4",
                                        uuidv5: "5"
                                    },
                                    guidSeparators: new Set([void 0, !0, !1, "-", ":"]),
                                    normalizationForms: ["NFC", "NFD", "NFKC", "NFKD"]
                                };
                            t.exports = d.extend({
                                type: "string",
                                flags: {
                                    insensitive: {
                                        default: !1
                                    },
                                    truncate: {
                                        default: !1
                                    }
                                },
                                terms: {
                                    replacements: {
                                        init: null
                                    }
                                },
                                coerce: {
                                    from: "string",
                                    method(t, {
                                        schema: e,
                                        state: r,
                                        prefs: n
                                    }) {
                                        const i = e.$_getRule("normalize");
                                        i && (t = t.normalize(i.args.form));
                                        const s = e.$_getRule("case");
                                        s && (t = "upper" === s.args.direction ? t.toLocaleUpperCase() : t.toLocaleLowerCase());
                                        const a = e.$_getRule("trim");
                                        if (a && a.args.enabled && (t = t.trim()), e.$_terms.replacements)
                                            for (const u of e.$_terms.replacements) t = t.replace(u.pattern, u.replacement);
                                        const o = e.$_getRule("hex");
                                        if (o && o.args.options.byteAligned && t.length % 2 != 0 && (t = "0".concat(t)), e.$_getRule("isoDate")) {
                                            const e = m.isoDate(t);
                                            e && (t = e)
                                        }
                                        if (e._flags.truncate) {
                                            const i = e.$_getRule("max");
                                            if (i) {
                                                let s = i.args.limit;
                                                if (p.isResolvable(s) && (s = s.resolve(t, r, n), !p.limit(s))) return {
                                                    value: t,
                                                    errors: e.$_createError("any.ref", s, {
                                                        ref: i.args.limit,
                                                        arg: "limit",
                                                        reason: "must be a positive integer"
                                                    }, r, n)
                                                };
                                                t = t.slice(0, s)
                                            }
                                        }
                                        return {
                                            value: t
                                        }
                                    }
                                },
                                validate(t, {
                                    schema: e,
                                    error: r
                                }) {
                                    if ("string" != typeof t) return {
                                        value: t,
                                        errors: r("string.base")
                                    };
                                    if ("" === t) {
                                        const n = e.$_getRule("min");
                                        if (n && 0 === n.args.limit) return;
                                        return {
                                            value: t,
                                            errors: r("string.empty")
                                        }
                                    }
                                },
                                rules: {
                                    alphanum: {
                                        method() {
                                            return this.$_addRule("alphanum")
                                        },
                                        validate: (t, e) => /^[a-zA-Z0-9]+$/.test(t) ? t : e.error("string.alphanum")
                                    },
                                    base64: {
                                        method(t = {}) {
                                            return p.assertOptions(t, ["paddingRequired", "urlSafe"]), t = i({
                                                urlSafe: !1,
                                                paddingRequired: !0
                                            }, t), a("boolean" == typeof t.paddingRequired, "paddingRequired must be boolean"), a("boolean" == typeof t.urlSafe, "urlSafe must be boolean"), this.$_addRule({
                                                name: "base64",
                                                args: {
                                                    options: t
                                                }
                                            })
                                        },
                                        validate: (t, e, {
                                            options: r
                                        }) => m.base64Regex[r.paddingRequired][r.urlSafe].test(t) ? t : e.error("string.base64")
                                    },
                                    case: {
                                        method(t) {
                                            return a(["lower", "upper"].includes(t), "Invalid case:", t), this.$_addRule({
                                                name: "case",
                                                args: {
                                                    direction: t
                                                }
                                            })
                                        },
                                        validate: (t, e, {
                                            direction: r
                                        }) => "lower" === r && t === t.toLocaleLowerCase() || "upper" === r && t === t.toLocaleUpperCase() ? t : e.error("string.".concat(r, "case")),
                                        convert: !0
                                    },
                                    creditCard: {
                                        method() {
                                            return this.$_addRule("creditCard")
                                        },
                                        validate(t, e) {
                                            let r = t.length,
                                                n = 0,
                                                i = 1;
                                            for (; r--;) {
                                                const e = t.charAt(r) * i;
                                                n += e - 9 * (e > 9), i ^= 3
                                            }
                                            return n > 0 && n % 10 == 0 ? t : e.error("string.creditCard")
                                        }
                                    },
                                    dataUri: {
                                        method(t = {}) {
                                            return p.assertOptions(t, ["paddingRequired"]), t = i({
                                                paddingRequired: !0
                                            }, t), a("boolean" == typeof t.paddingRequired, "paddingRequired must be boolean"), this.$_addRule({
                                                name: "dataUri",
                                                args: {
                                                    options: t
                                                }
                                            })
                                        },
                                        validate(t, e, {
                                            options: r
                                        }) {
                                            const n = t.match(m.dataUriRegex);
                                            if (n) {
                                                if (!n[2]) return t;
                                                if ("base64" !== n[2]) return t;
                                                if (m.base64Regex[r.paddingRequired].false.test(n[3])) return t
                                            }
                                            return e.error("string.dataUri")
                                        }
                                    },
                                    domain: {
                                        method(t) {
                                            t && p.assertOptions(t, ["allowFullyQualified", "allowUnicode", "maxDomainSegments", "minDomainSegments", "tlds"]);
                                            const e = m.addressOptions(t);
                                            return this.$_addRule({
                                                name: "domain",
                                                args: {
                                                    options: t
                                                },
                                                address: e
                                            })
                                        },
                                        validate: (t, e, r, {
                                            address: n
                                        }) => o.isValid(t, n) ? t : e.error("string.domain")
                                    },
                                    email: {
                                        method(t = {}) {
                                            p.assertOptions(t, ["allowFullyQualified", "allowUnicode", "ignoreLength", "maxDomainSegments", "minDomainSegments", "multiple", "separator", "tlds"]), a(void 0 === t.multiple || "boolean" == typeof t.multiple, "multiple option must be an boolean");
                                            const e = m.addressOptions(t),
                                                r = new RegExp("\\s*[".concat(t.separator ? f(t.separator) : ",", "]\\s*"));
                                            return this.$_addRule({
                                                name: "email",
                                                args: {
                                                    options: t
                                                },
                                                regex: r,
                                                address: e
                                            })
                                        },
                                        validate(t, e, {
                                            options: r
                                        }, {
                                            regex: n,
                                            address: i
                                        }) {
                                            const s = r.multiple ? t.split(n) : [t],
                                                a = [];
                                            for (const o of s) u.isValid(o, i) || a.push(o);
                                            return a.length ? e.error("string.email", {
                                                value: t,
                                                invalids: a
                                            }) : t
                                        }
                                    },
                                    guid: {
                                        alias: "uuid",
                                        method(t = {}) {
                                            p.assertOptions(t, ["version", "separator"]);
                                            let e = "";
                                            if (t.version) {
                                                const r = [].concat(t.version);
                                                a(r.length >= 1, "version must have at least 1 valid version specified");
                                                const n = new Set;
                                                for (let t = 0; t < r.length; ++t) {
                                                    const i = r[t];
                                                    a("string" == typeof i, "version at position " + t + " must be a string");
                                                    const s = m.guidVersions[i.toLowerCase()];
                                                    a(s, "version at position " + t + " must be one of " + Object.keys(m.guidVersions).join(", ")), a(!n.has(s), "version at position " + t + " must not be a duplicate"), e += s, n.add(s)
                                                }
                                            }
                                            a(m.guidSeparators.has(t.separator), 'separator must be one of true, false, "-", or ":"');
                                            const r = void 0 === t.separator ? "[:-]?" : !0 === t.separator ? "[:-]" : !1 === t.separator ? "[]?" : "\\".concat(t.separator),
                                                n = new RegExp("^([\\[{\\(]?)[0-9A-F]{8}(".concat(r, ")[0-9A-F]{4}\\2?[").concat(e || "0-9A-F", "][0-9A-F]{3}\\2?[").concat(e ? "89AB" : "0-9A-F", "][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$"), "i");
                                            return this.$_addRule({
                                                name: "guid",
                                                args: {
                                                    options: t
                                                },
                                                regex: n
                                            })
                                        },
                                        validate(t, e, r, {
                                            regex: n
                                        }) {
                                            const i = n.exec(t);
                                            return i ? m.guidBrackets[i[1]] !== i[i.length - 1] ? e.error("string.guid") : t : e.error("string.guid")
                                        }
                                    },
                                    hex: {
                                        method(t = {}) {
                                            return p.assertOptions(t, ["byteAligned"]), t = i({
                                                byteAligned: !1
                                            }, t), a("boolean" == typeof t.byteAligned, "byteAligned must be boolean"), this.$_addRule({
                                                name: "hex",
                                                args: {
                                                    options: t
                                                }
                                            })
                                        },
                                        validate: (t, e, {
                                            options: r
                                        }) => m.hexRegex.test(t) ? r.byteAligned && t.length % 2 != 0 ? e.error("string.hexAlign") : t : e.error("string.hex")
                                    },
                                    hostname: {
                                        method() {
                                            return this.$_addRule("hostname")
                                        },
                                        validate: (t, e) => o.isValid(t, {
                                            minDomainSegments: 1
                                        }) || m.ipRegex.test(t) ? t : e.error("string.hostname")
                                    },
                                    insensitive: {
                                        method() {
                                            return this.$_setFlag("insensitive", !0)
                                        }
                                    },
                                    ip: {
                                        method(t = {}) {
                                            p.assertOptions(t, ["cidr", "version"]);
                                            const {
                                                cidr: e,
                                                versions: r,
                                                regex: n
                                            } = h.regex(t), i = t.version ? r : void 0;
                                            return this.$_addRule({
                                                name: "ip",
                                                args: {
                                                    options: {
                                                        cidr: e,
                                                        version: i
                                                    }
                                                },
                                                regex: n
                                            })
                                        },
                                        validate: (t, e, {
                                            options: r
                                        }, {
                                            regex: n
                                        }) => n.test(t) ? t : r.version ? e.error("string.ipVersion", {
                                            value: t,
                                            cidr: r.cidr,
                                            version: r.version
                                        }) : e.error("string.ip", {
                                            value: t,
                                            cidr: r.cidr
                                        })
                                    },
                                    isoDate: {
                                        method() {
                                            return this.$_addRule("isoDate")
                                        },
                                        validate: (t, {
                                            error: e
                                        }) => m.isoDate(t) ? t : e("string.isoDate")
                                    },
                                    isoDuration: {
                                        method() {
                                            return this.$_addRule("isoDuration")
                                        },
                                        validate: (t, e) => m.isoDurationRegex.test(t) ? t : e.error("string.isoDuration")
                                    },
                                    length: {
                                        method(t, e) {
                                            return m.length(this, "length", t, "=", e)
                                        },
                                        validate(t, e, {
                                            limit: r,
                                            encoding: n
                                        }, {
                                            name: i,
                                            operator: s,
                                            args: a
                                        }) {
                                            const o = !n && t.length;
                                            return p.compare(o, r, s) ? t : e.error("string." + i, {
                                                limit: a.limit,
                                                value: t,
                                                encoding: n
                                            })
                                        },
                                        args: [{
                                            name: "limit",
                                            ref: !0,
                                            assert: p.limit,
                                            message: "must be a positive integer"
                                        }, "encoding"]
                                    },
                                    lowercase: {
                                        method() {
                                            return this.case("lower")
                                        }
                                    },
                                    max: {
                                        method(t, e) {
                                            return m.length(this, "max", t, "<=", e)
                                        },
                                        args: ["limit", "encoding"]
                                    },
                                    min: {
                                        method(t, e) {
                                            return m.length(this, "min", t, ">=", e)
                                        },
                                        args: ["limit", "encoding"]
                                    },
                                    normalize: {
                                        method(t = "NFC") {
                                            return a(m.normalizationForms.includes(t), "normalization form must be one of " + m.normalizationForms.join(", ")), this.$_addRule({
                                                name: "normalize",
                                                args: {
                                                    form: t
                                                }
                                            })
                                        },
                                        validate: (t, {
                                            error: e
                                        }, {
                                            form: r
                                        }) => t === t.normalize(r) ? t : e("string.normalize", {
                                            value: t,
                                            form: r
                                        }),
                                        convert: !0
                                    },
                                    pattern: {
                                        alias: "regex",
                                        method(t, e = {}) {
                                            a(t instanceof RegExp, "regex must be a RegExp"), a(!t.flags.includes("g") && !t.flags.includes("y"), "regex should not use global or sticky mode"), "string" == typeof e && (e = {
                                                name: e
                                            }), p.assertOptions(e, ["invert", "name"]);
                                            const r = ["string.pattern", e.invert ? ".invert" : "", e.name ? ".name" : ".base"].join("");
                                            return this.$_addRule({
                                                name: "pattern",
                                                args: {
                                                    regex: t,
                                                    options: e
                                                },
                                                errorCode: r
                                            })
                                        },
                                        validate: (t, e, {
                                            regex: r,
                                            options: n
                                        }, {
                                            errorCode: i
                                        }) => r.test(t) ^ n.invert ? t : e.error(i, {
                                            name: n.name,
                                            regex: r,
                                            value: t
                                        }),
                                        args: ["regex", "options"],
                                        multi: !0
                                    },
                                    replace: {
                                        method(t, e) {
                                            "string" == typeof t && (t = new RegExp(f(t), "g")), a(t instanceof RegExp, "pattern must be a RegExp"), a("string" == typeof e, "replacement must be a String");
                                            const r = this.clone();
                                            return r.$_terms.replacements || (r.$_terms.replacements = []), r.$_terms.replacements.push({
                                                pattern: t,
                                                replacement: e
                                            }), r
                                        }
                                    },
                                    token: {
                                        method() {
                                            return this.$_addRule("token")
                                        },
                                        validate: (t, e) => /^\w+$/.test(t) ? t : e.error("string.token")
                                    },
                                    trim: {
                                        method(t = !0) {
                                            return a("boolean" == typeof t, "enabled must be a boolean"), this.$_addRule({
                                                name: "trim",
                                                args: {
                                                    enabled: t
                                                }
                                            })
                                        },
                                        validate: (t, e, {
                                            enabled: r
                                        }) => r && t !== t.trim() ? e.error("string.trim") : t,
                                        convert: !0
                                    },
                                    truncate: {
                                        method(t = !0) {
                                            return a("boolean" == typeof t, "enabled must be a boolean"), this.$_setFlag("truncate", t)
                                        }
                                    },
                                    uppercase: {
                                        method() {
                                            return this.case("upper")
                                        }
                                    },
                                    uri: {
                                        method(t = {}) {
                                            p.assertOptions(t, ["allowRelative", "allowQuerySquareBrackets", "domain", "relativeOnly", "scheme"]), t.domain && p.assertOptions(t.domain, ["allowFullyQualified", "allowUnicode", "maxDomainSegments", "minDomainSegments", "tlds"]);
                                            const {
                                                regex: e,
                                                scheme: r
                                            } = l.regex(t), n = t.domain ? m.addressOptions(t.domain) : null;
                                            return this.$_addRule({
                                                name: "uri",
                                                args: {
                                                    options: t
                                                },
                                                regex: e,
                                                domain: n,
                                                scheme: r
                                            })
                                        },
                                        validate(t, e, {
                                            options: r
                                        }, {
                                            regex: n,
                                            domain: i,
                                            scheme: s
                                        }) {
                                            if (["http:/", "https:/"].includes(t)) return e.error("string.uri");
                                            const a = n.exec(t);
                                            if (a) {
                                                const n = a[1] || a[2];
                                                return !i || r.allowRelative && !n || o.isValid(n, i) ? t : e.error("string.domain", {
                                                    value: n
                                                })
                                            }
                                            return r.relativeOnly ? e.error("string.uriRelativeOnly") : r.scheme ? e.error("string.uriCustomScheme", {
                                                scheme: s,
                                                value: t
                                            }) : e.error("string.uri")
                                        }
                                    }
                                },
                                manifest: {
                                    build(t, e) {
                                        if (e.replacements)
                                            for (const {
                                                    pattern: r,
                                                    replacement: n
                                                } of e.replacements) t = t.replace(r, n);
                                        return t
                                    }
                                },
                                messages: {
                                    "string.alphanum": "{{#label}} must only contain alpha-numeric characters",
                                    "string.base": "{{#label}} must be a string",
                                    "string.base64": "{{#label}} must be a valid base64 string",
                                    "string.creditCard": "{{#label}} must be a credit card",
                                    "string.dataUri": "{{#label}} must be a valid dataUri string",
                                    "string.domain": "{{#label}} must contain a valid domain name",
                                    "string.email": "{{#label}} must be a valid email",
                                    "string.empty": "{{#label}} is not allowed to be empty",
                                    "string.guid": "{{#label}} must be a valid GUID",
                                    "string.hex": "{{#label}} must only contain hexadecimal characters",
                                    "string.hexAlign": "{{#label}} hex decoded representation must be byte aligned",
                                    "string.hostname": "{{#label}} must be a valid hostname",
                                    "string.ip": "{{#label}} must be a valid ip address with a {{#cidr}} CIDR",
                                    "string.ipVersion": "{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR",
                                    "string.isoDate": "{{#label}} must be in iso format",
                                    "string.isoDuration": "{{#label}} must be a valid ISO 8601 duration",
                                    "string.length": "{{#label}} length must be {{#limit}} characters long",
                                    "string.lowercase": "{{#label}} must only contain lowercase characters",
                                    "string.max": "{{#label}} length must be less than or equal to {{#limit}} characters long",
                                    "string.min": "{{#label}} length must be at least {{#limit}} characters long",
                                    "string.normalize": "{{#label}} must be unicode normalized in the {{#form}} form",
                                    "string.token": "{{#label}} must only contain alpha-numeric and underscore characters",
                                    "string.pattern.base": "{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}",
                                    "string.pattern.name": "{{#label}} with value {:[.]} fails to match the {{#name}} pattern",
                                    "string.pattern.invert.base": "{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}",
                                    "string.pattern.invert.name": "{{#label}} with value {:[.]} matches the inverted {{#name}} pattern",
                                    "string.trim": "{{#label}} must not have leading or trailing whitespace",
                                    "string.uri": "{{#label}} must be a valid uri",
                                    "string.uriCustomScheme": "{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern",
                                    "string.uriRelativeOnly": "{{#label}} must be a valid relative uri",
                                    "string.uppercase": "{{#label}} must only contain uppercase characters"
                                }
                            }), m.addressOptions = function(t) {
                                if (!t) return t;
                                if (a(void 0 === t.minDomainSegments || Number.isSafeInteger(t.minDomainSegments) && t.minDomainSegments > 0, "minDomainSegments must be a positive integer"), a(void 0 === t.maxDomainSegments || Number.isSafeInteger(t.maxDomainSegments) && t.maxDomainSegments > 0, "maxDomainSegments must be a positive integer"), !1 === t.tlds) return t;
                                if (!0 === t.tlds || void 0 === t.tlds) return a(m.tlds, "Built-in TLD list disabled"), Object.assign({}, t, m.tlds);
                                a("object" == typeof t.tlds, "tlds must be true, false, or an object");
                                const e = t.tlds.deny;
                                if (e) return Array.isArray(e) && (t = Object.assign({}, t, {
                                    tlds: {
                                        deny: new Set(e)
                                    }
                                })), a(t.tlds.deny instanceof Set, "tlds.deny must be an array, Set, or boolean"), a(!t.tlds.allow, "Cannot specify both tlds.allow and tlds.deny lists"), m.validateTlds(t.tlds.deny, "tlds.deny"), t;
                                const r = t.tlds.allow;
                                return r ? !0 === r ? (a(m.tlds, "Built-in TLD list disabled"), Object.assign({}, t, m.tlds)) : (Array.isArray(r) && (t = Object.assign({}, t, {
                                    tlds: {
                                        allow: new Set(r)
                                    }
                                })), a(t.tlds.allow instanceof Set, "tlds.allow must be an array, Set, or boolean"), m.validateTlds(t.tlds.allow, "tlds.allow"), t) : t
                            }, m.validateTlds = function(t, e) {
                                for (const r of t) a(o.isValid(r, {
                                    minDomainSegments: 1,
                                    maxDomainSegments: 1
                                }), "".concat(e, " must contain valid top level domain names"))
                            }, m.isoDate = function(t) {
                                if (!p.isIsoDate(t)) return null;
                                /.*T.*[+-]\d\d$/.test(t) && (t += "00");
                                const e = new Date(t);
                                return isNaN(e.getTime()) ? null : e.toISOString()
                            }, m.length = function(t, e, r, n, i) {
                                return a(!i || !1, "Invalid encoding:", i), t.$_addRule({
                                    name: e,
                                    method: "length",
                                    args: {
                                        limit: r,
                                        encoding: i
                                    },
                                    operator: n
                                })
                            }
                        },
                        8826: (t, e, r) => {
                            "use strict";
                            const n = r(375),
                                i = r(8068),
                                s = {};
                            s.Map = class extends Map {
                                slice() {
                                    return new s.Map(this)
                                }
                            }, t.exports = i.extend({
                                type: "symbol",
                                terms: {
                                    map: {
                                        init: new s.Map
                                    }
                                },
                                coerce: {
                                    method(t, {
                                        schema: e,
                                        error: r
                                    }) {
                                        const n = e.$_terms.map.get(t);
                                        return n && (t = n), e._flags.only && "symbol" != typeof t ? {
                                            value: t,
                                            errors: r("symbol.map", {
                                                map: e.$_terms.map
                                            })
                                        } : {
                                            value: t
                                        }
                                    }
                                },
                                validate(t, {
                                    error: e
                                }) {
                                    if ("symbol" != typeof t) return {
                                        value: t,
                                        errors: e("symbol.base")
                                    }
                                },
                                rules: {
                                    map: {
                                        method(t) {
                                            t && !t[Symbol.iterator] && "object" == typeof t && (t = Object.entries(t)), n(t && t[Symbol.iterator], "Iterable must be an iterable or object");
                                            const e = this.clone(),
                                                r = [];
                                            for (const i of t) {
                                                n(i && i[Symbol.iterator], "Entry must be an iterable");
                                                const [t, s] = i;
                                                n("object" != typeof t && "function" != typeof t && "symbol" != typeof t, "Key must not be of type object, function, or Symbol"), n("symbol" == typeof s, "Value must be a Symbol"), e.$_terms.map.set(t, s), r.push(s)
                                            }
                                            return e.valid(...r)
                                        }
                                    }
                                },
                                manifest: {
                                    build: (t, e) => (e.map && (t = t.map(e.map)), t)
                                },
                                messages: {
                                    "symbol.base": "{{#label}} must be a symbol",
                                    "symbol.map": "{{#label}} must be one of {{#map}}"
                                }
                            })
                        },
                        8863: (t, e, r) => {
                            "use strict";
                            const n = r(375),
                                i = r(8571),
                                s = r(738),
                                a = r(9621),
                                o = r(8160),
                                u = r(6354),
                                h = r(493),
                                f = {
                                    result: Symbol("result")
                                };
                            e.entry = function(t, e, r) {
                                let i = o.defaults;
                                r && (n(void 0 === r.warnings, "Cannot override warnings preference in synchronous validation"), n(void 0 === r.artifacts, "Cannot override artifacts preference in synchronous validation"), i = o.preferences(o.defaults, r));
                                const s = f.entry(t, e, i);
                                n(!s.mainstay.externals.length, "Schema with external rules must use validateAsync()");
                                const a = {
                                    value: s.value
                                };
                                return s.error && (a.error = s.error), s.mainstay.warnings.length && (a.warning = u.details(s.mainstay.warnings)), s.mainstay.debug && (a.debug = s.mainstay.debug), s.mainstay.artifacts && (a.artifacts = s.mainstay.artifacts), a
                            }, e.entryAsync = async function(t, e, r) {
                                let n = o.defaults;
                                r && (n = o.preferences(o.defaults, r));
                                const i = f.entry(t, e, n),
                                    s = i.mainstay;
                                if (i.error) throw s.debug && (i.error.debug = s.debug), i.error;
                                if (s.externals.length) {
                                    let e = i.value;
                                    for (const {
                                            method: i,
                                            path: o,
                                            label: u
                                        } of s.externals) {
                                        let s, h, f = e;
                                        o.length && (s = o[o.length - 1], h = a(e, o.slice(0, -1)), f = h[s]);
                                        try {
                                            const t = await i(f, {
                                                prefs: r
                                            });
                                            if (void 0 === t || t === f) continue;
                                            h ? h[s] = t : e = t
                                        } catch (t) {
                                            throw n.errors.label && (t.message += " (".concat(u, ")")), t
                                        }
                                    }
                                    i.value = e
                                }
                                if (!n.warnings && !n.debug && !n.artifacts) return i.value;
                                const h = {
                                    value: i.value
                                };
                                return s.warnings.length && (h.warning = u.details(s.warnings)), s.debug && (h.debug = s.debug), s.artifacts && (h.artifacts = s.artifacts), h
                            }, f.entry = function(t, r, n) {
                                const {
                                    tracer: i,
                                    cleanup: s
                                } = f.tracer(r, n), a = {
                                    externals: [],
                                    warnings: [],
                                    tracer: i,
                                    debug: n.debug ? [] : null,
                                    links: r._ids._schemaChain ? new Map : null
                                }, o = r._ids._schemaChain ? [{
                                    schema: r
                                }] : null, c = new h([], [], {
                                    mainstay: a,
                                    schemas: o
                                }), l = e.validate(t, r, c, n);
                                s && r.$_root.untrace();
                                const d = u.process(l.errors, t, n);
                                return {
                                    value: l.value,
                                    error: d,
                                    mainstay: a
                                }
                            }, f.tracer = function(t, e) {
                                return t.$_root._tracer ? {
                                    tracer: t.$_root._tracer._register(t)
                                } : e.debug ? (n(t.$_root.trace, "Debug mode not supported"), {
                                    tracer: t.$_root.trace()._register(t),
                                    cleanup: !0
                                }) : {
                                    tracer: f.ignore
                                }
                            }, e.validate = function(t, e, r, n, i = {}) {
                                if (e.$_terms.whens && (e = e._generate(t, r, n).schema), e._preferences && (n = f.prefs(e, n)), e._cache && n.cache) {
                                    const n = e._cache.get(t);
                                    if (r.mainstay.tracer.debug(r, "validate", "cached", !!n), n) return n
                                }
                                const s = (i, s, a) => e.$_createError(i, t, s, a || r, n),
                                    a = {
                                        original: t,
                                        prefs: n,
                                        schema: e,
                                        state: r,
                                        error: s,
                                        errorsArray: f.errorsArray,
                                        warn: (t, e, n) => r.mainstay.warnings.push(s(t, e, n)),
                                        message: (i, s) => e.$_createError("custom", t, s, r, n, {
                                            messages: i
                                        })
                                    };
                                r.mainstay.tracer.entry(e, r);
                                const u = e._definition;
                                if (u.prepare && void 0 !== t && n.convert) {
                                    const e = u.prepare(t, a);
                                    if (e) {
                                        if (r.mainstay.tracer.value(r, "prepare", t, e.value), e.errors) return f.finalize(e.value, [].concat(e.errors), a);
                                        t = e.value
                                    }
                                }
                                if (u.coerce && void 0 !== t && n.convert && (!u.coerce.from || u.coerce.from.includes(typeof t))) {
                                    const e = u.coerce.method(t, a);
                                    if (e) {
                                        if (r.mainstay.tracer.value(r, "coerced", t, e.value), e.errors) return f.finalize(e.value, [].concat(e.errors), a);
                                        t = e.value
                                    }
                                }
                                const h = e._flags.empty;
                                h && h.$_match(f.trim(t, e), r.nest(h), o.defaults) && (r.mainstay.tracer.value(r, "empty", t, void 0), t = void 0);
                                const c = i.presence || e._flags.presence || (e._flags._endedSwitch ? null : n.presence);
                                if (void 0 === t) {
                                    if ("forbidden" === c) return f.finalize(t, null, a);
                                    if ("required" === c) return f.finalize(t, [e.$_createError("any.required", t, null, r, n)], a);
                                    if ("optional" === c) {
                                        if (e._flags.default !== o.symbols.deepDefault) return f.finalize(t, null, a);
                                        r.mainstay.tracer.value(r, "default", t, {}), t = {}
                                    }
                                } else if ("forbidden" === c) return f.finalize(t, [e.$_createError("any.unknown", t, null, r, n)], a);
                                const l = [];
                                if (e._valids) {
                                    const i = e._valids.get(t, r, n, e._flags.insensitive);
                                    if (i) return n.convert && (r.mainstay.tracer.value(r, "valids", t, i.value), t = i.value), r.mainstay.tracer.filter(e, r, "valid", i), f.finalize(t, null, a);
                                    if (e._flags.only) {
                                        const i = e.$_createError("any.only", t, {
                                            valids: e._valids.values({
                                                display: !0
                                            })
                                        }, r, n);
                                        if (n.abortEarly) return f.finalize(t, [i], a);
                                        l.push(i)
                                    }
                                }
                                if (e._invalids) {
                                    const i = e._invalids.get(t, r, n, e._flags.insensitive);
                                    if (i) {
                                        r.mainstay.tracer.filter(e, r, "invalid", i);
                                        const s = e.$_createError("any.invalid", t, {
                                            invalids: e._invalids.values({
                                                display: !0
                                            })
                                        }, r, n);
                                        if (n.abortEarly) return f.finalize(t, [s], a);
                                        l.push(s)
                                    }
                                }
                                if (u.validate) {
                                    const e = u.validate(t, a);
                                    if (e && (r.mainstay.tracer.value(r, "base", t, e.value), t = e.value, e.errors)) {
                                        if (!Array.isArray(e.errors)) return l.push(e.errors), f.finalize(t, l, a);
                                        if (e.errors.length) return l.push(...e.errors), f.finalize(t, l, a)
                                    }
                                }
                                return e._rules.length ? f.rules(t, l, a) : f.finalize(t, l, a)
                            }, f.rules = function(t, e, r) {
                                const {
                                    schema: n,
                                    state: i,
                                    prefs: s
                                } = r;
                                for (const a of n._rules) {
                                    const u = n._definition.rules[a.method];
                                    if (u.convert && s.convert) {
                                        i.mainstay.tracer.log(n, i, "rule", a.name, "full");
                                        continue
                                    }
                                    let h, c = a.args;
                                    if (a._resolve.length) {
                                        c = Object.assign({}, c);
                                        for (const e of a._resolve) {
                                            const r = u.argsByName.get(e),
                                                a = c[e].resolve(t, i, s),
                                                f = r.normalize ? r.normalize(a) : a,
                                                l = o.validateArg(f, null, r);
                                            if (l) {
                                                h = n.$_createError("any.ref", a, {
                                                    arg: e,
                                                    ref: c[e],
                                                    reason: l
                                                }, i, s);
                                                break
                                            }
                                            c[e] = f
                                        }
                                    }
                                    h = h || u.validate(t, r, c, a);
                                    const l = f.rule(h, a);
                                    if (l.errors) {
                                        if (i.mainstay.tracer.log(n, i, "rule", a.name, "error"), a.warn) {
                                            i.mainstay.warnings.push(...l.errors);
                                            continue
                                        }
                                        if (s.abortEarly) return f.finalize(t, l.errors, r);
                                        e.push(...l.errors)
                                    } else i.mainstay.tracer.log(n, i, "rule", a.name, "pass"), i.mainstay.tracer.value(i, "rule", t, l.value, a.name), t = l.value
                                }
                                return f.finalize(t, e, r)
                            }, f.rule = function(t, e) {
                                return t instanceof u.Report ? (f.error(t, e), {
                                    errors: [t],
                                    value: null
                                }) : Array.isArray(t) && t[o.symbols.errors] ? (t.forEach(t => f.error(t, e)), {
                                    errors: t,
                                    value: null
                                }) : {
                                    errors: null,
                                    value: t
                                }
                            }, f.error = function(t, e) {
                                return e.message && t._setTemplate(e.message), t
                            }, f.finalize = function(t, e, r) {
                                e = e || [];
                                const {
                                    schema: i,
                                    state: s,
                                    prefs: a
                                } = r;
                                if (e.length) {
                                    const n = f.default("failover", void 0, e, r);
                                    void 0 !== n && (s.mainstay.tracer.value(s, "failover", t, n), t = n, e = [])
                                }
                                if (e.length && i._flags.error)
                                    if ("function" == typeof i._flags.error) {
                                        e = i._flags.error(e), Array.isArray(e) || (e = [e]);
                                        for (const t of e) n(t instanceof Error || t instanceof u.Report, "error() must return an Error object")
                                    } else e = [i._flags.error];
                                if (void 0 === t) {
                                    const n = f.default("default", t, e, r);
                                    s.mainstay.tracer.value(s, "default", t, n), t = n
                                }
                                if (i._flags.cast && void 0 !== t) {
                                    const e = i._definition.cast[i._flags.cast];
                                    if (e.from(t)) {
                                        const n = e.to(t, r);
                                        s.mainstay.tracer.value(s, "cast", t, n, i._flags.cast), t = n
                                    }
                                }
                                if (i.$_terms.externals && a.externals && !1 !== a._externals)
                                    for (const {
                                            method: n
                                        } of i.$_terms.externals) s.mainstay.externals.push({
                                        method: n,
                                        path: s.path,
                                        label: u.label(i._flags, s, a)
                                    });
                                const o = {
                                    value: t,
                                    errors: e.length ? e : null
                                };
                                return i._flags.result && (o.value = "strip" === i._flags.result ? void 0 : r.original, s.mainstay.tracer.value(s, i._flags.result, t, o.value), s.shadow(t, i._flags.result)), i._cache && !1 !== a.cache && !i._refs.length && i._cache.set(r.original, o), void 0 === t || o.errors || void 0 === i._flags.artifact || (s.mainstay.artifacts = s.mainstay.artifacts || new Map, s.mainstay.artifacts.has(i._flags.artifact) || s.mainstay.artifacts.set(i._flags.artifact, []), s.mainstay.artifacts.get(i._flags.artifact).push(s.path)), o
                            }, f.prefs = function(t, e) {
                                const r = e === o.defaults;
                                return r && t._preferences[o.symbols.prefs] ? t._preferences[o.symbols.prefs] : (e = o.preferences(e, t._preferences), r && (t._preferences[o.symbols.prefs] = e), e)
                            }, f.default = function(t, e, r, n) {
                                const {
                                    schema: s,
                                    state: a,
                                    prefs: u
                                } = n, h = s._flags[t];
                                if (u.noDefaults || void 0 === h) return e;
                                if (a.mainstay.tracer.log(s, a, "rule", t, "full"), !h) return h;
                                if ("function" == typeof h) {
                                    const o = h.length ? [i(a.ancestors[0]), n] : [];
                                    try {
                                        return h(...o)
                                    } catch (e) {
                                        return void r.push(s.$_createError("any.".concat(t), null, {
                                            error: e
                                        }, a, u))
                                    }
                                }
                                return "object" != typeof h ? h : h[o.symbols.literal] ? h.literal : o.isResolvable(h) ? h.resolve(e, a, u) : i(h)
                            }, f.trim = function(t, e) {
                                if ("string" != typeof t) return t;
                                const r = e.$_getRule("trim");
                                return r && r.args.enabled ? t.trim() : t
                            }, f.ignore = {
                                active: !1,
                                debug: s,
                                entry: s,
                                filter: s,
                                log: s,
                                resolve: s,
                                value: s
                            }, f.errorsArray = function() {
                                const t = [];
                                return t[o.symbols.errors] = !0, t
                            }
                        },
                        2036: (t, e, r) => {
                            "use strict";
                            const n = r(375),
                                i = r(9474),
                                s = r(8160),
                                a = {};
                            t.exports = a.Values = class {
                                constructor(t, e) {
                                    this._values = new Set(t), this._refs = new Set(e), this._lowercase = a.lowercases(t), this._override = !1
                                }
                                get length() {
                                    return this._values.size + this._refs.size
                                }
                                add(t, e) {
                                    s.isResolvable(t) ? this._refs.has(t) || (this._refs.add(t), e && e.register(t)) : this.has(t, null, null, !1) || (this._values.add(t), "string" == typeof t && this._lowercase.set(t.toLowerCase(), t))
                                }
                                static merge(t, e, r) {
                                    if (t = t || new a.Values, e) {
                                        if (e._override) return e.clone();
                                        for (const r of [...e._values, ...e._refs]) t.add(r)
                                    }
                                    if (r)
                                        for (const n of [...r._values, ...r._refs]) t.remove(n);
                                    return t.length ? t : null
                                }
                                remove(t) {
                                    s.isResolvable(t) ? this._refs.delete(t) : (this._values.delete(t), "string" == typeof t && this._lowercase.delete(t.toLowerCase()))
                                }
                                has(t, e, r, n) {
                                    return !!this.get(t, e, r, n)
                                }
                                get(t, e, r, n) {
                                    if (!this.length) return !1;
                                    if (this._values.has(t)) return {
                                        value: t
                                    };
                                    if ("string" == typeof t && t && n) {
                                        const e = this._lowercase.get(t.toLowerCase());
                                        if (e) return {
                                            value: e
                                        }
                                    }
                                    if (!this._refs.size && "object" != typeof t) return !1;
                                    if ("object" == typeof t)
                                        for (const s of this._values)
                                            if (i(s, t)) return {
                                                value: s
                                            };
                                    if (e)
                                        for (const s of this._refs) {
                                            const a = s.resolve(t, e, r, null, { in: !0
                                            });
                                            if (void 0 === a) continue;
                                            const o = s.in && "object" == typeof a ? Array.isArray(a) ? a : Object.keys(a) : [a];
                                            for (const e of o)
                                                if (typeof e == typeof t)
                                                    if (n && t && "string" == typeof t) {
                                                        if (e.toLowerCase() === t.toLowerCase()) return {
                                                            value: e,
                                                            ref: s
                                                        }
                                                    } else if (i(e, t)) return {
                                                value: e,
                                                ref: s
                                            }
                                        }
                                    return !1
                                }
                                override() {
                                    this._override = !0
                                }
                                values(t) {
                                    if (t && t.display) {
                                        const t = [];
                                        for (const e of [...this._values, ...this._refs]) void 0 !== e && t.push(e);
                                        return t
                                    }
                                    return Array.from([...this._values, ...this._refs])
                                }
                                clone() {
                                    const t = new a.Values(this._values, this._refs);
                                    return t._override = this._override, t
                                }
                                concat(t) {
                                    n(!t._override, "Cannot concat override set of values");
                                    const e = new a.Values([...this._values, ...t._values], [...this._refs, ...t._refs]);
                                    return e._override = this._override, e
                                }
                                describe() {
                                    const t = [];
                                    this._override && t.push({
                                        override: !0
                                    });
                                    for (const e of this._values.values()) t.push(e && "object" == typeof e ? {
                                        value: e
                                    } : e);
                                    for (const e of this._refs.values()) t.push(e.describe());
                                    return t
                                }
                            }, a.Values.prototype[s.symbols.values] = !0, a.Values.prototype.slice = a.Values.prototype.clone, a.lowercases = function(t) {
                                const e = new Map;
                                if (t)
                                    for (const r of t) "string" == typeof r && e.set(r.toLowerCase(), r);
                                return e
                            }
                        },
                        978: (t, e, r) => {
                            "use strict";
                            const n = r(375),
                                i = r(8571),
                                s = r(1687),
                                a = r(9621),
                                o = {};
                            t.exports = function(t, e, r = {}) {
                                if (n(t && "object" == typeof t, "Invalid defaults value: must be an object"), n(!e || !0 === e || "object" == typeof e, "Invalid source value: must be true, falsy or an object"), n("object" == typeof r, "Invalid options: must be an object"), !e) return null;
                                if (r.shallow) return o.applyToDefaultsWithShallow(t, e, r);
                                const a = i(t);
                                if (!0 === e) return a;
                                const u = void 0 !== r.nullOverride && r.nullOverride;
                                return s(a, e, {
                                    nullOverride: u,
                                    mergeArrays: !1
                                })
                            }, o.applyToDefaultsWithShallow = function(t, e, r) {
                                const u = r.shallow;
                                n(Array.isArray(u), "Invalid keys");
                                const h = new Map,
                                    f = !0 === e ? null : new Set;
                                for (let n of u) {
                                    n = Array.isArray(n) ? n : n.split(".");
                                    const r = a(t, n);
                                    r && "object" == typeof r ? h.set(r, f && a(e, n) || r) : f && f.add(n)
                                }
                                const c = i(t, {}, h);
                                if (!f) return c;
                                for (const n of f) o.reachCopy(c, e, n);
                                const l = void 0 !== r.nullOverride && r.nullOverride;
                                return s(c, e, {
                                    nullOverride: l,
                                    mergeArrays: !1
                                })
                            }, o.reachCopy = function(t, e, r) {
                                for (const s of r) {
                                    if (!(s in e)) return;
                                    const t = e[s];
                                    if ("object" != typeof t || null === t) return;
                                    e = t
                                }
                                const n = e;
                                let i = t;
                                for (let s = 0; s < r.length - 1; ++s) {
                                    const t = r[s];
                                    "object" != typeof i[t] && (i[t] = {}), i = i[t]
                                }
                                i[r[r.length - 1]] = n
                            }
                        },
                        375: (t, e, r) => {
                            "use strict";
                            const n = r(7916);
                            t.exports = function(t, ...e) {
                                if (!t) {
                                    if (1 === e.length && e[0] instanceof Error) throw e[0];
                                    throw new n(e)
                                }
                            }
                        },
                        8571: (t, e, r) => {
                            "use strict";
                            const n = r(9621),
                                i = r(4277),
                                s = r(7043),
                                a = {
                                    needsProtoHack: new Set([i.set, i.map, i.weakSet, i.weakMap])
                                };
                            t.exports = a.clone = function(t, e = {}, r = null) {
                                if ("object" != typeof t || null === t) return t;
                                let n = a.clone,
                                    o = r;
                                if (e.shallow) {
                                    if (!0 !== e.shallow) return a.cloneWithShallow(t, e);
                                    n = t => t
                                } else if (o) {
                                    const e = o.get(t);
                                    if (e) return e
                                } else o = new Map;
                                const u = i.getInternalProto(t);
                                if (u === i.buffer) return !1;
                                if (u === i.date) return new Date(t.getTime());
                                if (u === i.regex) return new RegExp(t);
                                const h = a.base(t, u, e);
                                if (h === t) return t;
                                if (o && o.set(t, h), u === i.set)
                                    for (const i of t) h.add(n(i, e, o));
                                else if (u === i.map)
                                    for (const [i, s] of t) h.set(i, n(s, e, o));
                                const f = s.keys(t, e);
                                for (const s of f) {
                                    if ("__proto__" === s) continue;
                                    if (u === i.array && "length" === s) {
                                        h.length = t.length;
                                        continue
                                    }
                                    const r = Object.getOwnPropertyDescriptor(t, s);
                                    r ? r.get || r.set ? Object.defineProperty(h, s, r) : r.enumerable ? h[s] = n(t[s], e, o) : Object.defineProperty(h, s, {
                                        enumerable: !1,
                                        writable: !0,
                                        configurable: !0,
                                        value: n(t[s], e, o)
                                    }) : Object.defineProperty(h, s, {
                                        enumerable: !0,
                                        writable: !0,
                                        configurable: !0,
                                        value: n(t[s], e, o)
                                    })
                                }
                                return h
                            }, a.cloneWithShallow = function(t, e) {
                                const r = e.shallow;
                                (e = Object.assign({}, e)).shallow = !1;
                                const i = new Map;
                                for (const s of r) {
                                    const e = n(t, s);
                                    "object" != typeof e && "function" != typeof e || i.set(e, e)
                                }
                                return a.clone(t, e, i)
                            }, a.base = function(t, e, r) {
                                if (!1 === r.prototype) return a.needsProtoHack.has(e) ? new e.constructor : e === i.array ? [] : {};
                                const n = Object.getPrototypeOf(t);
                                if (n && n.isImmutable) return t;
                                if (e === i.array) {
                                    const t = [];
                                    return n !== e && Object.setPrototypeOf(t, n), t
                                }
                                if (a.needsProtoHack.has(e)) {
                                    const t = new n.constructor;
                                    return n !== e && Object.setPrototypeOf(t, n), t
                                }
                                return Object.create(n)
                            }
                        },
                        9474: (t, e, r) => {
                            "use strict";
                            const n = r(4277),
                                i = {
                                    mismatched: null
                                };
                            t.exports = function(t, e, r) {
                                return r = Object.assign({
                                    prototype: !0
                                }, r), !!i.isDeepEqual(t, e, r, [])
                            }, i.isDeepEqual = function(t, e, r, s) {
                                if (t === e) return 0 !== t || 1 / t == 1 / e;
                                const a = typeof t;
                                if (a !== typeof e) return !1;
                                if (null === t || null === e) return !1;
                                if ("function" === a) {
                                    if (!r.deepFunction || t.toString() !== e.toString()) return !1
                                } else if ("object" !== a) return t != t && e != e;
                                const o = i.getSharedType(t, e, !!r.prototype);
                                switch (o) {
                                    case n.buffer:
                                        return !1;
                                    case n.promise:
                                        return t === e;
                                    case n.regex:
                                        return t.toString() === e.toString();
                                    case i.mismatched:
                                        return !1
                                }
                                for (let n = s.length - 1; n >= 0; --n)
                                    if (s[n].isSame(t, e)) return !0;
                                s.push(new i.SeenEntry(t, e));
                                try {
                                    return !!i.isDeepEqualObj(o, t, e, r, s)
                                } finally {
                                    s.pop()
                                }
                            }, i.getSharedType = function(t, e, r) {
                                if (r) return Object.getPrototypeOf(t) !== Object.getPrototypeOf(e) ? i.mismatched : n.getInternalProto(t);
                                const s = n.getInternalProto(t);
                                return s !== n.getInternalProto(e) ? i.mismatched : s
                            }, i.valueOf = function(t) {
                                const e = t.valueOf;
                                if (void 0 === e) return t;
                                try {
                                    return e.call(t)
                                } catch (t) {
                                    return t
                                }
                            }, i.hasOwnEnumerableProperty = function(t, e) {
                                return Object.prototype.propertyIsEnumerable.call(t, e)
                            }, i.isSetSimpleEqual = function(t, e) {
                                for (const r of Set.prototype.values.call(t))
                                    if (!Set.prototype.has.call(e, r)) return !1;
                                return !0
                            }, i.isDeepEqualObj = function(t, e, r, s, a) {
                                const {
                                    isDeepEqual: o,
                                    valueOf: u,
                                    hasOwnEnumerableProperty: h
                                } = i, {
                                    keys: f,
                                    getOwnPropertySymbols: c
                                } = Object;
                                if (t === n.array) {
                                    if (!s.part) {
                                        if (e.length !== r.length) return !1;
                                        for (let t = 0; t < e.length; ++t)
                                            if (!o(e[t], r[t], s, a)) return !1;
                                        return !0
                                    }
                                    for (const t of e)
                                        for (const e of r)
                                            if (o(t, e, s, a)) return !0
                                } else if (t === n.set) {
                                    if (e.size !== r.size) return !1;
                                    if (!i.isSetSimpleEqual(e, r)) {
                                        const t = new Set(Set.prototype.values.call(r));
                                        for (const r of Set.prototype.values.call(e)) {
                                            if (t.delete(r)) continue;
                                            let e = !1;
                                            for (const n of t)
                                                if (o(r, n, s, a)) {
                                                    t.delete(n), e = !0;
                                                    break
                                                }
                                            if (!e) return !1
                                        }
                                    }
                                } else if (t === n.map) {
                                    if (e.size !== r.size) return !1;
                                    for (const [t, n] of Map.prototype.entries.call(e)) {
                                        if (void 0 === n && !Map.prototype.has.call(r, t)) return !1;
                                        if (!o(n, Map.prototype.get.call(r, t), s, a)) return !1
                                    }
                                } else if (t === n.error && (e.name !== r.name || e.message !== r.message)) return !1;
                                const l = u(e),
                                    d = u(r);
                                if ((e !== l || r !== d) && !o(l, d, s, a)) return !1;
                                const p = f(e);
                                if (!s.part && p.length !== f(r).length && !s.skip) return !1;
                                let m = 0;
                                for (const n of p)
                                    if (s.skip && s.skip.includes(n)) void 0 === r[n] && ++m;
                                    else {
                                        if (!h(r, n)) return !1;
                                        if (!o(e[n], r[n], s, a)) return !1
                                    }
                                if (!s.part && p.length - m !== f(r).length) return !1;
                                if (!1 !== s.symbols) {
                                    const t = c(e),
                                        n = new Set(c(r));
                                    for (const i of t) {
                                        if (!s.skip || !s.skip.includes(i))
                                            if (h(e, i)) {
                                                if (!h(r, i)) return !1;
                                                if (!o(e[i], r[i], s, a)) return !1
                                            } else if (h(r, i)) return !1;
                                        n.delete(i)
                                    }
                                    for (const e of n)
                                        if (h(r, e)) return !1
                                }
                                return !0
                            }, i.SeenEntry = class {
                                constructor(t, e) {
                                    this.obj = t, this.ref = e
                                }
                                isSame(t, e) {
                                    return this.obj === t && this.ref === e
                                }
                            }
                        },
                        7916: (t, e, r) => {
                            "use strict";
                            const n = r(8761);
                            t.exports = class extends Error {
                                constructor(t) {
                                    super(t.filter(t => "" !== t).map(t => "string" == typeof t ? t : t instanceof Error ? t.message : n(t)).join(" ") || "Unknown error"), "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, e.assert)
                                }
                            }
                        },
                        5277: t => {
                            "use strict";
                            const e = {};
                            t.exports = function(t) {
                                if (!t) return "";
                                let r = "";
                                for (let n = 0; n < t.length; ++n) {
                                    const i = t.charCodeAt(n);
                                    e.isSafe(i) ? r += t[n] : r += e.escapeHtmlChar(i)
                                }
                                return r
                            }, e.escapeHtmlChar = function(t) {
                                const r = e.namedHtml[t];
                                if (void 0 !== r) return r;
                                if (t >= 256) return "&#" + t + ";";
                                const n = t.toString(16).padStart(2, "0");
                                return "&#x".concat(n, ";")
                            }, e.isSafe = function(t) {
                                return void 0 !== e.safeCharCodes[t]
                            }, e.namedHtml = {
                                38: "&amp;",
                                60: "&lt;",
                                62: "&gt;",
                                34: "&quot;",
                                160: "&nbsp;",
                                162: "&cent;",
                                163: "&pound;",
                                164: "&curren;",
                                169: "&copy;",
                                174: "&reg;"
                            }, e.safeCharCodes = function() {
                                const t = {};
                                for (let e = 32; e < 123; ++e)(e >= 97 || e >= 65 && e <= 90 || e >= 48 && e <= 57 || 32 === e || 46 === e || 44 === e || 45 === e || 58 === e || 95 === e) && (t[e] = null);
                                return t
                            }()
                        },
                        6064: t => {
                            "use strict";
                            t.exports = function(t) {
                                return t.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&")
                            }
                        },
                        738: t => {
                            "use strict";
                            t.exports = function() {}
                        },
                        1687: (t, e, r) => {
                            "use strict";
                            const n = r(375),
                                i = r(8571),
                                s = r(7043),
                                a = {};
                            t.exports = a.merge = function(t, e, r) {
                                if (n(t && "object" == typeof t, "Invalid target value: must be an object"), n(null == e || "object" == typeof e, "Invalid source value: must be null, undefined, or an object"), !e) return t;
                                if (r = Object.assign({
                                        nullOverride: !0,
                                        mergeArrays: !0
                                    }, r), Array.isArray(e)) {
                                    n(Array.isArray(t), "Cannot merge array onto an object"), r.mergeArrays || (t.length = 0);
                                    for (let n = 0; n < e.length; ++n) t.push(i(e[n], {
                                        symbols: r.symbols
                                    }));
                                    return t
                                }
                                const o = s.keys(e, r);
                                for (let n = 0; n < o.length; ++n) {
                                    const s = o[n];
                                    if ("__proto__" === s || !Object.prototype.propertyIsEnumerable.call(e, s)) continue;
                                    const u = e[s];
                                    if (u && "object" == typeof u) {
                                        if (t[s] === u) continue;
                                        !t[s] || "object" != typeof t[s] || Array.isArray(t[s]) !== Array.isArray(u) || u instanceof Date || u instanceof RegExp ? t[s] = i(u, {
                                            symbols: r.symbols
                                        }) : a.merge(t[s], u, r)
                                    } else(null != u || r.nullOverride) && (t[s] = u)
                                }
                                return t
                            }
                        },
                        9621: (t, e, r) => {
                            "use strict";
                            const n = r(375),
                                i = {};
                            t.exports = function(t, e, r) {
                                if (!1 === e || null == e) return t;
                                "string" == typeof(r = r || {}) && (r = {
                                    separator: r
                                });
                                const s = Array.isArray(e);
                                n(!s || !r.separator, "Separator option no valid for array-based chain");
                                const a = s ? e : e.split(r.separator || ".");
                                let o = t;
                                for (let u = 0; u < a.length; ++u) {
                                    let t = a[u];
                                    const s = r.iterables && i.iterables(o);
                                    if (Array.isArray(o) || "set" === s) {
                                        const e = Number(t);
                                        Number.isInteger(e) && (t = e < 0 ? o.length + e : e)
                                    }
                                    if (!o || "function" == typeof o && !1 === r.functions || !s && void 0 === o[t]) {
                                        n(!r.strict || u + 1 === a.length, "Missing segment", t, "in reach path ", e), n("object" == typeof o || !0 === r.functions || "function" != typeof o, "Invalid segment", t, "in reach path ", e), o = r.default;
                                        break
                                    }
                                    o = s ? "set" === s ? [...o][t] : o.get(t) : o[t]
                                }
                                return o
                            }, i.iterables = function(t) {
                                return t instanceof Set ? "set" : t instanceof Map ? "map" : void 0
                            }
                        },
                        8761: t => {
                            "use strict";
                            t.exports = function(...t) {
                                try {
                                    return JSON.stringify.apply(null, t)
                                } catch (t) {
                                    return "[Cannot display object: " + t.message + "]"
                                }
                            }
                        },
                        4277: (t, e) => {
                            "use strict";
                            const r = {};
                            e = t.exports = {
                                array: Array.prototype,
                                buffer: !1,
                                date: Date.prototype,
                                error: Error.prototype,
                                generic: Object.prototype,
                                map: Map.prototype,
                                promise: Promise.prototype,
                                regex: RegExp.prototype,
                                set: Set.prototype,
                                weakMap: WeakMap.prototype,
                                weakSet: WeakSet.prototype
                            }, r.typeMap = new Map([
                                ["[object Error]", e.error],
                                ["[object Map]", e.map],
                                ["[object Promise]", e.promise],
                                ["[object Set]", e.set],
                                ["[object WeakMap]", e.weakMap],
                                ["[object WeakSet]", e.weakSet]
                            ]), e.getInternalProto = function(t) {
                                if (Array.isArray(t)) return e.array;
                                if (t instanceof Date) return e.date;
                                if (t instanceof RegExp) return e.regex;
                                if (t instanceof Error) return e.error;
                                const n = Object.prototype.toString.call(t);
                                return r.typeMap.get(n) || e.generic
                            }
                        },
                        7043: (t, e) => {
                            "use strict";
                            e.keys = function(t, e = {}) {
                                return !1 !== e.symbols ? Reflect.ownKeys(t) : Object.getOwnPropertyNames(t)
                            }
                        },
                        3652: (t, e, r) => {
                            "use strict";
                            const n = r(375),
                                i = {};
                            e.Sorter = class {
                                constructor() {
                                    this._items = [], this.nodes = []
                                }
                                add(t, e) {
                                    const r = [].concat((e = e || {}).before || []),
                                        i = [].concat(e.after || []),
                                        s = e.group || "?",
                                        a = e.sort || 0;
                                    n(!r.includes(s), "Item cannot come before itself: ".concat(s)), n(!r.includes("?"), "Item cannot come before unassociated items"), n(!i.includes(s), "Item cannot come after itself: ".concat(s)), n(!i.includes("?"), "Item cannot come after unassociated items"), Array.isArray(t) || (t = [t]);
                                    for (const n of t) {
                                        const t = {
                                            seq: this._items.length,
                                            sort: a,
                                            before: r,
                                            after: i,
                                            group: s,
                                            node: n
                                        };
                                        this._items.push(t)
                                    }
                                    if (!e.manual) {
                                        const t = this._sort();
                                        n(t, "item", "?" !== s ? "added into group ".concat(s) : "", "created a dependencies error")
                                    }
                                    return this.nodes
                                }
                                merge(t) {
                                    Array.isArray(t) || (t = [t]);
                                    for (const r of t)
                                        if (r)
                                            for (const t of r._items) this._items.push(Object.assign({}, t));
                                    this._items.sort(i.mergeSort);
                                    for (let r = 0; r < this._items.length; ++r) this._items[r].seq = r;
                                    const e = this._sort();
                                    return n(e, "merge created a dependencies error"), this.nodes
                                }
                                sort() {
                                    const t = this._sort();
                                    return n(t, "sort created a dependencies error"), this.nodes
                                }
                                _sort() {
                                    const t = {},
                                        e = Object.create(null),
                                        r = Object.create(null);
                                    for (const o of this._items) {
                                        const n = o.seq,
                                            i = o.group;
                                        r[i] = r[i] || [], r[i].push(n), t[n] = o.before;
                                        for (const t of o.after) e[t] = e[t] || [], e[t].push(n)
                                    }
                                    for (const o in t) {
                                        const e = [];
                                        for (const n in t[o]) {
                                            const i = t[o][n];
                                            r[i] = r[i] || [], e.push(...r[i])
                                        }
                                        t[o] = e
                                    }
                                    for (const o in e)
                                        if (r[o])
                                            for (const n of r[o]) t[n].push(...e[o]);
                                    const n = {};
                                    for (const o in t) {
                                        const e = t[o];
                                        for (const t of e) n[t] = n[t] || [], n[t].push(o)
                                    }
                                    const i = {},
                                        s = [];
                                    for (let o = 0; o < this._items.length; ++o) {
                                        let t = o;
                                        if (n[o]) {
                                            t = null;
                                            for (let e = 0; e < this._items.length; ++e) {
                                                if (!0 === i[e]) continue;
                                                n[e] || (n[e] = []);
                                                const r = n[e].length;
                                                let s = 0;
                                                for (let t = 0; t < r; ++t) i[n[e][t]] && ++s;
                                                if (s === r) {
                                                    t = e;
                                                    break
                                                }
                                            }
                                        }
                                        null !== t && (i[t] = !0, s.push(t))
                                    }
                                    if (s.length !== this._items.length) return !1;
                                    const a = {};
                                    for (const o of this._items) a[o.seq] = o;
                                    this._items = [], this.nodes = [];
                                    for (const o of s) {
                                        const t = a[o];
                                        this.nodes.push(t.node), this._items.push(t)
                                    }
                                    return !0
                                }
                            }, i.mergeSort = (t, e) => t.sort === e.sort ? 0 : t.sort < e.sort ? -1 : 1
                        },
                        5380: (t, e, r) => {
                            "use strict";
                            const n = r(443),
                                i = r(2178),
                                s = {
                                    minDomainSegments: 2,
                                    nonAsciiRx: /[^\x00-\x7f]/,
                                    domainControlRx: /[\x00-\x20@\:\/\\#!\$&\'\(\)\*\+,;=\?]/,
                                    tldSegmentRx: /^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
                                    domainSegmentRx: /^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
                                    URL: n.URL || URL
                                };
                            e.analyze = function(t, e = {}) {
                                if (!t) return i.code("DOMAIN_NON_EMPTY_STRING");
                                if ("string" != typeof t) throw new Error("Invalid input: domain must be a string");
                                if (t.length > 256) return i.code("DOMAIN_TOO_LONG");
                                if (s.nonAsciiRx.test(t)) {
                                    if (!1 === e.allowUnicode) return i.code("DOMAIN_INVALID_UNICODE_CHARS");
                                    t = t.normalize("NFC")
                                }
                                if (s.domainControlRx.test(t)) return i.code("DOMAIN_INVALID_CHARS");
                                t = s.punycode(t), e.allowFullyQualified && "." === t[t.length - 1] && (t = t.slice(0, -1));
                                const r = e.minDomainSegments || s.minDomainSegments,
                                    n = t.split(".");
                                if (n.length < r) return i.code("DOMAIN_SEGMENTS_COUNT");
                                if (e.maxDomainSegments && n.length > e.maxDomainSegments) return i.code("DOMAIN_SEGMENTS_COUNT_MAX");
                                const a = e.tlds;
                                if (a) {
                                    const t = n[n.length - 1].toLowerCase();
                                    if (a.deny && a.deny.has(t) || a.allow && !a.allow.has(t)) return i.code("DOMAIN_FORBIDDEN_TLDS")
                                }
                                for (let o = 0; o < n.length; ++o) {
                                    const t = n[o];
                                    if (!t.length) return i.code("DOMAIN_EMPTY_SEGMENT");
                                    if (t.length > 63) return i.code("DOMAIN_LONG_SEGMENT");
                                    if (o < n.length - 1) {
                                        if (!s.domainSegmentRx.test(t)) return i.code("DOMAIN_INVALID_CHARS")
                                    } else if (!s.tldSegmentRx.test(t)) return i.code("DOMAIN_INVALID_TLDS_CHARS")
                                }
                                return null
                            }, e.isValid = function(t, r) {
                                return !e.analyze(t, r)
                            }, s.punycode = function(t) {
                                t.includes("%") && (t = t.replace(/%/g, "%25"));
                                try {
                                    return new s.URL("http://".concat(t)).host
                                } catch (e) {
                                    return t
                                }
                            }
                        },
                        1745: (t, e, r) => {
                            "use strict";
                            const n = r(9848),
                                i = r(5380),
                                s = r(2178),
                                a = {
                                    nonAsciiRx: /[^\x00-\x7f]/,
                                    encoder: new(n.TextEncoder || TextEncoder)
                                };
                            e.analyze = function(t, e) {
                                return a.email(t, e)
                            }, e.isValid = function(t, e) {
                                return !a.email(t, e)
                            }, a.email = function(t, e = {}) {
                                if ("string" != typeof t) throw new Error("Invalid input: email must be a string");
                                if (!t) return s.code("EMPTY_STRING");
                                const r = !a.nonAsciiRx.test(t);
                                if (!r) {
                                    if (!1 === e.allowUnicode) return s.code("FORBIDDEN_UNICODE");
                                    t = t.normalize("NFC")
                                }
                                const n = t.split("@");
                                if (2 !== n.length) return n.length > 2 ? s.code("MULTIPLE_AT_CHAR") : s.code("MISSING_AT_CHAR");
                                const [o, u] = n;
                                if (!o) return s.code("EMPTY_LOCAL");
                                if (!e.ignoreLength) {
                                    if (t.length > 254) return s.code("ADDRESS_TOO_LONG");
                                    if (a.encoder.encode(o).length > 64) return s.code("LOCAL_TOO_LONG")
                                }
                                return a.local(o, r) || i.analyze(u, e)
                            }, a.local = function(t, e) {
                                const r = t.split(".");
                                for (const n of r) {
                                    if (!n.length) return s.code("EMPTY_LOCAL_SEGMENT");
                                    if (e) {
                                        if (!a.atextRx.test(n)) return s.code("INVALID_LOCAL_CHARS")
                                    } else
                                        for (const t of n) {
                                            if (a.atextRx.test(t)) continue;
                                            const e = a.binary(t);
                                            if (!a.atomRx.test(e)) return s.code("INVALID_LOCAL_CHARS")
                                        }
                                }
                            }, a.binary = function(t) {
                                return Array.from(a.encoder.encode(t)).map(t => String.fromCharCode(t)).join("")
                            }, a.atextRx = /^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/, a.atomRx = new RegExp(["(?:[\\xc2-\\xdf][\\x80-\\xbf])", "(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})", "(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})"].join("|"))
                        },
                        2178: (t, e) => {
                            "use strict";
                            e.codes = {
                                EMPTY_STRING: "Address must be a non-empty string",
                                FORBIDDEN_UNICODE: "Address contains forbidden Unicode characters",
                                MULTIPLE_AT_CHAR: "Address cannot contain more than one @ character",
                                MISSING_AT_CHAR: "Address must contain one @ character",
                                EMPTY_LOCAL: "Address local part cannot be empty",
                                ADDRESS_TOO_LONG: "Address too long",
                                LOCAL_TOO_LONG: "Address local part too long",
                                EMPTY_LOCAL_SEGMENT: "Address local part contains empty dot-separated segment",
                                INVALID_LOCAL_CHARS: "Address local part contains invalid character",
                                DOMAIN_NON_EMPTY_STRING: "Domain must be a non-empty string",
                                DOMAIN_TOO_LONG: "Domain too long",
                                DOMAIN_INVALID_UNICODE_CHARS: "Domain contains forbidden Unicode characters",
                                DOMAIN_INVALID_CHARS: "Domain contains invalid character",
                                DOMAIN_INVALID_TLDS_CHARS: "Domain contains invalid tld character",
                                DOMAIN_SEGMENTS_COUNT: "Domain lacks the minimum required number of segments",
                                DOMAIN_SEGMENTS_COUNT_MAX: "Domain contains too many segments",
                                DOMAIN_FORBIDDEN_TLDS: "Domain uses forbidden TLD",
                                DOMAIN_EMPTY_SEGMENT: "Domain contains empty dot-separated segment",
                                DOMAIN_LONG_SEGMENT: "Domain contains dot-separated segment that is too long"
                            }, e.code = function(t) {
                                return {
                                    code: t,
                                    error: e.codes[t]
                                }
                            }
                        },
                        9959: (t, e, r) => {
                            "use strict";
                            const n = r(375),
                                i = r(5752);
                            e.regex = function(t = {}) {
                                n(void 0 === t.cidr || "string" == typeof t.cidr, "options.cidr must be a string");
                                const e = t.cidr ? t.cidr.toLowerCase() : "optional";
                                n(["required", "optional", "forbidden"].includes(e), "options.cidr must be one of required, optional, forbidden"), n(void 0 === t.version || "string" == typeof t.version || Array.isArray(t.version), "options.version must be a string or an array of string");
                                let r = t.version || ["ipv4", "ipv6", "ipvfuture"];
                                Array.isArray(r) || (r = [r]), n(r.length >= 1, "options.version must have at least 1 version specified");
                                for (let i = 0; i < r.length; ++i) n("string" == typeof r[i], "options.version must only contain strings"), r[i] = r[i].toLowerCase(), n(["ipv4", "ipv6", "ipvfuture"].includes(r[i]), "options.version contains unknown version " + r[i] + " - must be one of ipv4, ipv6, ipvfuture");
                                r = Array.from(new Set(r));
                                const s = r.map(t => {
                                        if ("forbidden" === e) return i.ip[t];
                                        const r = "\\/".concat("ipv4" === t ? i.ip.v4Cidr : i.ip.v6Cidr);
                                        return "required" === e ? "".concat(i.ip[t]).concat(r) : "".concat(i.ip[t], "(?:").concat(r, ")?")
                                    }),
                                    a = "(?:".concat(s.join("|"), ")"),
                                    o = new RegExp("^".concat(a, "$"));
                                return {
                                    cidr: e,
                                    versions: r,
                                    regex: o,
                                    raw: a
                                }
                            }
                        },
                        5752: (t, e, r) => {
                            "use strict";
                            const n = r(375),
                                i = r(6064),
                                s = {
                                    generate: function() {
                                        const t = {},
                                            e = "!\\$&'\\(\\)\\*\\+,;=",
                                            r = "\\w-\\.~%\\dA-Fa-f" + e + ":@",
                                            n = "[" + r + "]",
                                            i = "(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";
                                        t.ipv4address = "(?:" + i + "\\.){3}" + i;
                                        const s = "[\\dA-Fa-f]{1,4}",
                                            a = "(?:" + s + ":" + s + "|" + t.ipv4address + ")",
                                            o = "(?:" + s + ":){6}" + a,
                                            u = "::(?:" + s + ":){5}" + a,
                                            h = "(?:" + s + ")?::(?:" + s + ":){4}" + a,
                                            f = "(?:(?:" + s + ":){0,1}" + s + ")?::(?:" + s + ":){3}" + a,
                                            c = "(?:(?:" + s + ":){0,2}" + s + ")?::(?:" + s + ":){2}" + a,
                                            l = "(?:(?:" + s + ":){0,3}" + s + ")?::" + s + ":" + a,
                                            d = "(?:(?:" + s + ":){0,4}" + s + ")?::" + a;
                                        t.ipv4Cidr = "(?:\\d|[1-2]\\d|3[0-2])", t.ipv6Cidr = "(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])", t.ipv6address = "(?:" + o + "|" + u + "|" + h + "|" + f + "|" + c + "|" + l + "|" + d + "|(?:(?:[\\dA-Fa-f]{1,4}:){0,5}[\\dA-Fa-f]{1,4})?::[\\dA-Fa-f]{1,4}|(?:(?:[\\dA-Fa-f]{1,4}:){0,6}[\\dA-Fa-f]{1,4})?::)", t.ipvFuture = "v[\\dA-Fa-f]+\\.[\\w-\\.~" + e + ":]+", t.scheme = "[a-zA-Z][a-zA-Z\\d+-\\.]*", t.schemeRegex = new RegExp(t.scheme);
                                        const p = "[\\w-\\.~%\\dA-Fa-f" + e + ":]*",
                                            m = "(?:\\[(?:" + t.ipv6address + "|" + t.ipvFuture + ")\\]|" + t.ipv4address + "|[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=]{1,255})",
                                            b = "(?:" + p + "@)?" + m + "(?::\\d*)?",
                                            g = "(?:" + p + "@)?(" + m + ")(?::\\d*)?",
                                            y = n + "+",
                                            v = "(?:\\/[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=:@]*)*",
                                            w = "\\/(?:" + y + v + ")?",
                                            _ = y + v,
                                            M = "[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=@]+" + v;
                                        return t.hierPart = "(?:(?:\\/\\/" + b + v + ")|" + w + "|" + _ + "|(?:\\/\\/\\/[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=:@]*(?:\\/[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=:@]*)*))", t.hierPartCapture = "(?:(?:\\/\\/" + g + v + ")|" + w + "|" + _ + ")", t.relativeRef = "(?:(?:\\/\\/" + b + v + ")|" + w + "|" + M + "|)", t.relativeRefCapture = "(?:(?:\\/\\/" + g + v + ")|" + w + "|" + M + "|)", t.query = "[" + r + "\\/\\?]*(?=#|$)", t.queryWithSquareBrackets = "[" + r + "\\[\\]\\/\\?]*(?=#|$)", t.fragment = "[" + r + "\\/\\?]*", t
                                    }
                                };
                            s.rfc3986 = s.generate(), e.ip = {
                                v4Cidr: s.rfc3986.ipv4Cidr,
                                v6Cidr: s.rfc3986.ipv6Cidr,
                                ipv4: s.rfc3986.ipv4address,
                                ipv6: s.rfc3986.ipv6address,
                                ipvfuture: s.rfc3986.ipvFuture
                            }, s.createRegex = function(t) {
                                const e = s.rfc3986,
                                    r = "(?:\\?" + (t.allowQuerySquareBrackets ? e.queryWithSquareBrackets : e.query) + ")?(?:#" + e.fragment + ")?",
                                    a = t.domain ? e.relativeRefCapture : e.relativeRef;
                                if (t.relativeOnly) return s.wrap(a + r);
                                let o = "";
                                if (t.scheme) {
                                    n(t.scheme instanceof RegExp || "string" == typeof t.scheme || Array.isArray(t.scheme), "scheme must be a RegExp, String, or Array");
                                    const r = [].concat(t.scheme);
                                    n(r.length >= 1, "scheme must have at least 1 scheme specified");
                                    const s = [];
                                    for (let t = 0; t < r.length; ++t) {
                                        const a = r[t];
                                        n(a instanceof RegExp || "string" == typeof a, "scheme at position " + t + " must be a RegExp or String"), a instanceof RegExp ? s.push(a.source.toString()) : (n(e.schemeRegex.test(a), "scheme at position " + t + " must be a valid scheme"), s.push(i(a)))
                                    }
                                    o = s.join("|")
                                }
                                const u = "(?:" + (o ? "(?:" + o + ")" : e.scheme) + ":" + (t.domain ? e.hierPartCapture : e.hierPart) + ")",
                                    h = t.allowRelative ? "(?:" + u + "|" + a + ")" : u;
                                return s.wrap(h + r, o)
                            }, s.wrap = function(t, e) {
                                return {
                                    raw: t = "(?=.)(?!https?:/(?:$|[^/]))(?!https?:///)(?!https?:[^/])".concat(t),
                                    regex: new RegExp("^".concat(t, "$")),
                                    scheme: e
                                }
                            }, s.uriRegex = s.createRegex({}), e.regex = function(t = {}) {
                                return t.scheme || t.allowRelative || t.relativeOnly || t.allowQuerySquareBrackets || t.domain ? s.createRegex(t) : s.uriRegex
                            }
                        },
                        1447: (t, e) => {
                            "use strict";
                            const r = {
                                operators: ["!", "^", "*", "/", "%", "+", "-", "<", "<=", ">", ">=", "==", "!=", "&&", "||", "??"],
                                operatorCharacters: ["!", "^", "*", "/", "%", "+", "-", "<", "=", ">", "&", "|", "?"],
                                operatorsOrder: [
                                    ["^"],
                                    ["*", "/", "%"],
                                    ["+", "-"],
                                    ["<", "<=", ">", ">="],
                                    ["==", "!="],
                                    ["&&"],
                                    ["||", "??"]
                                ],
                                operatorsPrefix: ["!", "n"],
                                literals: {
                                    '"': '"',
                                    "`": "`",
                                    "'": "'",
                                    "[": "]"
                                },
                                numberRx: /^(?:[0-9]*\.?[0-9]*){1}$/,
                                tokenRx: /^[\w\$\#\.\@\:\{\}]+$/,
                                symbol: Symbol("formula"),
                                settings: Symbol("settings")
                            };
                            e.Parser = class {
                                constructor(t, e = {}) {
                                    if (!e[r.settings] && e.constants)
                                        for (const r in e.constants) {
                                            const t = e.constants[r];
                                            if (null !== t && !["boolean", "number", "string"].includes(typeof t)) throw new Error("Formula constant ".concat(r, " contains invalid ").concat(typeof t, " value type"))
                                        }
                                    this.settings = e[r.settings] ? e : Object.assign({
                                        [r.settings]: !0,
                                        constants: {},
                                        functions: {}
                                    }, e), this.single = null, this._parts = null, this._parse(t)
                                }
                                _parse(t) {
                                    let n = [],
                                        i = "",
                                        s = 0,
                                        a = !1;
                                    const o = t => {
                                        if (s) throw new Error("Formula missing closing parenthesis");
                                        const o = n.length ? n[n.length - 1] : null;
                                        if (a || i || t) {
                                            if (o && "reference" === o.type && ")" === t) return o.type = "function", o.value = this._subFormula(i, o.value), void(i = "");
                                            if (")" === t) {
                                                const t = new e.Parser(i, this.settings);
                                                n.push({
                                                    type: "segment",
                                                    value: t
                                                })
                                            } else if (a) {
                                                if ("]" === a) return n.push({
                                                    type: "reference",
                                                    value: i
                                                }), void(i = "");
                                                n.push({
                                                    type: "literal",
                                                    value: i
                                                })
                                            } else if (r.operatorCharacters.includes(i)) o && "operator" === o.type && r.operators.includes(o.value + i) ? o.value += i : n.push({
                                                type: "operator",
                                                value: i
                                            });
                                            else if (i.match(r.numberRx)) n.push({
                                                type: "constant",
                                                value: parseFloat(i)
                                            });
                                            else if (void 0 !== this.settings.constants[i]) n.push({
                                                type: "constant",
                                                value: this.settings.constants[i]
                                            });
                                            else {
                                                if (!i.match(r.tokenRx)) throw new Error("Formula contains invalid token: ".concat(i));
                                                n.push({
                                                    type: "reference",
                                                    value: i
                                                })
                                            }
                                            i = ""
                                        }
                                    };
                                    for (const e of t) a ? e === a ? (o(), a = !1) : i += e : s ? "(" === e ? (i += e, ++s) : ")" === e ? (--s, s ? i += e : o(e)) : i += e : e in r.literals ? a = r.literals[e] : "(" === e ? (o(), ++s) : r.operatorCharacters.includes(e) ? (o(), i = e, o()) : " " !== e ? i += e : o();
                                    o(), n = n.map((t, e) => "operator" !== t.type || "-" !== t.value || e && "operator" !== n[e - 1].type ? t : {
                                        type: "operator",
                                        value: "n"
                                    });
                                    let u = !1;
                                    for (const e of n) {
                                        if ("operator" === e.type) {
                                            if (r.operatorsPrefix.includes(e.value)) continue;
                                            if (!u) throw new Error("Formula contains an operator in invalid position");
                                            if (!r.operators.includes(e.value)) throw new Error("Formula contains an unknown operator ".concat(e.value))
                                        } else if (u) throw new Error("Formula missing expected operator");
                                        u = !u
                                    }
                                    if (!u) throw new Error("Formula contains invalid trailing operator");
                                    1 === n.length && ["reference", "literal", "constant"].includes(n[0].type) && (this.single = {
                                        type: "reference" === n[0].type ? "reference" : "value",
                                        value: n[0].value
                                    }), this._parts = n.map(t => {
                                        if ("operator" === t.type) return r.operatorsPrefix.includes(t.value) ? t : t.value;
                                        if ("reference" !== t.type) return t.value;
                                        if (this.settings.tokenRx && !this.settings.tokenRx.test(t.value)) throw new Error("Formula contains invalid reference ".concat(t.value));
                                        return this.settings.reference ? this.settings.reference(t.value) : r.reference(t.value)
                                    })
                                }
                                _subFormula(t, n) {
                                    const i = this.settings.functions[n];
                                    if ("function" != typeof i) throw new Error("Formula contains unknown function ".concat(n));
                                    let s = [];
                                    if (t) {
                                        let e = "",
                                            i = 0,
                                            a = !1;
                                        const o = () => {
                                            if (!e) throw new Error("Formula contains function ".concat(n, " with invalid arguments ").concat(t));
                                            s.push(e), e = ""
                                        };
                                        for (let n = 0; n < t.length; ++n) {
                                            const s = t[n];
                                            a ? (e += s, s === a && (a = !1)) : s in r.literals && !i ? (e += s, a = r.literals[s]) : "," !== s || i ? (e += s, "(" === s ? ++i : ")" === s && --i) : o()
                                        }
                                        o()
                                    }
                                    return s = s.map(t => new e.Parser(t, this.settings)),
                                        function(t) {
                                            const e = [];
                                            for (const r of s) e.push(r.evaluate(t));
                                            return i.call(t, ...e)
                                        }
                                }
                                evaluate(t) {
                                    const e = this._parts.slice();
                                    for (let n = e.length - 2; n >= 0; --n) {
                                        const i = e[n];
                                        if (i && "operator" === i.type) {
                                            const s = e[n + 1];
                                            e.splice(n + 1, 1);
                                            const a = r.evaluate(s, t);
                                            e[n] = r.single(i.value, a)
                                        }
                                    }
                                    return r.operatorsOrder.forEach(n => {
                                        for (let i = 1; i < e.length - 1;)
                                            if (n.includes(e[i])) {
                                                const n = e[i],
                                                    s = r.evaluate(e[i - 1], t),
                                                    a = r.evaluate(e[i + 1], t);
                                                e.splice(i, 2);
                                                const o = r.calculate(n, s, a);
                                                e[i - 1] = 0 === o ? 0 : o
                                            } else i += 2
                                    }), r.evaluate(e[0], t)
                                }
                            }, e.Parser.prototype[r.symbol] = !0, r.reference = function(t) {
                                return function(e) {
                                    return e && void 0 !== e[t] ? e[t] : null
                                }
                            }, r.evaluate = function(t, e) {
                                return null === t ? null : "function" == typeof t ? t(e) : t[r.symbol] ? t.evaluate(e) : t
                            }, r.single = function(t, e) {
                                if ("!" === t) return !e;
                                const r = -e;
                                return 0 === r ? 0 : r
                            }, r.calculate = function(t, e, n) {
                                if ("??" === t) return r.exists(e) ? e : n;
                                if ("string" == typeof e || "string" == typeof n) {
                                    if ("+" === t) return (e = r.exists(e) ? e : "") + (r.exists(n) ? n : "")
                                } else switch (t) {
                                    case "^":
                                        return Math.pow(e, n);
                                    case "*":
                                        return e * n;
                                    case "/":
                                        return e / n;
                                    case "%":
                                        return e % n;
                                    case "+":
                                        return e + n;
                                    case "-":
                                        return e - n
                                }
                                switch (t) {
                                    case "<":
                                        return e < n;
                                    case "<=":
                                        return e <= n;
                                    case ">":
                                        return e > n;
                                    case ">=":
                                        return e >= n;
                                    case "==":
                                        return e === n;
                                    case "!=":
                                        return e !== n;
                                    case "&&":
                                        return e && n;
                                    case "||":
                                        return e || n
                                }
                                return null
                            }, r.exists = function(t) {
                                return null != t
                            }
                        },
                        9926: () => {},
                        5688: () => {},
                        9708: () => {},
                        1152: () => {},
                        443: () => {},
                        9848: () => {}
                    }, e = {},
                    function r(n) {
                        var i = e[n];
                        if (void 0 !== i) return i.exports;
                        var s = e[n] = {
                            exports: {}
                        };
                        return t[n](s, s.exports, r), s.exports
                    }(5107);
                var t, e
            }))
        },
        db97: function(t, e, r) {
            "use strict";
            const n = r("e26f").v4,
                i = function(t, e, r, i) {
                    if ("string" !== typeof t) throw new TypeError(t + " must be a string");
                    i = i || {};
                    const s = "number" === typeof i.version ? i.version : 2;
                    if (1 !== s && 2 !== s) throw new TypeError(s + " must be 1 or 2");
                    const a = {
                        method: t
                    };
                    if (2 === s && (a.jsonrpc = "2.0"), e) {
                        if ("object" !== typeof e && !Array.isArray(e)) throw new TypeError(e + " must be an object, array or omitted");
                        a.params = e
                    }
                    if ("undefined" === typeof r) {
                        const t = "function" === typeof i.generator ? i.generator : function() {
                            return n()
                        };
                        a.id = t(a, i)
                    } else 2 === s && null === r ? i.notificationIdNull && (a.id = null) : a.id = r;
                    return a
                };
            t.exports = i
        },
        e26f: function(t, e, r) {
            "use strict";
            var n;
            r.r(e), r.d(e, "v1", (function() {
                return y
            })), r.d(e, "v3", (function() {
                return F
            })), r.d(e, "v4", (function() {
                return $
            })), r.d(e, "v5", (function() {
                return Z
            })), r.d(e, "NIL", (function() {
                return H
            })), r.d(e, "version", (function() {
                return J
            })), r.d(e, "validate", (function() {
                return u
            })), r.d(e, "stringify", (function() {
                return p
            })), r.d(e, "parse", (function() {
                return w
            }));
            var i = new Uint8Array(16);

            function s() {
                if (!n && (n = "undefined" !== typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" !== typeof msCrypto && "function" === typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto), !n)) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
                return n(i)
            }
            var a = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

            function o(t) {
                return "string" === typeof t && a.test(t)
            }
            for (var u = o, h = [], f = 0; f < 256; ++f) h.push((f + 256).toString(16).substr(1));

            function c(t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                    r = (h[t[e + 0]] + h[t[e + 1]] + h[t[e + 2]] + h[t[e + 3]] + "-" + h[t[e + 4]] + h[t[e + 5]] + "-" + h[t[e + 6]] + h[t[e + 7]] + "-" + h[t[e + 8]] + h[t[e + 9]] + "-" + h[t[e + 10]] + h[t[e + 11]] + h[t[e + 12]] + h[t[e + 13]] + h[t[e + 14]] + h[t[e + 15]]).toLowerCase();
                if (!u(r)) throw TypeError("Stringified UUID is invalid");
                return r
            }
            var l, d, p = c,
                m = 0,
                b = 0;

            function g(t, e, r) {
                var n = e && r || 0,
                    i = e || new Array(16);
                t = t || {};
                var a = t.node || l,
                    o = void 0 !== t.clockseq ? t.clockseq : d;
                if (null == a || null == o) {
                    var u = t.random || (t.rng || s)();
                    null == a && (a = l = [1 | u[0], u[1], u[2], u[3], u[4], u[5]]), null == o && (o = d = 16383 & (u[6] << 8 | u[7]))
                }
                var h = void 0 !== t.msecs ? t.msecs : Date.now(),
                    f = void 0 !== t.nsecs ? t.nsecs : b + 1,
                    c = h - m + (f - b) / 1e4;
                if (c < 0 && void 0 === t.clockseq && (o = o + 1 & 16383), (c < 0 || h > m) && void 0 === t.nsecs && (f = 0), f >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
                m = h, b = f, d = o, h += 122192928e5;
                var g = (1e4 * (268435455 & h) + f) % 4294967296;
                i[n++] = g >>> 24 & 255, i[n++] = g >>> 16 & 255, i[n++] = g >>> 8 & 255, i[n++] = 255 & g;
                var y = h / 4294967296 * 1e4 & 268435455;
                i[n++] = y >>> 8 & 255, i[n++] = 255 & y, i[n++] = y >>> 24 & 15 | 16, i[n++] = y >>> 16 & 255, i[n++] = o >>> 8 | 128, i[n++] = 255 & o;
                for (var v = 0; v < 6; ++v) i[n + v] = a[v];
                return e || p(i)
            }
            var y = g;

            function v(t) {
                if (!u(t)) throw TypeError("Invalid UUID");
                var e, r = new Uint8Array(16);
                return r[0] = (e = parseInt(t.slice(0, 8), 16)) >>> 24, r[1] = e >>> 16 & 255, r[2] = e >>> 8 & 255, r[3] = 255 & e, r[4] = (e = parseInt(t.slice(9, 13), 16)) >>> 8, r[5] = 255 & e, r[6] = (e = parseInt(t.slice(14, 18), 16)) >>> 8, r[7] = 255 & e, r[8] = (e = parseInt(t.slice(19, 23), 16)) >>> 8, r[9] = 255 & e, r[10] = (e = parseInt(t.slice(24, 36), 16)) / 1099511627776 & 255, r[11] = e / 4294967296 & 255, r[12] = e >>> 24 & 255, r[13] = e >>> 16 & 255, r[14] = e >>> 8 & 255, r[15] = 255 & e, r
            }
            var w = v;

            function _(t) {
                t = unescape(encodeURIComponent(t));
                for (var e = [], r = 0; r < t.length; ++r) e.push(t.charCodeAt(r));
                return e
            }
            var M = "6ba7b810-9dad-11d1-80b4-00c04fd430c8",
                A = "6ba7b811-9dad-11d1-80b4-00c04fd430c8",
                S = function(t, e, r) {
                    function n(t, n, i, s) {
                        if ("string" === typeof t && (t = _(t)), "string" === typeof n && (n = w(n)), 16 !== n.length) throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
                        var a = new Uint8Array(16 + t.length);
                        if (a.set(n), a.set(t, n.length), a = r(a), a[6] = 15 & a[6] | e, a[8] = 63 & a[8] | 128, i) {
                            s = s || 0;
                            for (var o = 0; o < 16; ++o) i[s + o] = a[o];
                            return i
                        }
                        return p(a)
                    }
                    try {
                        n.name = t
                    } catch (i) {}
                    return n.DNS = M, n.URL = A, n
                };

            function x(t) {
                if ("string" === typeof t) {
                    var e = unescape(encodeURIComponent(t));
                    t = new Uint8Array(e.length);
                    for (var r = 0; r < e.length; ++r) t[r] = e.charCodeAt(r)
                }
                return E(R(O(t), 8 * t.length))
            }

            function E(t) {
                for (var e = [], r = 32 * t.length, n = "0123456789abcdef", i = 0; i < r; i += 8) {
                    var s = t[i >> 5] >>> i % 32 & 255,
                        a = parseInt(n.charAt(s >>> 4 & 15) + n.charAt(15 & s), 16);
                    e.push(a)
                }
                return e
            }

            function k(t) {
                return 14 + (t + 64 >>> 9 << 4) + 1
            }

            function R(t, e) {
                t[e >> 5] |= 128 << e % 32, t[k(e) - 1] = e;
                for (var r = 1732584193, n = -271733879, i = -1732584194, s = 271733878, a = 0; a < t.length; a += 16) {
                    var o = r,
                        u = n,
                        h = i,
                        f = s;
                    r = N(r, n, i, s, t[a], 7, -680876936), s = N(s, r, n, i, t[a + 1], 12, -389564586), i = N(i, s, r, n, t[a + 2], 17, 606105819), n = N(n, i, s, r, t[a + 3], 22, -1044525330), r = N(r, n, i, s, t[a + 4], 7, -176418897), s = N(s, r, n, i, t[a + 5], 12, 1200080426), i = N(i, s, r, n, t[a + 6], 17, -1473231341), n = N(n, i, s, r, t[a + 7], 22, -45705983), r = N(r, n, i, s, t[a + 8], 7, 1770035416), s = N(s, r, n, i, t[a + 9], 12, -1958414417), i = N(i, s, r, n, t[a + 10], 17, -42063), n = N(n, i, s, r, t[a + 11], 22, -1990404162), r = N(r, n, i, s, t[a + 12], 7, 1804603682), s = N(s, r, n, i, t[a + 13], 12, -40341101), i = N(i, s, r, n, t[a + 14], 17, -1502002290), n = N(n, i, s, r, t[a + 15], 22, 1236535329), r = j(r, n, i, s, t[a + 1], 5, -165796510), s = j(s, r, n, i, t[a + 6], 9, -1069501632), i = j(i, s, r, n, t[a + 11], 14, 643717713), n = j(n, i, s, r, t[a], 20, -373897302), r = j(r, n, i, s, t[a + 5], 5, -701558691), s = j(s, r, n, i, t[a + 10], 9, 38016083), i = j(i, s, r, n, t[a + 15], 14, -660478335), n = j(n, i, s, r, t[a + 4], 20, -405537848), r = j(r, n, i, s, t[a + 9], 5, 568446438), s = j(s, r, n, i, t[a + 14], 9, -1019803690), i = j(i, s, r, n, t[a + 3], 14, -187363961), n = j(n, i, s, r, t[a + 8], 20, 1163531501), r = j(r, n, i, s, t[a + 13], 5, -1444681467), s = j(s, r, n, i, t[a + 2], 9, -51403784), i = j(i, s, r, n, t[a + 7], 14, 1735328473), n = j(n, i, s, r, t[a + 12], 20, -1926607734), r = C(r, n, i, s, t[a + 5], 4, -378558), s = C(s, r, n, i, t[a + 8], 11, -2022574463), i = C(i, s, r, n, t[a + 11], 16, 1839030562), n = C(n, i, s, r, t[a + 14], 23, -35309556), r = C(r, n, i, s, t[a + 1], 4, -1530992060), s = C(s, r, n, i, t[a + 4], 11, 1272893353), i = C(i, s, r, n, t[a + 7], 16, -155497632), n = C(n, i, s, r, t[a + 10], 23, -1094730640), r = C(r, n, i, s, t[a + 13], 4, 681279174), s = C(s, r, n, i, t[a], 11, -358537222), i = C(i, s, r, n, t[a + 3], 16, -722521979), n = C(n, i, s, r, t[a + 6], 23, 76029189), r = C(r, n, i, s, t[a + 9], 4, -640364487), s = C(s, r, n, i, t[a + 12], 11, -421815835), i = C(i, s, r, n, t[a + 15], 16, 530742520), n = C(n, i, s, r, t[a + 2], 23, -995338651), r = z(r, n, i, s, t[a], 6, -198630844), s = z(s, r, n, i, t[a + 7], 10, 1126891415), i = z(i, s, r, n, t[a + 14], 15, -1416354905), n = z(n, i, s, r, t[a + 5], 21, -57434055), r = z(r, n, i, s, t[a + 12], 6, 1700485571), s = z(s, r, n, i, t[a + 3], 10, -1894986606), i = z(i, s, r, n, t[a + 10], 15, -1051523), n = z(n, i, s, r, t[a + 1], 21, -2054922799), r = z(r, n, i, s, t[a + 8], 6, 1873313359), s = z(s, r, n, i, t[a + 15], 10, -30611744), i = z(i, s, r, n, t[a + 6], 15, -1560198380), n = z(n, i, s, r, t[a + 13], 21, 1309151649), r = z(r, n, i, s, t[a + 4], 6, -145523070), s = z(s, r, n, i, t[a + 11], 10, -1120210379), i = z(i, s, r, n, t[a + 2], 15, 718787259), n = z(n, i, s, r, t[a + 9], 21, -343485551), r = I(r, o), n = I(n, u), i = I(i, h), s = I(s, f)
                }
                return [r, n, i, s]
            }

            function O(t) {
                if (0 === t.length) return [];
                for (var e = 8 * t.length, r = new Uint32Array(k(e)), n = 0; n < e; n += 8) r[n >> 5] |= (255 & t[n / 8]) << n % 32;
                return r
            }

            function I(t, e) {
                var r = (65535 & t) + (65535 & e),
                    n = (t >> 16) + (e >> 16) + (r >> 16);
                return n << 16 | 65535 & r
            }

            function P(t, e) {
                return t << e | t >>> 32 - e
            }

            function T(t, e, r, n, i, s) {
                return I(P(I(I(e, t), I(n, s)), i), r)
            }

            function N(t, e, r, n, i, s, a) {
                return T(e & r | ~e & n, t, e, i, s, a)
            }

            function j(t, e, r, n, i, s, a) {
                return T(e & n | r & ~n, t, e, i, s, a)
            }

            function C(t, e, r, n, i, s, a) {
                return T(e ^ r ^ n, t, e, i, s, a)
            }

            function z(t, e, r, n, i, s, a) {
                return T(r ^ (e | ~n), t, e, i, s, a)
            }
            var D = x,
                L = S("v3", 48, D),
                F = L;

            function B(t, e, r) {
                t = t || {};
                var n = t.random || (t.rng || s)();
                if (n[6] = 15 & n[6] | 64, n[8] = 63 & n[8] | 128, e) {
                    r = r || 0;
                    for (var i = 0; i < 16; ++i) e[r + i] = n[i];
                    return e
                }
                return p(n)
            }
            var $ = B;

            function U(t, e, r, n) {
                switch (t) {
                    case 0:
                        return e & r ^ ~e & n;
                    case 1:
                        return e ^ r ^ n;
                    case 2:
                        return e & r ^ e & n ^ r & n;
                    case 3:
                        return e ^ r ^ n
                }
            }

            function q(t, e) {
                return t << e | t >>> 32 - e
            }

            function K(t) {
                var e = [1518500249, 1859775393, 2400959708, 3395469782],
                    r = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
                if ("string" === typeof t) {
                    var n = unescape(encodeURIComponent(t));
                    t = [];
                    for (var i = 0; i < n.length; ++i) t.push(n.charCodeAt(i))
                } else Array.isArray(t) || (t = Array.prototype.slice.call(t));
                t.push(128);
                for (var s = t.length / 4 + 2, a = Math.ceil(s / 16), o = new Array(a), u = 0; u < a; ++u) {
                    for (var h = new Uint32Array(16), f = 0; f < 16; ++f) h[f] = t[64 * u + 4 * f] << 24 | t[64 * u + 4 * f + 1] << 16 | t[64 * u + 4 * f + 2] << 8 | t[64 * u + 4 * f + 3];
                    o[u] = h
                }
                o[a - 1][14] = 8 * (t.length - 1) / Math.pow(2, 32), o[a - 1][14] = Math.floor(o[a - 1][14]), o[a - 1][15] = 8 * (t.length - 1) & 4294967295;
                for (var c = 0; c < a; ++c) {
                    for (var l = new Uint32Array(80), d = 0; d < 16; ++d) l[d] = o[c][d];
                    for (var p = 16; p < 80; ++p) l[p] = q(l[p - 3] ^ l[p - 8] ^ l[p - 14] ^ l[p - 16], 1);
                    for (var m = r[0], b = r[1], g = r[2], y = r[3], v = r[4], w = 0; w < 80; ++w) {
                        var _ = Math.floor(w / 20),
                            M = q(m, 5) + U(_, b, g, y) + v + e[_] + l[w] >>> 0;
                        v = y, y = g, g = q(b, 30) >>> 0, b = m, m = M
                    }
                    r[0] = r[0] + m >>> 0, r[1] = r[1] + b >>> 0, r[2] = r[2] + g >>> 0, r[3] = r[3] + y >>> 0, r[4] = r[4] + v >>> 0
                }
                return [r[0] >> 24 & 255, r[0] >> 16 & 255, r[0] >> 8 & 255, 255 & r[0], r[1] >> 24 & 255, r[1] >> 16 & 255, r[1] >> 8 & 255, 255 & r[1], r[2] >> 24 & 255, r[2] >> 16 & 255, r[2] >> 8 & 255, 255 & r[2], r[3] >> 24 & 255, r[3] >> 16 & 255, r[3] >> 8 & 255, 255 & r[3], r[4] >> 24 & 255, r[4] >> 16 & 255, r[4] >> 8 & 255, 255 & r[4]]
            }
            var V = K,
                W = S("v5", 80, V),
                Z = W,
                H = "00000000-0000-0000-0000-000000000000";

            function G(t) {
                if (!u(t)) throw TypeError("Invalid UUID");
                return parseInt(t.substr(14, 1), 16)
            }
            var J = G
        },
        e3db: function(t, e) {
            var r = {}.toString;
            t.exports = Array.isArray || function(t) {
                return "[object Array]" == r.call(t)
            }
        },
        e666: function(t, e, r) {
            "use strict";
            (function(e) {
                var n = Object.keys || function(t) {
                    var e = [];
                    for (var r in t) e.push(r);
                    return e
                };
                t.exports = h;
                var i = r("4250"),
                    s = r("19ea");
                r("3fb5")(h, i);
                for (var a = n(s.prototype), o = 0; o < a.length; o++) {
                    var u = a[o];
                    h.prototype[u] || (h.prototype[u] = s.prototype[u])
                }

                function h(t) {
                    if (!(this instanceof h)) return new h(t);
                    i.call(this, t), s.call(this, t), this.allowHalfOpen = !0, t && (!1 === t.readable && (this.readable = !1), !1 === t.writable && (this.writable = !1), !1 === t.allowHalfOpen && (this.allowHalfOpen = !1, this.once("end", f)))
                }

                function f() {
                    this._writableState.ended || e.nextTick(c, this)
                }

                function c(t) {
                    t.end()
                }
                Object.defineProperty(h.prototype, "writableHighWaterMark", {
                    enumerable: !1,
                    get: function() {
                        return this._writableState.highWaterMark
                    }
                }), Object.defineProperty(h.prototype, "writableBuffer", {
                    enumerable: !1,
                    get: function() {
                        return this._writableState && this._writableState.getBuffer()
                    }
                }), Object.defineProperty(h.prototype, "writableLength", {
                    enumerable: !1,
                    get: function() {
                        return this._writableState.length
                    }
                }), Object.defineProperty(h.prototype, "destroyed", {
                    enumerable: !1,
                    get: function() {
                        return void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed && this._writableState.destroyed)
                    },
                    set: function(t) {
                        void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = t, this._writableState.destroyed = t)
                    }
                })
            }).call(this, r("4362"))
        },
        e902: function(t, e, r) {
            "use strict";
            var n = function(t, e) {
                return n = Object.setPrototypeOf || {
                    __proto__: []
                }
                instanceof Array && function(t, e) {
                    t.__proto__ = e
                } || function(t, e) {
                    for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r])
                }, n(t, e)
            };

            function i(t, e) {
                if ("function" !== typeof e && null !== e) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");

                function r() {
                    this.constructor = t
                }
                n(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r)
            }
            var s = function() {
                return s = Object.assign || function(t) {
                    for (var e, r = 1, n = arguments.length; r < n; r++)
                        for (var i in e = arguments[r], e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
                    return t
                }, s.apply(this, arguments)
            };
            Object.create;

            function a(t, e, r) {
                if (r || 2 === arguments.length)
                    for (var n, i = 0, s = e.length; i < s; i++) !n && i in e || (n || (n = Array.prototype.slice.call(e, 0, i)), n[i] = e[i]);
                return t.concat(n || Array.prototype.slice.call(e))
            }
            Object.create;
            var o, u = r("2ae8"),
                h = r("7264");
            (function(t) {
                t["MISSING_VALUE"] = "MISSING_VALUE", t["INVALID_VALUE"] = "INVALID_VALUE", t["MISSING_INTL_API"] = "MISSING_INTL_API"
            })(o || (o = {}));
            var f, c = function(t) {
                    function e(e, r, n) {
                        var i = t.call(this, e) || this;
                        return i.code = r, i.originalMessage = n, i
                    }
                    return i(e, t), e.prototype.toString = function() {
                        return "[formatjs Error: ".concat(this.code, "] ").concat(this.message)
                    }, e
                }(Error),
                l = function(t) {
                    function e(e, r, n, i) {
                        return t.call(this, 'Invalid values for "'.concat(e, '": "').concat(r, '". Options are "').concat(Object.keys(n).join('", "'), '"'), o.INVALID_VALUE, i) || this
                    }
                    return i(e, t), e
                }(c),
                d = function(t) {
                    function e(e, r, n) {
                        return t.call(this, 'Value for "'.concat(e, '" must be of type ').concat(r), o.INVALID_VALUE, n) || this
                    }
                    return i(e, t), e
                }(c),
                p = function(t) {
                    function e(e, r) {
                        return t.call(this, 'The intl string context variable "'.concat(e, '" was not provided to the string "').concat(r, '"'), o.MISSING_VALUE, r) || this
                    }
                    return i(e, t), e
                }(c);

            function m(t) {
                return t.length < 2 ? t : t.reduce((function(t, e) {
                    var r = t[t.length - 1];
                    return r && r.type === f.literal && e.type === f.literal ? r.value += e.value : t.push(e), t
                }), [])
            }

            function b(t) {
                return "function" === typeof t
            }

            function g(t, e, r, n, i, s, a) {
                if (1 === t.length && Object(u["d"])(t[0])) return [{
                    type: f.literal,
                    value: t[0].value
                }];
                for (var h = [], y = 0, v = t; y < v.length; y++) {
                    var w = v[y];
                    if (Object(u["d"])(w)) h.push({
                        type: f.literal,
                        value: w.value
                    });
                    else if (Object(u["h"])(w)) "number" === typeof s && h.push({
                        type: f.literal,
                        value: r.getNumberFormat(e).format(s)
                    });
                    else {
                        var _ = w.value;
                        if (!i || !(_ in i)) throw new p(_, a);
                        var M = i[_];
                        if (Object(u["a"])(w)) M && "string" !== typeof M && "number" !== typeof M || (M = "string" === typeof M || "number" === typeof M ? String(M) : ""), h.push({
                            type: "string" === typeof M ? f.literal : f.object,
                            value: M
                        });
                        else if (Object(u["b"])(w)) {
                            var A = "string" === typeof w.style ? n.date[w.style] : Object(u["c"])(w.style) ? w.style.parsedOptions : void 0;
                            h.push({
                                type: f.literal,
                                value: r.getDateTimeFormat(e, A).format(M)
                            })
                        } else if (Object(u["k"])(w)) {
                            A = "string" === typeof w.style ? n.time[w.style] : Object(u["c"])(w.style) ? w.style.parsedOptions : n.time.medium;
                            h.push({
                                type: f.literal,
                                value: r.getDateTimeFormat(e, A).format(M)
                            })
                        } else if (Object(u["e"])(w)) {
                            A = "string" === typeof w.style ? n.number[w.style] : Object(u["f"])(w.style) ? w.style.parsedOptions : void 0;
                            A && A.scale && (M *= A.scale || 1), h.push({
                                type: f.literal,
                                value: r.getNumberFormat(e, A).format(M)
                            })
                        } else {
                            if (Object(u["j"])(w)) {
                                var S = w.children,
                                    x = w.value,
                                    E = i[x];
                                if (!b(E)) throw new d(x, "function", a);
                                var k = g(S, e, r, n, i, s),
                                    R = E(k.map((function(t) {
                                        return t.value
                                    })));
                                Array.isArray(R) || (R = [R]), h.push.apply(h, R.map((function(t) {
                                    return {
                                        type: "string" === typeof t ? f.literal : f.object,
                                        value: t
                                    }
                                })))
                            }
                            if (Object(u["i"])(w)) {
                                var O = w.options[M] || w.options.other;
                                if (!O) throw new l(w.value, M, Object.keys(w.options), a);
                                h.push.apply(h, g(O.value, e, r, n, i))
                            } else if (Object(u["g"])(w)) {
                                O = w.options["=".concat(M)];
                                if (!O) {
                                    if (!Intl.PluralRules) throw new c('Intl.PluralRules is not available in this environment.\nTry polyfilling it using "@formatjs/intl-pluralrules"\n', o.MISSING_INTL_API, a);
                                    var I = r.getPluralRules(e, {
                                        type: w.pluralType
                                    }).select(M - (w.offset || 0));
                                    O = w.options[I] || w.options.other
                                }
                                if (!O) throw new l(w.value, M, Object.keys(w.options), a);
                                h.push.apply(h, g(O.value, e, r, n, i, M - (w.offset || 0)))
                            } else;
                        }
                    }
                }
                return m(h)
            }

            function y(t, e) {
                return e ? s(s(s({}, t || {}), e || {}), Object.keys(t).reduce((function(r, n) {
                    return r[n] = s(s({}, t[n]), e[n] || {}), r
                }), {})) : t
            }

            function v(t, e) {
                return e ? Object.keys(t).reduce((function(r, n) {
                    return r[n] = y(t[n], e[n]), r
                }), s({}, t)) : t
            }

            function w(t) {
                return {
                    create: function() {
                        return {
                            get: function(e) {
                                return t[e]
                            },
                            set: function(e, r) {
                                t[e] = r
                            }
                        }
                    }
                }
            }

            function _(t) {
                return void 0 === t && (t = {
                    number: {},
                    dateTime: {},
                    pluralRules: {}
                }), {
                    getNumberFormat: Object(h["a"])((function() {
                        for (var t, e = [], r = 0; r < arguments.length; r++) e[r] = arguments[r];
                        return new((t = Intl.NumberFormat).bind.apply(t, a([void 0], e, !1)))
                    }), {
                        cache: w(t.number),
                        strategy: h["b"].variadic
                    }),
                    getDateTimeFormat: Object(h["a"])((function() {
                        for (var t, e = [], r = 0; r < arguments.length; r++) e[r] = arguments[r];
                        return new((t = Intl.DateTimeFormat).bind.apply(t, a([void 0], e, !1)))
                    }), {
                        cache: w(t.dateTime),
                        strategy: h["b"].variadic
                    }),
                    getPluralRules: Object(h["a"])((function() {
                        for (var t, e = [], r = 0; r < arguments.length; r++) e[r] = arguments[r];
                        return new((t = Intl.PluralRules).bind.apply(t, a([void 0], e, !1)))
                    }), {
                        cache: w(t.pluralRules),
                        strategy: h["b"].variadic
                    })
                }
            }(function(t) {
                t[t["literal"] = 0] = "literal", t[t["object"] = 1] = "object"
            })(f || (f = {}));
            var M = function() {
                function t(e, r, n, i) {
                    var s = this;
                    if (void 0 === r && (r = t.defaultLocale), this.formatterCache = {
                            number: {},
                            dateTime: {},
                            pluralRules: {}
                        }, this.format = function(t) {
                            var e = s.formatToParts(t);
                            if (1 === e.length) return e[0].value;
                            var r = e.reduce((function(t, e) {
                                return t.length && e.type === f.literal && "string" === typeof t[t.length - 1] ? t[t.length - 1] += e.value : t.push(e.value), t
                            }), []);
                            return r.length <= 1 ? r[0] || "" : r
                        }, this.formatToParts = function(t) {
                            return g(s.ast, s.locales, s.formatters, s.formats, t, void 0, s.message)
                        }, this.resolvedOptions = function() {
                            return {
                                locale: s.resolvedLocale.toString()
                            }
                        }, this.getAst = function() {
                            return s.ast
                        }, this.locales = r, this.resolvedLocale = t.resolveLocale(r), "string" === typeof e) {
                        if (this.message = e, !t.__parse) throw new TypeError("IntlMessageFormat.__parse must be set to process `message` of type `string`");
                        this.ast = t.__parse(e, {
                            ignoreTag: null === i || void 0 === i ? void 0 : i.ignoreTag,
                            locale: this.resolvedLocale
                        })
                    } else this.ast = e;
                    if (!Array.isArray(this.ast)) throw new TypeError("A message must be provided as a String or AST.");
                    this.formats = v(t.formats, n), this.formatters = i && i.formatters || _(this.formatterCache)
                }
                return Object.defineProperty(t, "defaultLocale", {
                    get: function() {
                        return t.memoizedDefaultLocale || (t.memoizedDefaultLocale = (new Intl.NumberFormat).resolvedOptions().locale), t.memoizedDefaultLocale
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.memoizedDefaultLocale = null, t.resolveLocale = function(t) {
                    var e = Intl.NumberFormat.supportedLocalesOf(t);
                    return e.length > 0 ? new Intl.Locale(e[0]) : new Intl.Locale("string" === typeof t ? t : t[0])
                }, t.__parse = u["l"], t.formats = {
                    number: {
                        integer: {
                            maximumFractionDigits: 0
                        },
                        currency: {
                            style: "currency"
                        },
                        percent: {
                            style: "percent"
                        }
                    },
                    date: {
                        short: {
                            month: "numeric",
                            day: "numeric",
                            year: "2-digit"
                        },
                        medium: {
                            month: "short",
                            day: "numeric",
                            year: "numeric"
                        },
                        long: {
                            month: "long",
                            day: "numeric",
                            year: "numeric"
                        },
                        full: {
                            weekday: "long",
                            month: "long",
                            day: "numeric",
                            year: "numeric"
                        }
                    },
                    time: {
                        short: {
                            hour: "numeric",
                            minute: "numeric"
                        },
                        medium: {
                            hour: "numeric",
                            minute: "numeric",
                            second: "numeric"
                        },
                        long: {
                            hour: "numeric",
                            minute: "numeric",
                            second: "numeric",
                            timeZoneName: "short"
                        },
                        full: {
                            hour: "numeric",
                            minute: "numeric",
                            second: "numeric",
                            timeZoneName: "short"
                        }
                    }
                }, t
            }();
            e["a"] = M
        },
        ea53: function(t, e, r) {
            "use strict";
            var n = r("80af"),
                i = r("f3a3"),
                s = i.getNAF,
                a = i.getJSF,
                o = i.assert;

            function u(t, e) {
                this.type = t, this.p = new n(e.p, 16), this.red = e.prime ? n.red(e.prime) : n.mont(this.p), this.zero = new n(0).toRed(this.red), this.one = new n(1).toRed(this.red), this.two = new n(2).toRed(this.red), this.n = e.n && new n(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
                var r = this.n && this.p.div(this.n);
                !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red))
            }

            function h(t, e) {
                this.curve = t, this.type = e, this.precomputed = null
            }
            t.exports = u, u.prototype.point = function() {
                throw new Error("Not implemented")
            }, u.prototype.validate = function() {
                throw new Error("Not implemented")
            }, u.prototype._fixedNafMul = function(t, e) {
                o(t.precomputed);
                var r = t._getDoubles(),
                    n = s(e, 1, this._bitLength),
                    i = (1 << r.step + 1) - (r.step % 2 === 0 ? 2 : 1);
                i /= 3;
                var a, u, h = [];
                for (a = 0; a < n.length; a += r.step) {
                    u = 0;
                    for (var f = a + r.step - 1; f >= a; f--) u = (u << 1) + n[f];
                    h.push(u)
                }
                for (var c = this.jpoint(null, null, null), l = this.jpoint(null, null, null), d = i; d > 0; d--) {
                    for (a = 0; a < h.length; a++) u = h[a], u === d ? l = l.mixedAdd(r.points[a]) : u === -d && (l = l.mixedAdd(r.points[a].neg()));
                    c = c.add(l)
                }
                return c.toP()
            }, u.prototype._wnafMul = function(t, e) {
                var r = 4,
                    n = t._getNAFPoints(r);
                r = n.wnd;
                for (var i = n.points, a = s(e, r, this._bitLength), u = this.jpoint(null, null, null), h = a.length - 1; h >= 0; h--) {
                    for (var f = 0; h >= 0 && 0 === a[h]; h--) f++;
                    if (h >= 0 && f++, u = u.dblp(f), h < 0) break;
                    var c = a[h];
                    o(0 !== c), u = "affine" === t.type ? c > 0 ? u.mixedAdd(i[c - 1 >> 1]) : u.mixedAdd(i[-c - 1 >> 1].neg()) : c > 0 ? u.add(i[c - 1 >> 1]) : u.add(i[-c - 1 >> 1].neg())
                }
                return "affine" === t.type ? u.toP() : u
            }, u.prototype._wnafMulAdd = function(t, e, r, n, i) {
                var o, u, h, f = this._wnafT1,
                    c = this._wnafT2,
                    l = this._wnafT3,
                    d = 0;
                for (o = 0; o < n; o++) {
                    h = e[o];
                    var p = h._getNAFPoints(t);
                    f[o] = p.wnd, c[o] = p.points
                }
                for (o = n - 1; o >= 1; o -= 2) {
                    var m = o - 1,
                        b = o;
                    if (1 === f[m] && 1 === f[b]) {
                        var g = [e[m], null, null, e[b]];
                        0 === e[m].y.cmp(e[b].y) ? (g[1] = e[m].add(e[b]), g[2] = e[m].toJ().mixedAdd(e[b].neg())) : 0 === e[m].y.cmp(e[b].y.redNeg()) ? (g[1] = e[m].toJ().mixedAdd(e[b]), g[2] = e[m].add(e[b].neg())) : (g[1] = e[m].toJ().mixedAdd(e[b]), g[2] = e[m].toJ().mixedAdd(e[b].neg()));
                        var y = [-3, -1, -5, -7, 0, 7, 5, 1, 3],
                            v = a(r[m], r[b]);
                        for (d = Math.max(v[0].length, d), l[m] = new Array(d), l[b] = new Array(d), u = 0; u < d; u++) {
                            var w = 0 | v[0][u],
                                _ = 0 | v[1][u];
                            l[m][u] = y[3 * (w + 1) + (_ + 1)], l[b][u] = 0, c[m] = g
                        }
                    } else l[m] = s(r[m], f[m], this._bitLength), l[b] = s(r[b], f[b], this._bitLength), d = Math.max(l[m].length, d), d = Math.max(l[b].length, d)
                }
                var M = this.jpoint(null, null, null),
                    A = this._wnafT4;
                for (o = d; o >= 0; o--) {
                    var S = 0;
                    while (o >= 0) {
                        var x = !0;
                        for (u = 0; u < n; u++) A[u] = 0 | l[u][o], 0 !== A[u] && (x = !1);
                        if (!x) break;
                        S++, o--
                    }
                    if (o >= 0 && S++, M = M.dblp(S), o < 0) break;
                    for (u = 0; u < n; u++) {
                        var E = A[u];
                        0 !== E && (E > 0 ? h = c[u][E - 1 >> 1] : E < 0 && (h = c[u][-E - 1 >> 1].neg()), M = "affine" === h.type ? M.mixedAdd(h) : M.add(h))
                    }
                }
                for (o = 0; o < n; o++) c[o] = null;
                return i ? M : M.toP()
            }, u.BasePoint = h, h.prototype.eq = function() {
                throw new Error("Not implemented")
            }, h.prototype.validate = function() {
                return this.curve.validate(this)
            }, u.prototype.decodePoint = function(t, e) {
                t = i.toArray(t, e);
                var r = this.p.byteLength();
                if ((4 === t[0] || 6 === t[0] || 7 === t[0]) && t.length - 1 === 2 * r) {
                    6 === t[0] ? o(t[t.length - 1] % 2 === 0) : 7 === t[0] && o(t[t.length - 1] % 2 === 1);
                    var n = this.point(t.slice(1, 1 + r), t.slice(1 + r, 1 + 2 * r));
                    return n
                }
                if ((2 === t[0] || 3 === t[0]) && t.length - 1 === r) return this.pointFromX(t.slice(1, 1 + r), 3 === t[0]);
                throw new Error("Unknown point format")
            }, h.prototype.encodeCompressed = function(t) {
                return this.encode(t, !0)
            }, h.prototype._encode = function(t) {
                var e = this.curve.p.byteLength(),
                    r = this.getX().toArray("be", e);
                return t ? [this.getY().isEven() ? 2 : 3].concat(r) : [4].concat(r, this.getY().toArray("be", e))
            }, h.prototype.encode = function(t, e) {
                return i.encode(this._encode(e), t)
            }, h.prototype.precompute = function(t) {
                if (this.precomputed) return this;
                var e = {
                    doubles: null,
                    naf: null,
                    beta: null
                };
                return e.naf = this._getNAFPoints(8), e.doubles = this._getDoubles(4, t), e.beta = this._getBeta(), this.precomputed = e, this
            }, h.prototype._hasDoubles = function(t) {
                if (!this.precomputed) return !1;
                var e = this.precomputed.doubles;
                return !!e && e.points.length >= Math.ceil((t.bitLength() + 1) / e.step)
            }, h.prototype._getDoubles = function(t, e) {
                if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
                for (var r = [this], n = this, i = 0; i < e; i += t) {
                    for (var s = 0; s < t; s++) n = n.dbl();
                    r.push(n)
                }
                return {
                    step: t,
                    points: r
                }
            }, h.prototype._getNAFPoints = function(t) {
                if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
                for (var e = [this], r = (1 << t) - 1, n = 1 === r ? null : this.dbl(), i = 1; i < r; i++) e[i] = e[i - 1].add(n);
                return {
                    wnd: t,
                    points: e
                }
            }, h.prototype._getBeta = function() {
                return null
            }, h.prototype.dblp = function(t) {
                for (var e = this, r = 0; r < t; r++) e = e.dbl();
                return e
            }
        },
        edc9: function(t, e, r) {
            "use strict";
            var n = r("c3c0"),
                i = r("da3e");

            function s() {
                this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32
            }
            e.BlockHash = s, s.prototype.update = function(t, e) {
                if (t = n.toArray(t, e), this.pending ? this.pending = this.pending.concat(t) : this.pending = t, this.pendingTotal += t.length, this.pending.length >= this._delta8) {
                    t = this.pending;
                    var r = t.length % this._delta8;
                    this.pending = t.slice(t.length - r, t.length), 0 === this.pending.length && (this.pending = null), t = n.join32(t, 0, t.length - r, this.endian);
                    for (var i = 0; i < t.length; i += this._delta32) this._update(t, i, i + this._delta32)
                }
                return this
            }, s.prototype.digest = function(t) {
                return this.update(this._pad()), i(null === this.pending), this._digest(t)
            }, s.prototype._pad = function() {
                var t = this.pendingTotal,
                    e = this._delta8,
                    r = e - (t + this.padLength) % e,
                    n = new Array(r + this.padLength);
                n[0] = 128;
                for (var i = 1; i < r; i++) n[i] = 0;
                if (t <<= 3, "big" === this.endian) {
                    for (var s = 8; s < this.padLength; s++) n[i++] = 0;
                    n[i++] = 0, n[i++] = 0, n[i++] = 0, n[i++] = 0, n[i++] = t >>> 24 & 255, n[i++] = t >>> 16 & 255, n[i++] = t >>> 8 & 255, n[i++] = 255 & t
                } else
                    for (n[i++] = 255 & t, n[i++] = t >>> 8 & 255, n[i++] = t >>> 16 & 255, n[i++] = t >>> 24 & 255, n[i++] = 0, n[i++] = 0, n[i++] = 0, n[i++] = 0, s = 8; s < this.padLength; s++) n[i++] = 0;
                return n
            }
        },
        ee93: function(t, e, r) {
            "use strict";
            var n = r("9d8a").codes.ERR_STREAM_PREMATURE_CLOSE;

            function i(t) {
                var e = !1;
                return function() {
                    if (!e) {
                        e = !0;
                        for (var r = arguments.length, n = new Array(r), i = 0; i < r; i++) n[i] = arguments[i];
                        t.apply(this, n)
                    }
                }
            }

            function s() {}

            function a(t) {
                return t.setHeader && "function" === typeof t.abort
            }

            function o(t, e, r) {
                if ("function" === typeof e) return o(t, null, e);
                e || (e = {}), r = i(r || s);
                var u = e.readable || !1 !== e.readable && t.readable,
                    h = e.writable || !1 !== e.writable && t.writable,
                    f = function() {
                        t.writable || l()
                    },
                    c = t._writableState && t._writableState.finished,
                    l = function() {
                        h = !1, c = !0, u || r.call(t)
                    },
                    d = t._readableState && t._readableState.endEmitted,
                    p = function() {
                        u = !1, d = !0, h || r.call(t)
                    },
                    m = function(e) {
                        r.call(t, e)
                    },
                    b = function() {
                        var e;
                        return u && !d ? (t._readableState && t._readableState.ended || (e = new n), r.call(t, e)) : h && !c ? (t._writableState && t._writableState.ended || (e = new n), r.call(t, e)) : void 0
                    },
                    g = function() {
                        t.req.on("finish", l)
                    };
                return a(t) ? (t.on("complete", l), t.on("abort", b), t.req ? g() : t.on("request", g)) : h && !t._writableState && (t.on("end", f), t.on("close", f)), t.on("end", p), t.on("finish", l), !1 !== e.error && t.on("error", m), t.on("close", b),
                    function() {
                        t.removeListener("complete", l), t.removeListener("abort", b), t.removeListener("request", g), t.req && t.req.removeListener("finish", l), t.removeListener("end", f), t.removeListener("close", f), t.removeListener("finish", l), t.removeListener("end", p), t.removeListener("error", m), t.removeListener("close", b)
                    }
            }
            t.exports = o
        },
        f3a3: function(t, e, r) {
            "use strict";
            var n = e,
                i = r("80af"),
                s = r("da3e"),
                a = r("7658");

            function o(t, e, r) {
                var n = new Array(Math.max(t.bitLength(), r) + 1);
                n.fill(0);
                for (var i = 1 << e + 1, s = t.clone(), a = 0; a < n.length; a++) {
                    var o, u = s.andln(i - 1);
                    s.isOdd() ? (o = u > (i >> 1) - 1 ? (i >> 1) - u : u, s.isubn(o)) : o = 0, n[a] = o, s.iushrn(1)
                }
                return n
            }

            function u(t, e) {
                var r = [
                    [],
                    []
                ];
                t = t.clone(), e = e.clone();
                var n, i = 0,
                    s = 0;
                while (t.cmpn(-i) > 0 || e.cmpn(-s) > 0) {
                    var a, o, u = t.andln(3) + i & 3,
                        h = e.andln(3) + s & 3;
                    3 === u && (u = -1), 3 === h && (h = -1), 0 === (1 & u) ? a = 0 : (n = t.andln(7) + i & 7, a = 3 !== n && 5 !== n || 2 !== h ? u : -u), r[0].push(a), 0 === (1 & h) ? o = 0 : (n = e.andln(7) + s & 7, o = 3 !== n && 5 !== n || 2 !== u ? h : -h), r[1].push(o), 2 * i === a + 1 && (i = 1 - i), 2 * s === o + 1 && (s = 1 - s), t.iushrn(1), e.iushrn(1)
                }
                return r
            }

            function h(t, e, r) {
                var n = "_" + e;
                t.prototype[e] = function() {
                    return void 0 !== this[n] ? this[n] : this[n] = r.call(this)
                }
            }

            function f(t) {
                return "string" === typeof t ? n.toArray(t, "hex") : t
            }

            function c(t) {
                return new i(t, "hex", "le")
            }
            n.assert = s, n.toArray = a.toArray, n.zero2 = a.zero2, n.toHex = a.toHex, n.encode = a.encode, n.getNAF = o, n.getJSF = u, n.cachedProperty = h, n.parseBytes = f, n.intFromLE = c
        },
        f8a0: function(t, e, r) {
            var n, i;
            (function(r) {
                s(Math.pow(36, 5)), s(Math.pow(16, 7)), s(Math.pow(10, 9)), s(Math.pow(2, 30)), s(36), s(16), s(10), s(2);

                function s(t, e) {
                    return this instanceof s ? (this._low = 0, this._high = 0, this.remainder = null, "undefined" == typeof e ? o.call(this, t) : "string" == typeof t ? u.call(this, t, e) : void a.call(this, t, e)) : new s(t, e)
                }

                function a(t, e) {
                    return this._low = 0 | t, this._high = 0 | e, this
                }

                function o(t) {
                    return this._low = 65535 & t, this._high = t >>> 16, this
                }

                function u(t, e) {
                    var r = parseInt(t, e || 10);
                    return this._low = 65535 & r, this._high = r >>> 16, this
                }
                s.prototype.fromBits = a, s.prototype.fromNumber = o, s.prototype.fromString = u, s.prototype.toNumber = function() {
                    return 65536 * this._high + this._low
                }, s.prototype.toString = function(t) {
                    return this.toNumber().toString(t || 10)
                }, s.prototype.add = function(t) {
                    var e = this._low + t._low,
                        r = e >>> 16;
                    return r += this._high + t._high, this._low = 65535 & e, this._high = 65535 & r, this
                }, s.prototype.subtract = function(t) {
                    return this.add(t.clone().negate())
                }, s.prototype.multiply = function(t) {
                    var e, r, n = this._high,
                        i = this._low,
                        s = t._high,
                        a = t._low;
                    return r = i * a, e = r >>> 16, e += n * a, e &= 65535, e += i * s, this._low = 65535 & r, this._high = 65535 & e, this
                }, s.prototype.div = function(t) {
                    if (0 == t._low && 0 == t._high) throw Error("division by zero");
                    if (0 == t._high && 1 == t._low) return this.remainder = new s(0), this;
                    if (t.gt(this)) return this.remainder = this.clone(), this._low = 0, this._high = 0, this;
                    if (this.eq(t)) return this.remainder = new s(0), this._low = 1, this._high = 0, this;
                    var e = t.clone(),
                        r = -1;
                    while (!this.lt(e)) e.shiftLeft(1, !0), r++;
                    for (this.remainder = this.clone(), this._low = 0, this._high = 0; r >= 0; r--) e.shiftRight(1), this.remainder.lt(e) || (this.remainder.subtract(e), r >= 16 ? this._high |= 1 << r - 16 : this._low |= 1 << r);
                    return this
                }, s.prototype.negate = function() {
                    var t = 1 + (65535 & ~this._low);
                    return this._low = 65535 & t, this._high = ~this._high + (t >>> 16) & 65535, this
                }, s.prototype.equals = s.prototype.eq = function(t) {
                    return this._low == t._low && this._high == t._high
                }, s.prototype.greaterThan = s.prototype.gt = function(t) {
                    return this._high > t._high || !(this._high < t._high) && this._low > t._low
                }, s.prototype.lessThan = s.prototype.lt = function(t) {
                    return this._high < t._high || !(this._high > t._high) && this._low < t._low
                }, s.prototype.or = function(t) {
                    return this._low |= t._low, this._high |= t._high, this
                }, s.prototype.and = function(t) {
                    return this._low &= t._low, this._high &= t._high, this
                }, s.prototype.not = function() {
                    return this._low = 65535 & ~this._low, this._high = 65535 & ~this._high, this
                }, s.prototype.xor = function(t) {
                    return this._low ^= t._low, this._high ^= t._high, this
                }, s.prototype.shiftRight = s.prototype.shiftr = function(t) {
                    return t > 16 ? (this._low = this._high >> t - 16, this._high = 0) : 16 == t ? (this._low = this._high, this._high = 0) : (this._low = this._low >> t | this._high << 16 - t & 65535, this._high >>= t), this
                }, s.prototype.shiftLeft = s.prototype.shiftl = function(t, e) {
                    return t > 16 ? (this._high = this._low << t - 16, this._low = 0, e || (this._high &= 65535)) : 16 == t ? (this._high = this._low, this._low = 0) : (this._high = this._high << t | this._low >> 16 - t, this._low = this._low << t & 65535, e || (this._high &= 65535)), this
                }, s.prototype.rotateLeft = s.prototype.rotl = function(t) {
                    var e = this._high << 16 | this._low;
                    return e = e << t | e >>> 32 - t, this._low = 65535 & e, this._high = e >>> 16, this
                }, s.prototype.rotateRight = s.prototype.rotr = function(t) {
                    var e = this._high << 16 | this._low;
                    return e = e >>> t | e << 32 - t, this._low = 65535 & e, this._high = e >>> 16, this
                }, s.prototype.clone = function() {
                    return new s(this._low, this._high)
                }, n = [], i = function() {
                    return s
                }.apply(e, n), void 0 === i || (t.exports = i)
            })()
        },
        faa1: function(t, e, r) {
            "use strict";
            var n, i = "object" === typeof Reflect ? Reflect : null,
                s = i && "function" === typeof i.apply ? i.apply : function(t, e, r) {
                    return Function.prototype.apply.call(t, e, r)
                };

            function a(t) {
                console && console.warn && console.warn(t)
            }
            n = i && "function" === typeof i.ownKeys ? i.ownKeys : Object.getOwnPropertySymbols ? function(t) {
                return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))
            } : function(t) {
                return Object.getOwnPropertyNames(t)
            };
            var o = Number.isNaN || function(t) {
                return t !== t
            };

            function u() {
                u.init.call(this)
            }
            t.exports = u, t.exports.once = w, u.EventEmitter = u, u.prototype._events = void 0, u.prototype._eventsCount = 0, u.prototype._maxListeners = void 0;
            var h = 10;

            function f(t) {
                if ("function" !== typeof t) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t)
            }

            function c(t) {
                return void 0 === t._maxListeners ? u.defaultMaxListeners : t._maxListeners
            }

            function l(t, e, r, n) {
                var i, s, o;
                if (f(r), s = t._events, void 0 === s ? (s = t._events = Object.create(null), t._eventsCount = 0) : (void 0 !== s.newListener && (t.emit("newListener", e, r.listener ? r.listener : r), s = t._events), o = s[e]), void 0 === o) o = s[e] = r, ++t._eventsCount;
                else if ("function" === typeof o ? o = s[e] = n ? [r, o] : [o, r] : n ? o.unshift(r) : o.push(r), i = c(t), i > 0 && o.length > i && !o.warned) {
                    o.warned = !0;
                    var u = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                    u.name = "MaxListenersExceededWarning", u.emitter = t, u.type = e, u.count = o.length, a(u)
                }
                return t
            }

            function d() {
                if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
            }

            function p(t, e, r) {
                var n = {
                        fired: !1,
                        wrapFn: void 0,
                        target: t,
                        type: e,
                        listener: r
                    },
                    i = d.bind(n);
                return i.listener = r, n.wrapFn = i, i
            }

            function m(t, e, r) {
                var n = t._events;
                if (void 0 === n) return [];
                var i = n[e];
                return void 0 === i ? [] : "function" === typeof i ? r ? [i.listener || i] : [i] : r ? v(i) : g(i, i.length)
            }

            function b(t) {
                var e = this._events;
                if (void 0 !== e) {
                    var r = e[t];
                    if ("function" === typeof r) return 1;
                    if (void 0 !== r) return r.length
                }
                return 0
            }

            function g(t, e) {
                for (var r = new Array(e), n = 0; n < e; ++n) r[n] = t[n];
                return r
            }

            function y(t, e) {
                for (; e + 1 < t.length; e++) t[e] = t[e + 1];
                t.pop()
            }

            function v(t) {
                for (var e = new Array(t.length), r = 0; r < e.length; ++r) e[r] = t[r].listener || t[r];
                return e
            }

            function w(t, e) {
                return new Promise((function(r, n) {
                    function i(r) {
                        t.removeListener(e, s), n(r)
                    }

                    function s() {
                        "function" === typeof t.removeListener && t.removeListener("error", i), r([].slice.call(arguments))
                    }
                    M(t, e, s, {
                        once: !0
                    }), "error" !== e && _(t, i, {
                        once: !0
                    })
                }))
            }

            function _(t, e, r) {
                "function" === typeof t.on && M(t, "error", e, r)
            }

            function M(t, e, r, n) {
                if ("function" === typeof t.on) n.once ? t.once(e, r) : t.on(e, r);
                else {
                    if ("function" !== typeof t.addEventListener) throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
                    t.addEventListener(e, (function i(s) {
                        n.once && t.removeEventListener(e, i), r(s)
                    }))
                }
            }
            Object.defineProperty(u, "defaultMaxListeners", {
                enumerable: !0,
                get: function() {
                    return h
                },
                set: function(t) {
                    if ("number" !== typeof t || t < 0 || o(t)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
                    h = t
                }
            }), u.init = function() {
                void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
            }, u.prototype.setMaxListeners = function(t) {
                if ("number" !== typeof t || t < 0 || o(t)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
                return this._maxListeners = t, this
            }, u.prototype.getMaxListeners = function() {
                return c(this)
            }, u.prototype.emit = function(t) {
                for (var e = [], r = 1; r < arguments.length; r++) e.push(arguments[r]);
                var n = "error" === t,
                    i = this._events;
                if (void 0 !== i) n = n && void 0 === i.error;
                else if (!n) return !1;
                if (n) {
                    var a;
                    if (e.length > 0 && (a = e[0]), a instanceof Error) throw a;
                    var o = new Error("Unhandled error." + (a ? " (" + a.message + ")" : ""));
                    throw o.context = a, o
                }
                var u = i[t];
                if (void 0 === u) return !1;
                if ("function" === typeof u) s(u, this, e);
                else {
                    var h = u.length,
                        f = g(u, h);
                    for (r = 0; r < h; ++r) s(f[r], this, e)
                }
                return !0
            }, u.prototype.addListener = function(t, e) {
                return l(this, t, e, !1)
            }, u.prototype.on = u.prototype.addListener, u.prototype.prependListener = function(t, e) {
                return l(this, t, e, !0)
            }, u.prototype.once = function(t, e) {
                return f(e), this.on(t, p(this, t, e)), this
            }, u.prototype.prependOnceListener = function(t, e) {
                return f(e), this.prependListener(t, p(this, t, e)), this
            }, u.prototype.removeListener = function(t, e) {
                var r, n, i, s, a;
                if (f(e), n = this._events, void 0 === n) return this;
                if (r = n[t], void 0 === r) return this;
                if (r === e || r.listener === e) 0 === --this._eventsCount ? this._events = Object.create(null) : (delete n[t], n.removeListener && this.emit("removeListener", t, r.listener || e));
                else if ("function" !== typeof r) {
                    for (i = -1, s = r.length - 1; s >= 0; s--)
                        if (r[s] === e || r[s].listener === e) {
                            a = r[s].listener, i = s;
                            break
                        }
                    if (i < 0) return this;
                    0 === i ? r.shift() : y(r, i), 1 === r.length && (n[t] = r[0]), void 0 !== n.removeListener && this.emit("removeListener", t, a || e)
                }
                return this
            }, u.prototype.off = u.prototype.removeListener, u.prototype.removeAllListeners = function(t) {
                var e, r, n;
                if (r = this._events, void 0 === r) return this;
                if (void 0 === r.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== r[t] && (0 === --this._eventsCount ? this._events = Object.create(null) : delete r[t]), this;
                if (0 === arguments.length) {
                    var i, s = Object.keys(r);
                    for (n = 0; n < s.length; ++n) i = s[n], "removeListener" !== i && this.removeAllListeners(i);
                    return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
                }
                if (e = r[t], "function" === typeof e) this.removeListener(t, e);
                else if (void 0 !== e)
                    for (n = e.length - 1; n >= 0; n--) this.removeListener(t, e[n]);
                return this
            }, u.prototype.listeners = function(t) {
                return m(this, t, !0)
            }, u.prototype.rawListeners = function(t) {
                return m(this, t, !1)
            }, u.listenerCount = function(t, e) {
                return "function" === typeof t.listenerCount ? t.listenerCount(e) : b.call(t, e)
            }, u.prototype.listenerCount = b, u.prototype.eventNames = function() {
                return this._eventsCount > 0 ? n(this._events) : []
            }
        },
        fbd5: function(t, e, r) {
            "use strict";
            var n;

            function i(t) {
                var e = !1;
                return function() {
                    e || (e = !0, t.apply(void 0, arguments))
                }
            }
            var s = r("9d8a").codes,
                a = s.ERR_MISSING_ARGS,
                o = s.ERR_STREAM_DESTROYED;

            function u(t) {
                if (t) throw t
            }

            function h(t) {
                return t.setHeader && "function" === typeof t.abort
            }

            function f(t, e, s, a) {
                a = i(a);
                var u = !1;
                t.on("close", (function() {
                    u = !0
                })), void 0 === n && (n = r("ee93")), n(t, {
                    readable: e,
                    writable: s
                }, (function(t) {
                    if (t) return a(t);
                    u = !0, a()
                }));
                var f = !1;
                return function(e) {
                    if (!u && !f) return f = !0, h(t) ? t.abort() : "function" === typeof t.destroy ? t.destroy() : void a(e || new o("pipe"))
                }
            }

            function c(t) {
                t()
            }

            function l(t, e) {
                return t.pipe(e)
            }

            function d(t) {
                return t.length ? "function" !== typeof t[t.length - 1] ? u : t.pop() : u
            }

            function p() {
                for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++) e[r] = arguments[r];
                var n, i = d(e);
                if (Array.isArray(e[0]) && (e = e[0]), e.length < 2) throw new a("streams");
                var s = e.map((function(t, r) {
                    var a = r < e.length - 1,
                        o = r > 0;
                    return f(t, a, o, (function(t) {
                        n || (n = t), t && s.forEach(c), a || (s.forEach(c), i(n))
                    }))
                }));
                return e.reduce(l)
            }
            t.exports = p
        },
        fdbb: function(t, e, r) {
            var n, i;
            (function(r) {
                var s = {
                        16: o(Math.pow(16, 5)),
                        10: o(Math.pow(10, 5)),
                        2: o(Math.pow(2, 5))
                    },
                    a = {
                        16: o(16),
                        10: o(10),
                        2: o(2)
                    };

                function o(t, e, r, n) {
                    return this instanceof o ? (this.remainder = null, "string" == typeof t ? f.call(this, t, e) : "undefined" == typeof e ? h.call(this, t) : void u.apply(this, arguments)) : new o(t, e, r, n)
                }

                function u(t, e, r, n) {
                    return "undefined" == typeof r ? (this._a00 = 65535 & t, this._a16 = t >>> 16, this._a32 = 65535 & e, this._a48 = e >>> 16, this) : (this._a00 = 0 | t, this._a16 = 0 | e, this._a32 = 0 | r, this._a48 = 0 | n, this)
                }

                function h(t) {
                    return this._a00 = 65535 & t, this._a16 = t >>> 16, this._a32 = 0, this._a48 = 0, this
                }

                function f(t, e) {
                    e = e || 10, this._a00 = 0, this._a16 = 0, this._a32 = 0, this._a48 = 0;
                    for (var r = s[e] || new o(Math.pow(e, 5)), n = 0, i = t.length; n < i; n += 5) {
                        var a = Math.min(5, i - n),
                            u = parseInt(t.slice(n, n + a), e);
                        this.multiply(a < 5 ? new o(Math.pow(e, a)) : r).add(new o(u))
                    }
                    return this
                }
                o.prototype.fromBits = u, o.prototype.fromNumber = h, o.prototype.fromString = f, o.prototype.toNumber = function() {
                    return 65536 * this._a16 + this._a00
                }, o.prototype.toString = function(t) {
                    t = t || 10;
                    var e = a[t] || new o(t);
                    if (!this.gt(e)) return this.toNumber().toString(t);
                    for (var r = this.clone(), n = new Array(64), i = 63; i >= 0; i--)
                        if (r.div(e), n[i] = r.remainder.toNumber().toString(t), !r.gt(e)) break;
                    return n[i - 1] = r.toNumber().toString(t), n.join("")
                }, o.prototype.add = function(t) {
                    var e = this._a00 + t._a00,
                        r = e >>> 16;
                    r += this._a16 + t._a16;
                    var n = r >>> 16;
                    n += this._a32 + t._a32;
                    var i = n >>> 16;
                    return i += this._a48 + t._a48, this._a00 = 65535 & e, this._a16 = 65535 & r, this._a32 = 65535 & n, this._a48 = 65535 & i, this
                }, o.prototype.subtract = function(t) {
                    return this.add(t.clone().negate())
                }, o.prototype.multiply = function(t) {
                    var e = this._a00,
                        r = this._a16,
                        n = this._a32,
                        i = this._a48,
                        s = t._a00,
                        a = t._a16,
                        o = t._a32,
                        u = t._a48,
                        h = e * s,
                        f = h >>> 16;
                    f += e * a;
                    var c = f >>> 16;
                    f &= 65535, f += r * s, c += f >>> 16, c += e * o;
                    var l = c >>> 16;
                    return c &= 65535, c += r * a, l += c >>> 16, c &= 65535, c += n * s, l += c >>> 16, l += e * u, l &= 65535, l += r * o, l &= 65535, l += n * a, l &= 65535, l += i * s, this._a00 = 65535 & h, this._a16 = 65535 & f, this._a32 = 65535 & c, this._a48 = 65535 & l, this
                }, o.prototype.div = function(t) {
                    if (0 == t._a16 && 0 == t._a32 && 0 == t._a48) {
                        if (0 == t._a00) throw Error("division by zero");
                        if (1 == t._a00) return this.remainder = new o(0), this
                    }
                    if (t.gt(this)) return this.remainder = this.clone(), this._a00 = 0, this._a16 = 0, this._a32 = 0, this._a48 = 0, this;
                    if (this.eq(t)) return this.remainder = new o(0), this._a00 = 1, this._a16 = 0, this._a32 = 0, this._a48 = 0, this;
                    var e = t.clone(),
                        r = -1;
                    while (!this.lt(e)) e.shiftLeft(1, !0), r++;
                    for (this.remainder = this.clone(), this._a00 = 0, this._a16 = 0, this._a32 = 0, this._a48 = 0; r >= 0; r--) e.shiftRight(1), this.remainder.lt(e) || (this.remainder.subtract(e), r >= 48 ? this._a48 |= 1 << r - 48 : r >= 32 ? this._a32 |= 1 << r - 32 : r >= 16 ? this._a16 |= 1 << r - 16 : this._a00 |= 1 << r);
                    return this
                }, o.prototype.negate = function() {
                    var t = 1 + (65535 & ~this._a00);
                    return this._a00 = 65535 & t, t = (65535 & ~this._a16) + (t >>> 16), this._a16 = 65535 & t, t = (65535 & ~this._a32) + (t >>> 16), this._a32 = 65535 & t, this._a48 = ~this._a48 + (t >>> 16) & 65535, this
                }, o.prototype.equals = o.prototype.eq = function(t) {
                    return this._a48 == t._a48 && this._a00 == t._a00 && this._a32 == t._a32 && this._a16 == t._a16
                }, o.prototype.greaterThan = o.prototype.gt = function(t) {
                    return this._a48 > t._a48 || !(this._a48 < t._a48) && (this._a32 > t._a32 || !(this._a32 < t._a32) && (this._a16 > t._a16 || !(this._a16 < t._a16) && this._a00 > t._a00))
                }, o.prototype.lessThan = o.prototype.lt = function(t) {
                    return this._a48 < t._a48 || !(this._a48 > t._a48) && (this._a32 < t._a32 || !(this._a32 > t._a32) && (this._a16 < t._a16 || !(this._a16 > t._a16) && this._a00 < t._a00))
                }, o.prototype.or = function(t) {
                    return this._a00 |= t._a00, this._a16 |= t._a16, this._a32 |= t._a32, this._a48 |= t._a48, this
                }, o.prototype.and = function(t) {
                    return this._a00 &= t._a00, this._a16 &= t._a16, this._a32 &= t._a32, this._a48 &= t._a48, this
                }, o.prototype.xor = function(t) {
                    return this._a00 ^= t._a00, this._a16 ^= t._a16, this._a32 ^= t._a32, this._a48 ^= t._a48, this
                }, o.prototype.not = function() {
                    return this._a00 = 65535 & ~this._a00, this._a16 = 65535 & ~this._a16, this._a32 = 65535 & ~this._a32, this._a48 = 65535 & ~this._a48, this
                }, o.prototype.shiftRight = o.prototype.shiftr = function(t) {
                    return t %= 64, t >= 48 ? (this._a00 = this._a48 >> t - 48, this._a16 = 0, this._a32 = 0, this._a48 = 0) : t >= 32 ? (t -= 32, this._a00 = 65535 & (this._a32 >> t | this._a48 << 16 - t), this._a16 = this._a48 >> t & 65535, this._a32 = 0, this._a48 = 0) : t >= 16 ? (t -= 16, this._a00 = 65535 & (this._a16 >> t | this._a32 << 16 - t), this._a16 = 65535 & (this._a32 >> t | this._a48 << 16 - t), this._a32 = this._a48 >> t & 65535, this._a48 = 0) : (this._a00 = 65535 & (this._a00 >> t | this._a16 << 16 - t), this._a16 = 65535 & (this._a16 >> t | this._a32 << 16 - t), this._a32 = 65535 & (this._a32 >> t | this._a48 << 16 - t), this._a48 = this._a48 >> t & 65535), this
                }, o.prototype.shiftLeft = o.prototype.shiftl = function(t, e) {
                    return t %= 64, t >= 48 ? (this._a48 = this._a00 << t - 48, this._a32 = 0, this._a16 = 0, this._a00 = 0) : t >= 32 ? (t -= 32, this._a48 = this._a16 << t | this._a00 >> 16 - t, this._a32 = this._a00 << t & 65535, this._a16 = 0, this._a00 = 0) : t >= 16 ? (t -= 16, this._a48 = this._a32 << t | this._a16 >> 16 - t, this._a32 = 65535 & (this._a16 << t | this._a00 >> 16 - t), this._a16 = this._a00 << t & 65535, this._a00 = 0) : (this._a48 = this._a48 << t | this._a32 >> 16 - t, this._a32 = 65535 & (this._a32 << t | this._a16 >> 16 - t), this._a16 = 65535 & (this._a16 << t | this._a00 >> 16 - t), this._a00 = this._a00 << t & 65535), e || (this._a48 &= 65535), this
                }, o.prototype.rotateLeft = o.prototype.rotl = function(t) {
                    if (t %= 64, 0 == t) return this;
                    if (t >= 32) {
                        var e = this._a00;
                        if (this._a00 = this._a32, this._a32 = e, e = this._a48, this._a48 = this._a16, this._a16 = e, 32 == t) return this;
                        t -= 32
                    }
                    var r = this._a48 << 16 | this._a32,
                        n = this._a16 << 16 | this._a00,
                        i = r << t | n >>> 32 - t,
                        s = n << t | r >>> 32 - t;
                    return this._a00 = 65535 & s, this._a16 = s >>> 16, this._a32 = 65535 & i, this._a48 = i >>> 16, this
                }, o.prototype.rotateRight = o.prototype.rotr = function(t) {
                    if (t %= 64, 0 == t) return this;
                    if (t >= 32) {
                        var e = this._a00;
                        if (this._a00 = this._a32, this._a32 = e, e = this._a48, this._a48 = this._a16, this._a16 = e, 32 == t) return this;
                        t -= 32
                    }
                    var r = this._a48 << 16 | this._a32,
                        n = this._a16 << 16 | this._a00,
                        i = r >>> t | n << 32 - t,
                        s = n >>> t | r << 32 - t;
                    return this._a00 = 65535 & s, this._a16 = s >>> 16, this._a32 = 65535 & i, this._a48 = i >>> 16, this
                }, o.prototype.clone = function() {
                    return new o(this._a00, this._a16, this._a32, this._a48)
                }, n = [], i = function() {
                    return o
                }.apply(e, n), void 0 === i || (t.exports = i)
            })()
        }
    }
]);