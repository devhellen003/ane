(window["webpackJsonp"] = window["webpackJsonp"] || []).push([
    ["chunk-vendors~f4520c04"], {
        "0067": function(e, t, n) {
            "use strict";

            function r(e) {
                if (!Number.isSafeInteger(e) || e < 0) throw new Error("positive integer expected, not " + e)
            }

            function o(e) {
                if ("boolean" !== typeof e) throw new Error("boolean expected, not " + e)
            }

            function i(e) {
                return e instanceof Uint8Array || null != e && "object" === typeof e && "Uint8Array" === e.constructor.name
            }

            function s(e, ...t) {
                if (!i(e)) throw new Error("Uint8Array expected");
                if (t.length > 0 && !t.includes(e.length)) throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`)
            }

            function a(e) {
                if ("function" !== typeof e || "function" !== typeof e.create) throw new Error("Hash should be wrapped by utils.wrapConstructor");
                r(e.outputLen), r(e.blockLen)
            }

            function c(e, t = !0) {
                if (e.destroyed) throw new Error("Hash instance has been destroyed");
                if (t && e.finished) throw new Error("Hash#digest() has already been called")
            }

            function u(e, t) {
                s(e);
                const n = t.outputLen;
                if (e.length < n) throw new Error("digestInto() expects output buffer of length at least " + n)
            }
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.output = t.exists = t.hash = t.bytes = t.bool = t.number = t.isBytes = void 0, t.number = r, t.bool = o, t.isBytes = i, t.bytes = s, t.hash = a, t.exists = c, t.output = u;
            const l = {
                number: r,
                bool: o,
                bytes: s,
                hash: a,
                exists: c,
                output: u
            };
            t.default = l
        },
        "0276": function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            });
            var r = n("b639"),
                o = n("f0f6"),
                i = n("7b8f"),
                s = n("399f"),
                a = n("0774"),
                c = n("ab84"),
                u = n("fa13"),
                l = n("8df2"),
                d = n("9ea2"),
                h = n("d920"),
                p = n("3f10"),
                g = n("502a"),
                f = n("5a86"),
                b = n("2fdf"),
                y = n("1f71");

            function m(e) {
                return e && "object" === typeof e && "default" in e ? e : {
                    default: e
                }
            }

            function w(e) {
                if (e && e.__esModule) return e;
                var t = Object.create(null);
                return e && Object.keys(e).forEach((function(n) {
                    if ("default" !== n) {
                        var r = Object.getOwnPropertyDescriptor(e, n);
                        Object.defineProperty(t, n, r.get ? r : {
                            enumerable: !0,
                            get: function() {
                                return e[n]
                            }
                        })
                    }
                })), t["default"] = e, Object.freeze(t)
            }
            var k = w(i),
                v = m(s),
                S = m(a),
                C = w(l),
                I = m(g),
                A = w(y);
            k.utils.sha512Sync = (...e) => o.sha512(k.utils.concatBytes(...e));
            const O = k.utils.randomPrivateKey,
                x = () => {
                    const e = k.utils.randomPrivateKey(),
                        t = _(e),
                        n = new Uint8Array(64);
                    return n.set(e), n.set(t, 32), {
                        publicKey: t,
                        secretKey: n
                    }
                },
                _ = k.sync.getPublicKey;

            function E(e) {
                try {
                    return k.Point.fromHex(e, !0), !0
                } catch {
                    return !1
                }
            }
            const T = (e, t) => k.sync.sign(e, t.slice(0, 32)),
                P = k.sync.verify,
                R = e => r.Buffer.isBuffer(e) ? e : e instanceof Uint8Array ? r.Buffer.from(e.buffer, e.byteOffset, e.byteLength) : r.Buffer.from(e);
            class j {
                constructor(e) {
                    Object.assign(this, e)
                }
                encode() {
                    return r.Buffer.from(u.serialize(L, this))
                }
                static decode(e) {
                    return u.deserialize(L, this, e)
                }
                static decodeUnchecked(e) {
                    return u.deserializeUnchecked(L, this, e)
                }
            }
            class B extends j {
                constructor(e) {
                    if (super(e), this.enum = "", 1 !== Object.keys(e).length) throw new Error("Enum can only take single value");
                    Object.keys(e).map(e => {
                        this.enum = e
                    })
                }
            }
            const L = new Map,
                W = 32,
                N = 32;

            function M(e) {
                return void 0 !== e._bn
            }
            let K = 1;
            class U extends j {
                constructor(e) {
                    if (super({}), this._bn = void 0, M(e)) this._bn = e._bn;
                    else {
                        if ("string" === typeof e) {
                            const t = S["default"].decode(e);
                            if (t.length != N) throw new Error("Invalid public key input");
                            this._bn = new v["default"](t)
                        } else this._bn = new v["default"](e);
                        if (this._bn.byteLength() > 32) throw new Error("Invalid public key input")
                    }
                }
                static unique() {
                    const e = new U(K);
                    return K += 1, new U(e.toBuffer())
                }
                equals(e) {
                    return this._bn.eq(e._bn)
                }
                toBase58() {
                    return S["default"].encode(this.toBytes())
                }
                toJSON() {
                    return this.toBase58()
                }
                toBytes() {
                    return this.toBuffer()
                }
                toBuffer() {
                    const e = this._bn.toArrayLike(r.Buffer);
                    if (e.length === N) return e;
                    const t = r.Buffer.alloc(32);
                    return e.copy(t, 32 - e.length), t
                }
                toString() {
                    return this.toBase58()
                }
                static async createWithSeed(e, t, n) {
                    const o = r.Buffer.concat([e.toBuffer(), r.Buffer.from(t), n.toBuffer()]),
                        i = c.sha256(o);
                    return new U(i)
                }
                static createProgramAddressSync(e, t) {
                    let n = r.Buffer.alloc(0);
                    e.forEach((function(e) {
                        if (e.length > W) throw new TypeError("Max seed length exceeded");
                        n = r.Buffer.concat([n, R(e)])
                    })), n = r.Buffer.concat([n, t.toBuffer(), r.Buffer.from("ProgramDerivedAddress")]);
                    const o = c.sha256(n);
                    if (E(o)) throw new Error("Invalid seeds, address must fall off the curve");
                    return new U(o)
                }
                static async createProgramAddress(e, t) {
                    return this.createProgramAddressSync(e, t)
                }
                static findProgramAddressSync(e, t) {
                    let n, o = 255;
                    while (0 != o) {
                        try {
                            const i = e.concat(r.Buffer.from([o]));
                            n = this.createProgramAddressSync(i, t)
                        } catch (i) {
                            if (i instanceof TypeError) throw i;
                            o--;
                            continue
                        }
                        return [n, o]
                    }
                    throw new Error("Unable to find a viable program address nonce")
                }
                static async findProgramAddress(e, t) {
                    return this.findProgramAddressSync(e, t)
                }
                static isOnCurve(e) {
                    const t = new U(e);
                    return E(t.toBytes())
                }
            }
            U.default = new U("11111111111111111111111111111111"), L.set(U, {
                kind: "struct",
                fields: [
                    ["_bn", "u256"]
                ]
            });
            class z {
                constructor(e) {
                    if (this._publicKey = void 0, this._secretKey = void 0, e) {
                        const t = R(e);
                        if (64 !== e.length) throw new Error("bad secret key size");
                        this._publicKey = t.slice(32, 64), this._secretKey = t.slice(0, 32)
                    } else this._secretKey = R(O()), this._publicKey = R(_(this._secretKey))
                }
                get publicKey() {
                    return new U(this._publicKey)
                }
                get secretKey() {
                    return r.Buffer.concat([this._secretKey, this._publicKey], 64)
                }
            }
            const D = new U("BPFLoader1111111111111111111111111111111111"),
                H = 1232,
                q = 127,
                $ = 64;
            class V extends Error {
                constructor(e) {
                    super(`Signature ${e} has expired: block height exceeded.`), this.signature = void 0, this.signature = e
                }
            }
            Object.defineProperty(V.prototype, "name", {
                value: "TransactionExpiredBlockheightExceededError"
            });
            class F extends Error {
                constructor(e, t) {
                    super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ` + e + " using the Solana Explorer or CLI tools."), this.signature = void 0, this.signature = e
                }
            }
            Object.defineProperty(F.prototype, "name", {
                value: "TransactionExpiredTimeoutError"
            });
            class G {
                constructor(e, t) {
                    this.staticAccountKeys = void 0, this.accountKeysFromLookups = void 0, this.staticAccountKeys = e, this.accountKeysFromLookups = t
                }
                keySegments() {
                    const e = [this.staticAccountKeys];
                    return this.accountKeysFromLookups && (e.push(this.accountKeysFromLookups.writable), e.push(this.accountKeysFromLookups.readonly)), e
                }
                get(e) {
                    for (const t of this.keySegments()) {
                        if (e < t.length) return t[e];
                        e -= t.length
                    }
                }
                get length() {
                    return this.keySegments().flat().length
                }
                compileInstructions(e) {
                    const t = 255;
                    if (this.length > t + 1) throw new Error("Account index overflow encountered during compilation");
                    const n = new Map;
                    this.keySegments().flat().forEach((e, t) => {
                        n.set(e.toBase58(), t)
                    });
                    const r = e => {
                        const t = n.get(e.toBase58());
                        if (void 0 === t) throw new Error("Encountered an unknown instruction account key during compilation");
                        return t
                    };
                    return e.map(e => ({
                        programIdIndex: r(e.programId),
                        accountKeyIndexes: e.keys.map(e => r(e.pubkey)),
                        data: e.data
                    }))
                }
            }
            const Y = (e = "publicKey") => C.blob(32, e),
                J = (e = "signature") => C.blob(64, e),
                Z = (e = "string") => {
                    const t = C.struct([C.u32("length"), C.u32("lengthPadding"), C.blob(C.offset(C.u32(), -8), "chars")], e),
                        n = t.decode.bind(t),
                        o = t.encode.bind(t),
                        i = t;
                    return i.decode = (e, t) => {
                        const r = n(e, t);
                        return r["chars"].toString()
                    }, i.encode = (e, t, n) => {
                        const i = {
                            chars: r.Buffer.from(e, "utf8")
                        };
                        return o(i, t, n)
                    }, i.alloc = e => C.u32().span + C.u32().span + r.Buffer.from(e, "utf8").length, i
                },
                X = (e = "authorized") => C.struct([Y("staker"), Y("withdrawer")], e),
                Q = (e = "lockup") => C.struct([C.ns64("unixTimestamp"), C.ns64("epoch"), Y("custodian")], e),
                ee = (e = "voteInit") => C.struct([Y("nodePubkey"), Y("authorizedVoter"), Y("authorizedWithdrawer"), C.u8("commission")], e),
                te = (e = "voteAuthorizeWithSeedArgs") => C.struct([C.u32("voteAuthorizationType"), Y("currentAuthorityDerivedKeyOwnerPubkey"), Z("currentAuthorityDerivedKeySeed"), Y("newAuthorized")], e);

            function ne(e, t) {
                const n = e => {
                    if (e.span >= 0) return e.span;
                    if ("function" === typeof e.alloc) return e.alloc(t[e.property]);
                    if ("count" in e && "elementLayout" in e) {
                        const r = t[e.property];
                        if (Array.isArray(r)) return r.length * n(e.elementLayout)
                    } else if ("fields" in e) return ne({
                        layout: e
                    }, t[e.property]);
                    return 0
                };
                let r = 0;
                return e.layout.fields.forEach(e => {
                    r += n(e)
                }), r
            }

            function re(e) {
                let t = 0,
                    n = 0;
                for (;;) {
                    let r = e.shift();
                    if (t |= (127 & r) << 7 * n, n += 1, 0 === (128 & r)) break
                }
                return t
            }

            function oe(e, t) {
                let n = t;
                for (;;) {
                    let t = 127 & n;
                    if (n >>= 7, 0 == n) {
                        e.push(t);
                        break
                    }
                    t |= 128, e.push(t)
                }
            }

            function ie(e, t) {
                if (!e) throw new Error(t || "Assertion failed")
            }
            class se {
                constructor(e, t) {
                    this.payer = void 0, this.keyMetaMap = void 0, this.payer = e, this.keyMetaMap = t
                }
                static compile(e, t) {
                    const n = new Map,
                        r = e => {
                            const t = e.toBase58();
                            let r = n.get(t);
                            return void 0 === r && (r = {
                                isSigner: !1,
                                isWritable: !1,
                                isInvoked: !1
                            }, n.set(t, r)), r
                        },
                        o = r(t);
                    o.isSigner = !0, o.isWritable = !0;
                    for (const i of e) {
                        r(i.programId).isInvoked = !0;
                        for (const e of i.keys) {
                            const t = r(e.pubkey);
                            t.isSigner || (t.isSigner = e.isSigner), t.isWritable || (t.isWritable = e.isWritable)
                        }
                    }
                    return new se(t, n)
                }
                getMessageComponents() {
                    const e = [...this.keyMetaMap.entries()];
                    ie(e.length <= 256, "Max static account keys length exceeded");
                    const t = e.filter(([, e]) => e.isSigner && e.isWritable),
                        n = e.filter(([, e]) => e.isSigner && !e.isWritable),
                        r = e.filter(([, e]) => !e.isSigner && e.isWritable),
                        o = e.filter(([, e]) => !e.isSigner && !e.isWritable),
                        i = {
                            numRequiredSignatures: t.length + n.length,
                            numReadonlySignedAccounts: n.length,
                            numReadonlyUnsignedAccounts: o.length
                        }; {
                        ie(t.length > 0, "Expected at least one writable signer key");
                        const [e] = t[0];
                        ie(e === this.payer.toBase58(), "Expected first writable signer key to be the fee payer")
                    }
                    const s = [...t.map(([e]) => new U(e)), ...n.map(([e]) => new U(e)), ...r.map(([e]) => new U(e)), ...o.map(([e]) => new U(e))];
                    return [i, s]
                }
                extractTableLookup(e) {
                    const [t, n] = this.drainKeysFoundInLookupTable(e.state.addresses, e => !e.isSigner && !e.isInvoked && e.isWritable), [r, o] = this.drainKeysFoundInLookupTable(e.state.addresses, e => !e.isSigner && !e.isInvoked && !e.isWritable);
                    if (0 !== t.length || 0 !== r.length) return [{
                        accountKey: e.key,
                        writableIndexes: t,
                        readonlyIndexes: r
                    }, {
                        writable: n,
                        readonly: o
                    }]
                }
                drainKeysFoundInLookupTable(e, t) {
                    const n = new Array,
                        r = new Array;
                    for (const [o, i] of this.keyMetaMap.entries())
                        if (t(i)) {
                            const t = new U(o),
                                i = e.findIndex(e => e.equals(t));
                            i >= 0 && (ie(i < 256, "Max lookup table index exceeded"), n.push(i), r.push(t), this.keyMetaMap.delete(o))
                        }
                    return [n, r]
                }
            }
            class ae {
                constructor(e) {
                    this.header = void 0, this.accountKeys = void 0, this.recentBlockhash = void 0, this.instructions = void 0, this.indexToProgramIds = new Map, this.header = e.header, this.accountKeys = e.accountKeys.map(e => new U(e)), this.recentBlockhash = e.recentBlockhash, this.instructions = e.instructions, this.instructions.forEach(e => this.indexToProgramIds.set(e.programIdIndex, this.accountKeys[e.programIdIndex]))
                }
                get version() {
                    return "legacy"
                }
                get staticAccountKeys() {
                    return this.accountKeys
                }
                get compiledInstructions() {
                    return this.instructions.map(e => ({
                        programIdIndex: e.programIdIndex,
                        accountKeyIndexes: e.accounts,
                        data: S["default"].decode(e.data)
                    }))
                }
                get addressTableLookups() {
                    return []
                }
                getAccountKeys() {
                    return new G(this.staticAccountKeys)
                }
                static compile(e) {
                    const t = se.compile(e.instructions, e.payerKey),
                        [n, r] = t.getMessageComponents(),
                        o = new G(r),
                        i = o.compileInstructions(e.instructions).map(e => ({
                            programIdIndex: e.programIdIndex,
                            accounts: e.accountKeyIndexes,
                            data: S["default"].encode(e.data)
                        }));
                    return new ae({
                        header: n,
                        accountKeys: r,
                        recentBlockhash: e.recentBlockhash,
                        instructions: i
                    })
                }
                isAccountSigner(e) {
                    return e < this.header.numRequiredSignatures
                }
                isAccountWritable(e) {
                    const t = this.header.numRequiredSignatures;
                    if (e >= this.header.numRequiredSignatures) {
                        const n = e - t,
                            r = this.accountKeys.length - t,
                            o = r - this.header.numReadonlyUnsignedAccounts;
                        return n < o
                    } {
                        const n = t - this.header.numReadonlySignedAccounts;
                        return e < n
                    }
                }
                isProgramId(e) {
                    return this.indexToProgramIds.has(e)
                }
                programIds() {
                    return [...this.indexToProgramIds.values()]
                }
                nonProgramIds() {
                    return this.accountKeys.filter((e, t) => !this.isProgramId(t))
                }
                serialize() {
                    const e = this.accountKeys.length;
                    let t = [];
                    oe(t, e);
                    const n = this.instructions.map(e => {
                        const {
                            accounts: t,
                            programIdIndex: n
                        } = e, o = Array.from(S["default"].decode(e.data));
                        let i = [];
                        oe(i, t.length);
                        let s = [];
                        return oe(s, o.length), {
                            programIdIndex: n,
                            keyIndicesCount: r.Buffer.from(i),
                            keyIndices: t,
                            dataLength: r.Buffer.from(s),
                            data: o
                        }
                    });
                    let o = [];
                    oe(o, n.length);
                    let i = r.Buffer.alloc(H);
                    r.Buffer.from(o).copy(i);
                    let s = o.length;
                    n.forEach(e => {
                        const t = C.struct([C.u8("programIdIndex"), C.blob(e.keyIndicesCount.length, "keyIndicesCount"), C.seq(C.u8("keyIndex"), e.keyIndices.length, "keyIndices"), C.blob(e.dataLength.length, "dataLength"), C.seq(C.u8("userdatum"), e.data.length, "data")]),
                            n = t.encode(e, i, s);
                        s += n
                    }), i = i.slice(0, s);
                    const a = C.struct([C.blob(1, "numRequiredSignatures"), C.blob(1, "numReadonlySignedAccounts"), C.blob(1, "numReadonlyUnsignedAccounts"), C.blob(t.length, "keyCount"), C.seq(Y("key"), e, "keys"), Y("recentBlockhash")]),
                        c = {
                            numRequiredSignatures: r.Buffer.from([this.header.numRequiredSignatures]),
                            numReadonlySignedAccounts: r.Buffer.from([this.header.numReadonlySignedAccounts]),
                            numReadonlyUnsignedAccounts: r.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
                            keyCount: r.Buffer.from(t),
                            keys: this.accountKeys.map(e => R(e.toBytes())),
                            recentBlockhash: S["default"].decode(this.recentBlockhash)
                        };
                    let u = r.Buffer.alloc(2048);
                    const l = a.encode(c, u);
                    return i.copy(u, l), u.slice(0, l + i.length)
                }
                static from(e) {
                    let t = [...e];
                    const n = t.shift();
                    if (n !== (n & q)) throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
                    const o = t.shift(),
                        i = t.shift(),
                        s = re(t);
                    let a = [];
                    for (let h = 0; h < s; h++) {
                        const e = t.slice(0, N);
                        t = t.slice(N), a.push(new U(r.Buffer.from(e)))
                    }
                    const c = t.slice(0, N);
                    t = t.slice(N);
                    const u = re(t);
                    let l = [];
                    for (let h = 0; h < u; h++) {
                        const e = t.shift(),
                            n = re(t),
                            o = t.slice(0, n);
                        t = t.slice(n);
                        const i = re(t),
                            s = t.slice(0, i),
                            a = S["default"].encode(r.Buffer.from(s));
                        t = t.slice(i), l.push({
                            programIdIndex: e,
                            accounts: o,
                            data: a
                        })
                    }
                    const d = {
                        header: {
                            numRequiredSignatures: n,
                            numReadonlySignedAccounts: o,
                            numReadonlyUnsignedAccounts: i
                        },
                        recentBlockhash: S["default"].encode(r.Buffer.from(c)),
                        accountKeys: a,
                        instructions: l
                    };
                    return new ae(d)
                }
            }
            class ce {
                constructor(e) {
                    this.header = void 0, this.staticAccountKeys = void 0, this.recentBlockhash = void 0, this.compiledInstructions = void 0, this.addressTableLookups = void 0, this.header = e.header, this.staticAccountKeys = e.staticAccountKeys, this.recentBlockhash = e.recentBlockhash, this.compiledInstructions = e.compiledInstructions, this.addressTableLookups = e.addressTableLookups
                }
                get version() {
                    return 0
                }
                get numAccountKeysFromLookups() {
                    let e = 0;
                    for (const t of this.addressTableLookups) e += t.readonlyIndexes.length + t.writableIndexes.length;
                    return e
                }
                getAccountKeys(e) {
                    let t;
                    if (e && "accountKeysFromLookups" in e && e.accountKeysFromLookups) {
                        if (this.numAccountKeysFromLookups != e.accountKeysFromLookups.writable.length + e.accountKeysFromLookups.readonly.length) throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
                        t = e.accountKeysFromLookups
                    } else if (e && "addressLookupTableAccounts" in e && e.addressLookupTableAccounts) t = this.resolveAddressTableLookups(e.addressLookupTableAccounts);
                    else if (this.addressTableLookups.length > 0) throw new Error("Failed to get account keys because address table lookups were not resolved");
                    return new G(this.staticAccountKeys, t)
                }
                isAccountSigner(e) {
                    return e < this.header.numRequiredSignatures
                }
                isAccountWritable(e) {
                    const t = this.header.numRequiredSignatures,
                        n = this.staticAccountKeys.length;
                    if (e >= n) {
                        const t = e - n,
                            r = this.addressTableLookups.reduce((e, t) => e + t.writableIndexes.length, 0);
                        return t < r
                    }
                    if (e >= this.header.numRequiredSignatures) {
                        const r = e - t,
                            o = n - t,
                            i = o - this.header.numReadonlyUnsignedAccounts;
                        return r < i
                    } {
                        const n = t - this.header.numReadonlySignedAccounts;
                        return e < n
                    }
                }
                resolveAddressTableLookups(e) {
                    const t = {
                        writable: [],
                        readonly: []
                    };
                    for (const n of this.addressTableLookups) {
                        const r = e.find(e => e.key.equals(n.accountKey));
                        if (!r) throw new Error("Failed to find address lookup table account for table key " + n.accountKey.toBase58());
                        for (const e of n.writableIndexes) {
                            if (!(e < r.state.addresses.length)) throw new Error(`Failed to find address for index ${e} in address lookup table ${n.accountKey.toBase58()}`);
                            t.writable.push(r.state.addresses[e])
                        }
                        for (const e of n.readonlyIndexes) {
                            if (!(e < r.state.addresses.length)) throw new Error(`Failed to find address for index ${e} in address lookup table ${n.accountKey.toBase58()}`);
                            t.readonly.push(r.state.addresses[e])
                        }
                    }
                    return t
                }
                static compile(e) {
                    const t = se.compile(e.instructions, e.payerKey),
                        n = new Array,
                        r = {
                            writable: new Array,
                            readonly: new Array
                        },
                        o = e.addressLookupTableAccounts || [];
                    for (const u of o) {
                        const e = t.extractTableLookup(u);
                        if (void 0 !== e) {
                            const [t, {
                                writable: o,
                                readonly: i
                            }] = e;
                            n.push(t), r.writable.push(...o), r.readonly.push(...i)
                        }
                    }
                    const [i, s] = t.getMessageComponents(), a = new G(s, r), c = a.compileInstructions(e.instructions);
                    return new ce({
                        header: i,
                        staticAccountKeys: s,
                        recentBlockhash: e.recentBlockhash,
                        compiledInstructions: c,
                        addressTableLookups: n
                    })
                }
                serialize() {
                    const e = Array();
                    oe(e, this.staticAccountKeys.length);
                    const t = this.serializeInstructions(),
                        n = Array();
                    oe(n, this.compiledInstructions.length);
                    const r = this.serializeAddressTableLookups(),
                        o = Array();
                    oe(o, this.addressTableLookups.length);
                    const i = C.struct([C.u8("prefix"), C.struct([C.u8("numRequiredSignatures"), C.u8("numReadonlySignedAccounts"), C.u8("numReadonlyUnsignedAccounts")], "header"), C.blob(e.length, "staticAccountKeysLength"), C.seq(Y(), this.staticAccountKeys.length, "staticAccountKeys"), Y("recentBlockhash"), C.blob(n.length, "instructionsLength"), C.blob(t.length, "serializedInstructions"), C.blob(o.length, "addressTableLookupsLength"), C.blob(r.length, "serializedAddressTableLookups")]),
                        s = new Uint8Array(H),
                        a = 128,
                        c = i.encode({
                            prefix: a,
                            header: this.header,
                            staticAccountKeysLength: new Uint8Array(e),
                            staticAccountKeys: this.staticAccountKeys.map(e => e.toBytes()),
                            recentBlockhash: S["default"].decode(this.recentBlockhash),
                            instructionsLength: new Uint8Array(n),
                            serializedInstructions: t,
                            addressTableLookupsLength: new Uint8Array(o),
                            serializedAddressTableLookups: r
                        }, s);
                    return s.slice(0, c)
                }
                serializeInstructions() {
                    let e = 0;
                    const t = new Uint8Array(H);
                    for (const n of this.compiledInstructions) {
                        const r = Array();
                        oe(r, n.accountKeyIndexes.length);
                        const o = Array();
                        oe(o, n.data.length);
                        const i = C.struct([C.u8("programIdIndex"), C.blob(r.length, "encodedAccountKeyIndexesLength"), C.seq(C.u8(), n.accountKeyIndexes.length, "accountKeyIndexes"), C.blob(o.length, "encodedDataLength"), C.blob(n.data.length, "data")]);
                        e += i.encode({
                            programIdIndex: n.programIdIndex,
                            encodedAccountKeyIndexesLength: new Uint8Array(r),
                            accountKeyIndexes: n.accountKeyIndexes,
                            encodedDataLength: new Uint8Array(o),
                            data: n.data
                        }, t, e)
                    }
                    return t.slice(0, e)
                }
                serializeAddressTableLookups() {
                    let e = 0;
                    const t = new Uint8Array(H);
                    for (const n of this.addressTableLookups) {
                        const r = Array();
                        oe(r, n.writableIndexes.length);
                        const o = Array();
                        oe(o, n.readonlyIndexes.length);
                        const i = C.struct([Y("accountKey"), C.blob(r.length, "encodedWritableIndexesLength"), C.seq(C.u8(), n.writableIndexes.length, "writableIndexes"), C.blob(o.length, "encodedReadonlyIndexesLength"), C.seq(C.u8(), n.readonlyIndexes.length, "readonlyIndexes")]);
                        e += i.encode({
                            accountKey: n.accountKey.toBytes(),
                            encodedWritableIndexesLength: new Uint8Array(r),
                            writableIndexes: n.writableIndexes,
                            encodedReadonlyIndexesLength: new Uint8Array(o),
                            readonlyIndexes: n.readonlyIndexes
                        }, t, e)
                    }
                    return t.slice(0, e)
                }
                static deserialize(e) {
                    let t = [...e];
                    const n = t.shift(),
                        r = n & q;
                    ie(n !== r, "Expected versioned message but received legacy message");
                    const o = r;
                    ie(0 === o, "Expected versioned message with version 0 but found version " + o);
                    const i = {
                            numRequiredSignatures: t.shift(),
                            numReadonlySignedAccounts: t.shift(),
                            numReadonlyUnsignedAccounts: t.shift()
                        },
                        s = [],
                        a = re(t);
                    for (let p = 0; p < a; p++) s.push(new U(t.splice(0, N)));
                    const c = S["default"].encode(t.splice(0, N)),
                        u = re(t),
                        l = [];
                    for (let p = 0; p < u; p++) {
                        const e = t.shift(),
                            n = re(t),
                            r = t.splice(0, n),
                            o = re(t),
                            i = new Uint8Array(t.splice(0, o));
                        l.push({
                            programIdIndex: e,
                            accountKeyIndexes: r,
                            data: i
                        })
                    }
                    const d = re(t),
                        h = [];
                    for (let p = 0; p < d; p++) {
                        const e = new U(t.splice(0, N)),
                            n = re(t),
                            r = t.splice(0, n),
                            o = re(t),
                            i = t.splice(0, o);
                        h.push({
                            accountKey: e,
                            writableIndexes: r,
                            readonlyIndexes: i
                        })
                    }
                    return new ce({
                        header: i,
                        staticAccountKeys: s,
                        recentBlockhash: c,
                        compiledInstructions: l,
                        addressTableLookups: h
                    })
                }
            }
            const ue = {
                deserializeMessageVersion(e) {
                    const t = e[0],
                        n = t & q;
                    return n === t ? "legacy" : n
                },
                deserialize: e => {
                    const t = ue.deserializeMessageVersion(e);
                    if ("legacy" === t) return ae.from(e);
                    if (0 === t) return ce.deserialize(e);
                    throw new Error(`Transaction message version ${t} deserialization is not supported`)
                }
            };
            t.TransactionStatus = void 0,
                function(e) {
                    e[e["BLOCKHEIGHT_EXCEEDED"] = 0] = "BLOCKHEIGHT_EXCEEDED", e[e["PROCESSED"] = 1] = "PROCESSED", e[e["TIMED_OUT"] = 2] = "TIMED_OUT"
                }(t.TransactionStatus || (t.TransactionStatus = {}));
            const le = r.Buffer.alloc($).fill(0);
            class de {
                constructor(e) {
                    this.keys = void 0, this.programId = void 0, this.data = r.Buffer.alloc(0), this.programId = e.programId, this.keys = e.keys, e.data && (this.data = e.data)
                }
                toJSON() {
                    return {
                        keys: this.keys.map(({
                            pubkey: e,
                            isSigner: t,
                            isWritable: n
                        }) => ({
                            pubkey: e.toJSON(),
                            isSigner: t,
                            isWritable: n
                        })),
                        programId: this.programId.toJSON(),
                        data: [...this.data]
                    }
                }
            }
            class he {
                get signature() {
                    return this.signatures.length > 0 ? this.signatures[0].signature : null
                }
                constructor(e) {
                    if (this.signatures = [], this.feePayer = void 0, this.instructions = [], this.recentBlockhash = void 0, this.lastValidBlockHeight = void 0, this.nonceInfo = void 0, this._message = void 0, this._json = void 0, e)
                        if (e.feePayer && (this.feePayer = e.feePayer), e.signatures && (this.signatures = e.signatures), Object.prototype.hasOwnProperty.call(e, "lastValidBlockHeight")) {
                            const {
                                blockhash: t,
                                lastValidBlockHeight: n
                            } = e;
                            this.recentBlockhash = t, this.lastValidBlockHeight = n
                        } else {
                            const {
                                recentBlockhash: t,
                                nonceInfo: n
                            } = e;
                            n && (this.nonceInfo = n), this.recentBlockhash = t
                        }
                }
                toJSON() {
                    return {
                        recentBlockhash: this.recentBlockhash || null,
                        feePayer: this.feePayer ? this.feePayer.toJSON() : null,
                        nonceInfo: this.nonceInfo ? {
                            nonce: this.nonceInfo.nonce,
                            nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
                        } : null,
                        instructions: this.instructions.map(e => e.toJSON()),
                        signers: this.signatures.map(({
                            publicKey: e
                        }) => e.toJSON())
                    }
                }
                add(...e) {
                    if (0 === e.length) throw new Error("No instructions");
                    return e.forEach(e => {
                        "instructions" in e ? this.instructions = this.instructions.concat(e.instructions) : "data" in e && "programId" in e && "keys" in e ? this.instructions.push(e) : this.instructions.push(new de(e))
                    }), this
                }
                compileMessage() {
                    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) return this._message;
                    let e, t, n;
                    if (this.nonceInfo ? (e = this.nonceInfo.nonce, t = this.instructions[0] != this.nonceInfo.nonceInstruction ? [this.nonceInfo.nonceInstruction, ...this.instructions] : this.instructions) : (e = this.recentBlockhash, t = this.instructions), !e) throw new Error("Transaction recentBlockhash required");
                    if (t.length < 1 && console.warn("No instructions provided"), this.feePayer) n = this.feePayer;
                    else {
                        if (!(this.signatures.length > 0 && this.signatures[0].publicKey)) throw new Error("Transaction fee payer required");
                        n = this.signatures[0].publicKey
                    }
                    for (let g = 0; g < t.length; g++)
                        if (void 0 === t[g].programId) throw new Error(`Transaction instruction index ${g} has undefined program id`);
                    const r = [],
                        o = [];
                    t.forEach(e => {
                        e.keys.forEach(e => {
                            o.push({ ...e
                            })
                        });
                        const t = e.programId.toString();
                        r.includes(t) || r.push(t)
                    }), r.forEach(e => {
                        o.push({
                            pubkey: new U(e),
                            isSigner: !1,
                            isWritable: !1
                        })
                    });
                    const i = [];
                    o.forEach(e => {
                        const t = e.pubkey.toString(),
                            n = i.findIndex(e => e.pubkey.toString() === t);
                        n > -1 ? (i[n].isWritable = i[n].isWritable || e.isWritable, i[n].isSigner = i[n].isSigner || e.isSigner) : i.push(e)
                    }), i.sort((function(e, t) {
                        return e.isSigner !== t.isSigner ? e.isSigner ? -1 : 1 : e.isWritable !== t.isWritable ? e.isWritable ? -1 : 1 : e.pubkey.toBase58().localeCompare(t.pubkey.toBase58())
                    }));
                    const s = i.findIndex(e => e.pubkey.equals(n));
                    if (s > -1) {
                        const [e] = i.splice(s, 1);
                        e.isSigner = !0, e.isWritable = !0, i.unshift(e)
                    } else i.unshift({
                        pubkey: n,
                        isSigner: !0,
                        isWritable: !0
                    });
                    for (const g of this.signatures) {
                        const e = i.findIndex(e => e.pubkey.equals(g.publicKey));
                        if (!(e > -1)) throw new Error("unknown signer: " + g.publicKey.toString());
                        i[e].isSigner || (i[e].isSigner = !0, console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."))
                    }
                    let a = 0,
                        c = 0,
                        u = 0;
                    const l = [],
                        d = [];
                    i.forEach(({
                        pubkey: e,
                        isSigner: t,
                        isWritable: n
                    }) => {
                        t ? (l.push(e.toString()), a += 1, n || (c += 1)) : (d.push(e.toString()), n || (u += 1))
                    });
                    const h = l.concat(d),
                        p = t.map(e => {
                            const {
                                data: t,
                                programId: n
                            } = e;
                            return {
                                programIdIndex: h.indexOf(n.toString()),
                                accounts: e.keys.map(e => h.indexOf(e.pubkey.toString())),
                                data: S["default"].encode(t)
                            }
                        });
                    return p.forEach(e => {
                        ie(e.programIdIndex >= 0), e.accounts.forEach(e => ie(e >= 0))
                    }), new ae({
                        header: {
                            numRequiredSignatures: a,
                            numReadonlySignedAccounts: c,
                            numReadonlyUnsignedAccounts: u
                        },
                        accountKeys: h,
                        recentBlockhash: e,
                        instructions: p
                    })
                }
                _compile() {
                    const e = this.compileMessage(),
                        t = e.accountKeys.slice(0, e.header.numRequiredSignatures);
                    if (this.signatures.length === t.length) {
                        const n = this.signatures.every((e, n) => t[n].equals(e.publicKey));
                        if (n) return e
                    }
                    return this.signatures = t.map(e => ({
                        signature: null,
                        publicKey: e
                    })), e
                }
                serializeMessage() {
                    return this._compile().serialize()
                }
                async getEstimatedFee(e) {
                    return (await e.getFeeForMessage(this.compileMessage())).value
                }
                setSigners(...e) {
                    if (0 === e.length) throw new Error("No signers");
                    const t = new Set;
                    this.signatures = e.filter(e => {
                        const n = e.toString();
                        return !t.has(n) && (t.add(n), !0)
                    }).map(e => ({
                        signature: null,
                        publicKey: e
                    }))
                }
                sign(...e) {
                    if (0 === e.length) throw new Error("No signers");
                    const t = new Set,
                        n = [];
                    for (const o of e) {
                        const e = o.publicKey.toString();
                        t.has(e) || (t.add(e), n.push(o))
                    }
                    this.signatures = n.map(e => ({
                        signature: null,
                        publicKey: e.publicKey
                    }));
                    const r = this._compile();
                    this._partialSign(r, ...n)
                }
                partialSign(...e) {
                    if (0 === e.length) throw new Error("No signers");
                    const t = new Set,
                        n = [];
                    for (const o of e) {
                        const e = o.publicKey.toString();
                        t.has(e) || (t.add(e), n.push(o))
                    }
                    const r = this._compile();
                    this._partialSign(r, ...n)
                }
                _partialSign(e, ...t) {
                    const n = e.serialize();
                    t.forEach(e => {
                        const t = T(n, e.secretKey);
                        this._addSignature(e.publicKey, R(t))
                    })
                }
                addSignature(e, t) {
                    this._compile(), this._addSignature(e, t)
                }
                _addSignature(e, t) {
                    ie(64 === t.length);
                    const n = this.signatures.findIndex(t => e.equals(t.publicKey));
                    if (n < 0) throw new Error("unknown signer: " + e.toString());
                    this.signatures[n].signature = r.Buffer.from(t)
                }
                verifySignatures() {
                    return this._verifySignatures(this.serializeMessage(), !0)
                }
                _verifySignatures(e, t) {
                    for (const {
                            signature: n,
                            publicKey: r
                        } of this.signatures)
                        if (null === n) {
                            if (t) return !1
                        } else if (!P(n, e, r.toBuffer())) return !1;
                    return !0
                }
                serialize(e) {
                    const {
                        requireAllSignatures: t,
                        verifySignatures: n
                    } = Object.assign({
                        requireAllSignatures: !0,
                        verifySignatures: !0
                    }, e), r = this.serializeMessage();
                    if (n && !this._verifySignatures(r, t)) throw new Error("Signature verification failed");
                    return this._serialize(r)
                }
                _serialize(e) {
                    const {
                        signatures: t
                    } = this, n = [];
                    oe(n, t.length);
                    const o = n.length + 64 * t.length + e.length,
                        i = r.Buffer.alloc(o);
                    return ie(t.length < 256), r.Buffer.from(n).copy(i, 0), t.forEach(({
                        signature: e
                    }, t) => {
                        null !== e && (ie(64 === e.length, "signature has invalid length"), r.Buffer.from(e).copy(i, n.length + 64 * t))
                    }), e.copy(i, n.length + 64 * t.length), ie(i.length <= H, `Transaction too large: ${i.length} > ${H}`), i
                }
                get keys() {
                    return ie(1 === this.instructions.length), this.instructions[0].keys.map(e => e.pubkey)
                }
                get programId() {
                    return ie(1 === this.instructions.length), this.instructions[0].programId
                }
                get data() {
                    return ie(1 === this.instructions.length), this.instructions[0].data
                }
                static from(e) {
                    let t = [...e];
                    const n = re(t);
                    let o = [];
                    for (let i = 0; i < n; i++) {
                        const e = t.slice(0, $);
                        t = t.slice($), o.push(S["default"].encode(r.Buffer.from(e)))
                    }
                    return he.populate(ae.from(t), o)
                }
                static populate(e, t = []) {
                    const n = new he;
                    return n.recentBlockhash = e.recentBlockhash, e.header.numRequiredSignatures > 0 && (n.feePayer = e.accountKeys[0]), t.forEach((t, r) => {
                        const o = {
                            signature: t == S["default"].encode(le) ? null : S["default"].decode(t),
                            publicKey: e.accountKeys[r]
                        };
                        n.signatures.push(o)
                    }), e.instructions.forEach(t => {
                        const r = t.accounts.map(t => {
                            const r = e.accountKeys[t];
                            return {
                                pubkey: r,
                                isSigner: n.signatures.some(e => e.publicKey.toString() === r.toString()) || e.isAccountSigner(t),
                                isWritable: e.isAccountWritable(t)
                            }
                        });
                        n.instructions.push(new de({
                            keys: r,
                            programId: e.accountKeys[t.programIdIndex],
                            data: S["default"].decode(t.data)
                        }))
                    }), n._message = e, n._json = n.toJSON(), n
                }
            }
            class pe {
                constructor(e) {
                    this.payerKey = void 0, this.instructions = void 0, this.recentBlockhash = void 0, this.payerKey = e.payerKey, this.instructions = e.instructions, this.recentBlockhash = e.recentBlockhash
                }
                static decompile(e, t) {
                    const {
                        header: n,
                        compiledInstructions: r,
                        recentBlockhash: o
                    } = e, {
                        numRequiredSignatures: i,
                        numReadonlySignedAccounts: s,
                        numReadonlyUnsignedAccounts: a
                    } = n, c = i - s;
                    ie(c > 0, "Message header is invalid");
                    const u = e.staticAccountKeys.length - a;
                    ie(u >= 0, "Message header is invalid");
                    const l = e.getAccountKeys(t),
                        d = l.get(0);
                    if (void 0 === d) throw new Error("Failed to decompile message because no account keys were found");
                    const h = [];
                    for (const p of r) {
                        const e = [];
                        for (const r of p.accountKeyIndexes) {
                            const t = l.get(r);
                            if (void 0 === t) throw new Error("Failed to find key for account key index " + r);
                            const o = r < i;
                            let s;
                            s = o ? r < c : r < l.staticAccountKeys.length ? r - i < u : r - l.staticAccountKeys.length < l.accountKeysFromLookups.writable.length, e.push({
                                pubkey: t,
                                isSigner: r < n.numRequiredSignatures,
                                isWritable: s
                            })
                        }
                        const t = l.get(p.programIdIndex);
                        if (void 0 === t) throw new Error("Failed to find program id for program id index " + p.programIdIndex);
                        h.push(new de({
                            programId: t,
                            data: R(p.data),
                            keys: e
                        }))
                    }
                    return new pe({
                        payerKey: d,
                        instructions: h,
                        recentBlockhash: o
                    })
                }
                compileToLegacyMessage() {
                    return ae.compile({
                        payerKey: this.payerKey,
                        recentBlockhash: this.recentBlockhash,
                        instructions: this.instructions
                    })
                }
                compileToV0Message(e) {
                    return ce.compile({
                        payerKey: this.payerKey,
                        recentBlockhash: this.recentBlockhash,
                        instructions: this.instructions,
                        addressLookupTableAccounts: e
                    })
                }
            }
            class ge {
                get version() {
                    return this.message.version
                }
                constructor(e, t) {
                    if (this.signatures = void 0, this.message = void 0, void 0 !== t) ie(t.length === e.header.numRequiredSignatures, "Expected signatures length to be equal to the number of required signatures"), this.signatures = t;
                    else {
                        const t = [];
                        for (let n = 0; n < e.header.numRequiredSignatures; n++) t.push(new Uint8Array($));
                        this.signatures = t
                    }
                    this.message = e
                }
                serialize() {
                    const e = this.message.serialize(),
                        t = Array();
                    oe(t, this.signatures.length);
                    const n = C.struct([C.blob(t.length, "encodedSignaturesLength"), C.seq(J(), this.signatures.length, "signatures"), C.blob(e.length, "serializedMessage")]),
                        r = new Uint8Array(2048),
                        o = n.encode({
                            encodedSignaturesLength: new Uint8Array(t),
                            signatures: this.signatures,
                            serializedMessage: e
                        }, r);
                    return r.slice(0, o)
                }
                static deserialize(e) {
                    let t = [...e];
                    const n = [],
                        r = re(t);
                    for (let i = 0; i < r; i++) n.push(new Uint8Array(t.splice(0, $)));
                    const o = ue.deserialize(new Uint8Array(t));
                    return new ge(o, n)
                }
                sign(e) {
                    const t = this.message.serialize(),
                        n = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
                    for (const r of e) {
                        const e = n.findIndex(e => e.equals(r.publicKey));
                        ie(e >= 0, "Cannot sign with non signer key " + r.publicKey.toBase58()), this.signatures[e] = T(t, r.secretKey)
                    }
                }
                addSignature(e, t) {
                    ie(64 === t.byteLength, "Signature must be 64 bytes long");
                    const n = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures),
                        r = n.findIndex(t => t.equals(e));
                    ie(r >= 0, `Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`), this.signatures[r] = t
                }
            }
            const fe = new U("SysvarC1ock11111111111111111111111111111111"),
                be = new U("SysvarEpochSchedu1e111111111111111111111111"),
                ye = new U("Sysvar1nstructions1111111111111111111111111"),
                me = new U("SysvarRecentB1ockHashes11111111111111111111"),
                we = new U("SysvarRent111111111111111111111111111111111"),
                ke = new U("SysvarRewards111111111111111111111111111111"),
                ve = new U("SysvarS1otHashes111111111111111111111111111"),
                Se = new U("SysvarS1otHistory11111111111111111111111111"),
                Ce = new U("SysvarStakeHistory1111111111111111111111111");
            async function Ie(e, t, n, r) {
                const o = r && {
                        skipPreflight: r.skipPreflight,
                        preflightCommitment: r.preflightCommitment || r.commitment,
                        maxRetries: r.maxRetries,
                        minContextSlot: r.minContextSlot
                    },
                    i = await e.sendTransaction(t, n, o),
                    s = null != t.recentBlockhash && null != t.lastValidBlockHeight ? (await e.confirmTransaction({
                        signature: i,
                        blockhash: t.recentBlockhash,
                        lastValidBlockHeight: t.lastValidBlockHeight
                    }, r && r.commitment)).value : (await e.confirmTransaction(i, r && r.commitment)).value;
                if (s.err) throw new Error(`Transaction ${i} failed (${JSON.stringify(s)})`);
                return i
            }

            function Ae(e) {
                return new Promise(t => setTimeout(t, e))
            }

            function Oe(e, t) {
                const n = e.layout.span >= 0 ? e.layout.span : ne(e, t),
                    o = r.Buffer.alloc(n),
                    i = Object.assign({
                        instruction: e.index
                    }, t);
                return e.layout.encode(i, o), o
            }

            function xe(e, t) {
                let n;
                try {
                    n = e.layout.decode(t)
                } catch (r) {
                    throw new Error("invalid instruction; " + r)
                }
                if (n.instruction !== e.index) throw new Error(`invalid instruction; instruction index mismatch ${n.instruction} != ${e.index}`);
                return n
            }
            const _e = C.nu64("lamportsPerSignature"),
                Ee = C.struct([C.u32("version"), C.u32("state"), Y("authorizedPubkey"), Y("nonce"), C.struct([_e], "feeCalculator")]),
                Te = Ee.span;
            class Pe {
                constructor(e) {
                    this.authorizedPubkey = void 0, this.nonce = void 0, this.feeCalculator = void 0, this.authorizedPubkey = e.authorizedPubkey, this.nonce = e.nonce, this.feeCalculator = e.feeCalculator
                }
                static fromAccountData(e) {
                    const t = Ee.decode(R(e), 0);
                    return new Pe({
                        authorizedPubkey: new U(t.authorizedPubkey),
                        nonce: new U(t.nonce).toString(),
                        feeCalculator: t.feeCalculator
                    })
                }
            }
            const Re = e => {
                    const t = e.decode.bind(e),
                        n = e.encode.bind(e);
                    return {
                        decode: t,
                        encode: n
                    }
                },
                je = e => t => {
                    const n = l.blob(e, t),
                        {
                            encode: o,
                            decode: i
                        } = Re(n),
                        s = n;
                    return s.decode = (e, t) => {
                        const n = i(e, t);
                        return d.toBigIntLE(r.Buffer.from(n))
                    }, s.encode = (t, n, r) => {
                        const i = d.toBufferLE(t, e);
                        return o(i, n, r)
                    }, s
                },
                Be = je(8);
            class Le {
                constructor() {}
                static decodeInstructionType(e) {
                    this.checkProgramId(e.programId);
                    const t = C.u32("instruction"),
                        n = t.decode(e.data);
                    let r;
                    for (const [o, i] of Object.entries(We))
                        if (i.index == n) {
                            r = o;
                            break
                        }
                    if (!r) throw new Error("Instruction type incorrect; not a SystemInstruction");
                    return r
                }
                static decodeCreateAccount(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
                    const {
                        lamports: t,
                        space: n,
                        programId: r
                    } = xe(We.Create, e.data);
                    return {
                        fromPubkey: e.keys[0].pubkey,
                        newAccountPubkey: e.keys[1].pubkey,
                        lamports: t,
                        space: n,
                        programId: new U(r)
                    }
                }
                static decodeTransfer(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
                    const {
                        lamports: t
                    } = xe(We.Transfer, e.data);
                    return {
                        fromPubkey: e.keys[0].pubkey,
                        toPubkey: e.keys[1].pubkey,
                        lamports: t
                    }
                }
                static decodeTransferWithSeed(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
                    const {
                        lamports: t,
                        seed: n,
                        programId: r
                    } = xe(We.TransferWithSeed, e.data);
                    return {
                        fromPubkey: e.keys[0].pubkey,
                        basePubkey: e.keys[1].pubkey,
                        toPubkey: e.keys[2].pubkey,
                        lamports: t,
                        seed: n,
                        programId: new U(r)
                    }
                }
                static decodeAllocate(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 1);
                    const {
                        space: t
                    } = xe(We.Allocate, e.data);
                    return {
                        accountPubkey: e.keys[0].pubkey,
                        space: t
                    }
                }
                static decodeAllocateWithSeed(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 1);
                    const {
                        base: t,
                        seed: n,
                        space: r,
                        programId: o
                    } = xe(We.AllocateWithSeed, e.data);
                    return {
                        accountPubkey: e.keys[0].pubkey,
                        basePubkey: new U(t),
                        seed: n,
                        space: r,
                        programId: new U(o)
                    }
                }
                static decodeAssign(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 1);
                    const {
                        programId: t
                    } = xe(We.Assign, e.data);
                    return {
                        accountPubkey: e.keys[0].pubkey,
                        programId: new U(t)
                    }
                }
                static decodeAssignWithSeed(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 1);
                    const {
                        base: t,
                        seed: n,
                        programId: r
                    } = xe(We.AssignWithSeed, e.data);
                    return {
                        accountPubkey: e.keys[0].pubkey,
                        basePubkey: new U(t),
                        seed: n,
                        programId: new U(r)
                    }
                }
                static decodeCreateWithSeed(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
                    const {
                        base: t,
                        seed: n,
                        lamports: r,
                        space: o,
                        programId: i
                    } = xe(We.CreateWithSeed, e.data);
                    return {
                        fromPubkey: e.keys[0].pubkey,
                        newAccountPubkey: e.keys[1].pubkey,
                        basePubkey: new U(t),
                        seed: n,
                        lamports: r,
                        space: o,
                        programId: new U(i)
                    }
                }
                static decodeNonceInitialize(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
                    const {
                        authorized: t
                    } = xe(We.InitializeNonceAccount, e.data);
                    return {
                        noncePubkey: e.keys[0].pubkey,
                        authorizedPubkey: new U(t)
                    }
                }
                static decodeNonceAdvance(e) {
                    return this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3), xe(We.AdvanceNonceAccount, e.data), {
                        noncePubkey: e.keys[0].pubkey,
                        authorizedPubkey: e.keys[2].pubkey
                    }
                }
                static decodeNonceWithdraw(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 5);
                    const {
                        lamports: t
                    } = xe(We.WithdrawNonceAccount, e.data);
                    return {
                        noncePubkey: e.keys[0].pubkey,
                        toPubkey: e.keys[1].pubkey,
                        authorizedPubkey: e.keys[4].pubkey,
                        lamports: t
                    }
                }
                static decodeNonceAuthorize(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
                    const {
                        authorized: t
                    } = xe(We.AuthorizeNonceAccount, e.data);
                    return {
                        noncePubkey: e.keys[0].pubkey,
                        authorizedPubkey: e.keys[1].pubkey,
                        newAuthorizedPubkey: new U(t)
                    }
                }
                static checkProgramId(e) {
                    if (!e.equals(Ne.programId)) throw new Error("invalid instruction; programId is not SystemProgram")
                }
                static checkKeyLength(e, t) {
                    if (e.length < t) throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)
                }
            }
            const We = Object.freeze({
                Create: {
                    index: 0,
                    layout: C.struct([C.u32("instruction"), C.ns64("lamports"), C.ns64("space"), Y("programId")])
                },
                Assign: {
                    index: 1,
                    layout: C.struct([C.u32("instruction"), Y("programId")])
                },
                Transfer: {
                    index: 2,
                    layout: C.struct([C.u32("instruction"), Be("lamports")])
                },
                CreateWithSeed: {
                    index: 3,
                    layout: C.struct([C.u32("instruction"), Y("base"), Z("seed"), C.ns64("lamports"), C.ns64("space"), Y("programId")])
                },
                AdvanceNonceAccount: {
                    index: 4,
                    layout: C.struct([C.u32("instruction")])
                },
                WithdrawNonceAccount: {
                    index: 5,
                    layout: C.struct([C.u32("instruction"), C.ns64("lamports")])
                },
                InitializeNonceAccount: {
                    index: 6,
                    layout: C.struct([C.u32("instruction"), Y("authorized")])
                },
                AuthorizeNonceAccount: {
                    index: 7,
                    layout: C.struct([C.u32("instruction"), Y("authorized")])
                },
                Allocate: {
                    index: 8,
                    layout: C.struct([C.u32("instruction"), C.ns64("space")])
                },
                AllocateWithSeed: {
                    index: 9,
                    layout: C.struct([C.u32("instruction"), Y("base"), Z("seed"), C.ns64("space"), Y("programId")])
                },
                AssignWithSeed: {
                    index: 10,
                    layout: C.struct([C.u32("instruction"), Y("base"), Z("seed"), Y("programId")])
                },
                TransferWithSeed: {
                    index: 11,
                    layout: C.struct([C.u32("instruction"), Be("lamports"), Z("seed"), Y("programId")])
                },
                UpgradeNonceAccount: {
                    index: 12,
                    layout: C.struct([C.u32("instruction")])
                }
            });
            class Ne {
                constructor() {}
                static createAccount(e) {
                    const t = We.Create,
                        n = Oe(t, {
                            lamports: e.lamports,
                            space: e.space,
                            programId: R(e.programId.toBuffer())
                        });
                    return new de({
                        keys: [{
                            pubkey: e.fromPubkey,
                            isSigner: !0,
                            isWritable: !0
                        }, {
                            pubkey: e.newAccountPubkey,
                            isSigner: !0,
                            isWritable: !0
                        }],
                        programId: this.programId,
                        data: n
                    })
                }
                static transfer(e) {
                    let t, n;
                    if ("basePubkey" in e) {
                        const r = We.TransferWithSeed;
                        t = Oe(r, {
                            lamports: BigInt(e.lamports),
                            seed: e.seed,
                            programId: R(e.programId.toBuffer())
                        }), n = [{
                            pubkey: e.fromPubkey,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: e.basePubkey,
                            isSigner: !0,
                            isWritable: !1
                        }, {
                            pubkey: e.toPubkey,
                            isSigner: !1,
                            isWritable: !0
                        }]
                    } else {
                        const r = We.Transfer;
                        t = Oe(r, {
                            lamports: BigInt(e.lamports)
                        }), n = [{
                            pubkey: e.fromPubkey,
                            isSigner: !0,
                            isWritable: !0
                        }, {
                            pubkey: e.toPubkey,
                            isSigner: !1,
                            isWritable: !0
                        }]
                    }
                    return new de({
                        keys: n,
                        programId: this.programId,
                        data: t
                    })
                }
                static assign(e) {
                    let t, n;
                    if ("basePubkey" in e) {
                        const r = We.AssignWithSeed;
                        t = Oe(r, {
                            base: R(e.basePubkey.toBuffer()),
                            seed: e.seed,
                            programId: R(e.programId.toBuffer())
                        }), n = [{
                            pubkey: e.accountPubkey,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: e.basePubkey,
                            isSigner: !0,
                            isWritable: !1
                        }]
                    } else {
                        const r = We.Assign;
                        t = Oe(r, {
                            programId: R(e.programId.toBuffer())
                        }), n = [{
                            pubkey: e.accountPubkey,
                            isSigner: !0,
                            isWritable: !0
                        }]
                    }
                    return new de({
                        keys: n,
                        programId: this.programId,
                        data: t
                    })
                }
                static createAccountWithSeed(e) {
                    const t = We.CreateWithSeed,
                        n = Oe(t, {
                            base: R(e.basePubkey.toBuffer()),
                            seed: e.seed,
                            lamports: e.lamports,
                            space: e.space,
                            programId: R(e.programId.toBuffer())
                        });
                    let r = [{
                        pubkey: e.fromPubkey,
                        isSigner: !0,
                        isWritable: !0
                    }, {
                        pubkey: e.newAccountPubkey,
                        isSigner: !1,
                        isWritable: !0
                    }];
                    return e.basePubkey != e.fromPubkey && r.push({
                        pubkey: e.basePubkey,
                        isSigner: !0,
                        isWritable: !1
                    }), new de({
                        keys: r,
                        programId: this.programId,
                        data: n
                    })
                }
                static createNonceAccount(e) {
                    const t = new he;
                    "basePubkey" in e && "seed" in e ? t.add(Ne.createAccountWithSeed({
                        fromPubkey: e.fromPubkey,
                        newAccountPubkey: e.noncePubkey,
                        basePubkey: e.basePubkey,
                        seed: e.seed,
                        lamports: e.lamports,
                        space: Te,
                        programId: this.programId
                    })) : t.add(Ne.createAccount({
                        fromPubkey: e.fromPubkey,
                        newAccountPubkey: e.noncePubkey,
                        lamports: e.lamports,
                        space: Te,
                        programId: this.programId
                    }));
                    const n = {
                        noncePubkey: e.noncePubkey,
                        authorizedPubkey: e.authorizedPubkey
                    };
                    return t.add(this.nonceInitialize(n)), t
                }
                static nonceInitialize(e) {
                    const t = We.InitializeNonceAccount,
                        n = Oe(t, {
                            authorized: R(e.authorizedPubkey.toBuffer())
                        }),
                        r = {
                            keys: [{
                                pubkey: e.noncePubkey,
                                isSigner: !1,
                                isWritable: !0
                            }, {
                                pubkey: me,
                                isSigner: !1,
                                isWritable: !1
                            }, {
                                pubkey: we,
                                isSigner: !1,
                                isWritable: !1
                            }],
                            programId: this.programId,
                            data: n
                        };
                    return new de(r)
                }
                static nonceAdvance(e) {
                    const t = We.AdvanceNonceAccount,
                        n = Oe(t),
                        r = {
                            keys: [{
                                pubkey: e.noncePubkey,
                                isSigner: !1,
                                isWritable: !0
                            }, {
                                pubkey: me,
                                isSigner: !1,
                                isWritable: !1
                            }, {
                                pubkey: e.authorizedPubkey,
                                isSigner: !0,
                                isWritable: !1
                            }],
                            programId: this.programId,
                            data: n
                        };
                    return new de(r)
                }
                static nonceWithdraw(e) {
                    const t = We.WithdrawNonceAccount,
                        n = Oe(t, {
                            lamports: e.lamports
                        });
                    return new de({
                        keys: [{
                            pubkey: e.noncePubkey,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: e.toPubkey,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: me,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: we,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: e.authorizedPubkey,
                            isSigner: !0,
                            isWritable: !1
                        }],
                        programId: this.programId,
                        data: n
                    })
                }
                static nonceAuthorize(e) {
                    const t = We.AuthorizeNonceAccount,
                        n = Oe(t, {
                            authorized: R(e.newAuthorizedPubkey.toBuffer())
                        });
                    return new de({
                        keys: [{
                            pubkey: e.noncePubkey,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: e.authorizedPubkey,
                            isSigner: !0,
                            isWritable: !1
                        }],
                        programId: this.programId,
                        data: n
                    })
                }
                static allocate(e) {
                    let t, n;
                    if ("basePubkey" in e) {
                        const r = We.AllocateWithSeed;
                        t = Oe(r, {
                            base: R(e.basePubkey.toBuffer()),
                            seed: e.seed,
                            space: e.space,
                            programId: R(e.programId.toBuffer())
                        }), n = [{
                            pubkey: e.accountPubkey,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: e.basePubkey,
                            isSigner: !0,
                            isWritable: !1
                        }]
                    } else {
                        const r = We.Allocate;
                        t = Oe(r, {
                            space: e.space
                        }), n = [{
                            pubkey: e.accountPubkey,
                            isSigner: !0,
                            isWritable: !0
                        }]
                    }
                    return new de({
                        keys: n,
                        programId: this.programId,
                        data: t
                    })
                }
            }
            Ne.programId = new U("11111111111111111111111111111111");
            const Me = H - 300;
            class Ke {
                constructor() {}
                static getMinNumSignatures(e) {
                    return 2 * (Math.ceil(e / Ke.chunkSize) + 1 + 1)
                }
                static async load(e, t, n, o, i) {
                    {
                        const r = await e.getMinimumBalanceForRentExemption(i.length),
                            s = await e.getAccountInfo(n.publicKey, "confirmed");
                        let a = null;
                        if (null !== s) {
                            if (s.executable) return console.error("Program load failed, account is already executable"), !1;
                            s.data.length !== i.length && (a = a || new he, a.add(Ne.allocate({
                                accountPubkey: n.publicKey,
                                space: i.length
                            }))), s.owner.equals(o) || (a = a || new he, a.add(Ne.assign({
                                accountPubkey: n.publicKey,
                                programId: o
                            }))), s.lamports < r && (a = a || new he, a.add(Ne.transfer({
                                fromPubkey: t.publicKey,
                                toPubkey: n.publicKey,
                                lamports: r - s.lamports
                            })))
                        } else a = (new he).add(Ne.createAccount({
                            fromPubkey: t.publicKey,
                            newAccountPubkey: n.publicKey,
                            lamports: r > 0 ? r : 1,
                            space: i.length,
                            programId: o
                        }));
                        null !== a && await Ie(e, a, [t, n], {
                            commitment: "confirmed"
                        })
                    }
                    const s = C.struct([C.u32("instruction"), C.u32("offset"), C.u32("bytesLength"), C.u32("bytesLengthPadding"), C.seq(C.u8("byte"), C.offset(C.u32(), -8), "bytes")]),
                        a = Ke.chunkSize;
                    let c = 0,
                        u = i,
                        l = [];
                    while (u.length > 0) {
                        const i = u.slice(0, a),
                            d = r.Buffer.alloc(a + 16);
                        s.encode({
                            instruction: 0,
                            offset: c,
                            bytes: i,
                            bytesLength: 0,
                            bytesLengthPadding: 0
                        }, d);
                        const h = (new he).add({
                            keys: [{
                                pubkey: n.publicKey,
                                isSigner: !0,
                                isWritable: !0
                            }],
                            programId: o,
                            data: d
                        });
                        if (l.push(Ie(e, h, [t, n], {
                                commitment: "confirmed"
                            })), e._rpcEndpoint.includes("solana.com")) {
                            const e = 4;
                            await Ae(1e3 / e)
                        }
                        c += a, u = u.slice(a)
                    }
                    await Promise.all(l); {
                        const i = C.struct([C.u32("instruction")]),
                            s = r.Buffer.alloc(i.span);
                        i.encode({
                            instruction: 1
                        }, s);
                        const a = (new he).add({
                            keys: [{
                                pubkey: n.publicKey,
                                isSigner: !0,
                                isWritable: !0
                            }, {
                                pubkey: we,
                                isSigner: !1,
                                isWritable: !1
                            }],
                            programId: o,
                            data: s
                        });
                        await Ie(e, a, [t, n], {
                            commitment: "confirmed"
                        })
                    }
                    return !0
                }
            }
            Ke.chunkSize = Me;
            const Ue = new U("BPFLoader2111111111111111111111111111111111");
            class ze {
                static getMinNumSignatures(e) {
                    return Ke.getMinNumSignatures(e)
                }
                static load(e, t, n, r, o) {
                    return Ke.load(e, t, n, o, r)
                }
            }
            var De = Object.prototype.toString,
                He = Object.keys || function(e) {
                    var t = [];
                    for (var n in e) t.push(n);
                    return t
                };

            function qe(e, t) {
                var n, r, o, i, s, a, c;
                if (!0 === e) return "true";
                if (!1 === e) return "false";
                switch (typeof e) {
                    case "object":
                        if (null === e) return null;
                        if (e.toJSON && "function" === typeof e.toJSON) return qe(e.toJSON(), t);
                        if (c = De.call(e), "[object Array]" === c) {
                            for (o = "[", r = e.length - 1, n = 0; n < r; n++) o += qe(e[n], !0) + ",";
                            return r > -1 && (o += qe(e[n], !0)), o + "]"
                        }
                        if ("[object Object]" === c) {
                            i = He(e).sort(), r = i.length, o = "", n = 0;
                            while (n < r) s = i[n], a = qe(e[s], !1), void 0 !== a && (o && (o += ","), o += JSON.stringify(s) + ":" + a), n++;
                            return "{" + o + "}"
                        }
                        return JSON.stringify(e);
                    case "function":
                    case "undefined":
                        return t ? null : void 0;
                    case "string":
                        return JSON.stringify(e);
                    default:
                        return isFinite(e) ? e : null
                }
            }
            var $e = function(e) {
                    var t = qe(e, !1);
                    if (void 0 !== t) return "" + t
                },
                Ve = $e;
            const Fe = 32;

            function Ge(e) {
                let t = 0;
                while (e > 1) e /= 2, t++;
                return t
            }

            function Ye(e) {
                return 0 === e ? 1 : (e--, e |= e >> 1, e |= e >> 2, e |= e >> 4, e |= e >> 8, e |= e >> 16, e |= e >> 32, e + 1)
            }
            class Je {
                constructor(e, t, n, r, o) {
                    this.slotsPerEpoch = void 0, this.leaderScheduleSlotOffset = void 0, this.warmup = void 0, this.firstNormalEpoch = void 0, this.firstNormalSlot = void 0, this.slotsPerEpoch = e, this.leaderScheduleSlotOffset = t, this.warmup = n, this.firstNormalEpoch = r, this.firstNormalSlot = o
                }
                getEpoch(e) {
                    return this.getEpochAndSlotIndex(e)[0]
                }
                getEpochAndSlotIndex(e) {
                    if (e < this.firstNormalSlot) {
                        const t = Ge(Ye(e + Fe + 1)) - Ge(Fe) - 1,
                            n = this.getSlotsInEpoch(t),
                            r = e - (n - Fe);
                        return [t, r]
                    } {
                        const t = e - this.firstNormalSlot,
                            n = Math.floor(t / this.slotsPerEpoch),
                            r = this.firstNormalEpoch + n,
                            o = t % this.slotsPerEpoch;
                        return [r, o]
                    }
                }
                getFirstSlotInEpoch(e) {
                    return e <= this.firstNormalEpoch ? (Math.pow(2, e) - 1) * Fe : (e - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot
                }
                getLastSlotInEpoch(e) {
                    return this.getFirstSlotInEpoch(e) + this.getSlotsInEpoch(e) - 1
                }
                getSlotsInEpoch(e) {
                    return e < this.firstNormalEpoch ? Math.pow(2, e + Ge(Fe)) : this.slotsPerEpoch
                }
            }
            class Ze extends Error {
                constructor(e, t) {
                    super(e), this.logs = void 0, this.logs = t
                }
            }
            const Xe = {
                JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
                JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
                JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
                JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
                JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
                JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
                JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
                JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
                JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
                JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
                JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
                JSON_RPC_SCAN_ERROR: -32012,
                JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
                JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
                JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
                JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016
            };
            class Qe extends Error {
                constructor({
                    code: e,
                    message: t,
                    data: n
                }, r) {
                    super(null != r ? `${r}: ${t}` : t), this.code = void 0, this.data = void 0, this.code = e, this.data = n, this.name = "SolanaJSONRPCError"
                }
            }
            var et = globalThis.fetch;
            const tt = 160,
                nt = 64,
                rt = tt / nt,
                ot = 1e3 / rt;

            function it(e, t) {
                let n;
                try {
                    n = e.layout.decode(t)
                } catch (r) {
                    throw new Error("invalid instruction; " + r)
                }
                if (n.typeIndex !== e.index) throw new Error(`invalid account data; account type mismatch ${n.typeIndex} != ${e.index}`);
                return n
            }
            const st = 56;
            class at {
                constructor(e) {
                    this.key = void 0, this.state = void 0, this.key = e.key, this.state = e.state
                }
                isActive() {
                    const e = BigInt("0xffffffffffffffff");
                    return this.state.deactivationSlot === e
                }
                static deserialize(e) {
                    const t = it(ct, e),
                        n = e.length - st;
                    ie(n >= 0, "lookup table is invalid"), ie(n % 32 === 0, "lookup table is invalid");
                    const r = n / 32,
                        {
                            addresses: o
                        } = C.struct([C.seq(Y(), r, "addresses")]).decode(e.slice(st));
                    return {
                        deactivationSlot: t.deactivationSlot,
                        lastExtendedSlot: t.lastExtendedSlot,
                        lastExtendedSlotStartIndex: t.lastExtendedStartIndex,
                        authority: 0 !== t.authority.length ? new U(t.authority[0]) : void 0,
                        addresses: o.map(e => new U(e))
                    }
                }
            }
            const ct = {
                    index: 1,
                    layout: C.struct([C.u32("typeIndex"), Be("deactivationSlot"), C.nu64("lastExtendedSlot"), C.u8("lastExtendedStartIndex"), C.u8(), C.seq(Y(), C.offset(C.u8(), -1), "authority")])
                },
                ut = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;

            function lt(e) {
                const t = e.match(ut);
                if (null == t) throw TypeError(`Failed to validate endpoint URL \`${e}\``);
                const [n, r, o, i] = t, s = e.startsWith("https:") ? "wss:" : "ws:", a = null == o ? null : parseInt(o.slice(1), 10), c = null == a ? "" : ":" + (a + 1);
                return `${s}//${r}${c}${i}`
            }
            var dt;
            const ht = h.coerce(h.instance(U), h.string(), e => new U(e)),
                pt = h.tuple([h.string(), h.literal("base64")]),
                gt = h.coerce(h.instance(r.Buffer), pt, e => r.Buffer.from(e[0], "base64")),
                ft = 3e4;

            function bt(e) {
                if (!1 === /^https?:/.test(e)) throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
                return e
            }

            function yt(e) {
                let t, n;
                if ("string" === typeof e) t = e;
                else if (e) {
                    const {
                        commitment: r,
                        ...o
                    } = e;
                    t = r, n = o
                }
                return {
                    commitment: t,
                    config: n
                }
            }

            function mt(e) {
                return h.union([h.type({
                    jsonrpc: h.literal("2.0"),
                    id: h.string(),
                    result: e
                }), h.type({
                    jsonrpc: h.literal("2.0"),
                    id: h.string(),
                    error: h.type({
                        code: h.unknown(),
                        message: h.string(),
                        data: h.optional(h.any())
                    })
                })])
            }
            const wt = mt(h.unknown());

            function kt(e) {
                return h.coerce(mt(e), wt, t => "error" in t ? t : { ...t,
                    result: h.create(t.result, e)
                })
            }

            function vt(e) {
                return kt(h.type({
                    context: h.type({
                        slot: h.number()
                    }),
                    value: e
                }))
            }

            function St(e) {
                return h.type({
                    context: h.type({
                        slot: h.number()
                    }),
                    value: e
                })
            }

            function Ct(e, t) {
                return 0 === e ? new ce({
                    header: t.header,
                    staticAccountKeys: t.accountKeys.map(e => new U(e)),
                    recentBlockhash: t.recentBlockhash,
                    compiledInstructions: t.instructions.map(e => ({
                        programIdIndex: e.programIdIndex,
                        accountKeyIndexes: e.accounts,
                        data: S["default"].decode(e.data)
                    })),
                    addressTableLookups: t.addressTableLookups
                }) : new ae(t)
            }
            const It = h.type({
                    foundation: h.number(),
                    foundationTerm: h.number(),
                    initial: h.number(),
                    taper: h.number(),
                    terminal: h.number()
                }),
                At = kt(h.array(h.nullable(h.type({
                    epoch: h.number(),
                    effectiveSlot: h.number(),
                    amount: h.number(),
                    postBalance: h.number()
                })))),
                Ot = h.type({
                    epoch: h.number(),
                    slotIndex: h.number(),
                    slotsInEpoch: h.number(),
                    absoluteSlot: h.number(),
                    blockHeight: h.optional(h.number()),
                    transactionCount: h.optional(h.number())
                }),
                xt = h.type({
                    slotsPerEpoch: h.number(),
                    leaderScheduleSlotOffset: h.number(),
                    warmup: h.boolean(),
                    firstNormalEpoch: h.number(),
                    firstNormalSlot: h.number()
                }),
                _t = h.record(h.string(), h.array(h.number())),
                Et = h.nullable(h.union([h.type({}), h.string()])),
                Tt = h.type({
                    err: Et
                }),
                Pt = h.literal("receivedSignature"),
                Rt = h.type({
                    "solana-core": h.string(),
                    "feature-set": h.optional(h.number())
                }),
                jt = vt(h.type({
                    err: h.nullable(h.union([h.type({}), h.string()])),
                    logs: h.nullable(h.array(h.string())),
                    accounts: h.optional(h.nullable(h.array(h.nullable(h.type({
                        executable: h.boolean(),
                        owner: h.string(),
                        lamports: h.number(),
                        data: h.array(h.string()),
                        rentEpoch: h.optional(h.number())
                    }))))),
                    unitsConsumed: h.optional(h.number()),
                    returnData: h.optional(h.nullable(h.type({
                        programId: h.string(),
                        data: h.tuple([h.string(), h.literal("base64")])
                    })))
                })),
                Bt = vt(h.type({
                    byIdentity: h.record(h.string(), h.array(h.number())),
                    range: h.type({
                        firstSlot: h.number(),
                        lastSlot: h.number()
                    })
                }));

            function Lt(e, t, n, r, o) {
                const i = n || et;
                let s;
                r && (s = async (e, t) => {
                    const n = await new Promise((n, o) => {
                        try {
                            r(e, t, (e, t) => n([e, t]))
                        } catch (i) {
                            o(i)
                        }
                    });
                    return await i(...n)
                });
                const a = new I["default"](async (n, r) => {
                    const a = void 0,
                        c = {
                            method: "POST",
                            body: n,
                            agent: a,
                            headers: Object.assign({
                                "Content-Type": "application/json"
                            }, t || {}, Yn)
                        };
                    try {
                        let t, n = 5,
                            a = 500;
                        for (;;) {
                            if (t = s ? await s(e, c) : await i(e, c), 429 !== t.status) break;
                            if (!0 === o) break;
                            if (n -= 1, 0 === n) break;
                            console.log(`Server responded with ${t.status} ${t.statusText}.  Retrying after ${a}ms delay...`), await Ae(a), a *= 2
                        }
                        const u = await t.text();
                        t.ok ? r(null, u) : r(new Error(`${t.status} ${t.statusText}: ${u}`))
                    } catch (u) {
                        u instanceof Error && r(u)
                    }
                }, {});
                return a
            }

            function Wt(e) {
                return (t, n) => new Promise((r, o) => {
                    e.request(t, n, (e, t) => {
                        e ? o(e) : r(t)
                    })
                })
            }

            function Nt(e) {
                return t => new Promise((n, r) => {
                    0 === t.length && n([]);
                    const o = t.map(t => e.request(t.methodName, t.args));
                    e.request(o, (e, t) => {
                        e ? r(e) : n(t)
                    })
                })
            }
            const Mt = kt(It),
                Kt = kt(Ot),
                Ut = kt(xt),
                zt = kt(_t),
                Dt = kt(h.number()),
                Ht = vt(h.type({
                    total: h.number(),
                    circulating: h.number(),
                    nonCirculating: h.number(),
                    nonCirculatingAccounts: h.array(ht)
                })),
                qt = h.type({
                    amount: h.string(),
                    uiAmount: h.nullable(h.number()),
                    decimals: h.number(),
                    uiAmountString: h.optional(h.string())
                }),
                $t = vt(h.array(h.type({
                    address: ht,
                    amount: h.string(),
                    uiAmount: h.nullable(h.number()),
                    decimals: h.number(),
                    uiAmountString: h.optional(h.string())
                }))),
                Vt = vt(h.array(h.type({
                    pubkey: ht,
                    account: h.type({
                        executable: h.boolean(),
                        owner: ht,
                        lamports: h.number(),
                        data: gt,
                        rentEpoch: h.number()
                    })
                }))),
                Ft = h.type({
                    program: h.string(),
                    parsed: h.unknown(),
                    space: h.number()
                }),
                Gt = vt(h.array(h.type({
                    pubkey: ht,
                    account: h.type({
                        executable: h.boolean(),
                        owner: ht,
                        lamports: h.number(),
                        data: Ft,
                        rentEpoch: h.number()
                    })
                }))),
                Yt = vt(h.array(h.type({
                    lamports: h.number(),
                    address: ht
                }))),
                Jt = h.type({
                    executable: h.boolean(),
                    owner: ht,
                    lamports: h.number(),
                    data: gt,
                    rentEpoch: h.number()
                }),
                Zt = h.type({
                    pubkey: ht,
                    account: Jt
                }),
                Xt = h.coerce(h.union([h.instance(r.Buffer), Ft]), h.union([pt, Ft]), e => Array.isArray(e) ? h.create(e, gt) : e),
                Qt = h.type({
                    executable: h.boolean(),
                    owner: ht,
                    lamports: h.number(),
                    data: Xt,
                    rentEpoch: h.number()
                }),
                en = h.type({
                    pubkey: ht,
                    account: Qt
                }),
                tn = h.type({
                    state: h.union([h.literal("active"), h.literal("inactive"), h.literal("activating"), h.literal("deactivating")]),
                    active: h.number(),
                    inactive: h.number()
                }),
                nn = kt(h.array(h.type({
                    signature: h.string(),
                    slot: h.number(),
                    err: Et,
                    memo: h.nullable(h.string()),
                    blockTime: h.optional(h.nullable(h.number()))
                }))),
                rn = kt(h.array(h.type({
                    signature: h.string(),
                    slot: h.number(),
                    err: Et,
                    memo: h.nullable(h.string()),
                    blockTime: h.optional(h.nullable(h.number()))
                }))),
                on = h.type({
                    subscription: h.number(),
                    result: St(Jt)
                }),
                sn = h.type({
                    pubkey: ht,
                    account: Jt
                }),
                an = h.type({
                    subscription: h.number(),
                    result: St(sn)
                }),
                cn = h.type({
                    parent: h.number(),
                    slot: h.number(),
                    root: h.number()
                }),
                un = h.type({
                    subscription: h.number(),
                    result: cn
                }),
                ln = h.union([h.type({
                    type: h.union([h.literal("firstShredReceived"), h.literal("completed"), h.literal("optimisticConfirmation"), h.literal("root")]),
                    slot: h.number(),
                    timestamp: h.number()
                }), h.type({
                    type: h.literal("createdBank"),
                    parent: h.number(),
                    slot: h.number(),
                    timestamp: h.number()
                }), h.type({
                    type: h.literal("frozen"),
                    slot: h.number(),
                    timestamp: h.number(),
                    stats: h.type({
                        numTransactionEntries: h.number(),
                        numSuccessfulTransactions: h.number(),
                        numFailedTransactions: h.number(),
                        maxTransactionsPerEntry: h.number()
                    })
                }), h.type({
                    type: h.literal("dead"),
                    slot: h.number(),
                    timestamp: h.number(),
                    err: h.string()
                })]),
                dn = h.type({
                    subscription: h.number(),
                    result: ln
                }),
                hn = h.type({
                    subscription: h.number(),
                    result: St(h.union([Tt, Pt]))
                }),
                pn = h.type({
                    subscription: h.number(),
                    result: h.number()
                }),
                gn = h.type({
                    pubkey: h.string(),
                    gossip: h.nullable(h.string()),
                    tpu: h.nullable(h.string()),
                    rpc: h.nullable(h.string()),
                    version: h.nullable(h.string())
                }),
                fn = h.type({
                    votePubkey: h.string(),
                    nodePubkey: h.string(),
                    activatedStake: h.number(),
                    epochVoteAccount: h.boolean(),
                    epochCredits: h.array(h.tuple([h.number(), h.number(), h.number()])),
                    commission: h.number(),
                    lastVote: h.number(),
                    rootSlot: h.nullable(h.number())
                }),
                bn = kt(h.type({
                    current: h.array(fn),
                    delinquent: h.array(fn)
                })),
                yn = h.union([h.literal("processed"), h.literal("confirmed"), h.literal("finalized")]),
                mn = h.type({
                    slot: h.number(),
                    confirmations: h.nullable(h.number()),
                    err: Et,
                    confirmationStatus: h.optional(yn)
                }),
                wn = vt(h.array(h.nullable(mn))),
                kn = kt(h.number()),
                vn = h.type({
                    accountKey: ht,
                    writableIndexes: h.array(h.number()),
                    readonlyIndexes: h.array(h.number())
                }),
                Sn = h.type({
                    signatures: h.array(h.string()),
                    message: h.type({
                        accountKeys: h.array(h.string()),
                        header: h.type({
                            numRequiredSignatures: h.number(),
                            numReadonlySignedAccounts: h.number(),
                            numReadonlyUnsignedAccounts: h.number()
                        }),
                        instructions: h.array(h.type({
                            accounts: h.array(h.number()),
                            data: h.string(),
                            programIdIndex: h.number()
                        })),
                        recentBlockhash: h.string(),
                        addressTableLookups: h.optional(h.array(vn))
                    })
                }),
                Cn = h.type({
                    parsed: h.unknown(),
                    program: h.string(),
                    programId: ht
                }),
                In = h.type({
                    accounts: h.array(ht),
                    data: h.string(),
                    programId: ht
                }),
                An = h.union([In, Cn]),
                On = h.union([h.type({
                    parsed: h.unknown(),
                    program: h.string(),
                    programId: h.string()
                }), h.type({
                    accounts: h.array(h.string()),
                    data: h.string(),
                    programId: h.string()
                })]),
                xn = h.coerce(An, On, e => "accounts" in e ? h.create(e, In) : h.create(e, Cn)),
                _n = h.type({
                    signatures: h.array(h.string()),
                    message: h.type({
                        accountKeys: h.array(h.type({
                            pubkey: ht,
                            signer: h.boolean(),
                            writable: h.boolean(),
                            source: h.optional(h.union([h.literal("transaction"), h.literal("lookupTable")]))
                        })),
                        instructions: h.array(xn),
                        recentBlockhash: h.string(),
                        addressTableLookups: h.optional(h.nullable(h.array(vn)))
                    })
                }),
                En = h.type({
                    accountIndex: h.number(),
                    mint: h.string(),
                    owner: h.optional(h.string()),
                    uiTokenAmount: qt
                }),
                Tn = h.type({
                    writable: h.array(ht),
                    readonly: h.array(ht)
                }),
                Pn = h.type({
                    err: Et,
                    fee: h.number(),
                    innerInstructions: h.optional(h.nullable(h.array(h.type({
                        index: h.number(),
                        instructions: h.array(h.type({
                            accounts: h.array(h.number()),
                            data: h.string(),
                            programIdIndex: h.number()
                        }))
                    })))),
                    preBalances: h.array(h.number()),
                    postBalances: h.array(h.number()),
                    logMessages: h.optional(h.nullable(h.array(h.string()))),
                    preTokenBalances: h.optional(h.nullable(h.array(En))),
                    postTokenBalances: h.optional(h.nullable(h.array(En))),
                    loadedAddresses: h.optional(Tn),
                    computeUnitsConsumed: h.optional(h.number())
                }),
                Rn = h.type({
                    err: Et,
                    fee: h.number(),
                    innerInstructions: h.optional(h.nullable(h.array(h.type({
                        index: h.number(),
                        instructions: h.array(xn)
                    })))),
                    preBalances: h.array(h.number()),
                    postBalances: h.array(h.number()),
                    logMessages: h.optional(h.nullable(h.array(h.string()))),
                    preTokenBalances: h.optional(h.nullable(h.array(En))),
                    postTokenBalances: h.optional(h.nullable(h.array(En))),
                    loadedAddresses: h.optional(Tn),
                    computeUnitsConsumed: h.optional(h.number())
                }),
                jn = h.union([h.literal(0), h.literal("legacy")]),
                Bn = kt(h.nullable(h.type({
                    blockhash: h.string(),
                    previousBlockhash: h.string(),
                    parentSlot: h.number(),
                    transactions: h.array(h.type({
                        transaction: Sn,
                        meta: h.nullable(Pn),
                        version: h.optional(jn)
                    })),
                    rewards: h.optional(h.array(h.type({
                        pubkey: h.string(),
                        lamports: h.number(),
                        postBalance: h.nullable(h.number()),
                        rewardType: h.nullable(h.string())
                    }))),
                    blockTime: h.nullable(h.number()),
                    blockHeight: h.nullable(h.number())
                }))),
                Ln = kt(h.nullable(h.type({
                    blockhash: h.string(),
                    previousBlockhash: h.string(),
                    parentSlot: h.number(),
                    transactions: h.array(h.type({
                        transaction: _n,
                        meta: h.nullable(Rn),
                        version: h.optional(jn)
                    })),
                    rewards: h.optional(h.array(h.type({
                        pubkey: h.string(),
                        lamports: h.number(),
                        postBalance: h.nullable(h.number()),
                        rewardType: h.nullable(h.string())
                    }))),
                    blockTime: h.nullable(h.number()),
                    blockHeight: h.nullable(h.number())
                }))),
                Wn = kt(h.nullable(h.type({
                    blockhash: h.string(),
                    previousBlockhash: h.string(),
                    parentSlot: h.number(),
                    transactions: h.array(h.type({
                        transaction: Sn,
                        meta: h.nullable(Pn)
                    })),
                    rewards: h.optional(h.array(h.type({
                        pubkey: h.string(),
                        lamports: h.number(),
                        postBalance: h.nullable(h.number()),
                        rewardType: h.nullable(h.string())
                    }))),
                    blockTime: h.nullable(h.number())
                }))),
                Nn = kt(h.nullable(h.type({
                    blockhash: h.string(),
                    previousBlockhash: h.string(),
                    parentSlot: h.number(),
                    signatures: h.array(h.string()),
                    blockTime: h.nullable(h.number())
                }))),
                Mn = kt(h.nullable(h.type({
                    slot: h.number(),
                    meta: Pn,
                    blockTime: h.optional(h.nullable(h.number())),
                    transaction: Sn,
                    version: h.optional(jn)
                }))),
                Kn = kt(h.nullable(h.type({
                    slot: h.number(),
                    transaction: _n,
                    meta: h.nullable(Rn),
                    blockTime: h.optional(h.nullable(h.number())),
                    version: h.optional(jn)
                }))),
                Un = vt(h.type({
                    blockhash: h.string(),
                    feeCalculator: h.type({
                        lamportsPerSignature: h.number()
                    })
                })),
                zn = vt(h.type({
                    blockhash: h.string(),
                    lastValidBlockHeight: h.number()
                })),
                Dn = h.type({
                    slot: h.number(),
                    numTransactions: h.number(),
                    numSlots: h.number(),
                    samplePeriodSecs: h.number()
                }),
                Hn = kt(h.array(Dn)),
                qn = vt(h.nullable(h.type({
                    feeCalculator: h.type({
                        lamportsPerSignature: h.number()
                    })
                }))),
                $n = kt(h.string()),
                Vn = kt(h.string()),
                Fn = h.type({
                    err: Et,
                    logs: h.array(h.string()),
                    signature: h.string()
                }),
                Gn = h.type({
                    result: St(Fn),
                    subscription: h.number()
                }),
                Yn = {
                    "solana-client": "js/" + (null !== (dt = "0.0.0-development") && void 0 !== dt ? dt : "UNKNOWN")
                };
            class Jn {
                constructor(e, t) {
                    let n, r, o, i, s;
                    this._commitment = void 0, this._confirmTransactionInitialTimeout = void 0, this._rpcEndpoint = void 0, this._rpcWsEndpoint = void 0, this._rpcClient = void 0, this._rpcRequest = void 0, this._rpcBatchRequest = void 0, this._rpcWebSocket = void 0, this._rpcWebSocketConnected = !1, this._rpcWebSocketHeartbeat = null, this._rpcWebSocketIdleTimeout = null, this._rpcWebSocketGeneration = 0, this._disableBlockhashCaching = !1, this._pollingBlockhash = !1, this._blockhashInfo = {
                        latestBlockhash: null,
                        lastFetch: 0,
                        transactionSignatures: [],
                        simulatedSignatures: []
                    }, this._nextClientSubscriptionId = 0, this._subscriptionDisposeFunctionsByClientSubscriptionId = {}, this._subscriptionCallbacksByServerSubscriptionId = {}, this._subscriptionsByHash = {}, this._subscriptionsAutoDisposedByRpc = new Set, t && "string" === typeof t ? this._commitment = t : t && (this._commitment = t.commitment, this._confirmTransactionInitialTimeout = t.confirmTransactionInitialTimeout, n = t.wsEndpoint, r = t.httpHeaders, o = t.fetch, i = t.fetchMiddleware, s = t.disableRetryOnRateLimit), this._rpcEndpoint = bt(e), this._rpcWsEndpoint = n || lt(e), this._rpcClient = Lt(e, r, o, i, s), this._rpcRequest = Wt(this._rpcClient), this._rpcBatchRequest = Nt(this._rpcClient), this._rpcWebSocket = new p.Client(this._rpcWsEndpoint, {
                        autoconnect: !1,
                        max_reconnects: 1 / 0
                    }), this._rpcWebSocket.on("open", this._wsOnOpen.bind(this)), this._rpcWebSocket.on("error", this._wsOnError.bind(this)), this._rpcWebSocket.on("close", this._wsOnClose.bind(this)), this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this)), this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this)), this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this)), this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this)), this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this)), this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this)), this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this))
                }
                get commitment() {
                    return this._commitment
                }
                get rpcEndpoint() {
                    return this._rpcEndpoint
                }
                async getBalanceAndContext(e, t) {
                    const {
                        commitment: n,
                        config: r
                    } = yt(t), o = this._buildArgs([e.toBase58()], n, void 0, r), i = await this._rpcRequest("getBalance", o), s = h.create(i, vt(h.number()));
                    if ("error" in s) throw new Qe(s.error, "failed to get balance for " + e.toBase58());
                    return s.result
                }
                async getBalance(e, t) {
                    return await this.getBalanceAndContext(e, t).then(e => e.value).catch(t => {
                        throw new Error("failed to get balance of account " + e.toBase58() + ": " + t)
                    })
                }
                async getBlockTime(e) {
                    const t = await this._rpcRequest("getBlockTime", [e]),
                        n = h.create(t, kt(h.nullable(h.number())));
                    if ("error" in n) throw new Qe(n.error, "failed to get block time for slot " + e);
                    return n.result
                }
                async getMinimumLedgerSlot() {
                    const e = await this._rpcRequest("minimumLedgerSlot", []),
                        t = h.create(e, kt(h.number()));
                    if ("error" in t) throw new Qe(t.error, "failed to get minimum ledger slot");
                    return t.result
                }
                async getFirstAvailableBlock() {
                    const e = await this._rpcRequest("getFirstAvailableBlock", []),
                        t = h.create(e, Dt);
                    if ("error" in t) throw new Qe(t.error, "failed to get first available block");
                    return t.result
                }
                async getSupply(e) {
                    let t = {};
                    t = "string" === typeof e ? {
                        commitment: e
                    } : e ? { ...e,
                        commitment: e && e.commitment || this.commitment
                    } : {
                        commitment: this.commitment
                    };
                    const n = await this._rpcRequest("getSupply", [t]),
                        r = h.create(n, Ht);
                    if ("error" in r) throw new Qe(r.error, "failed to get supply");
                    return r.result
                }
                async getTokenSupply(e, t) {
                    const n = this._buildArgs([e.toBase58()], t),
                        r = await this._rpcRequest("getTokenSupply", n),
                        o = h.create(r, vt(qt));
                    if ("error" in o) throw new Qe(o.error, "failed to get token supply");
                    return o.result
                }
                async getTokenAccountBalance(e, t) {
                    const n = this._buildArgs([e.toBase58()], t),
                        r = await this._rpcRequest("getTokenAccountBalance", n),
                        o = h.create(r, vt(qt));
                    if ("error" in o) throw new Qe(o.error, "failed to get token account balance");
                    return o.result
                }
                async getTokenAccountsByOwner(e, t, n) {
                    const {
                        commitment: r,
                        config: o
                    } = yt(n);
                    let i = [e.toBase58()];
                    "mint" in t ? i.push({
                        mint: t.mint.toBase58()
                    }) : i.push({
                        programId: t.programId.toBase58()
                    });
                    const s = this._buildArgs(i, r, "base64", o),
                        a = await this._rpcRequest("getTokenAccountsByOwner", s),
                        c = h.create(a, Vt);
                    if ("error" in c) throw new Qe(c.error, "failed to get token accounts owned by account " + e.toBase58());
                    return c.result
                }
                async getParsedTokenAccountsByOwner(e, t, n) {
                    let r = [e.toBase58()];
                    "mint" in t ? r.push({
                        mint: t.mint.toBase58()
                    }) : r.push({
                        programId: t.programId.toBase58()
                    });
                    const o = this._buildArgs(r, n, "jsonParsed"),
                        i = await this._rpcRequest("getTokenAccountsByOwner", o),
                        s = h.create(i, Gt);
                    if ("error" in s) throw new Qe(s.error, "failed to get token accounts owned by account " + e.toBase58());
                    return s.result
                }
                async getLargestAccounts(e) {
                    const t = { ...e,
                            commitment: e && e.commitment || this.commitment
                        },
                        n = t.filter || t.commitment ? [t] : [],
                        r = await this._rpcRequest("getLargestAccounts", n),
                        o = h.create(r, Yt);
                    if ("error" in o) throw new Qe(o.error, "failed to get largest accounts");
                    return o.result
                }
                async getTokenLargestAccounts(e, t) {
                    const n = this._buildArgs([e.toBase58()], t),
                        r = await this._rpcRequest("getTokenLargestAccounts", n),
                        o = h.create(r, $t);
                    if ("error" in o) throw new Qe(o.error, "failed to get token largest accounts");
                    return o.result
                }
                async getAccountInfoAndContext(e, t) {
                    const {
                        commitment: n,
                        config: r
                    } = yt(t), o = this._buildArgs([e.toBase58()], n, "base64", r), i = await this._rpcRequest("getAccountInfo", o), s = h.create(i, vt(h.nullable(Jt)));
                    if ("error" in s) throw new Qe(s.error, "failed to get info about account " + e.toBase58());
                    return s.result
                }
                async getParsedAccountInfo(e, t) {
                    const {
                        commitment: n,
                        config: r
                    } = yt(t), o = this._buildArgs([e.toBase58()], n, "jsonParsed", r), i = await this._rpcRequest("getAccountInfo", o), s = h.create(i, vt(h.nullable(Qt)));
                    if ("error" in s) throw new Qe(s.error, "failed to get info about account " + e.toBase58());
                    return s.result
                }
                async getAccountInfo(e, t) {
                    try {
                        const n = await this.getAccountInfoAndContext(e, t);
                        return n.value
                    } catch (n) {
                        throw new Error("failed to get info about account " + e.toBase58() + ": " + n)
                    }
                }
                async getMultipleParsedAccounts(e, t) {
                    const {
                        commitment: n,
                        config: r
                    } = yt(t), o = e.map(e => e.toBase58()), i = this._buildArgs([o], n, "jsonParsed", r), s = await this._rpcRequest("getMultipleAccounts", i), a = h.create(s, vt(h.array(h.nullable(Qt))));
                    if ("error" in a) throw new Qe(a.error, "failed to get info for accounts " + o);
                    return a.result
                }
                async getMultipleAccountsInfoAndContext(e, t) {
                    const {
                        commitment: n,
                        config: r
                    } = yt(t), o = e.map(e => e.toBase58()), i = this._buildArgs([o], n, "base64", r), s = await this._rpcRequest("getMultipleAccounts", i), a = h.create(s, vt(h.array(h.nullable(Jt))));
                    if ("error" in a) throw new Qe(a.error, "failed to get info for accounts " + o);
                    return a.result
                }
                async getMultipleAccountsInfo(e, t) {
                    const n = await this.getMultipleAccountsInfoAndContext(e, t);
                    return n.value
                }
                async getStakeActivation(e, t, n) {
                    const {
                        commitment: r,
                        config: o
                    } = yt(t), i = this._buildArgs([e.toBase58()], r, void 0, { ...o,
                        epoch: null != n ? n : null === o || void 0 === o ? void 0 : o.epoch
                    }), s = await this._rpcRequest("getStakeActivation", i), a = h.create(s, kt(tn));
                    if ("error" in a) throw new Qe(a.error, "failed to get Stake Activation " + e.toBase58());
                    return a.result
                }
                async getProgramAccounts(e, t) {
                    const {
                        commitment: n,
                        config: r
                    } = yt(t), {
                        encoding: o,
                        ...i
                    } = r || {}, s = this._buildArgs([e.toBase58()], n, o || "base64", i), a = await this._rpcRequest("getProgramAccounts", s), c = h.create(a, kt(h.array(Zt)));
                    if ("error" in c) throw new Qe(c.error, "failed to get accounts owned by program " + e.toBase58());
                    return c.result
                }
                async getParsedProgramAccounts(e, t) {
                    const {
                        commitment: n,
                        config: r
                    } = yt(t), o = this._buildArgs([e.toBase58()], n, "jsonParsed", r), i = await this._rpcRequest("getProgramAccounts", o), s = h.create(i, kt(h.array(en)));
                    if ("error" in s) throw new Qe(s.error, "failed to get accounts owned by program " + e.toBase58());
                    return s.result
                }
                async confirmTransaction(e, n) {
                    let r, o;
                    if ("string" == typeof e) r = e;
                    else {
                        const t = e;
                        r = t.signature
                    }
                    try {
                        o = S["default"].decode(r)
                    } catch (h) {
                        throw new Error("signature must be base58 encoded: " + r)
                    }
                    ie(64 === o.length, "signature has invalid length");
                    const i = n || this.commitment;
                    let s, a, c = !1;
                    const u = new Promise((e, n) => {
                            try {
                                a = this.onSignature(r, (n, r) => {
                                    a = void 0;
                                    const o = {
                                        context: r,
                                        value: n
                                    };
                                    c = !0, e({
                                        __type: t.TransactionStatus.PROCESSED,
                                        response: o
                                    })
                                }, i)
                            } catch (h) {
                                n(h)
                            }
                        }),
                        l = new Promise(r => {
                            if ("string" === typeof e) {
                                let e = this._confirmTransactionInitialTimeout || 6e4;
                                switch (i) {
                                    case "processed":
                                    case "recent":
                                    case "single":
                                    case "confirmed":
                                    case "singleGossip":
                                        e = this._confirmTransactionInitialTimeout || 3e4;
                                        break
                                }
                                s = setTimeout(() => r({
                                    __type: t.TransactionStatus.TIMED_OUT,
                                    timeoutMs: e
                                }), e)
                            } else {
                                let o = e;
                                const i = async () => {
                                    try {
                                        const e = await this.getBlockHeight(n);
                                        return e
                                    } catch (e) {
                                        return -1
                                    }
                                };
                                (async () => {
                                    let e = await i();
                                    if (!c) {
                                        while (e <= o.lastValidBlockHeight) {
                                            if (await Ae(1e3), c) return;
                                            if (e = await i(), c) return
                                        }
                                        r({
                                            __type: t.TransactionStatus.BLOCKHEIGHT_EXCEEDED
                                        })
                                    }
                                })()
                            }
                        });
                    let d;
                    try {
                        const e = await Promise.race([u, l]);
                        switch (e.__type) {
                            case t.TransactionStatus.BLOCKHEIGHT_EXCEEDED:
                                throw new V(r);
                            case t.TransactionStatus.PROCESSED:
                                d = e.response;
                                break;
                            case t.TransactionStatus.TIMED_OUT:
                                throw new F(r, e.timeoutMs / 1e3)
                        }
                    } finally {
                        clearTimeout(s), a && this.removeSignatureListener(a)
                    }
                    return d
                }
                async getClusterNodes() {
                    const e = await this._rpcRequest("getClusterNodes", []),
                        t = h.create(e, kt(h.array(gn)));
                    if ("error" in t) throw new Qe(t.error, "failed to get cluster nodes");
                    return t.result
                }
                async getVoteAccounts(e) {
                    const t = this._buildArgs([], e),
                        n = await this._rpcRequest("getVoteAccounts", t),
                        r = h.create(n, bn);
                    if ("error" in r) throw new Qe(r.error, "failed to get vote accounts");
                    return r.result
                }
                async getSlot(e) {
                    const {
                        commitment: t,
                        config: n
                    } = yt(e), r = this._buildArgs([], t, void 0, n), o = await this._rpcRequest("getSlot", r), i = h.create(o, kt(h.number()));
                    if ("error" in i) throw new Qe(i.error, "failed to get slot");
                    return i.result
                }
                async getSlotLeader(e) {
                    const {
                        commitment: t,
                        config: n
                    } = yt(e), r = this._buildArgs([], t, void 0, n), o = await this._rpcRequest("getSlotLeader", r), i = h.create(o, kt(h.string()));
                    if ("error" in i) throw new Qe(i.error, "failed to get slot leader");
                    return i.result
                }
                async getSlotLeaders(e, t) {
                    const n = [e, t],
                        r = await this._rpcRequest("getSlotLeaders", n),
                        o = h.create(r, kt(h.array(ht)));
                    if ("error" in o) throw new Qe(o.error, "failed to get slot leaders");
                    return o.result
                }
                async getSignatureStatus(e, t) {
                    const {
                        context: n,
                        value: r
                    } = await this.getSignatureStatuses([e], t);
                    ie(1 === r.length);
                    const o = r[0];
                    return {
                        context: n,
                        value: o
                    }
                }
                async getSignatureStatuses(e, t) {
                    const n = [e];
                    t && n.push(t);
                    const r = await this._rpcRequest("getSignatureStatuses", n),
                        o = h.create(r, wn);
                    if ("error" in o) throw new Qe(o.error, "failed to get signature status");
                    return o.result
                }
                async getTransactionCount(e) {
                    const {
                        commitment: t,
                        config: n
                    } = yt(e), r = this._buildArgs([], t, void 0, n), o = await this._rpcRequest("getTransactionCount", r), i = h.create(o, kt(h.number()));
                    if ("error" in i) throw new Qe(i.error, "failed to get transaction count");
                    return i.result
                }
                async getTotalSupply(e) {
                    const t = await this.getSupply({
                        commitment: e,
                        excludeNonCirculatingAccountsList: !0
                    });
                    return t.value.total
                }
                async getInflationGovernor(e) {
                    const t = this._buildArgs([], e),
                        n = await this._rpcRequest("getInflationGovernor", t),
                        r = h.create(n, Mt);
                    if ("error" in r) throw new Qe(r.error, "failed to get inflation");
                    return r.result
                }
                async getInflationReward(e, t, n) {
                    const {
                        commitment: r,
                        config: o
                    } = yt(n), i = this._buildArgs([e.map(e => e.toBase58())], r, void 0, { ...o,
                        epoch: null != t ? t : null === o || void 0 === o ? void 0 : o.epoch
                    }), s = await this._rpcRequest("getInflationReward", i), a = h.create(s, At);
                    if ("error" in a) throw new Qe(a.error, "failed to get inflation reward");
                    return a.result
                }
                async getEpochInfo(e) {
                    const {
                        commitment: t,
                        config: n
                    } = yt(e), r = this._buildArgs([], t, void 0, n), o = await this._rpcRequest("getEpochInfo", r), i = h.create(o, Kt);
                    if ("error" in i) throw new Qe(i.error, "failed to get epoch info");
                    return i.result
                }
                async getEpochSchedule() {
                    const e = await this._rpcRequest("getEpochSchedule", []),
                        t = h.create(e, Ut);
                    if ("error" in t) throw new Qe(t.error, "failed to get epoch schedule");
                    const n = t.result;
                    return new Je(n.slotsPerEpoch, n.leaderScheduleSlotOffset, n.warmup, n.firstNormalEpoch, n.firstNormalSlot)
                }
                async getLeaderSchedule() {
                    const e = await this._rpcRequest("getLeaderSchedule", []),
                        t = h.create(e, zt);
                    if ("error" in t) throw new Qe(t.error, "failed to get leader schedule");
                    return t.result
                }
                async getMinimumBalanceForRentExemption(e, t) {
                    const n = this._buildArgs([e], t),
                        r = await this._rpcRequest("getMinimumBalanceForRentExemption", n),
                        o = h.create(r, kn);
                    return "error" in o ? (console.warn("Unable to fetch minimum balance for rent exemption"), 0) : o.result
                }
                async getRecentBlockhashAndContext(e) {
                    const t = this._buildArgs([], e),
                        n = await this._rpcRequest("getRecentBlockhash", t),
                        r = h.create(n, Un);
                    if ("error" in r) throw new Qe(r.error, "failed to get recent blockhash");
                    return r.result
                }
                async getRecentPerformanceSamples(e) {
                    const t = await this._rpcRequest("getRecentPerformanceSamples", e ? [e] : []),
                        n = h.create(t, Hn);
                    if ("error" in n) throw new Qe(n.error, "failed to get recent performance samples");
                    return n.result
                }
                async getFeeCalculatorForBlockhash(e, t) {
                    const n = this._buildArgs([e], t),
                        r = await this._rpcRequest("getFeeCalculatorForBlockhash", n),
                        o = h.create(r, qn);
                    if ("error" in o) throw new Qe(o.error, "failed to get fee calculator");
                    const {
                        context: i,
                        value: s
                    } = o.result;
                    return {
                        context: i,
                        value: null !== s ? s.feeCalculator : null
                    }
                }
                async getFeeForMessage(e, t) {
                    const n = e.serialize().toString("base64"),
                        r = this._buildArgs([n], t),
                        o = await this._rpcRequest("getFeeForMessage", r),
                        i = h.create(o, vt(h.nullable(h.number())));
                    if ("error" in i) throw new Qe(i.error, "failed to get fee for message");
                    if (null === i.result) throw new Error("invalid blockhash");
                    return i.result
                }
                async getRecentBlockhash(e) {
                    try {
                        const t = await this.getRecentBlockhashAndContext(e);
                        return t.value
                    } catch (t) {
                        throw new Error("failed to get recent blockhash: " + t)
                    }
                }
                async getLatestBlockhash(e) {
                    try {
                        const t = await this.getLatestBlockhashAndContext(e);
                        return t.value
                    } catch (t) {
                        throw new Error("failed to get recent blockhash: " + t)
                    }
                }
                async getLatestBlockhashAndContext(e) {
                    const {
                        commitment: t,
                        config: n
                    } = yt(e), r = this._buildArgs([], t, void 0, n), o = await this._rpcRequest("getLatestBlockhash", r), i = h.create(o, zn);
                    if ("error" in i) throw new Qe(i.error, "failed to get latest blockhash");
                    return i.result
                }
                async getVersion() {
                    const e = await this._rpcRequest("getVersion", []),
                        t = h.create(e, kt(Rt));
                    if ("error" in t) throw new Qe(t.error, "failed to get version");
                    return t.result
                }
                async getGenesisHash() {
                    const e = await this._rpcRequest("getGenesisHash", []),
                        t = h.create(e, kt(h.string()));
                    if ("error" in t) throw new Qe(t.error, "failed to get genesis hash");
                    return t.result
                }
                async getBlock(e, t) {
                    const {
                        commitment: n,
                        config: r
                    } = yt(t), o = this._buildArgsAtLeastConfirmed([e], n, void 0, r), i = await this._rpcRequest("getBlock", o), s = h.create(i, Bn);
                    if ("error" in s) throw new Qe(s.error, "failed to get confirmed block");
                    const a = s.result;
                    return a ? { ...a,
                        transactions: a.transactions.map(({
                            transaction: e,
                            meta: t,
                            version: n
                        }) => ({
                            meta: t,
                            transaction: { ...e,
                                message: Ct(n, e.message)
                            },
                            version: n
                        }))
                    } : a
                }
                async getParsedBlock(e, t) {
                    const {
                        commitment: n,
                        config: r
                    } = yt(t), o = this._buildArgsAtLeastConfirmed([e], n, "jsonParsed", r), i = await this._rpcRequest("getBlock", o), s = h.create(i, Ln);
                    if ("error" in s) throw new Qe(s.error, "failed to get block");
                    return s.result
                }
                async getBlockHeight(e) {
                    const {
                        commitment: t,
                        config: n
                    } = yt(e), r = this._buildArgs([], t, void 0, n), o = await this._rpcRequest("getBlockHeight", r), i = h.create(o, kt(h.number()));
                    if ("error" in i) throw new Qe(i.error, "failed to get block height information");
                    return i.result
                }
                async getBlockProduction(e) {
                    let t, n;
                    if ("string" === typeof e) n = e;
                    else if (e) {
                        const {
                            commitment: r,
                            ...o
                        } = e;
                        n = r, t = o
                    }
                    const r = this._buildArgs([], n, "base64", t),
                        o = await this._rpcRequest("getBlockProduction", r),
                        i = h.create(o, Bt);
                    if ("error" in i) throw new Qe(i.error, "failed to get block production information");
                    return i.result
                }
                async getTransaction(e, t) {
                    const {
                        commitment: n,
                        config: r
                    } = yt(t), o = this._buildArgsAtLeastConfirmed([e], n, void 0, r), i = await this._rpcRequest("getTransaction", o), s = h.create(i, Mn);
                    if ("error" in s) throw new Qe(s.error, "failed to get transaction");
                    const a = s.result;
                    return a ? { ...a,
                        transaction: { ...a.transaction,
                            message: Ct(a.version, a.transaction.message)
                        }
                    } : a
                }
                async getParsedTransaction(e, t) {
                    const {
                        commitment: n,
                        config: r
                    } = yt(t), o = this._buildArgsAtLeastConfirmed([e], n, "jsonParsed", r), i = await this._rpcRequest("getTransaction", o), s = h.create(i, Kn);
                    if ("error" in s) throw new Qe(s.error, "failed to get transaction");
                    return s.result
                }
                async getParsedTransactions(e, t) {
                    const {
                        commitment: n,
                        config: r
                    } = yt(t), o = e.map(e => {
                        const t = this._buildArgsAtLeastConfirmed([e], n, "jsonParsed", r);
                        return {
                            methodName: "getTransaction",
                            args: t
                        }
                    }), i = await this._rpcBatchRequest(o), s = i.map(e => {
                        const t = h.create(e, Kn);
                        if ("error" in t) throw new Qe(t.error, "failed to get transactions");
                        return t.result
                    });
                    return s
                }
                async getTransactions(e, t) {
                    const {
                        commitment: n,
                        config: r
                    } = yt(t), o = e.map(e => {
                        const t = this._buildArgsAtLeastConfirmed([e], n, void 0, r);
                        return {
                            methodName: "getTransaction",
                            args: t
                        }
                    }), i = await this._rpcBatchRequest(o), s = i.map(e => {
                        const t = h.create(e, Mn);
                        if ("error" in t) throw new Qe(t.error, "failed to get transactions");
                        const n = t.result;
                        return n ? { ...n,
                            transaction: { ...n.transaction,
                                message: Ct(n.version, n.transaction.message)
                            }
                        } : n
                    });
                    return s
                }
                async getConfirmedBlock(e, t) {
                    const n = this._buildArgsAtLeastConfirmed([e], t),
                        r = await this._rpcRequest("getConfirmedBlock", n),
                        o = h.create(r, Wn);
                    if ("error" in o) throw new Qe(o.error, "failed to get confirmed block");
                    const i = o.result;
                    if (!i) throw new Error("Confirmed block " + e + " not found");
                    const s = { ...i,
                        transactions: i.transactions.map(({
                            transaction: e,
                            meta: t
                        }) => {
                            const n = new ae(e.message);
                            return {
                                meta: t,
                                transaction: { ...e,
                                    message: n
                                }
                            }
                        })
                    };
                    return { ...s,
                        transactions: s.transactions.map(({
                            transaction: e,
                            meta: t
                        }) => ({
                            meta: t,
                            transaction: he.populate(e.message, e.signatures)
                        }))
                    }
                }
                async getBlocks(e, t, n) {
                    const r = this._buildArgsAtLeastConfirmed(void 0 !== t ? [e, t] : [e], n),
                        o = await this._rpcRequest("getBlocks", r),
                        i = h.create(o, kt(h.array(h.number())));
                    if ("error" in i) throw new Qe(i.error, "failed to get blocks");
                    return i.result
                }
                async getBlockSignatures(e, t) {
                    const n = this._buildArgsAtLeastConfirmed([e], t, void 0, {
                            transactionDetails: "signatures",
                            rewards: !1
                        }),
                        r = await this._rpcRequest("getBlock", n),
                        o = h.create(r, Nn);
                    if ("error" in o) throw new Qe(o.error, "failed to get block");
                    const i = o.result;
                    if (!i) throw new Error("Block " + e + " not found");
                    return i
                }
                async getConfirmedBlockSignatures(e, t) {
                    const n = this._buildArgsAtLeastConfirmed([e], t, void 0, {
                            transactionDetails: "signatures",
                            rewards: !1
                        }),
                        r = await this._rpcRequest("getConfirmedBlock", n),
                        o = h.create(r, Nn);
                    if ("error" in o) throw new Qe(o.error, "failed to get confirmed block");
                    const i = o.result;
                    if (!i) throw new Error("Confirmed block " + e + " not found");
                    return i
                }
                async getConfirmedTransaction(e, t) {
                    const n = this._buildArgsAtLeastConfirmed([e], t),
                        r = await this._rpcRequest("getConfirmedTransaction", n),
                        o = h.create(r, Mn);
                    if ("error" in o) throw new Qe(o.error, "failed to get transaction");
                    const i = o.result;
                    if (!i) return i;
                    const s = new ae(i.transaction.message),
                        a = i.transaction.signatures;
                    return { ...i,
                        transaction: he.populate(s, a)
                    }
                }
                async getParsedConfirmedTransaction(e, t) {
                    const n = this._buildArgsAtLeastConfirmed([e], t, "jsonParsed"),
                        r = await this._rpcRequest("getConfirmedTransaction", n),
                        o = h.create(r, Kn);
                    if ("error" in o) throw new Qe(o.error, "failed to get confirmed transaction");
                    return o.result
                }
                async getParsedConfirmedTransactions(e, t) {
                    const n = e.map(e => {
                            const n = this._buildArgsAtLeastConfirmed([e], t, "jsonParsed");
                            return {
                                methodName: "getConfirmedTransaction",
                                args: n
                            }
                        }),
                        r = await this._rpcBatchRequest(n),
                        o = r.map(e => {
                            const t = h.create(e, Kn);
                            if ("error" in t) throw new Qe(t.error, "failed to get confirmed transactions");
                            return t.result
                        });
                    return o
                }
                async getConfirmedSignaturesForAddress(e, t, n) {
                    let r = {},
                        o = await this.getFirstAvailableBlock();
                    while (!("until" in r)) {
                        if (t--, t <= 0 || t < o) break;
                        try {
                            const e = await this.getConfirmedBlockSignatures(t, "finalized");
                            e.signatures.length > 0 && (r.until = e.signatures[e.signatures.length - 1].toString())
                        } catch (a) {
                            if (a instanceof Error && a.message.includes("skipped")) continue;
                            throw a
                        }
                    }
                    let i = await this.getSlot("finalized");
                    while (!("before" in r)) {
                        if (n++, n > i) break;
                        try {
                            const e = await this.getConfirmedBlockSignatures(n);
                            e.signatures.length > 0 && (r.before = e.signatures[e.signatures.length - 1].toString())
                        } catch (a) {
                            if (a instanceof Error && a.message.includes("skipped")) continue;
                            throw a
                        }
                    }
                    const s = await this.getConfirmedSignaturesForAddress2(e, r);
                    return s.map(e => e.signature)
                }
                async getConfirmedSignaturesForAddress2(e, t, n) {
                    const r = this._buildArgsAtLeastConfirmed([e.toBase58()], n, void 0, t),
                        o = await this._rpcRequest("getConfirmedSignaturesForAddress2", r),
                        i = h.create(o, nn);
                    if ("error" in i) throw new Qe(i.error, "failed to get confirmed signatures for address");
                    return i.result
                }
                async getSignaturesForAddress(e, t, n) {
                    const r = this._buildArgsAtLeastConfirmed([e.toBase58()], n, void 0, t),
                        o = await this._rpcRequest("getSignaturesForAddress", r),
                        i = h.create(o, rn);
                    if ("error" in i) throw new Qe(i.error, "failed to get signatures for address");
                    return i.result
                }
                async getAddressLookupTable(e, t) {
                    const {
                        context: n,
                        value: r
                    } = await this.getAccountInfoAndContext(e, t);
                    let o = null;
                    return null !== r && (o = new at({
                        key: e,
                        state: at.deserialize(r.data)
                    })), {
                        context: n,
                        value: o
                    }
                }
                async getNonceAndContext(e, t) {
                    const {
                        context: n,
                        value: r
                    } = await this.getAccountInfoAndContext(e, t);
                    let o = null;
                    return null !== r && (o = Pe.fromAccountData(r.data)), {
                        context: n,
                        value: o
                    }
                }
                async getNonce(e, t) {
                    return await this.getNonceAndContext(e, t).then(e => e.value).catch(t => {
                        throw new Error("failed to get nonce for account " + e.toBase58() + ": " + t)
                    })
                }
                async requestAirdrop(e, t) {
                    const n = await this._rpcRequest("requestAirdrop", [e.toBase58(), t]),
                        r = h.create(n, $n);
                    if ("error" in r) throw new Qe(r.error, `airdrop to ${e.toBase58()} failed`);
                    return r.result
                }
                async _blockhashWithExpiryBlockHeight(e) {
                    if (!e) {
                        while (this._pollingBlockhash) await Ae(100);
                        const e = Date.now() - this._blockhashInfo.lastFetch,
                            t = e >= ft;
                        if (null !== this._blockhashInfo.latestBlockhash && !t) return this._blockhashInfo.latestBlockhash
                    }
                    return await this._pollNewBlockhash()
                }
                async _pollNewBlockhash() {
                    this._pollingBlockhash = !0;
                    try {
                        const e = Date.now(),
                            t = this._blockhashInfo.latestBlockhash,
                            n = t ? t.blockhash : null;
                        for (let r = 0; r < 50; r++) {
                            const e = await this.getLatestBlockhash("finalized");
                            if (n !== e.blockhash) return this._blockhashInfo = {
                                latestBlockhash: e,
                                lastFetch: Date.now(),
                                transactionSignatures: [],
                                simulatedSignatures: []
                            }, e;
                            await Ae(ot / 2)
                        }
                        throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)
                    } finally {
                        this._pollingBlockhash = !1
                    }
                }
                async getStakeMinimumDelegation(e) {
                    const {
                        commitment: t,
                        config: n
                    } = yt(e), r = this._buildArgs([], t, "base64", n), o = await this._rpcRequest("getStakeMinimumDelegation", r), i = h.create(o, vt(h.number()));
                    if ("error" in i) throw new Qe(i.error, "failed to get stake minimum delegation");
                    return i.result
                }
                async simulateTransaction(e, t, n) {
                    if ("message" in e) {
                        const o = e,
                            i = o.serialize(),
                            s = r.Buffer.from(i).toString("base64");
                        if (Array.isArray(t) || void 0 !== n) throw new Error("Invalid arguments");
                        const a = t || {};
                        a.encoding = "base64", "commitment" in a || (a.commitment = this.commitment);
                        const c = [s, a],
                            u = await this._rpcRequest("simulateTransaction", c),
                            l = h.create(u, jt);
                        if ("error" in l) throw new Error("failed to simulate transaction: " + l.error.message);
                        return l.result
                    }
                    let o;
                    if (e instanceof he) {
                        let t = e;
                        o = new he, o.feePayer = t.feePayer, o.instructions = e.instructions, o.nonceInfo = t.nonceInfo, o.signatures = t.signatures
                    } else o = he.populate(e), o._message = o._json = void 0;
                    if (void 0 !== t && !Array.isArray(t)) throw new Error("Invalid arguments");
                    const i = t;
                    if (o.nonceInfo && i) o.sign(...i);
                    else {
                        let e = this._disableBlockhashCaching;
                        for (;;) {
                            const t = await this._blockhashWithExpiryBlockHeight(e);
                            if (o.lastValidBlockHeight = t.lastValidBlockHeight, o.recentBlockhash = t.blockhash, !i) break;
                            if (o.sign(...i), !o.signature) throw new Error("!signature");
                            const n = o.signature.toString("base64");
                            if (!this._blockhashInfo.simulatedSignatures.includes(n) && !this._blockhashInfo.transactionSignatures.includes(n)) {
                                this._blockhashInfo.simulatedSignatures.push(n);
                                break
                            }
                            e = !0
                        }
                    }
                    const s = o._compile(),
                        a = s.serialize(),
                        c = o._serialize(a),
                        u = c.toString("base64"),
                        l = {
                            encoding: "base64",
                            commitment: this.commitment
                        };
                    if (n) {
                        const e = (Array.isArray(n) ? n : s.nonProgramIds()).map(e => e.toBase58());
                        l["accounts"] = {
                            encoding: "base64",
                            addresses: e
                        }
                    }
                    i && (l.sigVerify = !0);
                    const d = [u, l],
                        p = await this._rpcRequest("simulateTransaction", d),
                        g = h.create(p, jt);
                    if ("error" in g) {
                        let e;
                        if ("data" in g.error && (e = g.error.data.logs, e && Array.isArray(e))) {
                            const t = "\n    ",
                                n = t + e.join(t);
                            console.error(g.error.message, n)
                        }
                        throw new Ze("failed to simulate transaction: " + g.error.message, e)
                    }
                    return g.result
                }
                async sendTransaction(e, t, n) {
                    if ("version" in e) {
                        if (t && Array.isArray(t)) throw new Error("Invalid arguments");
                        const r = e.serialize();
                        return await this.sendRawTransaction(r, n)
                    }
                    if (void 0 === t || !Array.isArray(t)) throw new Error("Invalid arguments");
                    const r = t;
                    if (e.nonceInfo) e.sign(...r);
                    else {
                        let t = this._disableBlockhashCaching;
                        for (;;) {
                            const n = await this._blockhashWithExpiryBlockHeight(t);
                            if (e.lastValidBlockHeight = n.lastValidBlockHeight, e.recentBlockhash = n.blockhash, e.sign(...r), !e.signature) throw new Error("!signature");
                            const o = e.signature.toString("base64");
                            if (!this._blockhashInfo.transactionSignatures.includes(o)) {
                                this._blockhashInfo.transactionSignatures.push(o);
                                break
                            }
                            t = !0
                        }
                    }
                    const o = e.serialize();
                    return await this.sendRawTransaction(o, n)
                }
                async sendRawTransaction(e, t) {
                    const n = R(e).toString("base64"),
                        r = await this.sendEncodedTransaction(n, t);
                    return r
                }
                async sendEncodedTransaction(e, t) {
                    const n = {
                            encoding: "base64"
                        },
                        r = t && t.skipPreflight,
                        o = t && t.preflightCommitment || this.commitment;
                    t && null != t.maxRetries && (n.maxRetries = t.maxRetries), t && null != t.minContextSlot && (n.minContextSlot = t.minContextSlot), r && (n.skipPreflight = r), o && (n.preflightCommitment = o);
                    const i = [e, n],
                        s = await this._rpcRequest("sendTransaction", i),
                        a = h.create(s, Vn);
                    if ("error" in a) {
                        let e;
                        throw "data" in a.error && (e = a.error.data.logs), new Ze("failed to send transaction: " + a.error.message, e)
                    }
                    return a.result
                }
                _wsOnOpen() {
                    this._rpcWebSocketConnected = !0, this._rpcWebSocketHeartbeat = setInterval(() => {
                        this._rpcWebSocket.notify("ping").catch(() => {})
                    }, 5e3), this._updateSubscriptions()
                }
                _wsOnError(e) {
                    this._rpcWebSocketConnected = !1, console.error("ws error:", e.message)
                }
                _wsOnClose(e) {
                    this._rpcWebSocketConnected = !1, this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER, this._rpcWebSocketIdleTimeout && (clearTimeout(this._rpcWebSocketIdleTimeout), this._rpcWebSocketIdleTimeout = null), this._rpcWebSocketHeartbeat && (clearInterval(this._rpcWebSocketHeartbeat), this._rpcWebSocketHeartbeat = null), 1e3 !== e ? (this._subscriptionCallbacksByServerSubscriptionId = {}, Object.entries(this._subscriptionsByHash).forEach(([e, t]) => {
                        this._subscriptionsByHash[e] = { ...t,
                            state: "pending"
                        }
                    })) : this._updateSubscriptions()
                }
                async _updateSubscriptions() {
                    if (0 === Object.keys(this._subscriptionsByHash).length) return void(this._rpcWebSocketConnected && (this._rpcWebSocketConnected = !1, this._rpcWebSocketIdleTimeout = setTimeout(() => {
                        this._rpcWebSocketIdleTimeout = null;
                        try {
                            this._rpcWebSocket.close()
                        } catch (e) {
                            e instanceof Error && console.log("Error when closing socket connection: " + e.message)
                        }
                    }, 500)));
                    if (null !== this._rpcWebSocketIdleTimeout && (clearTimeout(this._rpcWebSocketIdleTimeout), this._rpcWebSocketIdleTimeout = null, this._rpcWebSocketConnected = !0), !this._rpcWebSocketConnected) return void this._rpcWebSocket.connect();
                    const e = this._rpcWebSocketGeneration,
                        t = () => e === this._rpcWebSocketGeneration;
                    await Promise.all(Object.keys(this._subscriptionsByHash).map(async e => {
                        const n = this._subscriptionsByHash[e];
                        if (void 0 !== n) switch (n.state) {
                            case "pending":
                            case "unsubscribed":
                                if (0 === n.callbacks.size) return delete this._subscriptionsByHash[e], "unsubscribed" === n.state && delete this._subscriptionCallbacksByServerSubscriptionId[n.serverSubscriptionId], void await this._updateSubscriptions();
                                await (async () => {
                                    const {
                                        args: r,
                                        method: o
                                    } = n;
                                    try {
                                        this._subscriptionsByHash[e] = { ...n,
                                            state: "subscribing"
                                        };
                                        const t = await this._rpcWebSocket.call(o, r);
                                        this._subscriptionsByHash[e] = { ...n,
                                            serverSubscriptionId: t,
                                            state: "subscribed"
                                        }, this._subscriptionCallbacksByServerSubscriptionId[t] = n.callbacks, await this._updateSubscriptions()
                                    } catch (i) {
                                        if (i instanceof Error && console.error(o + " error for argument", r, i.message), !t()) return;
                                        this._subscriptionsByHash[e] = { ...n,
                                            state: "pending"
                                        }, await this._updateSubscriptions()
                                    }
                                })();
                                break;
                            case "subscribed":
                                0 === n.callbacks.size && await (async () => {
                                    const {
                                        serverSubscriptionId: r,
                                        unsubscribeMethod: o
                                    } = n;
                                    if (this._subscriptionsAutoDisposedByRpc.has(r)) this._subscriptionsAutoDisposedByRpc.delete(r);
                                    else {
                                        this._subscriptionsByHash[e] = { ...n,
                                            state: "unsubscribing"
                                        };
                                        try {
                                            await this._rpcWebSocket.call(o, [r])
                                        } catch (i) {
                                            if (i instanceof Error && console.error(o + " error:", i.message), !t()) return;
                                            return this._subscriptionsByHash[e] = { ...n,
                                                state: "subscribed"
                                            }, void await this._updateSubscriptions()
                                        }
                                    }
                                    this._subscriptionsByHash[e] = { ...n,
                                        state: "unsubscribed"
                                    }, await this._updateSubscriptions()
                                })();
                                break
                        }
                    }))
                }
                _handleServerNotification(e, t) {
                    const n = this._subscriptionCallbacksByServerSubscriptionId[e];
                    void 0 !== n && n.forEach(e => {
                        try {
                            e(...t)
                        } catch (n) {
                            console.error(n)
                        }
                    })
                }
                _wsOnAccountNotification(e) {
                    const {
                        result: t,
                        subscription: n
                    } = h.create(e, on);
                    this._handleServerNotification(n, [t.value, t.context])
                }
                _makeSubscription(e, t) {
                    const n = this._nextClientSubscriptionId++,
                        r = Ve([e.method, t], !0),
                        o = this._subscriptionsByHash[r];
                    return void 0 === o ? this._subscriptionsByHash[r] = { ...e,
                        args: t,
                        callbacks: new Set([e.callback]),
                        state: "pending"
                    } : o.callbacks.add(e.callback), this._subscriptionDisposeFunctionsByClientSubscriptionId[n] = async () => {
                        delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n];
                        const t = this._subscriptionsByHash[r];
                        ie(void 0 !== t, "Could not find a `Subscription` when tearing down client subscription #" + n), t.callbacks.delete(e.callback), await this._updateSubscriptions()
                    }, this._updateSubscriptions(), n
                }
                onAccountChange(e, t, n) {
                    const r = this._buildArgs([e.toBase58()], n || this._commitment || "finalized", "base64");
                    return this._makeSubscription({
                        callback: t,
                        method: "accountSubscribe",
                        unsubscribeMethod: "accountUnsubscribe"
                    }, r)
                }
                async removeAccountChangeListener(e) {
                    await this._unsubscribeClientSubscription(e, "account change")
                }
                _wsOnProgramAccountNotification(e) {
                    const {
                        result: t,
                        subscription: n
                    } = h.create(e, an);
                    this._handleServerNotification(n, [{
                        accountId: t.value.pubkey,
                        accountInfo: t.value.account
                    }, t.context])
                }
                onProgramAccountChange(e, t, n, r) {
                    const o = this._buildArgs([e.toBase58()], n || this._commitment || "finalized", "base64", r ? {
                        filters: r
                    } : void 0);
                    return this._makeSubscription({
                        callback: t,
                        method: "programSubscribe",
                        unsubscribeMethod: "programUnsubscribe"
                    }, o)
                }
                async removeProgramAccountChangeListener(e) {
                    await this._unsubscribeClientSubscription(e, "program account change")
                }
                onLogs(e, t, n) {
                    const r = this._buildArgs(["object" === typeof e ? {
                        mentions: [e.toString()]
                    } : e], n || this._commitment || "finalized");
                    return this._makeSubscription({
                        callback: t,
                        method: "logsSubscribe",
                        unsubscribeMethod: "logsUnsubscribe"
                    }, r)
                }
                async removeOnLogsListener(e) {
                    await this._unsubscribeClientSubscription(e, "logs")
                }
                _wsOnLogsNotification(e) {
                    const {
                        result: t,
                        subscription: n
                    } = h.create(e, Gn);
                    this._handleServerNotification(n, [t.value, t.context])
                }
                _wsOnSlotNotification(e) {
                    const {
                        result: t,
                        subscription: n
                    } = h.create(e, un);
                    this._handleServerNotification(n, [t])
                }
                onSlotChange(e) {
                    return this._makeSubscription({
                        callback: e,
                        method: "slotSubscribe",
                        unsubscribeMethod: "slotUnsubscribe"
                    }, [])
                }
                async removeSlotChangeListener(e) {
                    await this._unsubscribeClientSubscription(e, "slot change")
                }
                _wsOnSlotUpdatesNotification(e) {
                    const {
                        result: t,
                        subscription: n
                    } = h.create(e, dn);
                    this._handleServerNotification(n, [t])
                }
                onSlotUpdate(e) {
                    return this._makeSubscription({
                        callback: e,
                        method: "slotsUpdatesSubscribe",
                        unsubscribeMethod: "slotsUpdatesUnsubscribe"
                    }, [])
                }
                async removeSlotUpdateListener(e) {
                    await this._unsubscribeClientSubscription(e, "slot update")
                }
                async _unsubscribeClientSubscription(e, t) {
                    const n = this._subscriptionDisposeFunctionsByClientSubscriptionId[e];
                    n ? await n() : console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)
                }
                _buildArgs(e, t, n, r) {
                    const o = t || this._commitment;
                    if (o || n || r) {
                        let t = {};
                        n && (t.encoding = n), o && (t.commitment = o), r && (t = Object.assign(t, r)), e.push(t)
                    }
                    return e
                }
                _buildArgsAtLeastConfirmed(e, t, n, r) {
                    const o = t || this._commitment;
                    if (o && !["confirmed", "finalized"].includes(o)) throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
                    return this._buildArgs(e, t, n, r)
                }
                _wsOnSignatureNotification(e) {
                    const {
                        result: t,
                        subscription: n
                    } = h.create(e, hn);
                    "receivedSignature" !== t.value && this._subscriptionsAutoDisposedByRpc.add(n), this._handleServerNotification(n, "receivedSignature" === t.value ? [{
                        type: "received"
                    }, t.context] : [{
                        type: "status",
                        result: t.value
                    }, t.context])
                }
                onSignature(e, t, n) {
                    const r = this._buildArgs([e], n || this._commitment || "finalized"),
                        o = this._makeSubscription({
                            callback: (e, n) => {
                                if ("status" === e.type) {
                                    t(e.result, n);
                                    try {
                                        this.removeSignatureListener(o)
                                    } catch (r) {}
                                }
                            },
                            method: "signatureSubscribe",
                            unsubscribeMethod: "signatureUnsubscribe"
                        }, r);
                    return o
                }
                onSignatureWithOptions(e, t, n) {
                    const {
                        commitment: r,
                        ...o
                    } = { ...n,
                        commitment: n && n.commitment || this._commitment || "finalized"
                    }, i = this._buildArgs([e], r, void 0, o), s = this._makeSubscription({
                        callback: (e, n) => {
                            t(e, n);
                            try {
                                this.removeSignatureListener(s)
                            } catch (r) {}
                        },
                        method: "signatureSubscribe",
                        unsubscribeMethod: "signatureUnsubscribe"
                    }, i);
                    return s
                }
                async removeSignatureListener(e) {
                    await this._unsubscribeClientSubscription(e, "signature result")
                }
                _wsOnRootNotification(e) {
                    const {
                        result: t,
                        subscription: n
                    } = h.create(e, pn);
                    this._handleServerNotification(n, [t])
                }
                onRootChange(e) {
                    return this._makeSubscription({
                        callback: e,
                        method: "rootSubscribe",
                        unsubscribeMethod: "rootUnsubscribe"
                    }, [])
                }
                async removeRootChangeListener(e) {
                    await this._unsubscribeClientSubscription(e, "root change")
                }
            }
            class Zn {
                constructor(e) {
                    this._keypair = void 0, this._keypair = null !== e && void 0 !== e ? e : x()
                }
                static generate() {
                    return new Zn(x())
                }
                static fromSecretKey(e, t) {
                    if (64 !== e.byteLength) throw new Error("bad secret key size");
                    const n = e.slice(32, 64);
                    if (!t || !t.skipValidation) {
                        const t = e.slice(0, 32),
                            r = _(t);
                        for (let e = 0; e < 32; e++)
                            if (n[e] !== r[e]) throw new Error("provided secretKey is invalid")
                    }
                    return new Zn({
                        publicKey: n,
                        secretKey: e
                    })
                }
                static fromSeed(e) {
                    const t = _(e),
                        n = new Uint8Array(64);
                    return n.set(e), n.set(t, 32), new Zn({
                        publicKey: t,
                        secretKey: n
                    })
                }
                get publicKey() {
                    return new U(this._keypair.publicKey)
                }
                get secretKey() {
                    return new Uint8Array(this._keypair.secretKey)
                }
            }
            const Xn = Object.freeze({
                CreateLookupTable: {
                    index: 0,
                    layout: C.struct([C.u32("instruction"), Be("recentSlot"), C.u8("bumpSeed")])
                },
                FreezeLookupTable: {
                    index: 1,
                    layout: C.struct([C.u32("instruction")])
                },
                ExtendLookupTable: {
                    index: 2,
                    layout: C.struct([C.u32("instruction"), Be(), C.seq(Y(), C.offset(C.u32(), -8), "addresses")])
                },
                DeactivateLookupTable: {
                    index: 3,
                    layout: C.struct([C.u32("instruction")])
                },
                CloseLookupTable: {
                    index: 4,
                    layout: C.struct([C.u32("instruction")])
                }
            });
            class Qn {
                constructor() {}
                static decodeInstructionType(e) {
                    this.checkProgramId(e.programId);
                    const t = C.u32("instruction"),
                        n = t.decode(e.data);
                    let r;
                    for (const [o, i] of Object.entries(Xn))
                        if (i.index == n) {
                            r = o;
                            break
                        }
                    if (!r) throw new Error("Invalid Instruction. Should be a LookupTable Instruction");
                    return r
                }
                static decodeCreateLookupTable(e) {
                    this.checkProgramId(e.programId), this.checkKeysLength(e.keys, 4);
                    const {
                        recentSlot: t
                    } = xe(Xn.CreateLookupTable, e.data);
                    return {
                        authority: e.keys[1].pubkey,
                        payer: e.keys[2].pubkey,
                        recentSlot: Number(t)
                    }
                }
                static decodeExtendLookupTable(e) {
                    if (this.checkProgramId(e.programId), e.keys.length < 2) throw new Error(`invalid instruction; found ${e.keys.length} keys, expected at least 2`);
                    const {
                        addresses: t
                    } = xe(Xn.ExtendLookupTable, e.data);
                    return {
                        lookupTable: e.keys[0].pubkey,
                        authority: e.keys[1].pubkey,
                        payer: e.keys.length > 2 ? e.keys[2].pubkey : void 0,
                        addresses: t.map(e => new U(e))
                    }
                }
                static decodeCloseLookupTable(e) {
                    return this.checkProgramId(e.programId), this.checkKeysLength(e.keys, 3), {
                        lookupTable: e.keys[0].pubkey,
                        authority: e.keys[1].pubkey,
                        recipient: e.keys[2].pubkey
                    }
                }
                static decodeFreezeLookupTable(e) {
                    return this.checkProgramId(e.programId), this.checkKeysLength(e.keys, 2), {
                        lookupTable: e.keys[0].pubkey,
                        authority: e.keys[1].pubkey
                    }
                }
                static decodeDeactivateLookupTable(e) {
                    return this.checkProgramId(e.programId), this.checkKeysLength(e.keys, 2), {
                        lookupTable: e.keys[0].pubkey,
                        authority: e.keys[1].pubkey
                    }
                }
                static checkProgramId(e) {
                    if (!e.equals(er.programId)) throw new Error("invalid instruction; programId is not AddressLookupTable Program")
                }
                static checkKeysLength(e, t) {
                    if (e.length < t) throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)
                }
            }
            class er {
                constructor() {}
                static createLookupTable(e) {
                    const [t, n] = U.findProgramAddressSync([e.authority.toBuffer(), d.toBufferLE(BigInt(e.recentSlot), 8)], this.programId), r = Xn.CreateLookupTable, o = Oe(r, {
                        recentSlot: BigInt(e.recentSlot),
                        bumpSeed: n
                    }), i = [{
                        pubkey: t,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: e.authority,
                        isSigner: !0,
                        isWritable: !1
                    }, {
                        pubkey: e.payer,
                        isSigner: !0,
                        isWritable: !0
                    }, {
                        pubkey: Ne.programId,
                        isSigner: !1,
                        isWritable: !1
                    }];
                    return [new de({
                        programId: this.programId,
                        keys: i,
                        data: o
                    }), t]
                }
                static freezeLookupTable(e) {
                    const t = Xn.FreezeLookupTable,
                        n = Oe(t),
                        r = [{
                            pubkey: e.lookupTable,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: e.authority,
                            isSigner: !0,
                            isWritable: !1
                        }];
                    return new de({
                        programId: this.programId,
                        keys: r,
                        data: n
                    })
                }
                static extendLookupTable(e) {
                    const t = Xn.ExtendLookupTable,
                        n = Oe(t, {
                            addresses: e.addresses.map(e => e.toBytes())
                        }),
                        r = [{
                            pubkey: e.lookupTable,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: e.authority,
                            isSigner: !0,
                            isWritable: !1
                        }];
                    return e.payer && r.push({
                        pubkey: e.payer,
                        isSigner: !0,
                        isWritable: !0
                    }, {
                        pubkey: Ne.programId,
                        isSigner: !1,
                        isWritable: !1
                    }), new de({
                        programId: this.programId,
                        keys: r,
                        data: n
                    })
                }
                static deactivateLookupTable(e) {
                    const t = Xn.DeactivateLookupTable,
                        n = Oe(t),
                        r = [{
                            pubkey: e.lookupTable,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: e.authority,
                            isSigner: !0,
                            isWritable: !1
                        }];
                    return new de({
                        programId: this.programId,
                        keys: r,
                        data: n
                    })
                }
                static closeLookupTable(e) {
                    const t = Xn.CloseLookupTable,
                        n = Oe(t),
                        r = [{
                            pubkey: e.lookupTable,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: e.authority,
                            isSigner: !0,
                            isWritable: !1
                        }, {
                            pubkey: e.recipient,
                            isSigner: !1,
                            isWritable: !0
                        }];
                    return new de({
                        programId: this.programId,
                        keys: r,
                        data: n
                    })
                }
            }
            er.programId = new U("AddressLookupTab1e1111111111111111111111111");
            class tr {
                constructor() {}
                static decodeInstructionType(e) {
                    this.checkProgramId(e.programId);
                    const t = C.u8("instruction"),
                        n = t.decode(e.data);
                    let r;
                    for (const [o, i] of Object.entries(nr))
                        if (i.index == n) {
                            r = o;
                            break
                        }
                    if (!r) throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");
                    return r
                }
                static decodeRequestUnits(e) {
                    this.checkProgramId(e.programId);
                    const {
                        units: t,
                        additionalFee: n
                    } = xe(nr.RequestUnits, e.data);
                    return {
                        units: t,
                        additionalFee: n
                    }
                }
                static decodeRequestHeapFrame(e) {
                    this.checkProgramId(e.programId);
                    const {
                        bytes: t
                    } = xe(nr.RequestHeapFrame, e.data);
                    return {
                        bytes: t
                    }
                }
                static decodeSetComputeUnitLimit(e) {
                    this.checkProgramId(e.programId);
                    const {
                        units: t
                    } = xe(nr.SetComputeUnitLimit, e.data);
                    return {
                        units: t
                    }
                }
                static decodeSetComputeUnitPrice(e) {
                    this.checkProgramId(e.programId);
                    const {
                        microLamports: t
                    } = xe(nr.SetComputeUnitPrice, e.data);
                    return {
                        microLamports: t
                    }
                }
                static checkProgramId(e) {
                    if (!e.equals(rr.programId)) throw new Error("invalid instruction; programId is not ComputeBudgetProgram")
                }
            }
            const nr = Object.freeze({
                RequestUnits: {
                    index: 0,
                    layout: C.struct([C.u8("instruction"), C.u32("units"), C.u32("additionalFee")])
                },
                RequestHeapFrame: {
                    index: 1,
                    layout: C.struct([C.u8("instruction"), C.u32("bytes")])
                },
                SetComputeUnitLimit: {
                    index: 2,
                    layout: C.struct([C.u8("instruction"), C.u32("units")])
                },
                SetComputeUnitPrice: {
                    index: 3,
                    layout: C.struct([C.u8("instruction"), Be("microLamports")])
                }
            });
            class rr {
                constructor() {}
                static requestUnits(e) {
                    const t = nr.RequestUnits,
                        n = Oe(t, e);
                    return new de({
                        keys: [],
                        programId: this.programId,
                        data: n
                    })
                }
                static requestHeapFrame(e) {
                    const t = nr.RequestHeapFrame,
                        n = Oe(t, e);
                    return new de({
                        keys: [],
                        programId: this.programId,
                        data: n
                    })
                }
                static setComputeUnitLimit(e) {
                    const t = nr.SetComputeUnitLimit,
                        n = Oe(t, e);
                    return new de({
                        keys: [],
                        programId: this.programId,
                        data: n
                    })
                }
                static setComputeUnitPrice(e) {
                    const t = nr.SetComputeUnitPrice,
                        n = Oe(t, {
                            microLamports: BigInt(e.microLamports)
                        });
                    return new de({
                        keys: [],
                        programId: this.programId,
                        data: n
                    })
                }
            }
            rr.programId = new U("ComputeBudget111111111111111111111111111111");
            const or = 64,
                ir = 32,
                sr = 64,
                ar = C.struct([C.u8("numSignatures"), C.u8("padding"), C.u16("signatureOffset"), C.u16("signatureInstructionIndex"), C.u16("publicKeyOffset"), C.u16("publicKeyInstructionIndex"), C.u16("messageDataOffset"), C.u16("messageDataSize"), C.u16("messageInstructionIndex")]);
            class cr {
                constructor() {}
                static createInstructionWithPublicKey(e) {
                    const {
                        publicKey: t,
                        message: n,
                        signature: o,
                        instructionIndex: i
                    } = e;
                    ie(t.length === ir, `Public Key must be ${ir} bytes but received ${t.length} bytes`), ie(o.length === sr, `Signature must be ${sr} bytes but received ${o.length} bytes`);
                    const s = ar.span,
                        a = s + t.length,
                        c = a + o.length,
                        u = 1,
                        l = r.Buffer.alloc(c + n.length),
                        d = null == i ? 65535 : i;
                    return ar.encode({
                        numSignatures: u,
                        padding: 0,
                        signatureOffset: a,
                        signatureInstructionIndex: d,
                        publicKeyOffset: s,
                        publicKeyInstructionIndex: d,
                        messageDataOffset: c,
                        messageDataSize: n.length,
                        messageInstructionIndex: d
                    }, l), l.fill(t, s), l.fill(o, a), l.fill(n, c), new de({
                        keys: [],
                        programId: cr.programId,
                        data: l
                    })
                }
                static createInstructionWithPrivateKey(e) {
                    const {
                        privateKey: t,
                        message: n,
                        instructionIndex: r
                    } = e;
                    ie(t.length === or, `Private key must be ${or} bytes but received ${t.length} bytes`);
                    try {
                        const e = Zn.fromSecretKey(t),
                            o = e.publicKey.toBytes(),
                            i = T(n, e.secretKey);
                        return this.createInstructionWithPublicKey({
                            publicKey: o,
                            message: n,
                            signature: i,
                            instructionIndex: r
                        })
                    } catch (o) {
                        throw new Error("Error creating instruction; " + o)
                    }
                }
            }
            cr.programId = new U("Ed25519SigVerify111111111111111111111111111"), A.utils.hmacSha256Sync = (e, ...t) => {
                const n = b.hmac.create(c.sha256, e);
                return t.forEach(e => n.update(e)), n.digest()
            };
            const ur = (e, t) => A.signSync(e, t, {
                der: !1,
                recovered: !0
            });
            A.utils.isValidPrivateKey;
            const lr = A.getPublicKey,
                dr = 32,
                hr = 20,
                pr = 64,
                gr = 11,
                fr = C.struct([C.u8("numSignatures"), C.u16("signatureOffset"), C.u8("signatureInstructionIndex"), C.u16("ethAddressOffset"), C.u8("ethAddressInstructionIndex"), C.u16("messageDataOffset"), C.u16("messageDataSize"), C.u8("messageInstructionIndex"), C.blob(20, "ethAddress"), C.blob(64, "signature"), C.u8("recoveryId")]);
            class br {
                constructor() {}
                static publicKeyToEthAddress(e) {
                    ie(e.length === pr, `Public key must be ${pr} bytes but received ${e.length} bytes`);
                    try {
                        return r.Buffer.from(f.keccak_256(R(e))).slice(-hr)
                    } catch (t) {
                        throw new Error("Error constructing Ethereum address: " + t)
                    }
                }
                static createInstructionWithPublicKey(e) {
                    const {
                        publicKey: t,
                        message: n,
                        signature: r,
                        recoveryId: o,
                        instructionIndex: i
                    } = e;
                    return br.createInstructionWithEthAddress({
                        ethAddress: br.publicKeyToEthAddress(t),
                        message: n,
                        signature: r,
                        recoveryId: o,
                        instructionIndex: i
                    })
                }
                static createInstructionWithEthAddress(e) {
                    const {
                        ethAddress: t,
                        message: n,
                        signature: o,
                        recoveryId: i,
                        instructionIndex: s = 0
                    } = e;
                    let a;
                    a = "string" === typeof t ? t.startsWith("0x") ? r.Buffer.from(t.substr(2), "hex") : r.Buffer.from(t, "hex") : t, ie(a.length === hr, `Address must be ${hr} bytes but received ${a.length} bytes`);
                    const c = 1 + gr,
                        u = c,
                        l = c + a.length,
                        d = l + o.length + 1,
                        h = 1,
                        p = r.Buffer.alloc(fr.span + n.length);
                    return fr.encode({
                        numSignatures: h,
                        signatureOffset: l,
                        signatureInstructionIndex: s,
                        ethAddressOffset: u,
                        ethAddressInstructionIndex: s,
                        messageDataOffset: d,
                        messageDataSize: n.length,
                        messageInstructionIndex: s,
                        signature: R(o),
                        ethAddress: R(a),
                        recoveryId: i
                    }, p), p.fill(R(n), fr.span), new de({
                        keys: [],
                        programId: br.programId,
                        data: p
                    })
                }
                static createInstructionWithPrivateKey(e) {
                    const {
                        privateKey: t,
                        message: n,
                        instructionIndex: o
                    } = e;
                    ie(t.length === dr, `Private key must be ${dr} bytes but received ${t.length} bytes`);
                    try {
                        const e = R(t),
                            i = lr(e, !1).slice(1),
                            s = r.Buffer.from(f.keccak_256(R(n))),
                            [a, c] = ur(s, e);
                        return this.createInstructionWithPublicKey({
                            publicKey: i,
                            message: n,
                            signature: a,
                            recoveryId: c,
                            instructionIndex: o
                        })
                    } catch (i) {
                        throw new Error("Error creating instruction; " + i)
                    }
                }
            }
            br.programId = new U("KeccakSecp256k11111111111111111111111111111");
            const yr = new U("StakeConfig11111111111111111111111111111111");
            class mr {
                constructor(e, t) {
                    this.staker = void 0, this.withdrawer = void 0, this.staker = e, this.withdrawer = t
                }
            }
            class wr {
                constructor(e, t, n) {
                    this.unixTimestamp = void 0, this.epoch = void 0, this.custodian = void 0, this.unixTimestamp = e, this.epoch = t, this.custodian = n
                }
            }
            wr.default = new wr(0, 0, U.default);
            class kr {
                constructor() {}
                static decodeInstructionType(e) {
                    this.checkProgramId(e.programId);
                    const t = C.u32("instruction"),
                        n = t.decode(e.data);
                    let r;
                    for (const [o, i] of Object.entries(vr))
                        if (i.index == n) {
                            r = o;
                            break
                        }
                    if (!r) throw new Error("Instruction type incorrect; not a StakeInstruction");
                    return r
                }
                static decodeInitialize(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
                    const {
                        authorized: t,
                        lockup: n
                    } = xe(vr.Initialize, e.data);
                    return {
                        stakePubkey: e.keys[0].pubkey,
                        authorized: new mr(new U(t.staker), new U(t.withdrawer)),
                        lockup: new wr(n.unixTimestamp, n.epoch, new U(n.custodian))
                    }
                }
                static decodeDelegate(e) {
                    return this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 6), xe(vr.Delegate, e.data), {
                        stakePubkey: e.keys[0].pubkey,
                        votePubkey: e.keys[1].pubkey,
                        authorizedPubkey: e.keys[5].pubkey
                    }
                }
                static decodeAuthorize(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
                    const {
                        newAuthorized: t,
                        stakeAuthorizationType: n
                    } = xe(vr.Authorize, e.data), r = {
                        stakePubkey: e.keys[0].pubkey,
                        authorizedPubkey: e.keys[2].pubkey,
                        newAuthorizedPubkey: new U(t),
                        stakeAuthorizationType: {
                            index: n
                        }
                    };
                    return e.keys.length > 3 && (r.custodianPubkey = e.keys[3].pubkey), r
                }
                static decodeAuthorizeWithSeed(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
                    const {
                        newAuthorized: t,
                        stakeAuthorizationType: n,
                        authoritySeed: r,
                        authorityOwner: o
                    } = xe(vr.AuthorizeWithSeed, e.data), i = {
                        stakePubkey: e.keys[0].pubkey,
                        authorityBase: e.keys[1].pubkey,
                        authoritySeed: r,
                        authorityOwner: new U(o),
                        newAuthorizedPubkey: new U(t),
                        stakeAuthorizationType: {
                            index: n
                        }
                    };
                    return e.keys.length > 3 && (i.custodianPubkey = e.keys[3].pubkey), i
                }
                static decodeSplit(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
                    const {
                        lamports: t
                    } = xe(vr.Split, e.data);
                    return {
                        stakePubkey: e.keys[0].pubkey,
                        splitStakePubkey: e.keys[1].pubkey,
                        authorizedPubkey: e.keys[2].pubkey,
                        lamports: t
                    }
                }
                static decodeMerge(e) {
                    return this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3), xe(vr.Merge, e.data), {
                        stakePubkey: e.keys[0].pubkey,
                        sourceStakePubKey: e.keys[1].pubkey,
                        authorizedPubkey: e.keys[4].pubkey
                    }
                }
                static decodeWithdraw(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 5);
                    const {
                        lamports: t
                    } = xe(vr.Withdraw, e.data), n = {
                        stakePubkey: e.keys[0].pubkey,
                        toPubkey: e.keys[1].pubkey,
                        authorizedPubkey: e.keys[4].pubkey,
                        lamports: t
                    };
                    return e.keys.length > 5 && (n.custodianPubkey = e.keys[5].pubkey), n
                }
                static decodeDeactivate(e) {
                    return this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3), xe(vr.Deactivate, e.data), {
                        stakePubkey: e.keys[0].pubkey,
                        authorizedPubkey: e.keys[2].pubkey
                    }
                }
                static checkProgramId(e) {
                    if (!e.equals(Cr.programId)) throw new Error("invalid instruction; programId is not StakeProgram")
                }
                static checkKeyLength(e, t) {
                    if (e.length < t) throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)
                }
            }
            const vr = Object.freeze({
                    Initialize: {
                        index: 0,
                        layout: C.struct([C.u32("instruction"), X(), Q()])
                    },
                    Authorize: {
                        index: 1,
                        layout: C.struct([C.u32("instruction"), Y("newAuthorized"), C.u32("stakeAuthorizationType")])
                    },
                    Delegate: {
                        index: 2,
                        layout: C.struct([C.u32("instruction")])
                    },
                    Split: {
                        index: 3,
                        layout: C.struct([C.u32("instruction"), C.ns64("lamports")])
                    },
                    Withdraw: {
                        index: 4,
                        layout: C.struct([C.u32("instruction"), C.ns64("lamports")])
                    },
                    Deactivate: {
                        index: 5,
                        layout: C.struct([C.u32("instruction")])
                    },
                    Merge: {
                        index: 7,
                        layout: C.struct([C.u32("instruction")])
                    },
                    AuthorizeWithSeed: {
                        index: 8,
                        layout: C.struct([C.u32("instruction"), Y("newAuthorized"), C.u32("stakeAuthorizationType"), Z("authoritySeed"), Y("authorityOwner")])
                    }
                }),
                Sr = Object.freeze({
                    Staker: {
                        index: 0
                    },
                    Withdrawer: {
                        index: 1
                    }
                });
            class Cr {
                constructor() {}
                static initialize(e) {
                    const {
                        stakePubkey: t,
                        authorized: n,
                        lockup: r
                    } = e, o = r || wr.default, i = vr.Initialize, s = Oe(i, {
                        authorized: {
                            staker: R(n.staker.toBuffer()),
                            withdrawer: R(n.withdrawer.toBuffer())
                        },
                        lockup: {
                            unixTimestamp: o.unixTimestamp,
                            epoch: o.epoch,
                            custodian: R(o.custodian.toBuffer())
                        }
                    }), a = {
                        keys: [{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: we,
                            isSigner: !1,
                            isWritable: !1
                        }],
                        programId: this.programId,
                        data: s
                    };
                    return new de(a)
                }
                static createAccountWithSeed(e) {
                    const t = new he;
                    t.add(Ne.createAccountWithSeed({
                        fromPubkey: e.fromPubkey,
                        newAccountPubkey: e.stakePubkey,
                        basePubkey: e.basePubkey,
                        seed: e.seed,
                        lamports: e.lamports,
                        space: this.space,
                        programId: this.programId
                    }));
                    const {
                        stakePubkey: n,
                        authorized: r,
                        lockup: o
                    } = e;
                    return t.add(this.initialize({
                        stakePubkey: n,
                        authorized: r,
                        lockup: o
                    }))
                }
                static createAccount(e) {
                    const t = new he;
                    t.add(Ne.createAccount({
                        fromPubkey: e.fromPubkey,
                        newAccountPubkey: e.stakePubkey,
                        lamports: e.lamports,
                        space: this.space,
                        programId: this.programId
                    }));
                    const {
                        stakePubkey: n,
                        authorized: r,
                        lockup: o
                    } = e;
                    return t.add(this.initialize({
                        stakePubkey: n,
                        authorized: r,
                        lockup: o
                    }))
                }
                static delegate(e) {
                    const {
                        stakePubkey: t,
                        authorizedPubkey: n,
                        votePubkey: r
                    } = e, o = vr.Delegate, i = Oe(o);
                    return (new he).add({
                        keys: [{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: r,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: fe,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: Ce,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: yr,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: n,
                            isSigner: !0,
                            isWritable: !1
                        }],
                        programId: this.programId,
                        data: i
                    })
                }
                static authorize(e) {
                    const {
                        stakePubkey: t,
                        authorizedPubkey: n,
                        newAuthorizedPubkey: r,
                        stakeAuthorizationType: o,
                        custodianPubkey: i
                    } = e, s = vr.Authorize, a = Oe(s, {
                        newAuthorized: R(r.toBuffer()),
                        stakeAuthorizationType: o.index
                    }), c = [{
                        pubkey: t,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: fe,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: n,
                        isSigner: !0,
                        isWritable: !1
                    }];
                    return i && c.push({
                        pubkey: i,
                        isSigner: !1,
                        isWritable: !1
                    }), (new he).add({
                        keys: c,
                        programId: this.programId,
                        data: a
                    })
                }
                static authorizeWithSeed(e) {
                    const {
                        stakePubkey: t,
                        authorityBase: n,
                        authoritySeed: r,
                        authorityOwner: o,
                        newAuthorizedPubkey: i,
                        stakeAuthorizationType: s,
                        custodianPubkey: a
                    } = e, c = vr.AuthorizeWithSeed, u = Oe(c, {
                        newAuthorized: R(i.toBuffer()),
                        stakeAuthorizationType: s.index,
                        authoritySeed: r,
                        authorityOwner: R(o.toBuffer())
                    }), l = [{
                        pubkey: t,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: n,
                        isSigner: !0,
                        isWritable: !1
                    }, {
                        pubkey: fe,
                        isSigner: !1,
                        isWritable: !1
                    }];
                    return a && l.push({
                        pubkey: a,
                        isSigner: !1,
                        isWritable: !1
                    }), (new he).add({
                        keys: l,
                        programId: this.programId,
                        data: u
                    })
                }
                static splitInstruction(e) {
                    const {
                        stakePubkey: t,
                        authorizedPubkey: n,
                        splitStakePubkey: r,
                        lamports: o
                    } = e, i = vr.Split, s = Oe(i, {
                        lamports: o
                    });
                    return new de({
                        keys: [{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: r,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: n,
                            isSigner: !0,
                            isWritable: !1
                        }],
                        programId: this.programId,
                        data: s
                    })
                }
                static split(e) {
                    const t = new he;
                    return t.add(Ne.createAccount({
                        fromPubkey: e.authorizedPubkey,
                        newAccountPubkey: e.splitStakePubkey,
                        lamports: 0,
                        space: this.space,
                        programId: this.programId
                    })), t.add(this.splitInstruction(e))
                }
                static splitWithSeed(e) {
                    const {
                        stakePubkey: t,
                        authorizedPubkey: n,
                        splitStakePubkey: r,
                        basePubkey: o,
                        seed: i,
                        lamports: s
                    } = e, a = new he;
                    return a.add(Ne.allocate({
                        accountPubkey: r,
                        basePubkey: o,
                        seed: i,
                        space: this.space,
                        programId: this.programId
                    })), a.add(this.splitInstruction({
                        stakePubkey: t,
                        authorizedPubkey: n,
                        splitStakePubkey: r,
                        lamports: s
                    }))
                }
                static merge(e) {
                    const {
                        stakePubkey: t,
                        sourceStakePubKey: n,
                        authorizedPubkey: r
                    } = e, o = vr.Merge, i = Oe(o);
                    return (new he).add({
                        keys: [{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: n,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: fe,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: Ce,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: r,
                            isSigner: !0,
                            isWritable: !1
                        }],
                        programId: this.programId,
                        data: i
                    })
                }
                static withdraw(e) {
                    const {
                        stakePubkey: t,
                        authorizedPubkey: n,
                        toPubkey: r,
                        lamports: o,
                        custodianPubkey: i
                    } = e, s = vr.Withdraw, a = Oe(s, {
                        lamports: o
                    }), c = [{
                        pubkey: t,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: r,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: fe,
                        isSigner: !1,
                        isWritable: !1
                    }, {
                        pubkey: Ce,
                        isSigner: !1,
                        isWritable: !1
                    }, {
                        pubkey: n,
                        isSigner: !0,
                        isWritable: !1
                    }];
                    return i && c.push({
                        pubkey: i,
                        isSigner: !1,
                        isWritable: !1
                    }), (new he).add({
                        keys: c,
                        programId: this.programId,
                        data: a
                    })
                }
                static deactivate(e) {
                    const {
                        stakePubkey: t,
                        authorizedPubkey: n
                    } = e, r = vr.Deactivate, o = Oe(r);
                    return (new he).add({
                        keys: [{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: fe,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: n,
                            isSigner: !0,
                            isWritable: !1
                        }],
                        programId: this.programId,
                        data: o
                    })
                }
            }
            Cr.programId = new U("Stake11111111111111111111111111111111111111"), Cr.space = 200;
            class Ir {
                constructor(e, t, n, r) {
                    this.nodePubkey = void 0, this.authorizedVoter = void 0, this.authorizedWithdrawer = void 0, this.commission = void 0, this.nodePubkey = e, this.authorizedVoter = t, this.authorizedWithdrawer = n, this.commission = r
                }
            }
            class Ar {
                constructor() {}
                static decodeInstructionType(e) {
                    this.checkProgramId(e.programId);
                    const t = C.u32("instruction"),
                        n = t.decode(e.data);
                    let r;
                    for (const [o, i] of Object.entries(Or))
                        if (i.index == n) {
                            r = o;
                            break
                        }
                    if (!r) throw new Error("Instruction type incorrect; not a VoteInstruction");
                    return r
                }
                static decodeInitializeAccount(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 4);
                    const {
                        voteInit: t
                    } = xe(Or.InitializeAccount, e.data);
                    return {
                        votePubkey: e.keys[0].pubkey,
                        nodePubkey: e.keys[3].pubkey,
                        voteInit: new Ir(new U(t.nodePubkey), new U(t.authorizedVoter), new U(t.authorizedWithdrawer), t.commission)
                    }
                }
                static decodeAuthorize(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
                    const {
                        newAuthorized: t,
                        voteAuthorizationType: n
                    } = xe(Or.Authorize, e.data);
                    return {
                        votePubkey: e.keys[0].pubkey,
                        authorizedPubkey: e.keys[2].pubkey,
                        newAuthorizedPubkey: new U(t),
                        voteAuthorizationType: {
                            index: n
                        }
                    }
                }
                static decodeAuthorizeWithSeed(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
                    const {
                        voteAuthorizeWithSeedArgs: {
                            currentAuthorityDerivedKeyOwnerPubkey: t,
                            currentAuthorityDerivedKeySeed: n,
                            newAuthorized: r,
                            voteAuthorizationType: o
                        }
                    } = xe(Or.AuthorizeWithSeed, e.data);
                    return {
                        currentAuthorityDerivedKeyBasePubkey: e.keys[2].pubkey,
                        currentAuthorityDerivedKeyOwnerPubkey: new U(t),
                        currentAuthorityDerivedKeySeed: n,
                        newAuthorizedPubkey: new U(r),
                        voteAuthorizationType: {
                            index: o
                        },
                        votePubkey: e.keys[0].pubkey
                    }
                }
                static decodeWithdraw(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
                    const {
                        lamports: t
                    } = xe(Or.Withdraw, e.data);
                    return {
                        votePubkey: e.keys[0].pubkey,
                        authorizedWithdrawerPubkey: e.keys[2].pubkey,
                        lamports: t,
                        toPubkey: e.keys[1].pubkey
                    }
                }
                static checkProgramId(e) {
                    if (!e.equals(_r.programId)) throw new Error("invalid instruction; programId is not VoteProgram")
                }
                static checkKeyLength(e, t) {
                    if (e.length < t) throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)
                }
            }
            const Or = Object.freeze({
                    InitializeAccount: {
                        index: 0,
                        layout: C.struct([C.u32("instruction"), ee()])
                    },
                    Authorize: {
                        index: 1,
                        layout: C.struct([C.u32("instruction"), Y("newAuthorized"), C.u32("voteAuthorizationType")])
                    },
                    Withdraw: {
                        index: 3,
                        layout: C.struct([C.u32("instruction"), C.ns64("lamports")])
                    },
                    AuthorizeWithSeed: {
                        index: 10,
                        layout: C.struct([C.u32("instruction"), te()])
                    }
                }),
                xr = Object.freeze({
                    Voter: {
                        index: 0
                    },
                    Withdrawer: {
                        index: 1
                    }
                });
            class _r {
                constructor() {}
                static initializeAccount(e) {
                    const {
                        votePubkey: t,
                        nodePubkey: n,
                        voteInit: r
                    } = e, o = Or.InitializeAccount, i = Oe(o, {
                        voteInit: {
                            nodePubkey: R(r.nodePubkey.toBuffer()),
                            authorizedVoter: R(r.authorizedVoter.toBuffer()),
                            authorizedWithdrawer: R(r.authorizedWithdrawer.toBuffer()),
                            commission: r.commission
                        }
                    }), s = {
                        keys: [{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: we,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: fe,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: n,
                            isSigner: !0,
                            isWritable: !1
                        }],
                        programId: this.programId,
                        data: i
                    };
                    return new de(s)
                }
                static createAccount(e) {
                    const t = new he;
                    return t.add(Ne.createAccount({
                        fromPubkey: e.fromPubkey,
                        newAccountPubkey: e.votePubkey,
                        lamports: e.lamports,
                        space: this.space,
                        programId: this.programId
                    })), t.add(this.initializeAccount({
                        votePubkey: e.votePubkey,
                        nodePubkey: e.voteInit.nodePubkey,
                        voteInit: e.voteInit
                    }))
                }
                static authorize(e) {
                    const {
                        votePubkey: t,
                        authorizedPubkey: n,
                        newAuthorizedPubkey: r,
                        voteAuthorizationType: o
                    } = e, i = Or.Authorize, s = Oe(i, {
                        newAuthorized: R(r.toBuffer()),
                        voteAuthorizationType: o.index
                    }), a = [{
                        pubkey: t,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: fe,
                        isSigner: !1,
                        isWritable: !1
                    }, {
                        pubkey: n,
                        isSigner: !0,
                        isWritable: !1
                    }];
                    return (new he).add({
                        keys: a,
                        programId: this.programId,
                        data: s
                    })
                }
                static authorizeWithSeed(e) {
                    const {
                        currentAuthorityDerivedKeyBasePubkey: t,
                        currentAuthorityDerivedKeyOwnerPubkey: n,
                        currentAuthorityDerivedKeySeed: r,
                        newAuthorizedPubkey: o,
                        voteAuthorizationType: i,
                        votePubkey: s
                    } = e, a = Or.AuthorizeWithSeed, c = Oe(a, {
                        voteAuthorizeWithSeedArgs: {
                            currentAuthorityDerivedKeyOwnerPubkey: R(n.toBuffer()),
                            currentAuthorityDerivedKeySeed: r,
                            newAuthorized: R(o.toBuffer()),
                            voteAuthorizationType: i.index
                        }
                    }), u = [{
                        pubkey: s,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: fe,
                        isSigner: !1,
                        isWritable: !1
                    }, {
                        pubkey: t,
                        isSigner: !0,
                        isWritable: !1
                    }];
                    return (new he).add({
                        keys: u,
                        programId: this.programId,
                        data: c
                    })
                }
                static withdraw(e) {
                    const {
                        votePubkey: t,
                        authorizedWithdrawerPubkey: n,
                        lamports: r,
                        toPubkey: o
                    } = e, i = Or.Withdraw, s = Oe(i, {
                        lamports: r
                    }), a = [{
                        pubkey: t,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: o,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: n,
                        isSigner: !0,
                        isWritable: !1
                    }];
                    return (new he).add({
                        keys: a,
                        programId: this.programId,
                        data: s
                    })
                }
                static safeWithdraw(e, t, n) {
                    if (e.lamports > t - n) throw new Error("Withdraw will leave vote account with insuffcient funds.");
                    return _r.withdraw(e)
                }
            }
            _r.programId = new U("Vote111111111111111111111111111111111111111"), _r.space = 3731;
            const Er = new U("Va1idator1nfo111111111111111111111111111111"),
                Tr = h.type({
                    name: h.string(),
                    website: h.optional(h.string()),
                    details: h.optional(h.string()),
                    keybaseUsername: h.optional(h.string())
                });
            class Pr {
                constructor(e, t) {
                    this.key = void 0, this.info = void 0, this.key = e, this.info = t
                }
                static fromConfigData(e) {
                    let t = [...e];
                    const n = re(t);
                    if (2 !== n) return null;
                    const o = [];
                    for (let r = 0; r < 2; r++) {
                        const e = new U(t.slice(0, N));
                        t = t.slice(N);
                        const n = 1 === t.slice(0, 1)[0];
                        t = t.slice(1), o.push({
                            publicKey: e,
                            isSigner: n
                        })
                    }
                    if (o[0].publicKey.equals(Er) && o[1].isSigner) {
                        const e = Z().decode(r.Buffer.from(t)),
                            n = JSON.parse(e);
                        return h.assert(n, Tr), new Pr(o[1].publicKey, n)
                    }
                    return null
                }
            }
            const Rr = new U("Vote111111111111111111111111111111111111111"),
                jr = C.struct([Y("nodePubkey"), Y("authorizedWithdrawer"), C.u8("commission"), C.nu64(), C.seq(C.struct([C.nu64("slot"), C.u32("confirmationCount")]), C.offset(C.u32(), -8), "votes"), C.u8("rootSlotValid"), C.nu64("rootSlot"), C.nu64(), C.seq(C.struct([C.nu64("epoch"), Y("authorizedVoter")]), C.offset(C.u32(), -8), "authorizedVoters"), C.struct([C.seq(C.struct([Y("authorizedPubkey"), C.nu64("epochOfLastAuthorizedSwitch"), C.nu64("targetEpoch")]), 32, "buf"), C.nu64("idx"), C.u8("isEmpty")], "priorVoters"), C.nu64(), C.seq(C.struct([C.nu64("epoch"), C.nu64("credits"), C.nu64("prevCredits")]), C.offset(C.u32(), -8), "epochCredits"), C.struct([C.nu64("slot"), C.nu64("timestamp")], "lastTimestamp")]);
            class Br {
                constructor(e) {
                    this.nodePubkey = void 0, this.authorizedWithdrawer = void 0, this.commission = void 0, this.rootSlot = void 0, this.votes = void 0, this.authorizedVoters = void 0, this.priorVoters = void 0, this.epochCredits = void 0, this.lastTimestamp = void 0, this.nodePubkey = e.nodePubkey, this.authorizedWithdrawer = e.authorizedWithdrawer, this.commission = e.commission, this.rootSlot = e.rootSlot, this.votes = e.votes, this.authorizedVoters = e.authorizedVoters, this.priorVoters = e.priorVoters, this.epochCredits = e.epochCredits, this.lastTimestamp = e.lastTimestamp
                }
                static fromAccountData(e) {
                    const t = 4,
                        n = jr.decode(R(e), t);
                    let r = n.rootSlot;
                    return n.rootSlotValid || (r = null), new Br({
                        nodePubkey: new U(n.nodePubkey),
                        authorizedWithdrawer: new U(n.authorizedWithdrawer),
                        commission: n.commission,
                        votes: n.votes,
                        rootSlot: r,
                        authorizedVoters: n.authorizedVoters.map(Lr),
                        priorVoters: Nr(n.priorVoters),
                        epochCredits: n.epochCredits,
                        lastTimestamp: n.lastTimestamp
                    })
                }
            }

            function Lr({
                authorizedVoter: e,
                epoch: t
            }) {
                return {
                    epoch: t,
                    authorizedVoter: new U(e)
                }
            }

            function Wr({
                authorizedPubkey: e,
                epochOfLastAuthorizedSwitch: t,
                targetEpoch: n
            }) {
                return {
                    authorizedPubkey: new U(e),
                    epochOfLastAuthorizedSwitch: t,
                    targetEpoch: n
                }
            }

            function Nr({
                buf: e,
                idx: t,
                isEmpty: n
            }) {
                return n ? [] : [...e.slice(t + 1).map(Wr), ...e.slice(0, t).map(Wr)]
            }
            const Mr = {
                http: {
                    devnet: "http://api.devnet.solana.com",
                    testnet: "http://api.testnet.solana.com",
                    "mainnet-beta": "http://api.mainnet-beta.solana.com/"
                },
                https: {
                    devnet: "https://api.devnet.solana.com",
                    testnet: "https://api.testnet.solana.com",
                    "mainnet-beta": "https://api.mainnet-beta.solana.com/"
                }
            };

            function Kr(e, t) {
                const n = !1 === t ? "http" : "https";
                if (!e) return Mr[n]["devnet"];
                const r = Mr[n][e];
                if (!r) throw new Error(`Unknown ${n} cluster: ${e}`);
                return r
            }
            async function Ur(e, t, n, r) {
                let o, i;
                n && Object.prototype.hasOwnProperty.call(n, "lastValidBlockHeight") ? (o = n, i = r) : i = n;
                const s = i && {
                        skipPreflight: i.skipPreflight,
                        preflightCommitment: i.preflightCommitment || i.commitment,
                        minContextSlot: i.minContextSlot
                    },
                    a = await e.sendRawTransaction(t, s),
                    c = i && i.commitment,
                    u = o ? e.confirmTransaction(o, c) : e.confirmTransaction(a, c),
                    l = (await u).value;
                if (l.err) throw new Error(`Raw transaction ${a} failed (${JSON.stringify(l)})`);
                return a
            }
            const zr = 1e9;
            t.Account = z, t.AddressLookupTableAccount = at, t.AddressLookupTableInstruction = Qn, t.AddressLookupTableProgram = er, t.Authorized = mr, t.BLOCKHASH_CACHE_TIMEOUT_MS = ft, t.BPF_LOADER_DEPRECATED_PROGRAM_ID = D, t.BPF_LOADER_PROGRAM_ID = Ue, t.BpfLoader = ze, t.COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = nr, t.ComputeBudgetInstruction = tr, t.ComputeBudgetProgram = rr, t.Connection = Jn, t.Ed25519Program = cr, t.Enum = B, t.EpochSchedule = Je, t.FeeCalculatorLayout = _e, t.Keypair = Zn, t.LAMPORTS_PER_SOL = zr, t.LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Xn, t.Loader = Ke, t.Lockup = wr, t.MAX_SEED_LENGTH = W, t.Message = ae, t.MessageAccountKeys = G, t.MessageV0 = ce, t.NONCE_ACCOUNT_LENGTH = Te, t.NonceAccount = Pe, t.PACKET_DATA_SIZE = H, t.PUBLIC_KEY_LENGTH = N, t.PublicKey = U, t.SIGNATURE_LENGTH_IN_BYTES = $, t.SOLANA_SCHEMA = L, t.STAKE_CONFIG_ID = yr, t.STAKE_INSTRUCTION_LAYOUTS = vr, t.SYSTEM_INSTRUCTION_LAYOUTS = We, t.SYSVAR_CLOCK_PUBKEY = fe, t.SYSVAR_EPOCH_SCHEDULE_PUBKEY = be, t.SYSVAR_INSTRUCTIONS_PUBKEY = ye, t.SYSVAR_RECENT_BLOCKHASHES_PUBKEY = me, t.SYSVAR_RENT_PUBKEY = we, t.SYSVAR_REWARDS_PUBKEY = ke, t.SYSVAR_SLOT_HASHES_PUBKEY = ve, t.SYSVAR_SLOT_HISTORY_PUBKEY = Se, t.SYSVAR_STAKE_HISTORY_PUBKEY = Ce, t.Secp256k1Program = br, t.SendTransactionError = Ze, t.SolanaJSONRPCError = Qe, t.SolanaJSONRPCErrorCode = Xe, t.StakeAuthorizationLayout = Sr, t.StakeInstruction = kr, t.StakeProgram = Cr, t.Struct = j, t.SystemInstruction = Le, t.SystemProgram = Ne, t.Transaction = he, t.TransactionExpiredBlockheightExceededError = V, t.TransactionExpiredTimeoutError = F, t.TransactionInstruction = de, t.TransactionMessage = pe, t.VALIDATOR_INFO_KEY = Er, t.VERSION_PREFIX_MASK = q, t.VOTE_PROGRAM_ID = Rr, t.ValidatorInfo = Pr, t.VersionedMessage = ue, t.VersionedTransaction = ge, t.VoteAccount = Br, t.VoteAuthorizationLayout = xr, t.VoteInit = Ir, t.VoteInstruction = Ar, t.VoteProgram = _r, t.clusterApiUrl = Kr, t.sendAndConfirmRawTransaction = Ur, t.sendAndConfirmTransaction = Ie
        },
        "0609": function(e, t, n) {
            "use strict";

            function r(e, t, n) {
                if (n.length) {
                    e.push({
                        pubkey: t,
                        isSigner: !1,
                        isWritable: !1
                    });
                    for (const t of n) e.push({
                        pubkey: t.publicKey,
                        isSigner: !0,
                        isWritable: !1
                    })
                } else e.push({
                    pubkey: t,
                    isSigner: !0,
                    isWritable: !1
                });
                return e
            }
            n.d(t, "a", (function() {
                return r
            }))
        },
        "086c": function(e, t, n) {
            "use strict";
            (function(e) {
                n.d(t, "d", (function() {
                    return l
                })), n.d(t, "a", (function() {
                    return d
                })), n.d(t, "b", (function() {
                    return h
                })), n.d(t, "c", (function() {
                    return p
                }));
                var r = n("8df2"),
                    o = n("1c54"),
                    i = n("0276"),
                    s = n("4ae8"),
                    a = n("a15d"),
                    c = n("0609"),
                    u = n("5762");
                const l = Object(r["struct"])([Object(r["u8"])("instruction"), Object(o["u64"])("amount")]);

                function d(t, n, r, o, a = [], d = s["c"]) {
                    const h = Object(c["a"])([{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: n,
                            isSigner: !1,
                            isWritable: !0
                        }], r, a),
                        p = e.alloc(l.span);
                    return l.encode({
                        instruction: u["a"].Transfer,
                        amount: BigInt(o)
                    }, p), new i["TransactionInstruction"]({
                        keys: h,
                        programId: d,
                        data: p
                    })
                }

                function h(e, t = s["c"]) {
                    if (!e.programId.equals(t)) throw new a["g"];
                    if (e.data.length !== l.span) throw new a["e"];
                    const {
                        keys: {
                            source: n,
                            destination: r,
                            owner: o,
                            multiSigners: i
                        },
                        data: c
                    } = p(e);
                    if (c.instruction !== u["a"].Transfer) throw new a["h"];
                    if (!n || !r || !o) throw new a["f"];
                    return {
                        programId: t,
                        keys: {
                            source: n,
                            destination: r,
                            owner: o,
                            multiSigners: i
                        },
                        data: c
                    }
                }

                function p({
                    programId: e,
                    keys: [t, n, r, ...o],
                    data: i
                }) {
                    return {
                        programId: e,
                        keys: {
                            source: t,
                            destination: n,
                            owner: r,
                            multiSigners: o
                        },
                        data: l.decode(i)
                    }
                }
            }).call(this, n("b639").Buffer)
        },
        "10cb": function(e, t, n) {
            "use strict";
            var r = this && this.__importDefault || function(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.decimal = t.WAD = void 0;
            const o = r(n("901e")),
                i = n("ee73"),
                s = n("e093");
            t.WAD = new o.default("1e+18");
            const a = e => {
                const n = (0, s.u128)(e),
                    {
                        encode: r,
                        decode: a
                    } = (0, i.encodeDecode)(n),
                    c = n;
                return c.decode = (e, n) => {
                    const r = a(e, n).toString();
                    return new o.default(r).div(t.WAD)
                }, c.encode = (e, n, o) => {
                    const i = BigInt(e.times(t.WAD).integerValue().toString());
                    return r(i, n, o)
                }, c
            };
            t.decimal = a
        },
        "15ca": function(e, t, n) {
            "use strict";
            (function(e) {
                n.d(t, "d", (function() {
                    return l
                })), n.d(t, "a", (function() {
                    return d
                })), n.d(t, "b", (function() {
                    return h
                })), n.d(t, "c", (function() {
                    return p
                }));
                var r = n("8df2"),
                    o = n("1c54"),
                    i = n("0276"),
                    s = n("4ae8"),
                    a = n("a15d"),
                    c = n("0609"),
                    u = n("5762");
                const l = Object(r["struct"])([Object(r["u8"])("instruction"), Object(o["u64"])("amount"), Object(r["u8"])("decimals")]);

                function d(t, n, r, o, a, d, h = [], p = s["c"]) {
                    const g = Object(c["a"])([{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: n,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: r,
                            isSigner: !1,
                            isWritable: !0
                        }], o, h),
                        f = e.alloc(l.span);
                    return l.encode({
                        instruction: u["a"].TransferChecked,
                        amount: BigInt(a),
                        decimals: d
                    }, f), new i["TransactionInstruction"]({
                        keys: g,
                        programId: p,
                        data: f
                    })
                }

                function h(e, t = s["c"]) {
                    if (!e.programId.equals(t)) throw new a["g"];
                    if (e.data.length !== l.span) throw new a["e"];
                    const {
                        keys: {
                            source: n,
                            mint: r,
                            destination: o,
                            owner: i,
                            multiSigners: c
                        },
                        data: d
                    } = p(e);
                    if (d.instruction !== u["a"].TransferChecked) throw new a["h"];
                    if (!n || !r || !o || !i) throw new a["f"];
                    return {
                        programId: t,
                        keys: {
                            source: n,
                            mint: r,
                            destination: o,
                            owner: i,
                            multiSigners: c
                        },
                        data: d
                    }
                }

                function p({
                    programId: e,
                    keys: [t, n, r, o, ...i],
                    data: s
                }) {
                    return {
                        programId: e,
                        keys: {
                            source: t,
                            mint: n,
                            destination: r,
                            owner: o,
                            multiSigners: i
                        },
                        data: l.decode(s)
                    }
                }
            }).call(this, n("b639").Buffer)
        },
        1700: function(e, t, n) {
            "use strict";
            /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.randomBytes = t.wrapXOFConstructorWithOpts = t.wrapConstructorWithOpts = t.wrapConstructor = t.checkOpts = t.Hash = t.concatBytes = t.toBytes = t.utf8ToBytes = t.asyncLoop = t.nextTick = t.hexToBytes = t.bytesToHex = t.byteSwap32 = t.byteSwapIfBE = t.byteSwap = t.isLE = t.rotl = t.rotr = t.createView = t.u32 = t.u8 = t.isBytes = void 0;
            const r = n("3995"),
                o = n("0067");

            function i(e) {
                return e instanceof Uint8Array || null != e && "object" === typeof e && "Uint8Array" === e.constructor.name
            }
            t.isBytes = i;
            const s = e => new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
            t.u8 = s;
            const a = e => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4));
            t.u32 = a;
            const c = e => new DataView(e.buffer, e.byteOffset, e.byteLength);
            t.createView = c;
            const u = (e, t) => e << 32 - t | e >>> t;
            t.rotr = u;
            const l = (e, t) => e << t | e >>> 32 - t >>> 0;
            t.rotl = l, t.isLE = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0];
            const d = e => e << 24 & 4278190080 | e << 8 & 16711680 | e >>> 8 & 65280 | e >>> 24 & 255;

            function h(e) {
                for (let n = 0; n < e.length; n++) e[n] = (0, t.byteSwap)(e[n])
            }
            t.byteSwap = d, t.byteSwapIfBE = t.isLE ? e => e : e => (0, t.byteSwap)(e), t.byteSwap32 = h;
            const p = Array.from({
                length: 256
            }, (e, t) => t.toString(16).padStart(2, "0"));

            function g(e) {
                (0, o.bytes)(e);
                let t = "";
                for (let n = 0; n < e.length; n++) t += p[e[n]];
                return t
            }
            t.bytesToHex = g;
            const f = {
                _0: 48,
                _9: 57,
                _A: 65,
                _F: 70,
                _a: 97,
                _f: 102
            };

            function b(e) {
                return e >= f._0 && e <= f._9 ? e - f._0 : e >= f._A && e <= f._F ? e - (f._A - 10) : e >= f._a && e <= f._f ? e - (f._a - 10) : void 0
            }

            function y(e) {
                if ("string" !== typeof e) throw new Error("hex string expected, got " + typeof e);
                const t = e.length,
                    n = t / 2;
                if (t % 2) throw new Error("padded hex string expected, got unpadded hex of length " + t);
                const r = new Uint8Array(n);
                for (let o = 0, i = 0; o < n; o++, i += 2) {
                    const t = b(e.charCodeAt(i)),
                        n = b(e.charCodeAt(i + 1));
                    if (void 0 === t || void 0 === n) {
                        const t = e[i] + e[i + 1];
                        throw new Error('hex string expected, got non-hex character "' + t + '" at index ' + i)
                    }
                    r[o] = 16 * t + n
                }
                return r
            }
            t.hexToBytes = y;
            const m = async () => {};
            async function w(e, n, r) {
                let o = Date.now();
                for (let i = 0; i < e; i++) {
                    r(i);
                    const e = Date.now() - o;
                    e >= 0 && e < n || (await (0, t.nextTick)(), o += e)
                }
            }

            function k(e) {
                if ("string" !== typeof e) throw new Error("utf8ToBytes expected string, got " + typeof e);
                return new Uint8Array((new TextEncoder).encode(e))
            }

            function v(e) {
                return "string" === typeof e && (e = k(e)), (0, o.bytes)(e), e
            }

            function S(...e) {
                let t = 0;
                for (let r = 0; r < e.length; r++) {
                    const n = e[r];
                    (0, o.bytes)(n), t += n.length
                }
                const n = new Uint8Array(t);
                for (let r = 0, o = 0; r < e.length; r++) {
                    const t = e[r];
                    n.set(t, o), o += t.length
                }
                return n
            }
            t.nextTick = m, t.asyncLoop = w, t.utf8ToBytes = k, t.toBytes = v, t.concatBytes = S;
            class C {
                clone() {
                    return this._cloneInto()
                }
            }
            t.Hash = C;
            const I = {}.toString;

            function A(e, t) {
                if (void 0 !== t && "[object Object]" !== I.call(t)) throw new Error("Options should be object or undefined");
                const n = Object.assign(e, t);
                return n
            }

            function O(e) {
                const t = t => e().update(v(t)).digest(),
                    n = e();
                return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = () => e(), t
            }

            function x(e) {
                const t = (t, n) => e(n).update(v(t)).digest(),
                    n = e({});
                return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = t => e(t), t
            }

            function _(e) {
                const t = (t, n) => e(n).update(v(t)).digest(),
                    n = e({});
                return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = t => e(t), t
            }

            function E(e = 32) {
                if (r.crypto && "function" === typeof r.crypto.getRandomValues) return r.crypto.getRandomValues(new Uint8Array(e));
                throw new Error("crypto.getRandomValues must be defined")
            }
            t.checkOpts = A, t.wrapConstructor = O, t.wrapConstructorWithOpts = x, t.wrapXOFConstructorWithOpts = _, t.randomBytes = E
        },
        "1ac0": function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, "TokenInstruction", (function() {
                return r["a"]
            })), n.d(t, "initializeMintInstructionData", (function() {
                return o["d"]
            })), n.d(t, "createInitializeMintInstruction", (function() {
                return o["a"]
            })), n.d(t, "decodeInitializeMintInstruction", (function() {
                return o["b"]
            })), n.d(t, "decodeInitializeMintInstructionUnchecked", (function() {
                return o["c"]
            })), n.d(t, "initializeAccountInstructionData", (function() {
                return i["d"]
            })), n.d(t, "createInitializeAccountInstruction", (function() {
                return i["a"]
            })), n.d(t, "decodeInitializeAccountInstruction", (function() {
                return i["b"]
            })), n.d(t, "decodeInitializeAccountInstructionUnchecked", (function() {
                return i["c"]
            })), n.d(t, "initializeMultisigInstructionData", (function() {
                return s["d"]
            })), n.d(t, "createInitializeMultisigInstruction", (function() {
                return s["a"]
            })), n.d(t, "decodeInitializeMultisigInstruction", (function() {
                return s["b"]
            })), n.d(t, "decodeInitializeMultisigInstructionUnchecked", (function() {
                return s["c"]
            })), n.d(t, "transferInstructionData", (function() {
                return a["d"]
            })), n.d(t, "createTransferInstruction", (function() {
                return a["a"]
            })), n.d(t, "decodeTransferInstruction", (function() {
                return a["b"]
            })), n.d(t, "decodeTransferInstructionUnchecked", (function() {
                return a["c"]
            })), n.d(t, "approveInstructionData", (function() {
                return c["a"]
            })), n.d(t, "createApproveInstruction", (function() {
                return c["b"]
            })), n.d(t, "decodeApproveInstruction", (function() {
                return c["c"]
            })), n.d(t, "decodeApproveInstructionUnchecked", (function() {
                return c["d"]
            })), n.d(t, "revokeInstructionData", (function() {
                return u["d"]
            })), n.d(t, "createRevokeInstruction", (function() {
                return u["a"]
            })), n.d(t, "decodeRevokeInstruction", (function() {
                return u["b"]
            })), n.d(t, "decodeRevokeInstructionUnchecked", (function() {
                return u["c"]
            })), n.d(t, "AuthorityType", (function() {
                return l["a"]
            })), n.d(t, "setAuthorityInstructionData", (function() {
                return l["e"]
            })), n.d(t, "createSetAuthorityInstruction", (function() {
                return l["b"]
            })), n.d(t, "decodeSetAuthorityInstruction", (function() {
                return l["c"]
            })), n.d(t, "decodeSetAuthorityInstructionUnchecked", (function() {
                return l["d"]
            })), n.d(t, "mintToInstructionData", (function() {
                return d["d"]
            })), n.d(t, "createMintToInstruction", (function() {
                return d["a"]
            })), n.d(t, "decodeMintToInstruction", (function() {
                return d["b"]
            })), n.d(t, "decodeMintToInstructionUnchecked", (function() {
                return d["c"]
            })), n.d(t, "burnInstructionData", (function() {
                return h["a"]
            })), n.d(t, "createBurnInstruction", (function() {
                return h["b"]
            })), n.d(t, "decodeBurnInstruction", (function() {
                return h["c"]
            })), n.d(t, "decodeBurnInstructionUnchecked", (function() {
                return h["d"]
            })), n.d(t, "closeAccountInstructionData", (function() {
                return p["a"]
            })), n.d(t, "createCloseAccountInstruction", (function() {
                return p["b"]
            })), n.d(t, "decodeCloseAccountInstruction", (function() {
                return p["c"]
            })), n.d(t, "decodeCloseAccountInstructionUnchecked", (function() {
                return p["d"]
            })), n.d(t, "freezeAccountInstructionData", (function() {
                return g["d"]
            })), n.d(t, "createFreezeAccountInstruction", (function() {
                return g["a"]
            })), n.d(t, "decodeFreezeAccountInstruction", (function() {
                return g["b"]
            })), n.d(t, "decodeFreezeAccountInstructionUnchecked", (function() {
                return g["c"]
            })), n.d(t, "thawAccountInstructionData", (function() {
                return f["d"]
            })), n.d(t, "createThawAccountInstruction", (function() {
                return f["a"]
            })), n.d(t, "decodeThawAccountInstruction", (function() {
                return f["b"]
            })), n.d(t, "decodeThawAccountInstructionUnchecked", (function() {
                return f["c"]
            })), n.d(t, "transferCheckedInstructionData", (function() {
                return b["d"]
            })), n.d(t, "createTransferCheckedInstruction", (function() {
                return b["a"]
            })), n.d(t, "decodeTransferCheckedInstruction", (function() {
                return b["b"]
            })), n.d(t, "decodeTransferCheckedInstructionUnchecked", (function() {
                return b["c"]
            })), n.d(t, "approveCheckedInstructionData", (function() {
                return y["a"]
            })), n.d(t, "createApproveCheckedInstruction", (function() {
                return y["b"]
            })), n.d(t, "decodeApproveCheckedInstruction", (function() {
                return y["c"]
            })), n.d(t, "decodeApproveCheckedInstructionUnchecked", (function() {
                return y["d"]
            })), n.d(t, "mintToCheckedInstructionData", (function() {
                return m["d"]
            })), n.d(t, "createMintToCheckedInstruction", (function() {
                return m["a"]
            })), n.d(t, "decodeMintToCheckedInstruction", (function() {
                return m["b"]
            })), n.d(t, "decodeMintToCheckedInstructionUnchecked", (function() {
                return m["c"]
            })), n.d(t, "burnCheckedInstructionData", (function() {
                return w["a"]
            })), n.d(t, "createBurnCheckedInstruction", (function() {
                return w["b"]
            })), n.d(t, "decodeBurnCheckedInstruction", (function() {
                return w["c"]
            })), n.d(t, "decodeBurnCheckedInstructionUnchecked", (function() {
                return w["d"]
            })), n.d(t, "syncNativeInstructionData", (function() {
                return k["d"]
            })), n.d(t, "createSyncNativeInstruction", (function() {
                return k["a"]
            })), n.d(t, "decodeSyncNativeInstruction", (function() {
                return k["b"]
            })), n.d(t, "decodeSyncNativeInstructionUnchecked", (function() {
                return k["c"]
            })), n.d(t, "decodeInstruction", (function() {
                return I
            })), n.d(t, "isInitializeMintInstruction", (function() {
                return A
            })), n.d(t, "isInitializeAccountInstruction", (function() {
                return O
            })), n.d(t, "isInitializeMultisigInstruction", (function() {
                return x
            })), n.d(t, "isTransferInstruction", (function() {
                return _
            })), n.d(t, "isApproveInstruction", (function() {
                return E
            })), n.d(t, "isRevokeInstruction", (function() {
                return T
            })), n.d(t, "isSetAuthorityInstruction", (function() {
                return P
            })), n.d(t, "isMintToInstruction", (function() {
                return R
            })), n.d(t, "isBurnInstruction", (function() {
                return j
            })), n.d(t, "isCloseAccountInstruction", (function() {
                return B
            })), n.d(t, "isFreezeAccountInstruction", (function() {
                return L
            })), n.d(t, "isThawAccountInstruction", (function() {
                return W
            })), n.d(t, "isTransferCheckedInstruction", (function() {
                return N
            })), n.d(t, "isApproveCheckedInstruction", (function() {
                return M
            })), n.d(t, "isMintToCheckedInstruction", (function() {
                return K
            })), n.d(t, "isBurnCheckedInstruction", (function() {
                return U
            })), n.d(t, "isSyncNativeInstruction", (function() {
                return z
            })), n.d(t, "createAssociatedTokenAccountInstruction", (function() {
                return H["a"]
            })), n.d(t, "AccountState", (function() {
                return D
            })), n.d(t, "AccountLayout", (function() {
                return $
            })), n.d(t, "ACCOUNT_SIZE", (function() {
                return V
            })), n.d(t, "getAccount", (function() {
                return F
            })), n.d(t, "getMinimumBalanceForRentExemptAccount", (function() {
                return G
            })), n.d(t, "MintLayout", (function() {
                return J
            })), n.d(t, "MINT_SIZE", (function() {
                return Z
            })), n.d(t, "getMint", (function() {
                return X
            })), n.d(t, "getMinimumBalanceForRentExemptMint", (function() {
                return Q
            })), n.d(t, "getAssociatedTokenAddress", (function() {
                return ee
            })), n.d(t, "MultisigLayout", (function() {
                return te
            })), n.d(t, "MULTISIG_SIZE", (function() {
                return ne
            })), n.d(t, "getMultisig", (function() {
                return re
            })), n.d(t, "getMinimumBalanceForRentExemptMultisig", (function() {
                return oe
            })), n.d(t, "createMint", (function() {
                return ie
            })), n.d(t, "createAccount", (function() {
                return ae
            })), n.d(t, "createWrappedNativeAccount", (function() {
                return ce
            })), n.d(t, "createMultisig", (function() {
                return ue
            })), n.d(t, "transfer", (function() {
                return de
            })), n.d(t, "approve", (function() {
                return he
            })), n.d(t, "revoke", (function() {
                return pe
            })), n.d(t, "setAuthority", (function() {
                return ge
            })), n.d(t, "mintTo", (function() {
                return fe
            })), n.d(t, "burn", (function() {
                return be
            })), n.d(t, "closeAccount", (function() {
                return ye
            })), n.d(t, "freezeAccount", (function() {
                return me
            })), n.d(t, "thawAccount", (function() {
                return we
            })), n.d(t, "transferChecked", (function() {
                return ke
            })), n.d(t, "approveChecked", (function() {
                return ve
            })), n.d(t, "mintToChecked", (function() {
                return Se
            })), n.d(t, "burnChecked", (function() {
                return Ce
            })), n.d(t, "syncNative", (function() {
                return Ie
            })), n.d(t, "createAssociatedTokenAccount", (function() {
                return se
            })), n.d(t, "getOrCreateAssociatedTokenAccount", (function() {
                return Ae
            })), n.d(t, "TOKEN_PROGRAM_ID", (function() {
                return S["c"]
            })), n.d(t, "ASSOCIATED_TOKEN_PROGRAM_ID", (function() {
                return S["a"]
            })), n.d(t, "NATIVE_MINT", (function() {
                return S["b"]
            })), n.d(t, "TokenError", (function() {
                return C["b"]
            })), n.d(t, "TokenAccountNotFoundError", (function() {
                return C["a"]
            })), n.d(t, "TokenInvalidAccountOwnerError", (function() {
                return C["c"]
            })), n.d(t, "TokenInvalidAccountSizeError", (function() {
                return C["d"]
            })), n.d(t, "TokenInvalidMintError", (function() {
                return C["i"]
            })), n.d(t, "TokenInvalidOwnerError", (function() {
                return C["j"]
            })), n.d(t, "TokenOwnerOffCurveError", (function() {
                return C["k"]
            })), n.d(t, "TokenInvalidInstructionProgramError", (function() {
                return C["g"]
            })), n.d(t, "TokenInvalidInstructionKeysError", (function() {
                return C["f"]
            })), n.d(t, "TokenInvalidInstructionDataError", (function() {
                return C["e"]
            })), n.d(t, "TokenInvalidInstructionTypeError", (function() {
                return C["h"]
            }));
            var r = n("5762"),
                o = n("23ae"),
                i = n("568c"),
                s = n("abce"),
                a = n("086c"),
                c = n("9e49"),
                u = n("b962"),
                l = n("9f7c"),
                d = n("3ebd"),
                h = n("c4fe"),
                p = n("afea"),
                g = n("5f93"),
                f = n("a763"),
                b = n("15ca"),
                y = n("a6c0"),
                m = n("b192"),
                w = n("ce55"),
                k = n("4190"),
                v = n("8df2"),
                S = n("4ae8"),
                C = n("a15d");

            function I(e, t = S["c"]) {
                if (!e.data.length) throw new C["e"];
                const n = Object(v["u8"])().decode(e.data);
                if (n === r["a"].InitializeMint) return Object(o["b"])(e, t);
                if (n === r["a"].InitializeAccount) return Object(i["b"])(e, t);
                if (n === r["a"].InitializeMultisig) return Object(s["b"])(e, t);
                if (n === r["a"].Transfer) return Object(a["b"])(e, t);
                if (n === r["a"].Approve) return Object(c["c"])(e, t);
                if (n === r["a"].Revoke) return Object(u["b"])(e, t);
                if (n === r["a"].SetAuthority) return Object(l["c"])(e, t);
                if (n === r["a"].MintTo) return Object(d["b"])(e, t);
                if (n === r["a"].Burn) return Object(h["c"])(e, t);
                if (n === r["a"].CloseAccount) return Object(p["c"])(e, t);
                if (n === r["a"].FreezeAccount) return Object(g["b"])(e, t);
                if (n === r["a"].ThawAccount) return Object(f["b"])(e, t);
                if (n === r["a"].TransferChecked) return Object(b["b"])(e, t);
                if (n === r["a"].ApproveChecked) return Object(y["c"])(e, t);
                if (n === r["a"].MintToChecked) return Object(m["b"])(e, t);
                if (n === r["a"].BurnChecked) return Object(w["c"])(e, t);
                if (n === r["a"].InitializeAccount2) throw new C["h"];
                if (n === r["a"].SyncNative) return Object(k["b"])(e, t);
                if (n === r["a"].InitializeAccount3) throw new C["h"];
                if (n === r["a"].InitializeMultisig2) throw new C["h"];
                if (n === r["a"].InitializeMint2) throw new C["h"];
                throw new C["h"]
            }

            function A(e) {
                return e.data.instruction === r["a"].InitializeMint
            }

            function O(e) {
                return e.data.instruction === r["a"].InitializeAccount
            }

            function x(e) {
                return e.data.instruction === r["a"].InitializeMultisig
            }

            function _(e) {
                return e.data.instruction === r["a"].Transfer
            }

            function E(e) {
                return e.data.instruction === r["a"].Approve
            }

            function T(e) {
                return e.data.instruction === r["a"].Revoke
            }

            function P(e) {
                return e.data.instruction === r["a"].SetAuthority
            }

            function R(e) {
                return e.data.instruction === r["a"].MintTo
            }

            function j(e) {
                return e.data.instruction === r["a"].Burn
            }

            function B(e) {
                return e.data.instruction === r["a"].CloseAccount
            }

            function L(e) {
                return e.data.instruction === r["a"].FreezeAccount
            }

            function W(e) {
                return e.data.instruction === r["a"].ThawAccount
            }

            function N(e) {
                return e.data.instruction === r["a"].TransferChecked
            }

            function M(e) {
                return e.data.instruction === r["a"].ApproveChecked
            }

            function K(e) {
                return e.data.instruction === r["a"].MintToChecked
            }

            function U(e) {
                return e.data.instruction === r["a"].BurnChecked
            }

            function z(e) {
                return e.data.instruction === r["a"].SyncNative
            }
            var D, H = n("730b"),
                q = n("1c54");
            (function(e) {
                e[e["Uninitialized"] = 0] = "Uninitialized", e[e["Initialized"] = 1] = "Initialized", e[e["Frozen"] = 2] = "Frozen"
            })(D || (D = {}));
            const $ = Object(v["struct"])([Object(q["publicKey"])("mint"), Object(q["publicKey"])("owner"), Object(q["u64"])("amount"), Object(v["u32"])("delegateOption"), Object(q["publicKey"])("delegate"), Object(v["u8"])("state"), Object(v["u32"])("isNativeOption"), Object(q["u64"])("isNative"), Object(q["u64"])("delegatedAmount"), Object(v["u32"])("closeAuthorityOption"), Object(q["publicKey"])("closeAuthority")]),
                V = $.span;
            async function F(e, t, n, r = S["c"]) {
                const o = await e.getAccountInfo(t, n);
                if (!o) throw new C["a"];
                if (!o.owner.equals(r)) throw new C["c"];
                if (o.data.length != V) throw new C["d"];
                const i = $.decode(o.data);
                return {
                    address: t,
                    mint: i.mint,
                    owner: i.owner,
                    amount: i.amount,
                    delegate: i.delegateOption ? i.delegate : null,
                    delegatedAmount: i.delegatedAmount,
                    isInitialized: i.state !== D.Uninitialized,
                    isFrozen: i.state === D.Frozen,
                    isNative: !!i.isNativeOption,
                    rentExemptReserve: i.isNativeOption ? i.isNative : null,
                    closeAuthority: i.closeAuthorityOption ? i.closeAuthority : null
                }
            }
            async function G(e, t) {
                return await e.getMinimumBalanceForRentExemption(V, t)
            }
            var Y = n("0276");
            const J = Object(v["struct"])([Object(v["u32"])("mintAuthorityOption"), Object(q["publicKey"])("mintAuthority"), Object(q["u64"])("supply"), Object(v["u8"])("decimals"), Object(q["bool"])("isInitialized"), Object(v["u32"])("freezeAuthorityOption"), Object(q["publicKey"])("freezeAuthority")]),
                Z = J.span;
            async function X(e, t, n, r = S["c"]) {
                const o = await e.getAccountInfo(t, n);
                if (!o) throw new C["a"];
                if (!o.owner.equals(r)) throw new C["c"];
                if (o.data.length != Z) throw new C["d"];
                const i = J.decode(o.data);
                return {
                    address: t,
                    mintAuthority: i.mintAuthorityOption ? i.mintAuthority : null,
                    supply: i.supply,
                    decimals: i.decimals,
                    isInitialized: i.isInitialized,
                    freezeAuthority: i.freezeAuthorityOption ? i.freezeAuthority : null
                }
            }
            async function Q(e, t) {
                return await e.getMinimumBalanceForRentExemption(Z, t)
            }
            async function ee(e, t, n = !1, r = S["c"], o = S["a"]) {
                if (!n && !Y["PublicKey"].isOnCurve(t.toBuffer())) throw new C["k"];
                const [i] = await Y["PublicKey"].findProgramAddress([t.toBuffer(), r.toBuffer(), e.toBuffer()], o);
                return i
            }
            const te = Object(v["struct"])([Object(v["u8"])("m"), Object(v["u8"])("n"), Object(q["bool"])("isInitialized"), Object(q["publicKey"])("signer1"), Object(q["publicKey"])("signer2"), Object(q["publicKey"])("signer3"), Object(q["publicKey"])("signer4"), Object(q["publicKey"])("signer5"), Object(q["publicKey"])("signer6"), Object(q["publicKey"])("signer7"), Object(q["publicKey"])("signer8"), Object(q["publicKey"])("signer9"), Object(q["publicKey"])("signer10"), Object(q["publicKey"])("signer11")]),
                ne = te.span;
            async function re(e, t, n, r = S["c"]) {
                const o = await e.getAccountInfo(t, n);
                if (!o) throw new C["a"];
                if (!o.owner.equals(r)) throw new C["c"];
                if (o.data.length != ne) throw new C["d"];
                return {
                    address: t,
                    ...te.decode(o.data)
                }
            }
            async function oe(e, t) {
                return await e.getMinimumBalanceForRentExemption(ne, t)
            }
            async function ie(e, t, n, r, i, s = Y["Keypair"].generate(), a, c = S["c"]) {
                const u = await Q(e),
                    l = (new Y["Transaction"]).add(Y["SystemProgram"].createAccount({
                        fromPubkey: t.publicKey,
                        newAccountPubkey: s.publicKey,
                        space: Z,
                        lamports: u,
                        programId: c
                    }), Object(o["a"])(s.publicKey, i, n, r, c));
                return await Object(Y["sendAndConfirmTransaction"])(e, l, [t, s], a), s.publicKey
            }
            async function se(e, t, n, r, o, i = S["c"], s = S["a"]) {
                const a = await ee(n, r, !1, i, s),
                    c = (new Y["Transaction"]).add(Object(H["a"])(t.publicKey, a, r, n, i, s));
                return await Object(Y["sendAndConfirmTransaction"])(e, c, [t], o), a
            }
            async function ae(e, t, n, r, o, s, a = S["c"]) {
                if (!o) return await se(e, t, n, r, s, a);
                const c = await G(e),
                    u = (new Y["Transaction"]).add(Y["SystemProgram"].createAccount({
                        fromPubkey: t.publicKey,
                        newAccountPubkey: o.publicKey,
                        space: V,
                        lamports: c,
                        programId: a
                    }), Object(i["a"])(o.publicKey, n, r, a));
                return await Object(Y["sendAndConfirmTransaction"])(e, u, [t, o], s), o.publicKey
            }
            async function ce(e, t, n, r, o, s, a = S["c"]) {
                if (!r) return await ae(e, t, S["b"], n, o, s, a);
                if (!o) {
                    const o = await ee(S["b"], n, !1, a, S["a"]),
                        i = (new Y["Transaction"]).add(Object(H["a"])(t.publicKey, o, n, S["b"], a, S["a"]), Y["SystemProgram"].transfer({
                            fromPubkey: t.publicKey,
                            toPubkey: o,
                            lamports: r
                        }), Object(k["a"])(o, a));
                    return await Object(Y["sendAndConfirmTransaction"])(e, i, [t], s), o
                }
                const c = await G(e),
                    u = (new Y["Transaction"]).add(Y["SystemProgram"].createAccount({
                        fromPubkey: t.publicKey,
                        newAccountPubkey: o.publicKey,
                        space: V,
                        lamports: c,
                        programId: a
                    }), Y["SystemProgram"].transfer({
                        fromPubkey: t.publicKey,
                        toPubkey: o.publicKey,
                        lamports: r
                    }), Object(i["a"])(o.publicKey, S["b"], n, a));
                return await Object(Y["sendAndConfirmTransaction"])(e, u, [t, o], s), o.publicKey
            }
            async function ue(e, t, n, r, o = Y["Keypair"].generate(), i, a = S["c"]) {
                const c = await oe(e),
                    u = (new Y["Transaction"]).add(Y["SystemProgram"].createAccount({
                        fromPubkey: t.publicKey,
                        newAccountPubkey: o.publicKey,
                        space: ne,
                        lamports: c,
                        programId: a
                    }), Object(s["a"])(o.publicKey, n, r, a));
                return await Object(Y["sendAndConfirmTransaction"])(e, u, [t, o], i), o.publicKey
            }

            function le(e, t) {
                return e instanceof Y["PublicKey"] ? [e, t] : [e.publicKey, [e]]
            }
            async function de(e, t, n, r, o, i, s = [], c, u = S["c"]) {
                const [l, d] = le(o, s), h = (new Y["Transaction"]).add(Object(a["a"])(n, r, l, i, s, u));
                return await Object(Y["sendAndConfirmTransaction"])(e, h, [t, ...d], c)
            }
            async function he(e, t, n, r, o, i, s = [], a, u = S["c"]) {
                const [l, d] = le(o, s), h = (new Y["Transaction"]).add(Object(c["b"])(n, r, l, i, s, u));
                return await Object(Y["sendAndConfirmTransaction"])(e, h, [t, ...d], a)
            }
            async function pe(e, t, n, r, o = [], i, s = S["c"]) {
                const [a, c] = le(r, o), l = (new Y["Transaction"]).add(Object(u["a"])(n, a, o, s));
                return await Object(Y["sendAndConfirmTransaction"])(e, l, [t, ...c], i)
            }
            async function ge(e, t, n, r, o, i, s = [], a, c = S["c"]) {
                const [u, d] = le(r, s), h = (new Y["Transaction"]).add(Object(l["b"])(n, u, o, i, s, c));
                return await Object(Y["sendAndConfirmTransaction"])(e, h, [t, ...d], a)
            }
            async function fe(e, t, n, r, o, i, s = [], a, c = S["c"]) {
                const [u, l] = le(o, s), h = (new Y["Transaction"]).add(Object(d["a"])(n, r, u, i, s, c));
                return await Object(Y["sendAndConfirmTransaction"])(e, h, [t, ...l], a)
            }
            async function be(e, t, n, r, o, i, s = [], a, c = S["c"]) {
                const [u, l] = le(o, s), d = (new Y["Transaction"]).add(Object(h["b"])(n, r, u, i, s, c));
                return await Object(Y["sendAndConfirmTransaction"])(e, d, [t, ...l], a)
            }
            async function ye(e, t, n, r, o, i = [], s, a = S["c"]) {
                const [c, u] = le(o, i), l = (new Y["Transaction"]).add(Object(p["b"])(n, r, c, i, a));
                return await Object(Y["sendAndConfirmTransaction"])(e, l, [t, ...u], s)
            }
            async function me(e, t, n, r, o, i = [], s, a = S["c"]) {
                const [c, u] = le(o, i), l = (new Y["Transaction"]).add(Object(g["a"])(n, r, c, i, a));
                return await Object(Y["sendAndConfirmTransaction"])(e, l, [t, ...u], s)
            }
            async function we(e, t, n, r, o, i = [], s, a = S["c"]) {
                const [c, u] = le(o, i), l = (new Y["Transaction"]).add(Object(f["a"])(n, r, c, i, a));
                return await Object(Y["sendAndConfirmTransaction"])(e, l, [t, ...u], s)
            }
            async function ke(e, t, n, r, o, i, s, a, c = [], u, l = S["c"]) {
                const [d, h] = le(i, c), p = (new Y["Transaction"]).add(Object(b["a"])(n, r, o, d, s, a, c, l));
                return await Object(Y["sendAndConfirmTransaction"])(e, p, [t, ...h], u)
            }
            async function ve(e, t, n, r, o, i, s, a, c = [], u, l = S["c"]) {
                const [d, h] = le(i, c), p = (new Y["Transaction"]).add(Object(y["b"])(r, n, o, d, s, a, c, l));
                return await Object(Y["sendAndConfirmTransaction"])(e, p, [t, ...h], u)
            }
            async function Se(e, t, n, r, o, i, s, a = [], c, u = S["c"]) {
                const [l, d] = le(o, a), h = (new Y["Transaction"]).add(Object(m["a"])(n, r, l, i, s, a, u));
                return await Object(Y["sendAndConfirmTransaction"])(e, h, [t, ...d], c)
            }
            async function Ce(e, t, n, r, o, i, s, a = [], c, u = S["c"]) {
                const [l, d] = le(o, a), h = (new Y["Transaction"]).add(Object(w["b"])(n, r, l, i, s, a, u));
                return await Object(Y["sendAndConfirmTransaction"])(e, h, [t, ...d], c)
            }
            async function Ie(e, t, n, r, o = S["c"]) {
                const i = (new Y["Transaction"]).add(Object(k["a"])(n, o));
                return await Object(Y["sendAndConfirmTransaction"])(e, i, [t], r)
            }
            async function Ae(e, t, n, r, o = !1, i, s, a = S["c"], c = S["a"]) {
                const u = await ee(n, r, o, a, c);
                let l;
                try {
                    l = await F(e, u, i, a)
                } catch (d) {
                    if (!(d instanceof C["a"] || d instanceof C["c"])) throw d;
                    try {
                        const o = (new Y["Transaction"]).add(Object(H["a"])(t.publicKey, u, r, n, a, c));
                        await Object(Y["sendAndConfirmTransaction"])(e, o, [t], s)
                    } catch (d) {}
                    l = await F(e, u, i, a)
                }
                if (!l.mint.equals(n)) throw new C["i"];
                if (!l.owner.equals(r)) throw new C["j"];
                return l
            }
        },
        "1c54": function(e, t, n) {
            "use strict";
            var r = this && this.__createBinding || (Object.create ? function(e, t, n, r) {
                    void 0 === r && (r = n), Object.defineProperty(e, r, {
                        enumerable: !0,
                        get: function() {
                            return t[n]
                        }
                    })
                } : function(e, t, n, r) {
                    void 0 === r && (r = n), e[r] = t[n]
                }),
                o = this && this.__exportStar || function(e, t) {
                    for (var n in e) "default" === n || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n)
                };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), o(n("ee73"), t), o(n("e093"), t), o(n("10cb"), t), o(n("2aa1"), t), o(n("7d1c"), t)
        },
        "21fa": function(e, t, n) {
            "use strict";
            n.r(t),
                function(e) {
                    n.d(t, "Base64", (function() {
                        return y
                    })), n.d(t, "CHAIN", (function() {
                        return c
                    })), n.d(t, "CONNECT_EVENT_ERROR_CODES", (function() {
                        return r
                    })), n.d(t, "CONNECT_ITEM_ERROR_CODES", (function() {
                        return o
                    })), n.d(t, "DISCONNECT_ERROR_CODES", (function() {
                        return a
                    })), n.d(t, "SEND_TRANSACTION_ERROR_CODES", (function() {
                        return i
                    })), n.d(t, "SIGN_DATA_ERROR_CODES", (function() {
                        return s
                    })), n.d(t, "SessionCrypto", (function() {
                        return C
                    })), n.d(t, "concatUint8Arrays", (function() {
                        return m
                    })), n.d(t, "hexToByteArray", (function() {
                        return v
                    })), n.d(t, "isNode", (function() {
                        return S
                    })), n.d(t, "splitToUint8Arrays", (function() {
                        return w
                    })), n.d(t, "toHexString", (function() {
                        return k
                    }));
                    var r, o, i, s, a, c, u = n("427a"),
                        l = n.n(u),
                        d = n("2c8b"),
                        h = n.n(d);

                    function p(e, t) {
                        const n = l.a.encodeBase64(e);
                        return t ? encodeURIComponent(n) : n
                    }

                    function g(e, t) {
                        return t && (e = decodeURIComponent(e)), l.a.decodeBase64(e)
                    }

                    function f(e, t = !1) {
                        let n;
                        return e instanceof Uint8Array ? n = e : ("string" !== typeof e && (e = JSON.stringify(e)), n = l.a.decodeUTF8(e)), p(n, t)
                    }

                    function b(e, t = !1) {
                        const n = g(e, t);
                        return {
                            toString() {
                                return l.a.encodeUTF8(n)
                            },
                            toObject() {
                                try {
                                    return JSON.parse(l.a.encodeUTF8(n))
                                } catch (e) {
                                    return null
                                }
                            },
                            toUint8Array() {
                                return n
                            }
                        }
                    }(function(e) {
                        e[e["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR", e[e["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR", e[e["MANIFEST_NOT_FOUND_ERROR"] = 2] = "MANIFEST_NOT_FOUND_ERROR", e[e["MANIFEST_CONTENT_ERROR"] = 3] = "MANIFEST_CONTENT_ERROR", e[e["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR", e[e["USER_REJECTS_ERROR"] = 300] = "USER_REJECTS_ERROR", e[e["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED"
                    })(r || (r = {})),
                    function(e) {
                        e[e["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR", e[e["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED"
                    }(o || (o = {})),
                    function(e) {
                        e[e["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR", e[e["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR", e[e["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR", e[e["USER_REJECTS_ERROR"] = 300] = "USER_REJECTS_ERROR", e[e["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED"
                    }(i || (i = {})),
                    function(e) {
                        e[e["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR", e[e["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR", e[e["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR", e[e["USER_REJECTS_ERROR"] = 300] = "USER_REJECTS_ERROR", e[e["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED"
                    }(s || (s = {})),
                    function(e) {
                        e[e["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR", e[e["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR", e[e["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR", e[e["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED"
                    }(a || (a = {})),
                    function(e) {
                        e["MAINNET"] = "-239", e["TESTNET"] = "-3"
                    }(c || (c = {}));
                    const y = {
                        encode: f,
                        decode: b
                    };

                    function m(e, t) {
                        const n = new Uint8Array(e.length + t.length);
                        return n.set(e), n.set(t, e.length), n
                    }

                    function w(e, t) {
                        if (t >= e.length) throw new Error("Index is out of buffer");
                        const n = e.slice(0, t),
                            r = e.slice(t);
                        return [n, r]
                    }

                    function k(e) {
                        let t = "";
                        return e.forEach(e => {
                            t += ("0" + (255 & e).toString(16)).slice(-2)
                        }), t
                    }

                    function v(e) {
                        if (e.length % 2 !== 0) throw new Error(`Cannot convert ${e} to bytesArray`);
                        const t = new Uint8Array(e.length / 2);
                        for (let n = 0; n < e.length; n += 2) t[n / 2] = parseInt(e.slice(n, n + 2), 16);
                        return t
                    }

                    function S() {
                        return "undefined" !== typeof e && null != e.versions && null != e.versions.node
                    }
                    class C {
                        constructor(e) {
                            this.nonceLength = 24, this.keyPair = e ? this.createKeypairFromString(e) : this.createKeypair(), this.sessionId = k(this.keyPair.publicKey)
                        }
                        createKeypair() {
                            return h.a.box.keyPair()
                        }
                        createKeypairFromString(e) {
                            return {
                                publicKey: v(e.publicKey),
                                secretKey: v(e.secretKey)
                            }
                        }
                        createNonce() {
                            return h.a.randomBytes(this.nonceLength)
                        }
                        encrypt(e, t) {
                            const n = (new TextEncoder).encode(e),
                                r = this.createNonce(),
                                o = h.a.box(n, r, t, this.keyPair.secretKey);
                            return m(r, o)
                        }
                        decrypt(e, t) {
                            const [n, r] = w(e, this.nonceLength), o = h.a.box.open(r, n, t, this.keyPair.secretKey);
                            if (!o) throw new Error(`Decryption error: \n message: ${e.toString()} \n sender pubkey: ${t.toString()} \n keypair pubkey: ${this.keyPair.publicKey.toString()} \n keypair secretkey: ${this.keyPair.secretKey.toString()}`);
                            return (new TextDecoder).decode(o)
                        }
                        stringifyKeypair() {
                            return {
                                publicKey: k(this.keyPair.publicKey),
                                secretKey: k(this.keyPair.secretKey)
                            }
                        }
                    }
                }.call(this, n("4362"))
        },
        "23ae": function(e, t, n) {
            "use strict";
            (function(e) {
                n.d(t, "d", (function() {
                    return u
                })), n.d(t, "a", (function() {
                    return l
                })), n.d(t, "b", (function() {
                    return d
                })), n.d(t, "c", (function() {
                    return h
                }));
                var r = n("8df2"),
                    o = n("1c54"),
                    i = n("0276"),
                    s = n("4ae8"),
                    a = n("a15d"),
                    c = n("5762");
                const u = Object(r["struct"])([Object(r["u8"])("instruction"), Object(r["u8"])("decimals"), Object(o["publicKey"])("mintAuthority"), Object(r["u8"])("freezeAuthorityOption"), Object(o["publicKey"])("freezeAuthority")]);

                function l(t, n, r, o, a = s["c"]) {
                    const l = [{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: i["SYSVAR_RENT_PUBKEY"],
                            isSigner: !1,
                            isWritable: !1
                        }],
                        d = e.alloc(u.span);
                    return u.encode({
                        instruction: c["a"].InitializeMint,
                        decimals: n,
                        mintAuthority: r,
                        freezeAuthorityOption: o ? 1 : 0,
                        freezeAuthority: o || new i["PublicKey"](0)
                    }, d), new i["TransactionInstruction"]({
                        keys: l,
                        programId: a,
                        data: d
                    })
                }

                function d(e, t = s["c"]) {
                    if (!e.programId.equals(t)) throw new a["g"];
                    if (e.data.length !== u.span) throw new a["e"];
                    const {
                        keys: {
                            mint: n,
                            rent: r
                        },
                        data: o
                    } = h(e);
                    if (o.instruction !== c["a"].InitializeMint) throw new a["h"];
                    if (!n || !r) throw new a["f"];
                    return {
                        programId: t,
                        keys: {
                            mint: n,
                            rent: r
                        },
                        data: o
                    }
                }

                function h({
                    programId: e,
                    keys: [t, n],
                    data: r
                }) {
                    const {
                        instruction: o,
                        decimals: i,
                        mintAuthority: s,
                        freezeAuthorityOption: a,
                        freezeAuthority: c
                    } = u.decode(r);
                    return {
                        programId: e,
                        keys: {
                            mint: t,
                            rent: n
                        },
                        data: {
                            instruction: o,
                            decimals: i,
                            mintAuthority: s,
                            freezeAuthority: a ? c : null
                        }
                    }
                }
            }).call(this, n("b639").Buffer)
        },
        "2aa1": function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.bool = void 0;
            const r = n("8df2"),
                o = n("ee73"),
                i = e => {
                    const t = (0, r.u8)(e),
                        {
                            encode: n,
                            decode: i
                        } = (0, o.encodeDecode)(t),
                        s = t;
                    return s.decode = (e, t) => {
                        const n = i(e, t);
                        return !!n
                    }, s.encode = (e, t, r) => {
                        const o = Number(e);
                        return n(o, t, r)
                    }, s
                };
            t.bool = i
        },
        "2c8b": function(e, t, n) {
            (function(e) {
                "use strict";
                var t = function(e) {
                        var t, n = new Float64Array(16);
                        if (e)
                            for (t = 0; t < e.length; t++) n[t] = e[t];
                        return n
                    },
                    r = function() {
                        throw new Error("no PRNG")
                    },
                    o = new Uint8Array(16),
                    i = new Uint8Array(32);
                i[0] = 9;
                var s = t(),
                    a = t([1]),
                    c = t([56129, 1]),
                    u = t([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]),
                    l = t([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]),
                    d = t([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]),
                    h = t([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]),
                    p = t([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);

                function g(e, t, n, r) {
                    e[t] = n >> 24 & 255, e[t + 1] = n >> 16 & 255, e[t + 2] = n >> 8 & 255, e[t + 3] = 255 & n, e[t + 4] = r >> 24 & 255, e[t + 5] = r >> 16 & 255, e[t + 6] = r >> 8 & 255, e[t + 7] = 255 & r
                }

                function f(e, t, n, r, o) {
                    var i, s = 0;
                    for (i = 0; i < o; i++) s |= e[t + i] ^ n[r + i];
                    return (1 & s - 1 >>> 8) - 1
                }

                function b(e, t, n, r) {
                    return f(e, t, n, r, 16)
                }

                function y(e, t, n, r) {
                    return f(e, t, n, r, 32)
                }

                function m(e, t, n, r) {
                    for (var o, i = 255 & r[0] | (255 & r[1]) << 8 | (255 & r[2]) << 16 | (255 & r[3]) << 24, s = 255 & n[0] | (255 & n[1]) << 8 | (255 & n[2]) << 16 | (255 & n[3]) << 24, a = 255 & n[4] | (255 & n[5]) << 8 | (255 & n[6]) << 16 | (255 & n[7]) << 24, c = 255 & n[8] | (255 & n[9]) << 8 | (255 & n[10]) << 16 | (255 & n[11]) << 24, u = 255 & n[12] | (255 & n[13]) << 8 | (255 & n[14]) << 16 | (255 & n[15]) << 24, l = 255 & r[4] | (255 & r[5]) << 8 | (255 & r[6]) << 16 | (255 & r[7]) << 24, d = 255 & t[0] | (255 & t[1]) << 8 | (255 & t[2]) << 16 | (255 & t[3]) << 24, h = 255 & t[4] | (255 & t[5]) << 8 | (255 & t[6]) << 16 | (255 & t[7]) << 24, p = 255 & t[8] | (255 & t[9]) << 8 | (255 & t[10]) << 16 | (255 & t[11]) << 24, g = 255 & t[12] | (255 & t[13]) << 8 | (255 & t[14]) << 16 | (255 & t[15]) << 24, f = 255 & r[8] | (255 & r[9]) << 8 | (255 & r[10]) << 16 | (255 & r[11]) << 24, b = 255 & n[16] | (255 & n[17]) << 8 | (255 & n[18]) << 16 | (255 & n[19]) << 24, y = 255 & n[20] | (255 & n[21]) << 8 | (255 & n[22]) << 16 | (255 & n[23]) << 24, m = 255 & n[24] | (255 & n[25]) << 8 | (255 & n[26]) << 16 | (255 & n[27]) << 24, w = 255 & n[28] | (255 & n[29]) << 8 | (255 & n[30]) << 16 | (255 & n[31]) << 24, k = 255 & r[12] | (255 & r[13]) << 8 | (255 & r[14]) << 16 | (255 & r[15]) << 24, v = i, S = s, C = a, I = c, A = u, O = l, x = d, _ = h, E = p, T = g, P = f, R = b, j = y, B = m, L = w, W = k, N = 0; N < 20; N += 2) o = v + j | 0, A ^= o << 7 | o >>> 25, o = A + v | 0, E ^= o << 9 | o >>> 23, o = E + A | 0, j ^= o << 13 | o >>> 19, o = j + E | 0, v ^= o << 18 | o >>> 14, o = O + S | 0, T ^= o << 7 | o >>> 25, o = T + O | 0, B ^= o << 9 | o >>> 23, o = B + T | 0, S ^= o << 13 | o >>> 19, o = S + B | 0, O ^= o << 18 | o >>> 14, o = P + x | 0, L ^= o << 7 | o >>> 25, o = L + P | 0, C ^= o << 9 | o >>> 23, o = C + L | 0, x ^= o << 13 | o >>> 19, o = x + C | 0, P ^= o << 18 | o >>> 14, o = W + R | 0, I ^= o << 7 | o >>> 25, o = I + W | 0, _ ^= o << 9 | o >>> 23, o = _ + I | 0, R ^= o << 13 | o >>> 19, o = R + _ | 0, W ^= o << 18 | o >>> 14, o = v + I | 0, S ^= o << 7 | o >>> 25, o = S + v | 0, C ^= o << 9 | o >>> 23, o = C + S | 0, I ^= o << 13 | o >>> 19, o = I + C | 0, v ^= o << 18 | o >>> 14, o = O + A | 0, x ^= o << 7 | o >>> 25, o = x + O | 0, _ ^= o << 9 | o >>> 23, o = _ + x | 0, A ^= o << 13 | o >>> 19, o = A + _ | 0, O ^= o << 18 | o >>> 14, o = P + T | 0, R ^= o << 7 | o >>> 25, o = R + P | 0, E ^= o << 9 | o >>> 23, o = E + R | 0, T ^= o << 13 | o >>> 19, o = T + E | 0, P ^= o << 18 | o >>> 14, o = W + L | 0, j ^= o << 7 | o >>> 25, o = j + W | 0, B ^= o << 9 | o >>> 23, o = B + j | 0, L ^= o << 13 | o >>> 19, o = L + B | 0, W ^= o << 18 | o >>> 14;
                    v = v + i | 0, S = S + s | 0, C = C + a | 0, I = I + c | 0, A = A + u | 0, O = O + l | 0, x = x + d | 0, _ = _ + h | 0, E = E + p | 0, T = T + g | 0, P = P + f | 0, R = R + b | 0, j = j + y | 0, B = B + m | 0, L = L + w | 0, W = W + k | 0, e[0] = v >>> 0 & 255, e[1] = v >>> 8 & 255, e[2] = v >>> 16 & 255, e[3] = v >>> 24 & 255, e[4] = S >>> 0 & 255, e[5] = S >>> 8 & 255, e[6] = S >>> 16 & 255, e[7] = S >>> 24 & 255, e[8] = C >>> 0 & 255, e[9] = C >>> 8 & 255, e[10] = C >>> 16 & 255, e[11] = C >>> 24 & 255, e[12] = I >>> 0 & 255, e[13] = I >>> 8 & 255, e[14] = I >>> 16 & 255, e[15] = I >>> 24 & 255, e[16] = A >>> 0 & 255, e[17] = A >>> 8 & 255, e[18] = A >>> 16 & 255, e[19] = A >>> 24 & 255, e[20] = O >>> 0 & 255, e[21] = O >>> 8 & 255, e[22] = O >>> 16 & 255, e[23] = O >>> 24 & 255, e[24] = x >>> 0 & 255, e[25] = x >>> 8 & 255, e[26] = x >>> 16 & 255, e[27] = x >>> 24 & 255, e[28] = _ >>> 0 & 255, e[29] = _ >>> 8 & 255, e[30] = _ >>> 16 & 255, e[31] = _ >>> 24 & 255, e[32] = E >>> 0 & 255, e[33] = E >>> 8 & 255, e[34] = E >>> 16 & 255, e[35] = E >>> 24 & 255, e[36] = T >>> 0 & 255, e[37] = T >>> 8 & 255, e[38] = T >>> 16 & 255, e[39] = T >>> 24 & 255, e[40] = P >>> 0 & 255, e[41] = P >>> 8 & 255, e[42] = P >>> 16 & 255, e[43] = P >>> 24 & 255, e[44] = R >>> 0 & 255, e[45] = R >>> 8 & 255, e[46] = R >>> 16 & 255, e[47] = R >>> 24 & 255, e[48] = j >>> 0 & 255, e[49] = j >>> 8 & 255, e[50] = j >>> 16 & 255, e[51] = j >>> 24 & 255, e[52] = B >>> 0 & 255, e[53] = B >>> 8 & 255, e[54] = B >>> 16 & 255, e[55] = B >>> 24 & 255, e[56] = L >>> 0 & 255, e[57] = L >>> 8 & 255, e[58] = L >>> 16 & 255, e[59] = L >>> 24 & 255, e[60] = W >>> 0 & 255, e[61] = W >>> 8 & 255, e[62] = W >>> 16 & 255, e[63] = W >>> 24 & 255
                }

                function w(e, t, n, r) {
                    for (var o, i = 255 & r[0] | (255 & r[1]) << 8 | (255 & r[2]) << 16 | (255 & r[3]) << 24, s = 255 & n[0] | (255 & n[1]) << 8 | (255 & n[2]) << 16 | (255 & n[3]) << 24, a = 255 & n[4] | (255 & n[5]) << 8 | (255 & n[6]) << 16 | (255 & n[7]) << 24, c = 255 & n[8] | (255 & n[9]) << 8 | (255 & n[10]) << 16 | (255 & n[11]) << 24, u = 255 & n[12] | (255 & n[13]) << 8 | (255 & n[14]) << 16 | (255 & n[15]) << 24, l = 255 & r[4] | (255 & r[5]) << 8 | (255 & r[6]) << 16 | (255 & r[7]) << 24, d = 255 & t[0] | (255 & t[1]) << 8 | (255 & t[2]) << 16 | (255 & t[3]) << 24, h = 255 & t[4] | (255 & t[5]) << 8 | (255 & t[6]) << 16 | (255 & t[7]) << 24, p = 255 & t[8] | (255 & t[9]) << 8 | (255 & t[10]) << 16 | (255 & t[11]) << 24, g = 255 & t[12] | (255 & t[13]) << 8 | (255 & t[14]) << 16 | (255 & t[15]) << 24, f = 255 & r[8] | (255 & r[9]) << 8 | (255 & r[10]) << 16 | (255 & r[11]) << 24, b = 255 & n[16] | (255 & n[17]) << 8 | (255 & n[18]) << 16 | (255 & n[19]) << 24, y = 255 & n[20] | (255 & n[21]) << 8 | (255 & n[22]) << 16 | (255 & n[23]) << 24, m = 255 & n[24] | (255 & n[25]) << 8 | (255 & n[26]) << 16 | (255 & n[27]) << 24, w = 255 & n[28] | (255 & n[29]) << 8 | (255 & n[30]) << 16 | (255 & n[31]) << 24, k = 255 & r[12] | (255 & r[13]) << 8 | (255 & r[14]) << 16 | (255 & r[15]) << 24, v = i, S = s, C = a, I = c, A = u, O = l, x = d, _ = h, E = p, T = g, P = f, R = b, j = y, B = m, L = w, W = k, N = 0; N < 20; N += 2) o = v + j | 0, A ^= o << 7 | o >>> 25, o = A + v | 0, E ^= o << 9 | o >>> 23, o = E + A | 0, j ^= o << 13 | o >>> 19, o = j + E | 0, v ^= o << 18 | o >>> 14, o = O + S | 0, T ^= o << 7 | o >>> 25, o = T + O | 0, B ^= o << 9 | o >>> 23, o = B + T | 0, S ^= o << 13 | o >>> 19, o = S + B | 0, O ^= o << 18 | o >>> 14, o = P + x | 0, L ^= o << 7 | o >>> 25, o = L + P | 0, C ^= o << 9 | o >>> 23, o = C + L | 0, x ^= o << 13 | o >>> 19, o = x + C | 0, P ^= o << 18 | o >>> 14, o = W + R | 0, I ^= o << 7 | o >>> 25, o = I + W | 0, _ ^= o << 9 | o >>> 23, o = _ + I | 0, R ^= o << 13 | o >>> 19, o = R + _ | 0, W ^= o << 18 | o >>> 14, o = v + I | 0, S ^= o << 7 | o >>> 25, o = S + v | 0, C ^= o << 9 | o >>> 23, o = C + S | 0, I ^= o << 13 | o >>> 19, o = I + C | 0, v ^= o << 18 | o >>> 14, o = O + A | 0, x ^= o << 7 | o >>> 25, o = x + O | 0, _ ^= o << 9 | o >>> 23, o = _ + x | 0, A ^= o << 13 | o >>> 19, o = A + _ | 0, O ^= o << 18 | o >>> 14, o = P + T | 0, R ^= o << 7 | o >>> 25, o = R + P | 0, E ^= o << 9 | o >>> 23, o = E + R | 0, T ^= o << 13 | o >>> 19, o = T + E | 0, P ^= o << 18 | o >>> 14, o = W + L | 0, j ^= o << 7 | o >>> 25, o = j + W | 0, B ^= o << 9 | o >>> 23, o = B + j | 0, L ^= o << 13 | o >>> 19, o = L + B | 0, W ^= o << 18 | o >>> 14;
                    e[0] = v >>> 0 & 255, e[1] = v >>> 8 & 255, e[2] = v >>> 16 & 255, e[3] = v >>> 24 & 255, e[4] = O >>> 0 & 255, e[5] = O >>> 8 & 255, e[6] = O >>> 16 & 255, e[7] = O >>> 24 & 255, e[8] = P >>> 0 & 255, e[9] = P >>> 8 & 255, e[10] = P >>> 16 & 255, e[11] = P >>> 24 & 255, e[12] = W >>> 0 & 255, e[13] = W >>> 8 & 255, e[14] = W >>> 16 & 255, e[15] = W >>> 24 & 255, e[16] = x >>> 0 & 255, e[17] = x >>> 8 & 255, e[18] = x >>> 16 & 255, e[19] = x >>> 24 & 255, e[20] = _ >>> 0 & 255, e[21] = _ >>> 8 & 255, e[22] = _ >>> 16 & 255, e[23] = _ >>> 24 & 255, e[24] = E >>> 0 & 255, e[25] = E >>> 8 & 255, e[26] = E >>> 16 & 255, e[27] = E >>> 24 & 255, e[28] = T >>> 0 & 255, e[29] = T >>> 8 & 255, e[30] = T >>> 16 & 255, e[31] = T >>> 24 & 255
                }

                function k(e, t, n, r) {
                    m(e, t, n, r)
                }

                function v(e, t, n, r) {
                    w(e, t, n, r)
                }
                var S = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);

                function C(e, t, n, r, o, i, s) {
                    var a, c, u = new Uint8Array(16),
                        l = new Uint8Array(64);
                    for (c = 0; c < 16; c++) u[c] = 0;
                    for (c = 0; c < 8; c++) u[c] = i[c];
                    while (o >= 64) {
                        for (k(l, u, s, S), c = 0; c < 64; c++) e[t + c] = n[r + c] ^ l[c];
                        for (a = 1, c = 8; c < 16; c++) a = a + (255 & u[c]) | 0, u[c] = 255 & a, a >>>= 8;
                        o -= 64, t += 64, r += 64
                    }
                    if (o > 0)
                        for (k(l, u, s, S), c = 0; c < o; c++) e[t + c] = n[r + c] ^ l[c];
                    return 0
                }

                function I(e, t, n, r, o) {
                    var i, s, a = new Uint8Array(16),
                        c = new Uint8Array(64);
                    for (s = 0; s < 16; s++) a[s] = 0;
                    for (s = 0; s < 8; s++) a[s] = r[s];
                    while (n >= 64) {
                        for (k(c, a, o, S), s = 0; s < 64; s++) e[t + s] = c[s];
                        for (i = 1, s = 8; s < 16; s++) i = i + (255 & a[s]) | 0, a[s] = 255 & i, i >>>= 8;
                        n -= 64, t += 64
                    }
                    if (n > 0)
                        for (k(c, a, o, S), s = 0; s < n; s++) e[t + s] = c[s];
                    return 0
                }

                function A(e, t, n, r, o) {
                    var i = new Uint8Array(32);
                    v(i, r, o, S);
                    for (var s = new Uint8Array(8), a = 0; a < 8; a++) s[a] = r[a + 16];
                    return I(e, t, n, s, i)
                }

                function O(e, t, n, r, o, i, s) {
                    var a = new Uint8Array(32);
                    v(a, i, s, S);
                    for (var c = new Uint8Array(8), u = 0; u < 8; u++) c[u] = i[u + 16];
                    return C(e, t, n, r, o, c, a)
                }
                var x = function(e) {
                    var t, n, r, o, i, s, a, c;
                    this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0, t = 255 & e[0] | (255 & e[1]) << 8, this.r[0] = 8191 & t, n = 255 & e[2] | (255 & e[3]) << 8, this.r[1] = 8191 & (t >>> 13 | n << 3), r = 255 & e[4] | (255 & e[5]) << 8, this.r[2] = 7939 & (n >>> 10 | r << 6), o = 255 & e[6] | (255 & e[7]) << 8, this.r[3] = 8191 & (r >>> 7 | o << 9), i = 255 & e[8] | (255 & e[9]) << 8, this.r[4] = 255 & (o >>> 4 | i << 12), this.r[5] = i >>> 1 & 8190, s = 255 & e[10] | (255 & e[11]) << 8, this.r[6] = 8191 & (i >>> 14 | s << 2), a = 255 & e[12] | (255 & e[13]) << 8, this.r[7] = 8065 & (s >>> 11 | a << 5), c = 255 & e[14] | (255 & e[15]) << 8, this.r[8] = 8191 & (a >>> 8 | c << 8), this.r[9] = c >>> 5 & 127, this.pad[0] = 255 & e[16] | (255 & e[17]) << 8, this.pad[1] = 255 & e[18] | (255 & e[19]) << 8, this.pad[2] = 255 & e[20] | (255 & e[21]) << 8, this.pad[3] = 255 & e[22] | (255 & e[23]) << 8, this.pad[4] = 255 & e[24] | (255 & e[25]) << 8, this.pad[5] = 255 & e[26] | (255 & e[27]) << 8, this.pad[6] = 255 & e[28] | (255 & e[29]) << 8, this.pad[7] = 255 & e[30] | (255 & e[31]) << 8
                };

                function _(e, t, n, r, o, i) {
                    var s = new x(i);
                    return s.update(n, r, o), s.finish(e, t), 0
                }

                function E(e, t, n, r, o, i) {
                    var s = new Uint8Array(16);
                    return _(s, 0, n, r, o, i), b(e, t, s, 0)
                }

                function T(e, t, n, r, o) {
                    var i;
                    if (n < 32) return -1;
                    for (O(e, 0, t, 0, n, r, o), _(e, 16, e, 32, n - 32, e), i = 0; i < 16; i++) e[i] = 0;
                    return 0
                }

                function P(e, t, n, r, o) {
                    var i, s = new Uint8Array(32);
                    if (n < 32) return -1;
                    if (A(s, 0, 32, r, o), 0 !== E(t, 16, t, 32, n - 32, s)) return -1;
                    for (O(e, 0, t, 0, n, r, o), i = 0; i < 32; i++) e[i] = 0;
                    return 0
                }

                function R(e, t) {
                    var n;
                    for (n = 0; n < 16; n++) e[n] = 0 | t[n]
                }

                function j(e) {
                    var t, n, r = 1;
                    for (t = 0; t < 16; t++) n = e[t] + r + 65535, r = Math.floor(n / 65536), e[t] = n - 65536 * r;
                    e[0] += r - 1 + 37 * (r - 1)
                }

                function B(e, t, n) {
                    for (var r, o = ~(n - 1), i = 0; i < 16; i++) r = o & (e[i] ^ t[i]), e[i] ^= r, t[i] ^= r
                }

                function L(e, n) {
                    var r, o, i, s = t(),
                        a = t();
                    for (r = 0; r < 16; r++) a[r] = n[r];
                    for (j(a), j(a), j(a), o = 0; o < 2; o++) {
                        for (s[0] = a[0] - 65517, r = 1; r < 15; r++) s[r] = a[r] - 65535 - (s[r - 1] >> 16 & 1), s[r - 1] &= 65535;
                        s[15] = a[15] - 32767 - (s[14] >> 16 & 1), i = s[15] >> 16 & 1, s[14] &= 65535, B(a, s, 1 - i)
                    }
                    for (r = 0; r < 16; r++) e[2 * r] = 255 & a[r], e[2 * r + 1] = a[r] >> 8
                }

                function W(e, t) {
                    var n = new Uint8Array(32),
                        r = new Uint8Array(32);
                    return L(n, e), L(r, t), y(n, 0, r, 0)
                }

                function N(e) {
                    var t = new Uint8Array(32);
                    return L(t, e), 1 & t[0]
                }

                function M(e, t) {
                    var n;
                    for (n = 0; n < 16; n++) e[n] = t[2 * n] + (t[2 * n + 1] << 8);
                    e[15] &= 32767
                }

                function K(e, t, n) {
                    for (var r = 0; r < 16; r++) e[r] = t[r] + n[r]
                }

                function U(e, t, n) {
                    for (var r = 0; r < 16; r++) e[r] = t[r] - n[r]
                }

                function z(e, t, n) {
                    var r, o, i = 0,
                        s = 0,
                        a = 0,
                        c = 0,
                        u = 0,
                        l = 0,
                        d = 0,
                        h = 0,
                        p = 0,
                        g = 0,
                        f = 0,
                        b = 0,
                        y = 0,
                        m = 0,
                        w = 0,
                        k = 0,
                        v = 0,
                        S = 0,
                        C = 0,
                        I = 0,
                        A = 0,
                        O = 0,
                        x = 0,
                        _ = 0,
                        E = 0,
                        T = 0,
                        P = 0,
                        R = 0,
                        j = 0,
                        B = 0,
                        L = 0,
                        W = n[0],
                        N = n[1],
                        M = n[2],
                        K = n[3],
                        U = n[4],
                        z = n[5],
                        D = n[6],
                        H = n[7],
                        q = n[8],
                        $ = n[9],
                        V = n[10],
                        F = n[11],
                        G = n[12],
                        Y = n[13],
                        J = n[14],
                        Z = n[15];
                    r = t[0], i += r * W, s += r * N, a += r * M, c += r * K, u += r * U, l += r * z, d += r * D, h += r * H, p += r * q, g += r * $, f += r * V, b += r * F, y += r * G, m += r * Y, w += r * J, k += r * Z, r = t[1], s += r * W, a += r * N, c += r * M, u += r * K, l += r * U, d += r * z, h += r * D, p += r * H, g += r * q, f += r * $, b += r * V, y += r * F, m += r * G, w += r * Y, k += r * J, v += r * Z, r = t[2], a += r * W, c += r * N, u += r * M, l += r * K, d += r * U, h += r * z, p += r * D, g += r * H, f += r * q, b += r * $, y += r * V, m += r * F, w += r * G, k += r * Y, v += r * J, S += r * Z, r = t[3], c += r * W, u += r * N, l += r * M, d += r * K, h += r * U, p += r * z, g += r * D, f += r * H, b += r * q, y += r * $, m += r * V, w += r * F, k += r * G, v += r * Y, S += r * J, C += r * Z, r = t[4], u += r * W, l += r * N, d += r * M, h += r * K, p += r * U, g += r * z, f += r * D, b += r * H, y += r * q, m += r * $, w += r * V, k += r * F, v += r * G, S += r * Y, C += r * J, I += r * Z, r = t[5], l += r * W, d += r * N, h += r * M, p += r * K, g += r * U, f += r * z, b += r * D, y += r * H, m += r * q, w += r * $, k += r * V, v += r * F, S += r * G, C += r * Y, I += r * J, A += r * Z, r = t[6], d += r * W, h += r * N, p += r * M, g += r * K, f += r * U, b += r * z, y += r * D, m += r * H, w += r * q, k += r * $, v += r * V, S += r * F, C += r * G, I += r * Y, A += r * J, O += r * Z, r = t[7], h += r * W, p += r * N, g += r * M, f += r * K, b += r * U, y += r * z, m += r * D, w += r * H, k += r * q, v += r * $, S += r * V, C += r * F, I += r * G, A += r * Y, O += r * J, x += r * Z, r = t[8], p += r * W, g += r * N, f += r * M, b += r * K, y += r * U, m += r * z, w += r * D, k += r * H, v += r * q, S += r * $, C += r * V, I += r * F, A += r * G, O += r * Y, x += r * J, _ += r * Z, r = t[9], g += r * W, f += r * N, b += r * M, y += r * K, m += r * U, w += r * z, k += r * D, v += r * H, S += r * q, C += r * $, I += r * V, A += r * F, O += r * G, x += r * Y, _ += r * J, E += r * Z, r = t[10], f += r * W, b += r * N, y += r * M, m += r * K, w += r * U, k += r * z, v += r * D, S += r * H, C += r * q, I += r * $, A += r * V, O += r * F, x += r * G, _ += r * Y, E += r * J, T += r * Z, r = t[11], b += r * W, y += r * N, m += r * M, w += r * K, k += r * U, v += r * z, S += r * D, C += r * H, I += r * q, A += r * $, O += r * V, x += r * F, _ += r * G, E += r * Y, T += r * J, P += r * Z, r = t[12], y += r * W, m += r * N, w += r * M, k += r * K, v += r * U, S += r * z, C += r * D, I += r * H, A += r * q, O += r * $, x += r * V, _ += r * F, E += r * G, T += r * Y, P += r * J, R += r * Z, r = t[13], m += r * W, w += r * N, k += r * M, v += r * K, S += r * U, C += r * z, I += r * D, A += r * H, O += r * q, x += r * $, _ += r * V, E += r * F, T += r * G, P += r * Y, R += r * J, j += r * Z, r = t[14], w += r * W, k += r * N, v += r * M, S += r * K, C += r * U, I += r * z, A += r * D, O += r * H, x += r * q, _ += r * $, E += r * V, T += r * F, P += r * G, R += r * Y, j += r * J, B += r * Z, r = t[15], k += r * W, v += r * N, S += r * M, C += r * K, I += r * U, A += r * z, O += r * D, x += r * H, _ += r * q, E += r * $, T += r * V, P += r * F, R += r * G, j += r * Y, B += r * J, L += r * Z, i += 38 * v, s += 38 * S, a += 38 * C, c += 38 * I, u += 38 * A, l += 38 * O, d += 38 * x, h += 38 * _, p += 38 * E, g += 38 * T, f += 38 * P, b += 38 * R, y += 38 * j, m += 38 * B, w += 38 * L, o = 1, r = i + o + 65535, o = Math.floor(r / 65536), i = r - 65536 * o, r = s + o + 65535, o = Math.floor(r / 65536), s = r - 65536 * o, r = a + o + 65535, o = Math.floor(r / 65536), a = r - 65536 * o, r = c + o + 65535, o = Math.floor(r / 65536), c = r - 65536 * o, r = u + o + 65535, o = Math.floor(r / 65536), u = r - 65536 * o, r = l + o + 65535, o = Math.floor(r / 65536), l = r - 65536 * o, r = d + o + 65535, o = Math.floor(r / 65536), d = r - 65536 * o, r = h + o + 65535, o = Math.floor(r / 65536), h = r - 65536 * o, r = p + o + 65535, o = Math.floor(r / 65536), p = r - 65536 * o, r = g + o + 65535, o = Math.floor(r / 65536), g = r - 65536 * o, r = f + o + 65535, o = Math.floor(r / 65536), f = r - 65536 * o, r = b + o + 65535, o = Math.floor(r / 65536), b = r - 65536 * o, r = y + o + 65535, o = Math.floor(r / 65536), y = r - 65536 * o, r = m + o + 65535, o = Math.floor(r / 65536), m = r - 65536 * o, r = w + o + 65535, o = Math.floor(r / 65536), w = r - 65536 * o, r = k + o + 65535, o = Math.floor(r / 65536), k = r - 65536 * o, i += o - 1 + 37 * (o - 1), o = 1, r = i + o + 65535, o = Math.floor(r / 65536), i = r - 65536 * o, r = s + o + 65535, o = Math.floor(r / 65536), s = r - 65536 * o, r = a + o + 65535, o = Math.floor(r / 65536), a = r - 65536 * o, r = c + o + 65535, o = Math.floor(r / 65536), c = r - 65536 * o, r = u + o + 65535, o = Math.floor(r / 65536), u = r - 65536 * o, r = l + o + 65535, o = Math.floor(r / 65536), l = r - 65536 * o, r = d + o + 65535, o = Math.floor(r / 65536), d = r - 65536 * o, r = h + o + 65535, o = Math.floor(r / 65536), h = r - 65536 * o, r = p + o + 65535, o = Math.floor(r / 65536), p = r - 65536 * o, r = g + o + 65535, o = Math.floor(r / 65536), g = r - 65536 * o, r = f + o + 65535, o = Math.floor(r / 65536), f = r - 65536 * o, r = b + o + 65535, o = Math.floor(r / 65536), b = r - 65536 * o, r = y + o + 65535, o = Math.floor(r / 65536), y = r - 65536 * o, r = m + o + 65535, o = Math.floor(r / 65536), m = r - 65536 * o, r = w + o + 65535, o = Math.floor(r / 65536), w = r - 65536 * o, r = k + o + 65535, o = Math.floor(r / 65536), k = r - 65536 * o, i += o - 1 + 37 * (o - 1), e[0] = i, e[1] = s, e[2] = a, e[3] = c, e[4] = u, e[5] = l, e[6] = d, e[7] = h, e[8] = p, e[9] = g, e[10] = f, e[11] = b, e[12] = y, e[13] = m, e[14] = w, e[15] = k
                }

                function D(e, t) {
                    z(e, t, t)
                }

                function H(e, n) {
                    var r, o = t();
                    for (r = 0; r < 16; r++) o[r] = n[r];
                    for (r = 253; r >= 0; r--) D(o, o), 2 !== r && 4 !== r && z(o, o, n);
                    for (r = 0; r < 16; r++) e[r] = o[r]
                }

                function q(e, n) {
                    var r, o = t();
                    for (r = 0; r < 16; r++) o[r] = n[r];
                    for (r = 250; r >= 0; r--) D(o, o), 1 !== r && z(o, o, n);
                    for (r = 0; r < 16; r++) e[r] = o[r]
                }

                function $(e, n, r) {
                    var o, i, s = new Uint8Array(32),
                        a = new Float64Array(80),
                        u = t(),
                        l = t(),
                        d = t(),
                        h = t(),
                        p = t(),
                        g = t();
                    for (i = 0; i < 31; i++) s[i] = n[i];
                    for (s[31] = 127 & n[31] | 64, s[0] &= 248, M(a, r), i = 0; i < 16; i++) l[i] = a[i], h[i] = u[i] = d[i] = 0;
                    for (u[0] = h[0] = 1, i = 254; i >= 0; --i) o = s[i >>> 3] >>> (7 & i) & 1, B(u, l, o), B(d, h, o), K(p, u, d), U(u, u, d), K(d, l, h), U(l, l, h), D(h, p), D(g, u), z(u, d, u), z(d, l, p), K(p, u, d), U(u, u, d), D(l, u), U(d, h, g), z(u, d, c), K(u, u, h), z(d, d, u), z(u, h, g), z(h, l, a), D(l, p), B(u, l, o), B(d, h, o);
                    for (i = 0; i < 16; i++) a[i + 16] = u[i], a[i + 32] = d[i], a[i + 48] = l[i], a[i + 64] = h[i];
                    var f = a.subarray(32),
                        b = a.subarray(16);
                    return H(f, f), z(b, b, f), L(e, b), 0
                }

                function V(e, t) {
                    return $(e, t, i)
                }

                function F(e, t) {
                    return r(t, 32), V(e, t)
                }

                function G(e, t, n) {
                    var r = new Uint8Array(32);
                    return $(r, n, t), v(e, o, r, S)
                }
                x.prototype.blocks = function(e, t, n) {
                    var r, o, i, s, a, c, u, l, d, h, p, g, f, b, y, m, w, k, v, S = this.fin ? 0 : 2048,
                        C = this.h[0],
                        I = this.h[1],
                        A = this.h[2],
                        O = this.h[3],
                        x = this.h[4],
                        _ = this.h[5],
                        E = this.h[6],
                        T = this.h[7],
                        P = this.h[8],
                        R = this.h[9],
                        j = this.r[0],
                        B = this.r[1],
                        L = this.r[2],
                        W = this.r[3],
                        N = this.r[4],
                        M = this.r[5],
                        K = this.r[6],
                        U = this.r[7],
                        z = this.r[8],
                        D = this.r[9];
                    while (n >= 16) r = 255 & e[t + 0] | (255 & e[t + 1]) << 8, C += 8191 & r, o = 255 & e[t + 2] | (255 & e[t + 3]) << 8, I += 8191 & (r >>> 13 | o << 3), i = 255 & e[t + 4] | (255 & e[t + 5]) << 8, A += 8191 & (o >>> 10 | i << 6), s = 255 & e[t + 6] | (255 & e[t + 7]) << 8, O += 8191 & (i >>> 7 | s << 9), a = 255 & e[t + 8] | (255 & e[t + 9]) << 8, x += 8191 & (s >>> 4 | a << 12), _ += a >>> 1 & 8191, c = 255 & e[t + 10] | (255 & e[t + 11]) << 8, E += 8191 & (a >>> 14 | c << 2), u = 255 & e[t + 12] | (255 & e[t + 13]) << 8, T += 8191 & (c >>> 11 | u << 5), l = 255 & e[t + 14] | (255 & e[t + 15]) << 8, P += 8191 & (u >>> 8 | l << 8), R += l >>> 5 | S, d = 0, h = d, h += C * j, h += I * (5 * D), h += A * (5 * z), h += O * (5 * U), h += x * (5 * K), d = h >>> 13, h &= 8191, h += _ * (5 * M), h += E * (5 * N), h += T * (5 * W), h += P * (5 * L), h += R * (5 * B), d += h >>> 13, h &= 8191, p = d, p += C * B, p += I * j, p += A * (5 * D), p += O * (5 * z), p += x * (5 * U), d = p >>> 13, p &= 8191, p += _ * (5 * K), p += E * (5 * M), p += T * (5 * N), p += P * (5 * W), p += R * (5 * L), d += p >>> 13, p &= 8191, g = d, g += C * L, g += I * B, g += A * j, g += O * (5 * D), g += x * (5 * z), d = g >>> 13, g &= 8191, g += _ * (5 * U), g += E * (5 * K), g += T * (5 * M), g += P * (5 * N), g += R * (5 * W), d += g >>> 13, g &= 8191, f = d, f += C * W, f += I * L, f += A * B, f += O * j, f += x * (5 * D), d = f >>> 13, f &= 8191, f += _ * (5 * z), f += E * (5 * U), f += T * (5 * K), f += P * (5 * M), f += R * (5 * N), d += f >>> 13, f &= 8191, b = d, b += C * N, b += I * W, b += A * L, b += O * B, b += x * j, d = b >>> 13, b &= 8191, b += _ * (5 * D), b += E * (5 * z), b += T * (5 * U), b += P * (5 * K), b += R * (5 * M), d += b >>> 13, b &= 8191, y = d, y += C * M, y += I * N, y += A * W, y += O * L, y += x * B, d = y >>> 13, y &= 8191, y += _ * j, y += E * (5 * D), y += T * (5 * z), y += P * (5 * U), y += R * (5 * K), d += y >>> 13, y &= 8191, m = d, m += C * K, m += I * M, m += A * N, m += O * W, m += x * L, d = m >>> 13, m &= 8191, m += _ * B, m += E * j, m += T * (5 * D), m += P * (5 * z), m += R * (5 * U), d += m >>> 13, m &= 8191, w = d, w += C * U, w += I * K, w += A * M, w += O * N, w += x * W, d = w >>> 13, w &= 8191, w += _ * L, w += E * B, w += T * j, w += P * (5 * D), w += R * (5 * z), d += w >>> 13, w &= 8191, k = d, k += C * z, k += I * U, k += A * K, k += O * M, k += x * N, d = k >>> 13, k &= 8191, k += _ * W, k += E * L, k += T * B, k += P * j, k += R * (5 * D), d += k >>> 13, k &= 8191, v = d, v += C * D, v += I * z, v += A * U, v += O * K, v += x * M, d = v >>> 13, v &= 8191, v += _ * N, v += E * W, v += T * L, v += P * B, v += R * j, d += v >>> 13, v &= 8191, d = (d << 2) + d | 0, d = d + h | 0, h = 8191 & d, d >>>= 13, p += d, C = h, I = p, A = g, O = f, x = b, _ = y, E = m, T = w, P = k, R = v, t += 16, n -= 16;
                    this.h[0] = C, this.h[1] = I, this.h[2] = A, this.h[3] = O, this.h[4] = x, this.h[5] = _, this.h[6] = E, this.h[7] = T, this.h[8] = P, this.h[9] = R
                }, x.prototype.finish = function(e, t) {
                    var n, r, o, i, s = new Uint16Array(10);
                    if (this.leftover) {
                        for (i = this.leftover, this.buffer[i++] = 1; i < 16; i++) this.buffer[i] = 0;
                        this.fin = 1, this.blocks(this.buffer, 0, 16)
                    }
                    for (n = this.h[1] >>> 13, this.h[1] &= 8191, i = 2; i < 10; i++) this.h[i] += n, n = this.h[i] >>> 13, this.h[i] &= 8191;
                    for (this.h[0] += 5 * n, n = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += n, n = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += n, s[0] = this.h[0] + 5, n = s[0] >>> 13, s[0] &= 8191, i = 1; i < 10; i++) s[i] = this.h[i] + n, n = s[i] >>> 13, s[i] &= 8191;
                    for (s[9] -= 8192, r = (1 ^ n) - 1, i = 0; i < 10; i++) s[i] &= r;
                    for (r = ~r, i = 0; i < 10; i++) this.h[i] = this.h[i] & r | s[i];
                    for (this.h[0] = 65535 & (this.h[0] | this.h[1] << 13), this.h[1] = 65535 & (this.h[1] >>> 3 | this.h[2] << 10), this.h[2] = 65535 & (this.h[2] >>> 6 | this.h[3] << 7), this.h[3] = 65535 & (this.h[3] >>> 9 | this.h[4] << 4), this.h[4] = 65535 & (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14), this.h[5] = 65535 & (this.h[6] >>> 2 | this.h[7] << 11), this.h[6] = 65535 & (this.h[7] >>> 5 | this.h[8] << 8), this.h[7] = 65535 & (this.h[8] >>> 8 | this.h[9] << 5), o = this.h[0] + this.pad[0], this.h[0] = 65535 & o, i = 1; i < 8; i++) o = (this.h[i] + this.pad[i] | 0) + (o >>> 16) | 0, this.h[i] = 65535 & o;
                    e[t + 0] = this.h[0] >>> 0 & 255, e[t + 1] = this.h[0] >>> 8 & 255, e[t + 2] = this.h[1] >>> 0 & 255, e[t + 3] = this.h[1] >>> 8 & 255, e[t + 4] = this.h[2] >>> 0 & 255, e[t + 5] = this.h[2] >>> 8 & 255, e[t + 6] = this.h[3] >>> 0 & 255, e[t + 7] = this.h[3] >>> 8 & 255, e[t + 8] = this.h[4] >>> 0 & 255, e[t + 9] = this.h[4] >>> 8 & 255, e[t + 10] = this.h[5] >>> 0 & 255, e[t + 11] = this.h[5] >>> 8 & 255, e[t + 12] = this.h[6] >>> 0 & 255, e[t + 13] = this.h[6] >>> 8 & 255, e[t + 14] = this.h[7] >>> 0 & 255, e[t + 15] = this.h[7] >>> 8 & 255
                }, x.prototype.update = function(e, t, n) {
                    var r, o;
                    if (this.leftover) {
                        for (o = 16 - this.leftover, o > n && (o = n), r = 0; r < o; r++) this.buffer[this.leftover + r] = e[t + r];
                        if (n -= o, t += o, this.leftover += o, this.leftover < 16) return;
                        this.blocks(this.buffer, 0, 16), this.leftover = 0
                    }
                    if (n >= 16 && (o = n - n % 16, this.blocks(e, t, o), t += o, n -= o), n) {
                        for (r = 0; r < n; r++) this.buffer[this.leftover + r] = e[t + r];
                        this.leftover += n
                    }
                };
                var Y = T,
                    J = P;

                function Z(e, t, n, r, o, i) {
                    var s = new Uint8Array(32);
                    return G(s, o, i), Y(e, t, n, r, s)
                }

                function X(e, t, n, r, o, i) {
                    var s = new Uint8Array(32);
                    return G(s, o, i), J(e, t, n, r, s)
                }
                var Q = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];

                function ee(e, t, n, r) {
                    var o, i, s, a, c, u, l, d, h, p, g, f, b, y, m, w, k, v, S, C, I, A, O, x, _, E, T = new Int32Array(16),
                        P = new Int32Array(16),
                        R = e[0],
                        j = e[1],
                        B = e[2],
                        L = e[3],
                        W = e[4],
                        N = e[5],
                        M = e[6],
                        K = e[7],
                        U = t[0],
                        z = t[1],
                        D = t[2],
                        H = t[3],
                        q = t[4],
                        $ = t[5],
                        V = t[6],
                        F = t[7],
                        G = 0;
                    while (r >= 128) {
                        for (S = 0; S < 16; S++) C = 8 * S + G, T[S] = n[C + 0] << 24 | n[C + 1] << 16 | n[C + 2] << 8 | n[C + 3], P[S] = n[C + 4] << 24 | n[C + 5] << 16 | n[C + 6] << 8 | n[C + 7];
                        for (S = 0; S < 80; S++)
                            if (o = R, i = j, s = B, a = L, c = W, u = N, l = M, d = K, h = U, p = z, g = D, f = H, b = q, y = $, m = V, w = F, I = K, A = F, O = 65535 & A, x = A >>> 16, _ = 65535 & I, E = I >>> 16, I = (W >>> 14 | q << 18) ^ (W >>> 18 | q << 14) ^ (q >>> 9 | W << 23), A = (q >>> 14 | W << 18) ^ (q >>> 18 | W << 14) ^ (W >>> 9 | q << 23), O += 65535 & A, x += A >>> 16, _ += 65535 & I, E += I >>> 16, I = W & N ^ ~W & M, A = q & $ ^ ~q & V, O += 65535 & A, x += A >>> 16, _ += 65535 & I, E += I >>> 16, I = Q[2 * S], A = Q[2 * S + 1], O += 65535 & A, x += A >>> 16, _ += 65535 & I, E += I >>> 16, I = T[S % 16], A = P[S % 16], O += 65535 & A, x += A >>> 16, _ += 65535 & I, E += I >>> 16, x += O >>> 16, _ += x >>> 16, E += _ >>> 16, k = 65535 & _ | E << 16, v = 65535 & O | x << 16, I = k, A = v, O = 65535 & A, x = A >>> 16, _ = 65535 & I, E = I >>> 16, I = (R >>> 28 | U << 4) ^ (U >>> 2 | R << 30) ^ (U >>> 7 | R << 25), A = (U >>> 28 | R << 4) ^ (R >>> 2 | U << 30) ^ (R >>> 7 | U << 25), O += 65535 & A, x += A >>> 16, _ += 65535 & I, E += I >>> 16, I = R & j ^ R & B ^ j & B, A = U & z ^ U & D ^ z & D, O += 65535 & A, x += A >>> 16, _ += 65535 & I, E += I >>> 16, x += O >>> 16, _ += x >>> 16, E += _ >>> 16, d = 65535 & _ | E << 16, w = 65535 & O | x << 16, I = a, A = f, O = 65535 & A, x = A >>> 16, _ = 65535 & I, E = I >>> 16, I = k, A = v, O += 65535 & A, x += A >>> 16, _ += 65535 & I, E += I >>> 16, x += O >>> 16, _ += x >>> 16, E += _ >>> 16, a = 65535 & _ | E << 16, f = 65535 & O | x << 16, j = o, B = i, L = s, W = a, N = c, M = u, K = l, R = d, z = h, D = p, H = g, q = f, $ = b, V = y, F = m, U = w, S % 16 === 15)
                                for (C = 0; C < 16; C++) I = T[C], A = P[C], O = 65535 & A, x = A >>> 16, _ = 65535 & I, E = I >>> 16, I = T[(C + 9) % 16], A = P[(C + 9) % 16], O += 65535 & A, x += A >>> 16, _ += 65535 & I, E += I >>> 16, k = T[(C + 1) % 16], v = P[(C + 1) % 16], I = (k >>> 1 | v << 31) ^ (k >>> 8 | v << 24) ^ k >>> 7, A = (v >>> 1 | k << 31) ^ (v >>> 8 | k << 24) ^ (v >>> 7 | k << 25), O += 65535 & A, x += A >>> 16, _ += 65535 & I, E += I >>> 16, k = T[(C + 14) % 16], v = P[(C + 14) % 16], I = (k >>> 19 | v << 13) ^ (v >>> 29 | k << 3) ^ k >>> 6, A = (v >>> 19 | k << 13) ^ (k >>> 29 | v << 3) ^ (v >>> 6 | k << 26), O += 65535 & A, x += A >>> 16, _ += 65535 & I, E += I >>> 16, x += O >>> 16, _ += x >>> 16, E += _ >>> 16, T[C] = 65535 & _ | E << 16, P[C] = 65535 & O | x << 16;
                        I = R, A = U, O = 65535 & A, x = A >>> 16, _ = 65535 & I, E = I >>> 16, I = e[0], A = t[0], O += 65535 & A, x += A >>> 16, _ += 65535 & I, E += I >>> 16, x += O >>> 16, _ += x >>> 16, E += _ >>> 16, e[0] = R = 65535 & _ | E << 16, t[0] = U = 65535 & O | x << 16, I = j, A = z, O = 65535 & A, x = A >>> 16, _ = 65535 & I, E = I >>> 16, I = e[1], A = t[1], O += 65535 & A, x += A >>> 16, _ += 65535 & I, E += I >>> 16, x += O >>> 16, _ += x >>> 16, E += _ >>> 16, e[1] = j = 65535 & _ | E << 16, t[1] = z = 65535 & O | x << 16, I = B, A = D, O = 65535 & A, x = A >>> 16, _ = 65535 & I, E = I >>> 16, I = e[2], A = t[2], O += 65535 & A, x += A >>> 16, _ += 65535 & I, E += I >>> 16, x += O >>> 16, _ += x >>> 16, E += _ >>> 16, e[2] = B = 65535 & _ | E << 16, t[2] = D = 65535 & O | x << 16, I = L, A = H, O = 65535 & A, x = A >>> 16, _ = 65535 & I, E = I >>> 16, I = e[3], A = t[3], O += 65535 & A, x += A >>> 16, _ += 65535 & I, E += I >>> 16, x += O >>> 16, _ += x >>> 16, E += _ >>> 16, e[3] = L = 65535 & _ | E << 16, t[3] = H = 65535 & O | x << 16, I = W, A = q, O = 65535 & A, x = A >>> 16, _ = 65535 & I, E = I >>> 16, I = e[4], A = t[4], O += 65535 & A, x += A >>> 16, _ += 65535 & I, E += I >>> 16, x += O >>> 16, _ += x >>> 16, E += _ >>> 16, e[4] = W = 65535 & _ | E << 16, t[4] = q = 65535 & O | x << 16, I = N, A = $, O = 65535 & A, x = A >>> 16, _ = 65535 & I, E = I >>> 16, I = e[5], A = t[5], O += 65535 & A, x += A >>> 16, _ += 65535 & I, E += I >>> 16, x += O >>> 16, _ += x >>> 16, E += _ >>> 16, e[5] = N = 65535 & _ | E << 16, t[5] = $ = 65535 & O | x << 16, I = M, A = V, O = 65535 & A, x = A >>> 16, _ = 65535 & I, E = I >>> 16, I = e[6], A = t[6], O += 65535 & A, x += A >>> 16, _ += 65535 & I, E += I >>> 16, x += O >>> 16, _ += x >>> 16, E += _ >>> 16, e[6] = M = 65535 & _ | E << 16, t[6] = V = 65535 & O | x << 16, I = K, A = F, O = 65535 & A, x = A >>> 16, _ = 65535 & I, E = I >>> 16, I = e[7], A = t[7], O += 65535 & A, x += A >>> 16, _ += 65535 & I, E += I >>> 16, x += O >>> 16, _ += x >>> 16, E += _ >>> 16, e[7] = K = 65535 & _ | E << 16, t[7] = F = 65535 & O | x << 16, G += 128, r -= 128
                    }
                    return r
                }

                function te(e, t, n) {
                    var r, o = new Int32Array(8),
                        i = new Int32Array(8),
                        s = new Uint8Array(256),
                        a = n;
                    for (o[0] = 1779033703, o[1] = 3144134277, o[2] = 1013904242, o[3] = 2773480762, o[4] = 1359893119, o[5] = 2600822924, o[6] = 528734635, o[7] = 1541459225, i[0] = 4089235720, i[1] = 2227873595, i[2] = 4271175723, i[3] = 1595750129, i[4] = 2917565137, i[5] = 725511199, i[6] = 4215389547, i[7] = 327033209, ee(o, i, t, n), n %= 128, r = 0; r < n; r++) s[r] = t[a - n + r];
                    for (s[n] = 128, n = 256 - 128 * (n < 112 ? 1 : 0), s[n - 9] = 0, g(s, n - 8, a / 536870912 | 0, a << 3), ee(o, i, s, n), r = 0; r < 8; r++) g(e, 8 * r, o[r], i[r]);
                    return 0
                }

                function ne(e, n) {
                    var r = t(),
                        o = t(),
                        i = t(),
                        s = t(),
                        a = t(),
                        c = t(),
                        u = t(),
                        d = t(),
                        h = t();
                    U(r, e[1], e[0]), U(h, n[1], n[0]), z(r, r, h), K(o, e[0], e[1]), K(h, n[0], n[1]), z(o, o, h), z(i, e[3], n[3]), z(i, i, l), z(s, e[2], n[2]), K(s, s, s), U(a, o, r), U(c, s, i), K(u, s, i), K(d, o, r), z(e[0], a, c), z(e[1], d, u), z(e[2], u, c), z(e[3], a, d)
                }

                function re(e, t, n) {
                    var r;
                    for (r = 0; r < 4; r++) B(e[r], t[r], n)
                }

                function oe(e, n) {
                    var r = t(),
                        o = t(),
                        i = t();
                    H(i, n[2]), z(r, n[0], i), z(o, n[1], i), L(e, o), e[31] ^= N(r) << 7
                }

                function ie(e, t, n) {
                    var r, o;
                    for (R(e[0], s), R(e[1], a), R(e[2], a), R(e[3], s), o = 255; o >= 0; --o) r = n[o / 8 | 0] >> (7 & o) & 1, re(e, t, r), ne(t, e), ne(e, e), re(e, t, r)
                }

                function se(e, n) {
                    var r = [t(), t(), t(), t()];
                    R(r[0], d), R(r[1], h), R(r[2], a), z(r[3], d, h), ie(e, r, n)
                }

                function ae(e, n, o) {
                    var i, s = new Uint8Array(64),
                        a = [t(), t(), t(), t()];
                    for (o || r(n, 32), te(s, n, 32), s[0] &= 248, s[31] &= 127, s[31] |= 64, se(a, s), oe(e, a), i = 0; i < 32; i++) n[i + 32] = e[i];
                    return 0
                }
                var ce = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);

                function ue(e, t) {
                    var n, r, o, i;
                    for (r = 63; r >= 32; --r) {
                        for (n = 0, o = r - 32, i = r - 12; o < i; ++o) t[o] += n - 16 * t[r] * ce[o - (r - 32)], n = Math.floor((t[o] + 128) / 256), t[o] -= 256 * n;
                        t[o] += n, t[r] = 0
                    }
                    for (n = 0, o = 0; o < 32; o++) t[o] += n - (t[31] >> 4) * ce[o], n = t[o] >> 8, t[o] &= 255;
                    for (o = 0; o < 32; o++) t[o] -= n * ce[o];
                    for (r = 0; r < 32; r++) t[r + 1] += t[r] >> 8, e[r] = 255 & t[r]
                }

                function le(e) {
                    var t, n = new Float64Array(64);
                    for (t = 0; t < 64; t++) n[t] = e[t];
                    for (t = 0; t < 64; t++) e[t] = 0;
                    ue(e, n)
                }

                function de(e, n, r, o) {
                    var i, s, a = new Uint8Array(64),
                        c = new Uint8Array(64),
                        u = new Uint8Array(64),
                        l = new Float64Array(64),
                        d = [t(), t(), t(), t()];
                    te(a, o, 32), a[0] &= 248, a[31] &= 127, a[31] |= 64;
                    var h = r + 64;
                    for (i = 0; i < r; i++) e[64 + i] = n[i];
                    for (i = 0; i < 32; i++) e[32 + i] = a[32 + i];
                    for (te(u, e.subarray(32), r + 32), le(u), se(d, u), oe(e, d), i = 32; i < 64; i++) e[i] = o[i];
                    for (te(c, e, r + 64), le(c), i = 0; i < 64; i++) l[i] = 0;
                    for (i = 0; i < 32; i++) l[i] = u[i];
                    for (i = 0; i < 32; i++)
                        for (s = 0; s < 32; s++) l[i + s] += c[i] * a[s];
                    return ue(e.subarray(32), l), h
                }

                function he(e, n) {
                    var r = t(),
                        o = t(),
                        i = t(),
                        c = t(),
                        l = t(),
                        d = t(),
                        h = t();
                    return R(e[2], a), M(e[1], n), D(i, e[1]), z(c, i, u), U(i, i, e[2]), K(c, e[2], c), D(l, c), D(d, l), z(h, d, l), z(r, h, i), z(r, r, c), q(r, r), z(r, r, i), z(r, r, c), z(r, r, c), z(e[0], r, c), D(o, e[0]), z(o, o, c), W(o, i) && z(e[0], e[0], p), D(o, e[0]), z(o, o, c), W(o, i) ? -1 : (N(e[0]) === n[31] >> 7 && U(e[0], s, e[0]), z(e[3], e[0], e[1]), 0)
                }

                function pe(e, n, r, o) {
                    var i, s = new Uint8Array(32),
                        a = new Uint8Array(64),
                        c = [t(), t(), t(), t()],
                        u = [t(), t(), t(), t()];
                    if (r < 64) return -1;
                    if (he(u, o)) return -1;
                    for (i = 0; i < r; i++) e[i] = n[i];
                    for (i = 0; i < 32; i++) e[i + 32] = o[i];
                    if (te(a, e, r), le(a), ie(c, u, a), se(u, n.subarray(32)), ne(c, u), oe(s, c), r -= 64, y(n, 0, s, 0)) {
                        for (i = 0; i < r; i++) e[i] = 0;
                        return -1
                    }
                    for (i = 0; i < r; i++) e[i] = n[i + 64];
                    return r
                }
                var ge = 32,
                    fe = 24,
                    be = 32,
                    ye = 16,
                    me = 32,
                    we = 32,
                    ke = 32,
                    ve = 32,
                    Se = 32,
                    Ce = fe,
                    Ie = be,
                    Ae = ye,
                    Oe = 64,
                    xe = 32,
                    _e = 64,
                    Ee = 32,
                    Te = 64;

                function Pe(e, t) {
                    if (e.length !== ge) throw new Error("bad key size");
                    if (t.length !== fe) throw new Error("bad nonce size")
                }

                function Re(e, t) {
                    if (e.length !== ke) throw new Error("bad public key size");
                    if (t.length !== ve) throw new Error("bad secret key size")
                }

                function je() {
                    for (var e = 0; e < arguments.length; e++)
                        if (!(arguments[e] instanceof Uint8Array)) throw new TypeError("unexpected type, use Uint8Array")
                }

                function Be(e) {
                    for (var t = 0; t < e.length; t++) e[t] = 0
                }
                e.lowlevel = {
                        crypto_core_hsalsa20: v,
                        crypto_stream_xor: O,
                        crypto_stream: A,
                        crypto_stream_salsa20_xor: C,
                        crypto_stream_salsa20: I,
                        crypto_onetimeauth: _,
                        crypto_onetimeauth_verify: E,
                        crypto_verify_16: b,
                        crypto_verify_32: y,
                        crypto_secretbox: T,
                        crypto_secretbox_open: P,
                        crypto_scalarmult: $,
                        crypto_scalarmult_base: V,
                        crypto_box_beforenm: G,
                        crypto_box_afternm: Y,
                        crypto_box: Z,
                        crypto_box_open: X,
                        crypto_box_keypair: F,
                        crypto_hash: te,
                        crypto_sign: de,
                        crypto_sign_keypair: ae,
                        crypto_sign_open: pe,
                        crypto_secretbox_KEYBYTES: ge,
                        crypto_secretbox_NONCEBYTES: fe,
                        crypto_secretbox_ZEROBYTES: be,
                        crypto_secretbox_BOXZEROBYTES: ye,
                        crypto_scalarmult_BYTES: me,
                        crypto_scalarmult_SCALARBYTES: we,
                        crypto_box_PUBLICKEYBYTES: ke,
                        crypto_box_SECRETKEYBYTES: ve,
                        crypto_box_BEFORENMBYTES: Se,
                        crypto_box_NONCEBYTES: Ce,
                        crypto_box_ZEROBYTES: Ie,
                        crypto_box_BOXZEROBYTES: Ae,
                        crypto_sign_BYTES: Oe,
                        crypto_sign_PUBLICKEYBYTES: xe,
                        crypto_sign_SECRETKEYBYTES: _e,
                        crypto_sign_SEEDBYTES: Ee,
                        crypto_hash_BYTES: Te,
                        gf: t,
                        D: u,
                        L: ce,
                        pack25519: L,
                        unpack25519: M,
                        M: z,
                        A: K,
                        S: D,
                        Z: U,
                        pow2523: q,
                        add: ne,
                        set25519: R,
                        modL: ue,
                        scalarmult: ie,
                        scalarbase: se
                    }, e.randomBytes = function(e) {
                        var t = new Uint8Array(e);
                        return r(t, e), t
                    }, e.secretbox = function(e, t, n) {
                        je(e, t, n), Pe(n, t);
                        for (var r = new Uint8Array(be + e.length), o = new Uint8Array(r.length), i = 0; i < e.length; i++) r[i + be] = e[i];
                        return T(o, r, r.length, t, n), o.subarray(ye)
                    }, e.secretbox.open = function(e, t, n) {
                        je(e, t, n), Pe(n, t);
                        for (var r = new Uint8Array(ye + e.length), o = new Uint8Array(r.length), i = 0; i < e.length; i++) r[i + ye] = e[i];
                        return r.length < 32 || 0 !== P(o, r, r.length, t, n) ? null : o.subarray(be)
                    }, e.secretbox.keyLength = ge, e.secretbox.nonceLength = fe, e.secretbox.overheadLength = ye, e.scalarMult = function(e, t) {
                        if (je(e, t), e.length !== we) throw new Error("bad n size");
                        if (t.length !== me) throw new Error("bad p size");
                        var n = new Uint8Array(me);
                        return $(n, e, t), n
                    }, e.scalarMult.base = function(e) {
                        if (je(e), e.length !== we) throw new Error("bad n size");
                        var t = new Uint8Array(me);
                        return V(t, e), t
                    }, e.scalarMult.scalarLength = we, e.scalarMult.groupElementLength = me, e.box = function(t, n, r, o) {
                        var i = e.box.before(r, o);
                        return e.secretbox(t, n, i)
                    }, e.box.before = function(e, t) {
                        je(e, t), Re(e, t);
                        var n = new Uint8Array(Se);
                        return G(n, e, t), n
                    }, e.box.after = e.secretbox, e.box.open = function(t, n, r, o) {
                        var i = e.box.before(r, o);
                        return e.secretbox.open(t, n, i)
                    }, e.box.open.after = e.secretbox.open, e.box.keyPair = function() {
                        var e = new Uint8Array(ke),
                            t = new Uint8Array(ve);
                        return F(e, t), {
                            publicKey: e,
                            secretKey: t
                        }
                    }, e.box.keyPair.fromSecretKey = function(e) {
                        if (je(e), e.length !== ve) throw new Error("bad secret key size");
                        var t = new Uint8Array(ke);
                        return V(t, e), {
                            publicKey: t,
                            secretKey: new Uint8Array(e)
                        }
                    }, e.box.publicKeyLength = ke, e.box.secretKeyLength = ve, e.box.sharedKeyLength = Se, e.box.nonceLength = Ce, e.box.overheadLength = e.secretbox.overheadLength, e.sign = function(e, t) {
                        if (je(e, t), t.length !== _e) throw new Error("bad secret key size");
                        var n = new Uint8Array(Oe + e.length);
                        return de(n, e, e.length, t), n
                    }, e.sign.open = function(e, t) {
                        if (je(e, t), t.length !== xe) throw new Error("bad public key size");
                        var n = new Uint8Array(e.length),
                            r = pe(n, e, e.length, t);
                        if (r < 0) return null;
                        for (var o = new Uint8Array(r), i = 0; i < o.length; i++) o[i] = n[i];
                        return o
                    }, e.sign.detached = function(t, n) {
                        for (var r = e.sign(t, n), o = new Uint8Array(Oe), i = 0; i < o.length; i++) o[i] = r[i];
                        return o
                    }, e.sign.detached.verify = function(e, t, n) {
                        if (je(e, t, n), t.length !== Oe) throw new Error("bad signature size");
                        if (n.length !== xe) throw new Error("bad public key size");
                        var r, o = new Uint8Array(Oe + e.length),
                            i = new Uint8Array(Oe + e.length);
                        for (r = 0; r < Oe; r++) o[r] = t[r];
                        for (r = 0; r < e.length; r++) o[r + Oe] = e[r];
                        return pe(i, o, o.length, n) >= 0
                    }, e.sign.keyPair = function() {
                        var e = new Uint8Array(xe),
                            t = new Uint8Array(_e);
                        return ae(e, t), {
                            publicKey: e,
                            secretKey: t
                        }
                    }, e.sign.keyPair.fromSecretKey = function(e) {
                        if (je(e), e.length !== _e) throw new Error("bad secret key size");
                        for (var t = new Uint8Array(xe), n = 0; n < t.length; n++) t[n] = e[32 + n];
                        return {
                            publicKey: t,
                            secretKey: new Uint8Array(e)
                        }
                    }, e.sign.keyPair.fromSeed = function(e) {
                        if (je(e), e.length !== Ee) throw new Error("bad seed size");
                        for (var t = new Uint8Array(xe), n = new Uint8Array(_e), r = 0; r < 32; r++) n[r] = e[r];
                        return ae(t, n, !0), {
                            publicKey: t,
                            secretKey: n
                        }
                    }, e.sign.publicKeyLength = xe, e.sign.secretKeyLength = _e, e.sign.seedLength = Ee, e.sign.signatureLength = Oe, e.hash = function(e) {
                        je(e);
                        var t = new Uint8Array(Te);
                        return te(t, e, e.length), t
                    }, e.hash.hashLength = Te, e.verify = function(e, t) {
                        return je(e, t), 0 !== e.length && 0 !== t.length && (e.length === t.length && 0 === f(e, 0, t, 0, e.length))
                    }, e.setPRNG = function(e) {
                        r = e
                    },
                    function() {
                        var t = "undefined" !== typeof self ? self.crypto || self.msCrypto : null;
                        if (t && t.getRandomValues) {
                            var r = 65536;
                            e.setPRNG((function(e, n) {
                                var o, i = new Uint8Array(n);
                                for (o = 0; o < n; o += r) t.getRandomValues(i.subarray(o, o + Math.min(n - o, r)));
                                for (o = 0; o < n; o++) e[o] = i[o];
                                Be(i)
                            }))
                        } else t = n(38), t && t.randomBytes && e.setPRNG((function(e, n) {
                            var r, o = t.randomBytes(n);
                            for (r = 0; r < n; r++) e[r] = o[r];
                            Be(o)
                        }))
                    }()
            })(e.exports ? e.exports : self.nacl = self.nacl || {})
        },
        "2fdf": function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.hmac = t.HMAC = void 0;
            const r = n("0067"),
                o = n("1700");
            class i extends o.Hash {
                constructor(e, t) {
                    super(), this.finished = !1, this.destroyed = !1, (0, r.hash)(e);
                    const n = (0, o.toBytes)(t);
                    if (this.iHash = e.create(), "function" !== typeof this.iHash.update) throw new Error("Expected instance of class which extends utils.Hash");
                    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
                    const i = this.blockLen,
                        s = new Uint8Array(i);
                    s.set(n.length > i ? e.create().update(n).digest() : n);
                    for (let r = 0; r < s.length; r++) s[r] ^= 54;
                    this.iHash.update(s), this.oHash = e.create();
                    for (let r = 0; r < s.length; r++) s[r] ^= 106;
                    this.oHash.update(s), s.fill(0)
                }
                update(e) {
                    return (0, r.exists)(this), this.iHash.update(e), this
                }
                digestInto(e) {
                    (0, r.exists)(this), (0, r.bytes)(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy()
                }
                digest() {
                    const e = new Uint8Array(this.oHash.outputLen);
                    return this.digestInto(e), e
                }
                _cloneInto(e) {
                    e || (e = Object.create(Object.getPrototypeOf(this), {}));
                    const {
                        oHash: t,
                        iHash: n,
                        finished: r,
                        destroyed: o,
                        blockLen: i,
                        outputLen: s
                    } = this;
                    return e = e, e.finished = r, e.destroyed = o, e.blockLen = i, e.outputLen = s, e.oHash = t._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e
                }
                destroy() {
                    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy()
                }
            }
            t.HMAC = i;
            const s = (e, t, n) => new i(e, t).update(n).digest();
            t.hmac = s, t.hmac.create = (e, t) => new i(e, t)
        },
        3995: function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.crypto = void 0, t.crypto = "object" === typeof globalThis && "crypto" in globalThis ? globalThis.crypto : void 0
        },
        "3ebd": function(e, t, n) {
            "use strict";
            (function(e) {
                n.d(t, "d", (function() {
                    return l
                })), n.d(t, "a", (function() {
                    return d
                })), n.d(t, "b", (function() {
                    return h
                })), n.d(t, "c", (function() {
                    return p
                }));
                var r = n("8df2"),
                    o = n("1c54"),
                    i = n("0276"),
                    s = n("4ae8"),
                    a = n("a15d"),
                    c = n("0609"),
                    u = n("5762");
                const l = Object(r["struct"])([Object(r["u8"])("instruction"), Object(o["u64"])("amount")]);

                function d(t, n, r, o, a = [], d = s["c"]) {
                    const h = Object(c["a"])([{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: n,
                            isSigner: !1,
                            isWritable: !0
                        }], r, a),
                        p = e.alloc(l.span);
                    return l.encode({
                        instruction: u["a"].MintTo,
                        amount: BigInt(o)
                    }, p), new i["TransactionInstruction"]({
                        keys: h,
                        programId: d,
                        data: p
                    })
                }

                function h(e, t = s["c"]) {
                    if (!e.programId.equals(t)) throw new a["g"];
                    if (e.data.length !== l.span) throw new a["e"];
                    const {
                        keys: {
                            mint: n,
                            destination: r,
                            authority: o,
                            multiSigners: i
                        },
                        data: c
                    } = p(e);
                    if (c.instruction !== u["a"].MintTo) throw new a["h"];
                    if (!n || !r || !o) throw new a["f"];
                    return {
                        programId: t,
                        keys: {
                            mint: n,
                            destination: r,
                            authority: o,
                            multiSigners: i
                        },
                        data: c
                    }
                }

                function p({
                    programId: e,
                    keys: [t, n, r, ...o],
                    data: i
                }) {
                    return {
                        programId: e,
                        keys: {
                            mint: t,
                            destination: n,
                            authority: r,
                            multiSigners: o
                        },
                        data: l.decode(i)
                    }
                }
            }).call(this, n("b639").Buffer)
        },
        4190: function(e, t, n) {
            "use strict";
            (function(e) {
                n.d(t, "d", (function() {
                    return c
                })), n.d(t, "a", (function() {
                    return u
                })), n.d(t, "b", (function() {
                    return l
                })), n.d(t, "c", (function() {
                    return d
                }));
                var r = n("8df2"),
                    o = n("0276"),
                    i = n("4ae8"),
                    s = n("a15d"),
                    a = n("5762");
                const c = Object(r["struct"])([Object(r["u8"])("instruction")]);

                function u(t, n = i["c"]) {
                    const r = [{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }],
                        s = e.alloc(c.span);
                    return c.encode({
                        instruction: a["a"].SyncNative
                    }, s), new o["TransactionInstruction"]({
                        keys: r,
                        programId: n,
                        data: s
                    })
                }

                function l(e, t = i["c"]) {
                    if (!e.programId.equals(t)) throw new s["g"];
                    if (e.data.length !== c.span) throw new s["e"];
                    const {
                        keys: {
                            account: n
                        },
                        data: r
                    } = d(e);
                    if (r.instruction !== a["a"].SyncNative) throw new s["h"];
                    if (!n) throw new s["f"];
                    return {
                        programId: t,
                        keys: {
                            account: n
                        },
                        data: r
                    }
                }

                function d({
                    programId: e,
                    keys: [t],
                    data: n
                }) {
                    return {
                        programId: e,
                        keys: {
                            account: t
                        },
                        data: c.decode(n)
                    }
                }
            }).call(this, n("b639").Buffer)
        },
        "4ae8": function(e, t, n) {
            "use strict";
            n.d(t, "c", (function() {
                return o
            })), n.d(t, "a", (function() {
                return i
            })), n.d(t, "b", (function() {
                return s
            }));
            var r = n("0276");
            const o = new r["PublicKey"]("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
                i = new r["PublicKey"]("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"),
                s = new r["PublicKey"]("So11111111111111111111111111111111111111112")
        },
        "568c": function(e, t, n) {
            "use strict";
            (function(e) {
                n.d(t, "d", (function() {
                    return c
                })), n.d(t, "a", (function() {
                    return u
                })), n.d(t, "b", (function() {
                    return l
                })), n.d(t, "c", (function() {
                    return d
                }));
                var r = n("8df2"),
                    o = n("0276"),
                    i = n("4ae8"),
                    s = n("a15d"),
                    a = n("5762");
                const c = Object(r["struct"])([Object(r["u8"])("instruction")]);

                function u(t, n, r, s = i["c"]) {
                    const u = [{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: n,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: r,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: o["SYSVAR_RENT_PUBKEY"],
                            isSigner: !1,
                            isWritable: !1
                        }],
                        l = e.alloc(c.span);
                    return c.encode({
                        instruction: a["a"].InitializeAccount
                    }, l), new o["TransactionInstruction"]({
                        keys: u,
                        programId: s,
                        data: l
                    })
                }

                function l(e, t = i["c"]) {
                    if (!e.programId.equals(t)) throw new s["g"];
                    if (e.data.length !== c.span) throw new s["e"];
                    const {
                        keys: {
                            account: n,
                            mint: r,
                            owner: o,
                            rent: u
                        },
                        data: l
                    } = d(e);
                    if (l.instruction !== a["a"].InitializeAccount) throw new s["h"];
                    if (!n || !r || !o || !u) throw new s["f"];
                    return {
                        programId: t,
                        keys: {
                            account: n,
                            mint: r,
                            owner: o,
                            rent: u
                        },
                        data: l
                    }
                }

                function d({
                    programId: e,
                    keys: [t, n, r, o],
                    data: i
                }) {
                    return {
                        programId: e,
                        keys: {
                            account: t,
                            mint: n,
                            owner: r,
                            rent: o
                        },
                        data: c.decode(i)
                    }
                }
            }).call(this, n("b639").Buffer)
        },
        5762: function(e, t, n) {
            "use strict";
            var r;
            n.d(t, "a", (function() {
                    return r
                })),
                function(e) {
                    e[e["InitializeMint"] = 0] = "InitializeMint", e[e["InitializeAccount"] = 1] = "InitializeAccount", e[e["InitializeMultisig"] = 2] = "InitializeMultisig", e[e["Transfer"] = 3] = "Transfer", e[e["Approve"] = 4] = "Approve", e[e["Revoke"] = 5] = "Revoke", e[e["SetAuthority"] = 6] = "SetAuthority", e[e["MintTo"] = 7] = "MintTo", e[e["Burn"] = 8] = "Burn", e[e["CloseAccount"] = 9] = "CloseAccount", e[e["FreezeAccount"] = 10] = "FreezeAccount", e[e["ThawAccount"] = 11] = "ThawAccount", e[e["TransferChecked"] = 12] = "TransferChecked", e[e["ApproveChecked"] = 13] = "ApproveChecked", e[e["MintToChecked"] = 14] = "MintToChecked", e[e["BurnChecked"] = 15] = "BurnChecked", e[e["InitializeAccount2"] = 16] = "InitializeAccount2", e[e["SyncNative"] = 17] = "SyncNative", e[e["InitializeAccount3"] = 18] = "InitializeAccount3", e[e["InitializeMultisig2"] = 19] = "InitializeMultisig2", e[e["InitializeMint2"] = 20] = "InitializeMint2"
                }(r || (r = {}))
        },
        "5a86": function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.shake256 = t.shake128 = t.keccak_512 = t.keccak_384 = t.keccak_256 = t.keccak_224 = t.sha3_512 = t.sha3_384 = t.sha3_256 = t.sha3_224 = t.Keccak = t.keccakP = void 0;
            const r = n("0067"),
                o = n("6b27"),
                i = n("1700"),
                s = [],
                a = [],
                c = [],
                u = BigInt(0),
                l = BigInt(1),
                d = BigInt(2),
                h = BigInt(7),
                p = BigInt(256),
                g = BigInt(113);
            for (let C = 0, I = l, A = 1, O = 0; C < 24; C++) {
                [A, O] = [O, (2 * A + 3 * O) % 5], s.push(2 * (5 * O + A)), a.push((C + 1) * (C + 2) / 2 % 64);
                let e = u;
                for (let t = 0; t < 7; t++) I = (I << l ^ (I >> h) * g) % p, I & d && (e ^= l << (l << BigInt(t)) - l);
                c.push(e)
            }
            const [f, b] = (0, o.split)(c, !0), y = (e, t, n) => n > 32 ? (0, o.rotlBH)(e, t, n) : (0, o.rotlSH)(e, t, n), m = (e, t, n) => n > 32 ? (0, o.rotlBL)(e, t, n) : (0, o.rotlSL)(e, t, n);

            function w(e, t = 24) {
                const n = new Uint32Array(10);
                for (let r = 24 - t; r < 24; r++) {
                    for (let r = 0; r < 10; r++) n[r] = e[r] ^ e[r + 10] ^ e[r + 20] ^ e[r + 30] ^ e[r + 40];
                    for (let r = 0; r < 10; r += 2) {
                        const t = (r + 8) % 10,
                            o = (r + 2) % 10,
                            i = n[o],
                            s = n[o + 1],
                            a = y(i, s, 1) ^ n[t],
                            c = m(i, s, 1) ^ n[t + 1];
                        for (let n = 0; n < 50; n += 10) e[r + n] ^= a, e[r + n + 1] ^= c
                    }
                    let t = e[2],
                        o = e[3];
                    for (let n = 0; n < 24; n++) {
                        const r = a[n],
                            i = y(t, o, r),
                            c = m(t, o, r),
                            u = s[n];
                        t = e[u], o = e[u + 1], e[u] = i, e[u + 1] = c
                    }
                    for (let r = 0; r < 50; r += 10) {
                        for (let t = 0; t < 10; t++) n[t] = e[r + t];
                        for (let t = 0; t < 10; t++) e[r + t] ^= ~n[(t + 2) % 10] & n[(t + 4) % 10]
                    }
                    e[0] ^= f[r], e[1] ^= b[r]
                }
                n.fill(0)
            }
            t.keccakP = w;
            class k extends i.Hash {
                constructor(e, t, n, o = !1, s = 24) {
                    if (super(), this.blockLen = e, this.suffix = t, this.outputLen = n, this.enableXOF = o, this.rounds = s, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, (0, r.number)(n), 0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
                    this.state = new Uint8Array(200), this.state32 = (0, i.u32)(this.state)
                }
                keccak() {
                    i.isLE || (0, i.byteSwap32)(this.state32), w(this.state32, this.rounds), i.isLE || (0, i.byteSwap32)(this.state32), this.posOut = 0, this.pos = 0
                }
                update(e) {
                    (0, r.exists)(this);
                    const {
                        blockLen: t,
                        state: n
                    } = this;
                    e = (0, i.toBytes)(e);
                    const o = e.length;
                    for (let r = 0; r < o;) {
                        const i = Math.min(t - this.pos, o - r);
                        for (let t = 0; t < i; t++) n[this.pos++] ^= e[r++];
                        this.pos === t && this.keccak()
                    }
                    return this
                }
                finish() {
                    if (this.finished) return;
                    this.finished = !0;
                    const {
                        state: e,
                        suffix: t,
                        pos: n,
                        blockLen: r
                    } = this;
                    e[n] ^= t, 0 !== (128 & t) && n === r - 1 && this.keccak(), e[r - 1] ^= 128, this.keccak()
                }
                writeInto(e) {
                    (0, r.exists)(this, !1), (0, r.bytes)(e), this.finish();
                    const t = this.state,
                        {
                            blockLen: n
                        } = this;
                    for (let r = 0, o = e.length; r < o;) {
                        this.posOut >= n && this.keccak();
                        const i = Math.min(n - this.posOut, o - r);
                        e.set(t.subarray(this.posOut, this.posOut + i), r), this.posOut += i, r += i
                    }
                    return e
                }
                xofInto(e) {
                    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
                    return this.writeInto(e)
                }
                xof(e) {
                    return (0, r.number)(e), this.xofInto(new Uint8Array(e))
                }
                digestInto(e) {
                    if ((0, r.output)(e, this), this.finished) throw new Error("digest() was already called");
                    return this.writeInto(e), this.destroy(), e
                }
                digest() {
                    return this.digestInto(new Uint8Array(this.outputLen))
                }
                destroy() {
                    this.destroyed = !0, this.state.fill(0)
                }
                _cloneInto(e) {
                    const {
                        blockLen: t,
                        suffix: n,
                        outputLen: r,
                        rounds: o,
                        enableXOF: i
                    } = this;
                    return e || (e = new k(t, n, r, i, o)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = o, e.suffix = n, e.outputLen = r, e.enableXOF = i, e.destroyed = this.destroyed, e
                }
            }
            t.Keccak = k;
            const v = (e, t, n) => (0, i.wrapConstructor)(() => new k(t, e, n));
            t.sha3_224 = v(6, 144, 28), t.sha3_256 = v(6, 136, 32), t.sha3_384 = v(6, 104, 48), t.sha3_512 = v(6, 72, 64), t.keccak_224 = v(1, 144, 28), t.keccak_256 = v(1, 136, 32), t.keccak_384 = v(1, 104, 48), t.keccak_512 = v(1, 72, 64);
            const S = (e, t, n) => (0, i.wrapXOFConstructorWithOpts)((r = {}) => new k(t, e, void 0 === r.dkLen ? n : r.dkLen, !0));
            t.shake128 = S(31, 168, 16), t.shake256 = S(31, 136, 32)
        },
        "5f93": function(e, t, n) {
            "use strict";
            (function(e) {
                n.d(t, "d", (function() {
                    return u
                })), n.d(t, "a", (function() {
                    return l
                })), n.d(t, "b", (function() {
                    return d
                })), n.d(t, "c", (function() {
                    return h
                }));
                var r = n("8df2"),
                    o = n("0276"),
                    i = n("4ae8"),
                    s = n("a15d"),
                    a = n("0609"),
                    c = n("5762");
                const u = Object(r["struct"])([Object(r["u8"])("instruction")]);

                function l(t, n, r, s = [], l = i["c"]) {
                    const d = Object(a["a"])([{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: n,
                            isSigner: !1,
                            isWritable: !1
                        }], r, s),
                        h = e.alloc(u.span);
                    return u.encode({
                        instruction: c["a"].FreezeAccount
                    }, h), new o["TransactionInstruction"]({
                        keys: d,
                        programId: l,
                        data: h
                    })
                }

                function d(e, t = i["c"]) {
                    if (!e.programId.equals(t)) throw new s["g"];
                    if (e.data.length !== u.span) throw new s["e"];
                    const {
                        keys: {
                            account: n,
                            mint: r,
                            authority: o,
                            multiSigners: a
                        },
                        data: l
                    } = h(e);
                    if (l.instruction !== c["a"].FreezeAccount) throw new s["h"];
                    if (!n || !r || !o) throw new s["f"];
                    return {
                        programId: t,
                        keys: {
                            account: n,
                            mint: r,
                            authority: o,
                            multiSigners: a
                        },
                        data: l
                    }
                }

                function h({
                    programId: e,
                    keys: [t, n, r, ...o],
                    data: i
                }) {
                    return {
                        programId: e,
                        keys: {
                            account: t,
                            mint: n,
                            authority: r,
                            multiSigners: o
                        },
                        data: u.decode(i)
                    }
                }
            }).call(this, n("b639").Buffer)
        },
        "64b9": function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, "Account", (function() {
                return W
            })), n.d(t, "AddressLookupTableAccount", (function() {
                return rt
            })), n.d(t, "AddressLookupTableInstruction", (function() {
                return Yn
            })), n.d(t, "AddressLookupTableProgram", (function() {
                return Jn
            })), n.d(t, "Authorized", (function() {
                return gr
            })), n.d(t, "BLOCKHASH_CACHE_TIMEOUT_MS", (function() {
                return dt
            })), n.d(t, "BPF_LOADER_DEPRECATED_PROGRAM_ID", (function() {
                return N
            })), n.d(t, "BPF_LOADER_PROGRAM_ID", (function() {
                return We
            })), n.d(t, "BpfLoader", (function() {
                return Ne
            })), n.d(t, "COMPUTE_BUDGET_INSTRUCTION_LAYOUTS", (function() {
                return Xn
            })), n.d(t, "ComputeBudgetInstruction", (function() {
                return Zn
            })), n.d(t, "ComputeBudgetProgram", (function() {
                return Qn
            })), n.d(t, "Connection", (function() {
                return Vn
            })), n.d(t, "Ed25519Program", (function() {
                return or
            })), n.d(t, "Enum", (function() {
                return E
            })), n.d(t, "EpochSchedule", (function() {
                return Ve
            })), n.d(t, "FeeCalculatorLayout", (function() {
                return Ie
            })), n.d(t, "Keypair", (function() {
                return Fn
            })), n.d(t, "LAMPORTS_PER_SOL", (function() {
                return Nr
            })), n.d(t, "LOOKUP_TABLE_INSTRUCTION_LAYOUTS", (function() {
                return Gn
            })), n.d(t, "Loader", (function() {
                return Le
            })), n.d(t, "Lockup", (function() {
                return fr
            })), n.d(t, "MAX_SEED_LENGTH", (function() {
                return P
            })), n.d(t, "Message", (function() {
                return ne
            })), n.d(t, "MessageAccountKeys", (function() {
                return H
            })), n.d(t, "MessageV0", (function() {
                return re
            })), n.d(t, "NONCE_ACCOUNT_LENGTH", (function() {
                return Oe
            })), n.d(t, "NonceAccount", (function() {
                return xe
            })), n.d(t, "PACKET_DATA_SIZE", (function() {
                return M
            })), n.d(t, "PUBLIC_KEY_LENGTH", (function() {
                return R
            })), n.d(t, "PublicKey", (function() {
                return L
            })), n.d(t, "SIGNATURE_LENGTH_IN_BYTES", (function() {
                return U
            })), n.d(t, "SOLANA_SCHEMA", (function() {
                return T
            })), n.d(t, "STAKE_CONFIG_ID", (function() {
                return pr
            })), n.d(t, "STAKE_INSTRUCTION_LAYOUTS", (function() {
                return yr
            })), n.d(t, "SYSTEM_INSTRUCTION_LAYOUTS", (function() {
                return Re
            })), n.d(t, "SYSVAR_CLOCK_PUBKEY", (function() {
                return de
            })), n.d(t, "SYSVAR_EPOCH_SCHEDULE_PUBKEY", (function() {
                return he
            })), n.d(t, "SYSVAR_INSTRUCTIONS_PUBKEY", (function() {
                return pe
            })), n.d(t, "SYSVAR_RECENT_BLOCKHASHES_PUBKEY", (function() {
                return ge
            })), n.d(t, "SYSVAR_RENT_PUBKEY", (function() {
                return fe
            })), n.d(t, "SYSVAR_REWARDS_PUBKEY", (function() {
                return be
            })), n.d(t, "SYSVAR_SLOT_HASHES_PUBKEY", (function() {
                return ye
            })), n.d(t, "SYSVAR_SLOT_HISTORY_PUBKEY", (function() {
                return me
            })), n.d(t, "SYSVAR_STAKE_HISTORY_PUBKEY", (function() {
                return we
            })), n.d(t, "Secp256k1Program", (function() {
                return hr
            })), n.d(t, "SendTransactionError", (function() {
                return Fe
            })), n.d(t, "SolanaJSONRPCError", (function() {
                return Ye
            })), n.d(t, "SolanaJSONRPCErrorCode", (function() {
                return Ge
            })), n.d(t, "StakeAuthorizationLayout", (function() {
                return mr
            })), n.d(t, "StakeInstruction", (function() {
                return br
            })), n.d(t, "StakeProgram", (function() {
                return wr
            })), n.d(t, "Struct", (function() {
                return _
            })), n.d(t, "SystemInstruction", (function() {
                return Pe
            })), n.d(t, "SystemProgram", (function() {
                return je
            })), n.d(t, "Transaction", (function() {
                return ce
            })), n.d(t, "TransactionExpiredBlockheightExceededError", (function() {
                return z
            })), n.d(t, "TransactionExpiredTimeoutError", (function() {
                return D
            })), n.d(t, "TransactionInstruction", (function() {
                return ae
            })), n.d(t, "TransactionMessage", (function() {
                return ue
            })), n.d(t, "TransactionStatus", (function() {
                return ie
            })), n.d(t, "VALIDATOR_INFO_KEY", (function() {
                return Ar
            })), n.d(t, "VERSION_PREFIX_MASK", (function() {
                return K
            })), n.d(t, "VOTE_PROGRAM_ID", (function() {
                return _r
            })), n.d(t, "ValidatorInfo", (function() {
                return xr
            })), n.d(t, "VersionedMessage", (function() {
                return oe
            })), n.d(t, "VersionedTransaction", (function() {
                return le
            })), n.d(t, "VoteAccount", (function() {
                return Tr
            })), n.d(t, "VoteAuthorizationLayout", (function() {
                return Cr
            })), n.d(t, "VoteInit", (function() {
                return kr
            })), n.d(t, "VoteInstruction", (function() {
                return vr
            })), n.d(t, "VoteProgram", (function() {
                return Ir
            })), n.d(t, "clusterApiUrl", (function() {
                return Lr
            })), n.d(t, "sendAndConfirmRawTransaction", (function() {
                return Wr
            })), n.d(t, "sendAndConfirmTransaction", (function() {
                return ke
            }));
            var r = n("b639"),
                o = n("f0f6"),
                i = n("7b8f"),
                s = n("399f"),
                a = n.n(s),
                c = n("0774"),
                u = n.n(c),
                l = n("ab84"),
                d = n("fa13"),
                h = n("8df2"),
                p = n("9ea2"),
                g = n("d920"),
                f = n("3f10"),
                b = n("502a"),
                y = n.n(b),
                m = n("5a86"),
                w = n("2fdf"),
                k = n("1f71");
            i["utils"].sha512Sync = (...e) => Object(o["sha512"])(i["utils"].concatBytes(...e));
            const v = i["utils"].randomPrivateKey,
                S = () => {
                    const e = i["utils"].randomPrivateKey(),
                        t = C(e),
                        n = new Uint8Array(64);
                    return n.set(e), n.set(t, 32), {
                        publicKey: t,
                        secretKey: n
                    }
                },
                C = i["sync"].getPublicKey;

            function I(e) {
                try {
                    return i["Point"].fromHex(e, !0), !0
                } catch {
                    return !1
                }
            }
            const A = (e, t) => i["sync"].sign(e, t.slice(0, 32)),
                O = i["sync"].verify,
                x = e => r["Buffer"].isBuffer(e) ? e : e instanceof Uint8Array ? r["Buffer"].from(e.buffer, e.byteOffset, e.byteLength) : r["Buffer"].from(e);
            class _ {
                constructor(e) {
                    Object.assign(this, e)
                }
                encode() {
                    return r["Buffer"].from(Object(d["serialize"])(T, this))
                }
                static decode(e) {
                    return Object(d["deserialize"])(T, this, e)
                }
                static decodeUnchecked(e) {
                    return Object(d["deserializeUnchecked"])(T, this, e)
                }
            }
            class E extends _ {
                constructor(e) {
                    if (super(e), this.enum = "", 1 !== Object.keys(e).length) throw new Error("Enum can only take single value");
                    Object.keys(e).map(e => {
                        this.enum = e
                    })
                }
            }
            const T = new Map,
                P = 32,
                R = 32;

            function j(e) {
                return void 0 !== e._bn
            }
            let B = 1;
            class L extends _ {
                constructor(e) {
                    if (super({}), this._bn = void 0, j(e)) this._bn = e._bn;
                    else {
                        if ("string" === typeof e) {
                            const t = u.a.decode(e);
                            if (t.length != R) throw new Error("Invalid public key input");
                            this._bn = new a.a(t)
                        } else this._bn = new a.a(e);
                        if (this._bn.byteLength() > 32) throw new Error("Invalid public key input")
                    }
                }
                static unique() {
                    const e = new L(B);
                    return B += 1, new L(e.toBuffer())
                }
                equals(e) {
                    return this._bn.eq(e._bn)
                }
                toBase58() {
                    return u.a.encode(this.toBytes())
                }
                toJSON() {
                    return this.toBase58()
                }
                toBytes() {
                    return this.toBuffer()
                }
                toBuffer() {
                    const e = this._bn.toArrayLike(r["Buffer"]);
                    if (e.length === R) return e;
                    const t = r["Buffer"].alloc(32);
                    return e.copy(t, 32 - e.length), t
                }
                toString() {
                    return this.toBase58()
                }
                static async createWithSeed(e, t, n) {
                    const o = r["Buffer"].concat([e.toBuffer(), r["Buffer"].from(t), n.toBuffer()]),
                        i = Object(l["sha256"])(o);
                    return new L(i)
                }
                static createProgramAddressSync(e, t) {
                    let n = r["Buffer"].alloc(0);
                    e.forEach((function(e) {
                        if (e.length > P) throw new TypeError("Max seed length exceeded");
                        n = r["Buffer"].concat([n, x(e)])
                    })), n = r["Buffer"].concat([n, t.toBuffer(), r["Buffer"].from("ProgramDerivedAddress")]);
                    const o = Object(l["sha256"])(n);
                    if (I(o)) throw new Error("Invalid seeds, address must fall off the curve");
                    return new L(o)
                }
                static async createProgramAddress(e, t) {
                    return this.createProgramAddressSync(e, t)
                }
                static findProgramAddressSync(e, t) {
                    let n, o = 255;
                    while (0 != o) {
                        try {
                            const i = e.concat(r["Buffer"].from([o]));
                            n = this.createProgramAddressSync(i, t)
                        } catch (i) {
                            if (i instanceof TypeError) throw i;
                            o--;
                            continue
                        }
                        return [n, o]
                    }
                    throw new Error("Unable to find a viable program address nonce")
                }
                static async findProgramAddress(e, t) {
                    return this.findProgramAddressSync(e, t)
                }
                static isOnCurve(e) {
                    const t = new L(e);
                    return I(t.toBytes())
                }
            }
            L.default = new L("11111111111111111111111111111111"), T.set(L, {
                kind: "struct",
                fields: [
                    ["_bn", "u256"]
                ]
            });
            class W {
                constructor(e) {
                    if (this._publicKey = void 0, this._secretKey = void 0, e) {
                        const t = x(e);
                        if (64 !== e.length) throw new Error("bad secret key size");
                        this._publicKey = t.slice(32, 64), this._secretKey = t.slice(0, 32)
                    } else this._secretKey = x(v()), this._publicKey = x(C(this._secretKey))
                }
                get publicKey() {
                    return new L(this._publicKey)
                }
                get secretKey() {
                    return r["Buffer"].concat([this._secretKey, this._publicKey], 64)
                }
            }
            const N = new L("BPFLoader1111111111111111111111111111111111"),
                M = 1232,
                K = 127,
                U = 64;
            class z extends Error {
                constructor(e) {
                    super(`Signature ${e} has expired: block height exceeded.`), this.signature = void 0, this.signature = e
                }
            }
            Object.defineProperty(z.prototype, "name", {
                value: "TransactionExpiredBlockheightExceededError"
            });
            class D extends Error {
                constructor(e, t) {
                    super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ` + e + " using the Solana Explorer or CLI tools."), this.signature = void 0, this.signature = e
                }
            }
            Object.defineProperty(D.prototype, "name", {
                value: "TransactionExpiredTimeoutError"
            });
            class H {
                constructor(e, t) {
                    this.staticAccountKeys = void 0, this.accountKeysFromLookups = void 0, this.staticAccountKeys = e, this.accountKeysFromLookups = t
                }
                keySegments() {
                    const e = [this.staticAccountKeys];
                    return this.accountKeysFromLookups && (e.push(this.accountKeysFromLookups.writable), e.push(this.accountKeysFromLookups.readonly)), e
                }
                get(e) {
                    for (const t of this.keySegments()) {
                        if (e < t.length) return t[e];
                        e -= t.length
                    }
                }
                get length() {
                    return this.keySegments().flat().length
                }
                compileInstructions(e) {
                    const t = 255;
                    if (this.length > t + 1) throw new Error("Account index overflow encountered during compilation");
                    const n = new Map;
                    this.keySegments().flat().forEach((e, t) => {
                        n.set(e.toBase58(), t)
                    });
                    const r = e => {
                        const t = n.get(e.toBase58());
                        if (void 0 === t) throw new Error("Encountered an unknown instruction account key during compilation");
                        return t
                    };
                    return e.map(e => ({
                        programIdIndex: r(e.programId),
                        accountKeyIndexes: e.keys.map(e => r(e.pubkey)),
                        data: e.data
                    }))
                }
            }
            const q = (e = "publicKey") => h["blob"](32, e),
                $ = (e = "signature") => h["blob"](64, e),
                V = (e = "string") => {
                    const t = h["struct"]([h["u32"]("length"), h["u32"]("lengthPadding"), h["blob"](h["offset"](h["u32"](), -8), "chars")], e),
                        n = t.decode.bind(t),
                        o = t.encode.bind(t),
                        i = t;
                    return i.decode = (e, t) => {
                        const r = n(e, t);
                        return r["chars"].toString()
                    }, i.encode = (e, t, n) => {
                        const i = {
                            chars: r["Buffer"].from(e, "utf8")
                        };
                        return o(i, t, n)
                    }, i.alloc = e => h["u32"]().span + h["u32"]().span + r["Buffer"].from(e, "utf8").length, i
                },
                F = (e = "authorized") => h["struct"]([q("staker"), q("withdrawer")], e),
                G = (e = "lockup") => h["struct"]([h["ns64"]("unixTimestamp"), h["ns64"]("epoch"), q("custodian")], e),
                Y = (e = "voteInit") => h["struct"]([q("nodePubkey"), q("authorizedVoter"), q("authorizedWithdrawer"), h["u8"]("commission")], e),
                J = (e = "voteAuthorizeWithSeedArgs") => h["struct"]([h["u32"]("voteAuthorizationType"), q("currentAuthorityDerivedKeyOwnerPubkey"), V("currentAuthorityDerivedKeySeed"), q("newAuthorized")], e);

            function Z(e, t) {
                const n = e => {
                    if (e.span >= 0) return e.span;
                    if ("function" === typeof e.alloc) return e.alloc(t[e.property]);
                    if ("count" in e && "elementLayout" in e) {
                        const r = t[e.property];
                        if (Array.isArray(r)) return r.length * n(e.elementLayout)
                    } else if ("fields" in e) return Z({
                        layout: e
                    }, t[e.property]);
                    return 0
                };
                let r = 0;
                return e.layout.fields.forEach(e => {
                    r += n(e)
                }), r
            }

            function X(e) {
                let t = 0,
                    n = 0;
                for (;;) {
                    let r = e.shift();
                    if (t |= (127 & r) << 7 * n, n += 1, 0 === (128 & r)) break
                }
                return t
            }

            function Q(e, t) {
                let n = t;
                for (;;) {
                    let t = 127 & n;
                    if (n >>= 7, 0 == n) {
                        e.push(t);
                        break
                    }
                    t |= 128, e.push(t)
                }
            }

            function ee(e, t) {
                if (!e) throw new Error(t || "Assertion failed")
            }
            class te {
                constructor(e, t) {
                    this.payer = void 0, this.keyMetaMap = void 0, this.payer = e, this.keyMetaMap = t
                }
                static compile(e, t) {
                    const n = new Map,
                        r = e => {
                            const t = e.toBase58();
                            let r = n.get(t);
                            return void 0 === r && (r = {
                                isSigner: !1,
                                isWritable: !1,
                                isInvoked: !1
                            }, n.set(t, r)), r
                        },
                        o = r(t);
                    o.isSigner = !0, o.isWritable = !0;
                    for (const i of e) {
                        r(i.programId).isInvoked = !0;
                        for (const e of i.keys) {
                            const t = r(e.pubkey);
                            t.isSigner || (t.isSigner = e.isSigner), t.isWritable || (t.isWritable = e.isWritable)
                        }
                    }
                    return new te(t, n)
                }
                getMessageComponents() {
                    const e = [...this.keyMetaMap.entries()];
                    ee(e.length <= 256, "Max static account keys length exceeded");
                    const t = e.filter(([, e]) => e.isSigner && e.isWritable),
                        n = e.filter(([, e]) => e.isSigner && !e.isWritable),
                        r = e.filter(([, e]) => !e.isSigner && e.isWritable),
                        o = e.filter(([, e]) => !e.isSigner && !e.isWritable),
                        i = {
                            numRequiredSignatures: t.length + n.length,
                            numReadonlySignedAccounts: n.length,
                            numReadonlyUnsignedAccounts: o.length
                        }; {
                        ee(t.length > 0, "Expected at least one writable signer key");
                        const [e] = t[0];
                        ee(e === this.payer.toBase58(), "Expected first writable signer key to be the fee payer")
                    }
                    const s = [...t.map(([e]) => new L(e)), ...n.map(([e]) => new L(e)), ...r.map(([e]) => new L(e)), ...o.map(([e]) => new L(e))];
                    return [i, s]
                }
                extractTableLookup(e) {
                    const [t, n] = this.drainKeysFoundInLookupTable(e.state.addresses, e => !e.isSigner && !e.isInvoked && e.isWritable), [r, o] = this.drainKeysFoundInLookupTable(e.state.addresses, e => !e.isSigner && !e.isInvoked && !e.isWritable);
                    if (0 !== t.length || 0 !== r.length) return [{
                        accountKey: e.key,
                        writableIndexes: t,
                        readonlyIndexes: r
                    }, {
                        writable: n,
                        readonly: o
                    }]
                }
                drainKeysFoundInLookupTable(e, t) {
                    const n = new Array,
                        r = new Array;
                    for (const [o, i] of this.keyMetaMap.entries())
                        if (t(i)) {
                            const t = new L(o),
                                i = e.findIndex(e => e.equals(t));
                            i >= 0 && (ee(i < 256, "Max lookup table index exceeded"), n.push(i), r.push(t), this.keyMetaMap.delete(o))
                        }
                    return [n, r]
                }
            }
            class ne {
                constructor(e) {
                    this.header = void 0, this.accountKeys = void 0, this.recentBlockhash = void 0, this.instructions = void 0, this.indexToProgramIds = new Map, this.header = e.header, this.accountKeys = e.accountKeys.map(e => new L(e)), this.recentBlockhash = e.recentBlockhash, this.instructions = e.instructions, this.instructions.forEach(e => this.indexToProgramIds.set(e.programIdIndex, this.accountKeys[e.programIdIndex]))
                }
                get version() {
                    return "legacy"
                }
                get staticAccountKeys() {
                    return this.accountKeys
                }
                get compiledInstructions() {
                    return this.instructions.map(e => ({
                        programIdIndex: e.programIdIndex,
                        accountKeyIndexes: e.accounts,
                        data: u.a.decode(e.data)
                    }))
                }
                get addressTableLookups() {
                    return []
                }
                getAccountKeys() {
                    return new H(this.staticAccountKeys)
                }
                static compile(e) {
                    const t = te.compile(e.instructions, e.payerKey),
                        [n, r] = t.getMessageComponents(),
                        o = new H(r),
                        i = o.compileInstructions(e.instructions).map(e => ({
                            programIdIndex: e.programIdIndex,
                            accounts: e.accountKeyIndexes,
                            data: u.a.encode(e.data)
                        }));
                    return new ne({
                        header: n,
                        accountKeys: r,
                        recentBlockhash: e.recentBlockhash,
                        instructions: i
                    })
                }
                isAccountSigner(e) {
                    return e < this.header.numRequiredSignatures
                }
                isAccountWritable(e) {
                    const t = this.header.numRequiredSignatures;
                    if (e >= this.header.numRequiredSignatures) {
                        const n = e - t,
                            r = this.accountKeys.length - t,
                            o = r - this.header.numReadonlyUnsignedAccounts;
                        return n < o
                    } {
                        const n = t - this.header.numReadonlySignedAccounts;
                        return e < n
                    }
                }
                isProgramId(e) {
                    return this.indexToProgramIds.has(e)
                }
                programIds() {
                    return [...this.indexToProgramIds.values()]
                }
                nonProgramIds() {
                    return this.accountKeys.filter((e, t) => !this.isProgramId(t))
                }
                serialize() {
                    const e = this.accountKeys.length;
                    let t = [];
                    Q(t, e);
                    const n = this.instructions.map(e => {
                        const {
                            accounts: t,
                            programIdIndex: n
                        } = e, o = Array.from(u.a.decode(e.data));
                        let i = [];
                        Q(i, t.length);
                        let s = [];
                        return Q(s, o.length), {
                            programIdIndex: n,
                            keyIndicesCount: r["Buffer"].from(i),
                            keyIndices: t,
                            dataLength: r["Buffer"].from(s),
                            data: o
                        }
                    });
                    let o = [];
                    Q(o, n.length);
                    let i = r["Buffer"].alloc(M);
                    r["Buffer"].from(o).copy(i);
                    let s = o.length;
                    n.forEach(e => {
                        const t = h["struct"]([h["u8"]("programIdIndex"), h["blob"](e.keyIndicesCount.length, "keyIndicesCount"), h["seq"](h["u8"]("keyIndex"), e.keyIndices.length, "keyIndices"), h["blob"](e.dataLength.length, "dataLength"), h["seq"](h["u8"]("userdatum"), e.data.length, "data")]),
                            n = t.encode(e, i, s);
                        s += n
                    }), i = i.slice(0, s);
                    const a = h["struct"]([h["blob"](1, "numRequiredSignatures"), h["blob"](1, "numReadonlySignedAccounts"), h["blob"](1, "numReadonlyUnsignedAccounts"), h["blob"](t.length, "keyCount"), h["seq"](q("key"), e, "keys"), q("recentBlockhash")]),
                        c = {
                            numRequiredSignatures: r["Buffer"].from([this.header.numRequiredSignatures]),
                            numReadonlySignedAccounts: r["Buffer"].from([this.header.numReadonlySignedAccounts]),
                            numReadonlyUnsignedAccounts: r["Buffer"].from([this.header.numReadonlyUnsignedAccounts]),
                            keyCount: r["Buffer"].from(t),
                            keys: this.accountKeys.map(e => x(e.toBytes())),
                            recentBlockhash: u.a.decode(this.recentBlockhash)
                        };
                    let l = r["Buffer"].alloc(2048);
                    const d = a.encode(c, l);
                    return i.copy(l, d), l.slice(0, d + i.length)
                }
                static from(e) {
                    let t = [...e];
                    const n = t.shift();
                    if (n !== (n & K)) throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
                    const o = t.shift(),
                        i = t.shift(),
                        s = X(t);
                    let a = [];
                    for (let u = 0; u < s; u++) {
                        const e = t.slice(0, R);
                        t = t.slice(R), a.push(new L(r["Buffer"].from(e)))
                    }
                    const c = t.slice(0, R);
                    t = t.slice(R);
                    const l = X(t);
                    let d = [];
                    for (let p = 0; p < l; p++) {
                        const e = t.shift(),
                            n = X(t),
                            o = t.slice(0, n);
                        t = t.slice(n);
                        const i = X(t),
                            s = t.slice(0, i),
                            a = u.a.encode(r["Buffer"].from(s));
                        t = t.slice(i), d.push({
                            programIdIndex: e,
                            accounts: o,
                            data: a
                        })
                    }
                    const h = {
                        header: {
                            numRequiredSignatures: n,
                            numReadonlySignedAccounts: o,
                            numReadonlyUnsignedAccounts: i
                        },
                        recentBlockhash: u.a.encode(r["Buffer"].from(c)),
                        accountKeys: a,
                        instructions: d
                    };
                    return new ne(h)
                }
            }
            class re {
                constructor(e) {
                    this.header = void 0, this.staticAccountKeys = void 0, this.recentBlockhash = void 0, this.compiledInstructions = void 0, this.addressTableLookups = void 0, this.header = e.header, this.staticAccountKeys = e.staticAccountKeys, this.recentBlockhash = e.recentBlockhash, this.compiledInstructions = e.compiledInstructions, this.addressTableLookups = e.addressTableLookups
                }
                get version() {
                    return 0
                }
                get numAccountKeysFromLookups() {
                    let e = 0;
                    for (const t of this.addressTableLookups) e += t.readonlyIndexes.length + t.writableIndexes.length;
                    return e
                }
                getAccountKeys(e) {
                    let t;
                    if (e && "accountKeysFromLookups" in e && e.accountKeysFromLookups) {
                        if (this.numAccountKeysFromLookups != e.accountKeysFromLookups.writable.length + e.accountKeysFromLookups.readonly.length) throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
                        t = e.accountKeysFromLookups
                    } else if (e && "addressLookupTableAccounts" in e && e.addressLookupTableAccounts) t = this.resolveAddressTableLookups(e.addressLookupTableAccounts);
                    else if (this.addressTableLookups.length > 0) throw new Error("Failed to get account keys because address table lookups were not resolved");
                    return new H(this.staticAccountKeys, t)
                }
                isAccountSigner(e) {
                    return e < this.header.numRequiredSignatures
                }
                isAccountWritable(e) {
                    const t = this.header.numRequiredSignatures,
                        n = this.staticAccountKeys.length;
                    if (e >= n) {
                        const t = e - n,
                            r = this.addressTableLookups.reduce((e, t) => e + t.writableIndexes.length, 0);
                        return t < r
                    }
                    if (e >= this.header.numRequiredSignatures) {
                        const r = e - t,
                            o = n - t,
                            i = o - this.header.numReadonlyUnsignedAccounts;
                        return r < i
                    } {
                        const n = t - this.header.numReadonlySignedAccounts;
                        return e < n
                    }
                }
                resolveAddressTableLookups(e) {
                    const t = {
                        writable: [],
                        readonly: []
                    };
                    for (const n of this.addressTableLookups) {
                        const r = e.find(e => e.key.equals(n.accountKey));
                        if (!r) throw new Error("Failed to find address lookup table account for table key " + n.accountKey.toBase58());
                        for (const e of n.writableIndexes) {
                            if (!(e < r.state.addresses.length)) throw new Error(`Failed to find address for index ${e} in address lookup table ${n.accountKey.toBase58()}`);
                            t.writable.push(r.state.addresses[e])
                        }
                        for (const e of n.readonlyIndexes) {
                            if (!(e < r.state.addresses.length)) throw new Error(`Failed to find address for index ${e} in address lookup table ${n.accountKey.toBase58()}`);
                            t.readonly.push(r.state.addresses[e])
                        }
                    }
                    return t
                }
                static compile(e) {
                    const t = te.compile(e.instructions, e.payerKey),
                        n = new Array,
                        r = {
                            writable: new Array,
                            readonly: new Array
                        },
                        o = e.addressLookupTableAccounts || [];
                    for (const u of o) {
                        const e = t.extractTableLookup(u);
                        if (void 0 !== e) {
                            const [t, {
                                writable: o,
                                readonly: i
                            }] = e;
                            n.push(t), r.writable.push(...o), r.readonly.push(...i)
                        }
                    }
                    const [i, s] = t.getMessageComponents(), a = new H(s, r), c = a.compileInstructions(e.instructions);
                    return new re({
                        header: i,
                        staticAccountKeys: s,
                        recentBlockhash: e.recentBlockhash,
                        compiledInstructions: c,
                        addressTableLookups: n
                    })
                }
                serialize() {
                    const e = Array();
                    Q(e, this.staticAccountKeys.length);
                    const t = this.serializeInstructions(),
                        n = Array();
                    Q(n, this.compiledInstructions.length);
                    const r = this.serializeAddressTableLookups(),
                        o = Array();
                    Q(o, this.addressTableLookups.length);
                    const i = h["struct"]([h["u8"]("prefix"), h["struct"]([h["u8"]("numRequiredSignatures"), h["u8"]("numReadonlySignedAccounts"), h["u8"]("numReadonlyUnsignedAccounts")], "header"), h["blob"](e.length, "staticAccountKeysLength"), h["seq"](q(), this.staticAccountKeys.length, "staticAccountKeys"), q("recentBlockhash"), h["blob"](n.length, "instructionsLength"), h["blob"](t.length, "serializedInstructions"), h["blob"](o.length, "addressTableLookupsLength"), h["blob"](r.length, "serializedAddressTableLookups")]),
                        s = new Uint8Array(M),
                        a = 128,
                        c = i.encode({
                            prefix: a,
                            header: this.header,
                            staticAccountKeysLength: new Uint8Array(e),
                            staticAccountKeys: this.staticAccountKeys.map(e => e.toBytes()),
                            recentBlockhash: u.a.decode(this.recentBlockhash),
                            instructionsLength: new Uint8Array(n),
                            serializedInstructions: t,
                            addressTableLookupsLength: new Uint8Array(o),
                            serializedAddressTableLookups: r
                        }, s);
                    return s.slice(0, c)
                }
                serializeInstructions() {
                    let e = 0;
                    const t = new Uint8Array(M);
                    for (const n of this.compiledInstructions) {
                        const r = Array();
                        Q(r, n.accountKeyIndexes.length);
                        const o = Array();
                        Q(o, n.data.length);
                        const i = h["struct"]([h["u8"]("programIdIndex"), h["blob"](r.length, "encodedAccountKeyIndexesLength"), h["seq"](h["u8"](), n.accountKeyIndexes.length, "accountKeyIndexes"), h["blob"](o.length, "encodedDataLength"), h["blob"](n.data.length, "data")]);
                        e += i.encode({
                            programIdIndex: n.programIdIndex,
                            encodedAccountKeyIndexesLength: new Uint8Array(r),
                            accountKeyIndexes: n.accountKeyIndexes,
                            encodedDataLength: new Uint8Array(o),
                            data: n.data
                        }, t, e)
                    }
                    return t.slice(0, e)
                }
                serializeAddressTableLookups() {
                    let e = 0;
                    const t = new Uint8Array(M);
                    for (const n of this.addressTableLookups) {
                        const r = Array();
                        Q(r, n.writableIndexes.length);
                        const o = Array();
                        Q(o, n.readonlyIndexes.length);
                        const i = h["struct"]([q("accountKey"), h["blob"](r.length, "encodedWritableIndexesLength"), h["seq"](h["u8"](), n.writableIndexes.length, "writableIndexes"), h["blob"](o.length, "encodedReadonlyIndexesLength"), h["seq"](h["u8"](), n.readonlyIndexes.length, "readonlyIndexes")]);
                        e += i.encode({
                            accountKey: n.accountKey.toBytes(),
                            encodedWritableIndexesLength: new Uint8Array(r),
                            writableIndexes: n.writableIndexes,
                            encodedReadonlyIndexesLength: new Uint8Array(o),
                            readonlyIndexes: n.readonlyIndexes
                        }, t, e)
                    }
                    return t.slice(0, e)
                }
                static deserialize(e) {
                    let t = [...e];
                    const n = t.shift(),
                        r = n & K;
                    ee(n !== r, "Expected versioned message but received legacy message");
                    const o = r;
                    ee(0 === o, "Expected versioned message with version 0 but found version " + o);
                    const i = {
                            numRequiredSignatures: t.shift(),
                            numReadonlySignedAccounts: t.shift(),
                            numReadonlyUnsignedAccounts: t.shift()
                        },
                        s = [],
                        a = X(t);
                    for (let u = 0; u < a; u++) s.push(new L(t.splice(0, R)));
                    const c = u.a.encode(t.splice(0, R)),
                        l = X(t),
                        d = [];
                    for (let u = 0; u < l; u++) {
                        const e = t.shift(),
                            n = X(t),
                            r = t.splice(0, n),
                            o = X(t),
                            i = new Uint8Array(t.splice(0, o));
                        d.push({
                            programIdIndex: e,
                            accountKeyIndexes: r,
                            data: i
                        })
                    }
                    const h = X(t),
                        p = [];
                    for (let u = 0; u < h; u++) {
                        const e = new L(t.splice(0, R)),
                            n = X(t),
                            r = t.splice(0, n),
                            o = X(t),
                            i = t.splice(0, o);
                        p.push({
                            accountKey: e,
                            writableIndexes: r,
                            readonlyIndexes: i
                        })
                    }
                    return new re({
                        header: i,
                        staticAccountKeys: s,
                        recentBlockhash: c,
                        compiledInstructions: d,
                        addressTableLookups: p
                    })
                }
            }
            const oe = {
                deserializeMessageVersion(e) {
                    const t = e[0],
                        n = t & K;
                    return n === t ? "legacy" : n
                },
                deserialize: e => {
                    const t = oe.deserializeMessageVersion(e);
                    if ("legacy" === t) return ne.from(e);
                    if (0 === t) return re.deserialize(e);
                    throw new Error(`Transaction message version ${t} deserialization is not supported`)
                }
            };
            let ie;
            (function(e) {
                e[e["BLOCKHEIGHT_EXCEEDED"] = 0] = "BLOCKHEIGHT_EXCEEDED", e[e["PROCESSED"] = 1] = "PROCESSED", e[e["TIMED_OUT"] = 2] = "TIMED_OUT"
            })(ie || (ie = {}));
            const se = r["Buffer"].alloc(U).fill(0);
            class ae {
                constructor(e) {
                    this.keys = void 0, this.programId = void 0, this.data = r["Buffer"].alloc(0), this.programId = e.programId, this.keys = e.keys, e.data && (this.data = e.data)
                }
                toJSON() {
                    return {
                        keys: this.keys.map(({
                            pubkey: e,
                            isSigner: t,
                            isWritable: n
                        }) => ({
                            pubkey: e.toJSON(),
                            isSigner: t,
                            isWritable: n
                        })),
                        programId: this.programId.toJSON(),
                        data: [...this.data]
                    }
                }
            }
            class ce {
                get signature() {
                    return this.signatures.length > 0 ? this.signatures[0].signature : null
                }
                constructor(e) {
                    if (this.signatures = [], this.feePayer = void 0, this.instructions = [], this.recentBlockhash = void 0, this.lastValidBlockHeight = void 0, this.nonceInfo = void 0, this._message = void 0, this._json = void 0, e)
                        if (e.feePayer && (this.feePayer = e.feePayer), e.signatures && (this.signatures = e.signatures), Object.prototype.hasOwnProperty.call(e, "lastValidBlockHeight")) {
                            const {
                                blockhash: t,
                                lastValidBlockHeight: n
                            } = e;
                            this.recentBlockhash = t, this.lastValidBlockHeight = n
                        } else {
                            const {
                                recentBlockhash: t,
                                nonceInfo: n
                            } = e;
                            n && (this.nonceInfo = n), this.recentBlockhash = t
                        }
                }
                toJSON() {
                    return {
                        recentBlockhash: this.recentBlockhash || null,
                        feePayer: this.feePayer ? this.feePayer.toJSON() : null,
                        nonceInfo: this.nonceInfo ? {
                            nonce: this.nonceInfo.nonce,
                            nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
                        } : null,
                        instructions: this.instructions.map(e => e.toJSON()),
                        signers: this.signatures.map(({
                            publicKey: e
                        }) => e.toJSON())
                    }
                }
                add(...e) {
                    if (0 === e.length) throw new Error("No instructions");
                    return e.forEach(e => {
                        "instructions" in e ? this.instructions = this.instructions.concat(e.instructions) : "data" in e && "programId" in e && "keys" in e ? this.instructions.push(e) : this.instructions.push(new ae(e))
                    }), this
                }
                compileMessage() {
                    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) return this._message;
                    let e, t, n;
                    if (this.nonceInfo ? (e = this.nonceInfo.nonce, t = this.instructions[0] != this.nonceInfo.nonceInstruction ? [this.nonceInfo.nonceInstruction, ...this.instructions] : this.instructions) : (e = this.recentBlockhash, t = this.instructions), !e) throw new Error("Transaction recentBlockhash required");
                    if (t.length < 1 && console.warn("No instructions provided"), this.feePayer) n = this.feePayer;
                    else {
                        if (!(this.signatures.length > 0 && this.signatures[0].publicKey)) throw new Error("Transaction fee payer required");
                        n = this.signatures[0].publicKey
                    }
                    for (let u = 0; u < t.length; u++)
                        if (void 0 === t[u].programId) throw new Error(`Transaction instruction index ${u} has undefined program id`);
                    const r = [],
                        o = [];
                    t.forEach(e => {
                        e.keys.forEach(e => {
                            o.push({ ...e
                            })
                        });
                        const t = e.programId.toString();
                        r.includes(t) || r.push(t)
                    }), r.forEach(e => {
                        o.push({
                            pubkey: new L(e),
                            isSigner: !1,
                            isWritable: !1
                        })
                    });
                    const i = [];
                    o.forEach(e => {
                        const t = e.pubkey.toString(),
                            n = i.findIndex(e => e.pubkey.toString() === t);
                        n > -1 ? (i[n].isWritable = i[n].isWritable || e.isWritable, i[n].isSigner = i[n].isSigner || e.isSigner) : i.push(e)
                    }), i.sort((function(e, t) {
                        return e.isSigner !== t.isSigner ? e.isSigner ? -1 : 1 : e.isWritable !== t.isWritable ? e.isWritable ? -1 : 1 : e.pubkey.toBase58().localeCompare(t.pubkey.toBase58())
                    }));
                    const s = i.findIndex(e => e.pubkey.equals(n));
                    if (s > -1) {
                        const [e] = i.splice(s, 1);
                        e.isSigner = !0, e.isWritable = !0, i.unshift(e)
                    } else i.unshift({
                        pubkey: n,
                        isSigner: !0,
                        isWritable: !0
                    });
                    for (const u of this.signatures) {
                        const e = i.findIndex(e => e.pubkey.equals(u.publicKey));
                        if (!(e > -1)) throw new Error("unknown signer: " + u.publicKey.toString());
                        i[e].isSigner || (i[e].isSigner = !0, console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."))
                    }
                    let a = 0,
                        c = 0,
                        l = 0;
                    const d = [],
                        h = [];
                    i.forEach(({
                        pubkey: e,
                        isSigner: t,
                        isWritable: n
                    }) => {
                        t ? (d.push(e.toString()), a += 1, n || (c += 1)) : (h.push(e.toString()), n || (l += 1))
                    });
                    const p = d.concat(h),
                        g = t.map(e => {
                            const {
                                data: t,
                                programId: n
                            } = e;
                            return {
                                programIdIndex: p.indexOf(n.toString()),
                                accounts: e.keys.map(e => p.indexOf(e.pubkey.toString())),
                                data: u.a.encode(t)
                            }
                        });
                    return g.forEach(e => {
                        ee(e.programIdIndex >= 0), e.accounts.forEach(e => ee(e >= 0))
                    }), new ne({
                        header: {
                            numRequiredSignatures: a,
                            numReadonlySignedAccounts: c,
                            numReadonlyUnsignedAccounts: l
                        },
                        accountKeys: p,
                        recentBlockhash: e,
                        instructions: g
                    })
                }
                _compile() {
                    const e = this.compileMessage(),
                        t = e.accountKeys.slice(0, e.header.numRequiredSignatures);
                    if (this.signatures.length === t.length) {
                        const n = this.signatures.every((e, n) => t[n].equals(e.publicKey));
                        if (n) return e
                    }
                    return this.signatures = t.map(e => ({
                        signature: null,
                        publicKey: e
                    })), e
                }
                serializeMessage() {
                    return this._compile().serialize()
                }
                async getEstimatedFee(e) {
                    return (await e.getFeeForMessage(this.compileMessage())).value
                }
                setSigners(...e) {
                    if (0 === e.length) throw new Error("No signers");
                    const t = new Set;
                    this.signatures = e.filter(e => {
                        const n = e.toString();
                        return !t.has(n) && (t.add(n), !0)
                    }).map(e => ({
                        signature: null,
                        publicKey: e
                    }))
                }
                sign(...e) {
                    if (0 === e.length) throw new Error("No signers");
                    const t = new Set,
                        n = [];
                    for (const o of e) {
                        const e = o.publicKey.toString();
                        t.has(e) || (t.add(e), n.push(o))
                    }
                    this.signatures = n.map(e => ({
                        signature: null,
                        publicKey: e.publicKey
                    }));
                    const r = this._compile();
                    this._partialSign(r, ...n)
                }
                partialSign(...e) {
                    if (0 === e.length) throw new Error("No signers");
                    const t = new Set,
                        n = [];
                    for (const o of e) {
                        const e = o.publicKey.toString();
                        t.has(e) || (t.add(e), n.push(o))
                    }
                    const r = this._compile();
                    this._partialSign(r, ...n)
                }
                _partialSign(e, ...t) {
                    const n = e.serialize();
                    t.forEach(e => {
                        const t = A(n, e.secretKey);
                        this._addSignature(e.publicKey, x(t))
                    })
                }
                addSignature(e, t) {
                    this._compile(), this._addSignature(e, t)
                }
                _addSignature(e, t) {
                    ee(64 === t.length);
                    const n = this.signatures.findIndex(t => e.equals(t.publicKey));
                    if (n < 0) throw new Error("unknown signer: " + e.toString());
                    this.signatures[n].signature = r["Buffer"].from(t)
                }
                verifySignatures() {
                    return this._verifySignatures(this.serializeMessage(), !0)
                }
                _verifySignatures(e, t) {
                    for (const {
                            signature: n,
                            publicKey: r
                        } of this.signatures)
                        if (null === n) {
                            if (t) return !1
                        } else if (!O(n, e, r.toBuffer())) return !1;
                    return !0
                }
                serialize(e) {
                    const {
                        requireAllSignatures: t,
                        verifySignatures: n
                    } = Object.assign({
                        requireAllSignatures: !0,
                        verifySignatures: !0
                    }, e), r = this.serializeMessage();
                    if (n && !this._verifySignatures(r, t)) throw new Error("Signature verification failed");
                    return this._serialize(r)
                }
                _serialize(e) {
                    const {
                        signatures: t
                    } = this, n = [];
                    Q(n, t.length);
                    const o = n.length + 64 * t.length + e.length,
                        i = r["Buffer"].alloc(o);
                    return ee(t.length < 256), r["Buffer"].from(n).copy(i, 0), t.forEach(({
                        signature: e
                    }, t) => {
                        null !== e && (ee(64 === e.length, "signature has invalid length"), r["Buffer"].from(e).copy(i, n.length + 64 * t))
                    }), e.copy(i, n.length + 64 * t.length), ee(i.length <= M, `Transaction too large: ${i.length} > ${M}`), i
                }
                get keys() {
                    return ee(1 === this.instructions.length), this.instructions[0].keys.map(e => e.pubkey)
                }
                get programId() {
                    return ee(1 === this.instructions.length), this.instructions[0].programId
                }
                get data() {
                    return ee(1 === this.instructions.length), this.instructions[0].data
                }
                static from(e) {
                    let t = [...e];
                    const n = X(t);
                    let o = [];
                    for (let i = 0; i < n; i++) {
                        const e = t.slice(0, U);
                        t = t.slice(U), o.push(u.a.encode(r["Buffer"].from(e)))
                    }
                    return ce.populate(ne.from(t), o)
                }
                static populate(e, t = []) {
                    const n = new ce;
                    return n.recentBlockhash = e.recentBlockhash, e.header.numRequiredSignatures > 0 && (n.feePayer = e.accountKeys[0]), t.forEach((t, r) => {
                        const o = {
                            signature: t == u.a.encode(se) ? null : u.a.decode(t),
                            publicKey: e.accountKeys[r]
                        };
                        n.signatures.push(o)
                    }), e.instructions.forEach(t => {
                        const r = t.accounts.map(t => {
                            const r = e.accountKeys[t];
                            return {
                                pubkey: r,
                                isSigner: n.signatures.some(e => e.publicKey.toString() === r.toString()) || e.isAccountSigner(t),
                                isWritable: e.isAccountWritable(t)
                            }
                        });
                        n.instructions.push(new ae({
                            keys: r,
                            programId: e.accountKeys[t.programIdIndex],
                            data: u.a.decode(t.data)
                        }))
                    }), n._message = e, n._json = n.toJSON(), n
                }
            }
            class ue {
                constructor(e) {
                    this.payerKey = void 0, this.instructions = void 0, this.recentBlockhash = void 0, this.payerKey = e.payerKey, this.instructions = e.instructions, this.recentBlockhash = e.recentBlockhash
                }
                static decompile(e, t) {
                    const {
                        header: n,
                        compiledInstructions: r,
                        recentBlockhash: o
                    } = e, {
                        numRequiredSignatures: i,
                        numReadonlySignedAccounts: s,
                        numReadonlyUnsignedAccounts: a
                    } = n, c = i - s;
                    ee(c > 0, "Message header is invalid");
                    const u = e.staticAccountKeys.length - a;
                    ee(u >= 0, "Message header is invalid");
                    const l = e.getAccountKeys(t),
                        d = l.get(0);
                    if (void 0 === d) throw new Error("Failed to decompile message because no account keys were found");
                    const h = [];
                    for (const p of r) {
                        const e = [];
                        for (const r of p.accountKeyIndexes) {
                            const t = l.get(r);
                            if (void 0 === t) throw new Error("Failed to find key for account key index " + r);
                            const o = r < i;
                            let s;
                            s = o ? r < c : r < l.staticAccountKeys.length ? r - i < u : r - l.staticAccountKeys.length < l.accountKeysFromLookups.writable.length, e.push({
                                pubkey: t,
                                isSigner: r < n.numRequiredSignatures,
                                isWritable: s
                            })
                        }
                        const t = l.get(p.programIdIndex);
                        if (void 0 === t) throw new Error("Failed to find program id for program id index " + p.programIdIndex);
                        h.push(new ae({
                            programId: t,
                            data: x(p.data),
                            keys: e
                        }))
                    }
                    return new ue({
                        payerKey: d,
                        instructions: h,
                        recentBlockhash: o
                    })
                }
                compileToLegacyMessage() {
                    return ne.compile({
                        payerKey: this.payerKey,
                        recentBlockhash: this.recentBlockhash,
                        instructions: this.instructions
                    })
                }
                compileToV0Message(e) {
                    return re.compile({
                        payerKey: this.payerKey,
                        recentBlockhash: this.recentBlockhash,
                        instructions: this.instructions,
                        addressLookupTableAccounts: e
                    })
                }
            }
            class le {
                get version() {
                    return this.message.version
                }
                constructor(e, t) {
                    if (this.signatures = void 0, this.message = void 0, void 0 !== t) ee(t.length === e.header.numRequiredSignatures, "Expected signatures length to be equal to the number of required signatures"), this.signatures = t;
                    else {
                        const t = [];
                        for (let n = 0; n < e.header.numRequiredSignatures; n++) t.push(new Uint8Array(U));
                        this.signatures = t
                    }
                    this.message = e
                }
                serialize() {
                    const e = this.message.serialize(),
                        t = Array();
                    Q(t, this.signatures.length);
                    const n = h["struct"]([h["blob"](t.length, "encodedSignaturesLength"), h["seq"]($(), this.signatures.length, "signatures"), h["blob"](e.length, "serializedMessage")]),
                        r = new Uint8Array(2048),
                        o = n.encode({
                            encodedSignaturesLength: new Uint8Array(t),
                            signatures: this.signatures,
                            serializedMessage: e
                        }, r);
                    return r.slice(0, o)
                }
                static deserialize(e) {
                    let t = [...e];
                    const n = [],
                        r = X(t);
                    for (let i = 0; i < r; i++) n.push(new Uint8Array(t.splice(0, U)));
                    const o = oe.deserialize(new Uint8Array(t));
                    return new le(o, n)
                }
                sign(e) {
                    const t = this.message.serialize(),
                        n = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
                    for (const r of e) {
                        const e = n.findIndex(e => e.equals(r.publicKey));
                        ee(e >= 0, "Cannot sign with non signer key " + r.publicKey.toBase58()), this.signatures[e] = A(t, r.secretKey)
                    }
                }
                addSignature(e, t) {
                    ee(64 === t.byteLength, "Signature must be 64 bytes long");
                    const n = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures),
                        r = n.findIndex(t => t.equals(e));
                    ee(r >= 0, `Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`), this.signatures[r] = t
                }
            }
            const de = new L("SysvarC1ock11111111111111111111111111111111"),
                he = new L("SysvarEpochSchedu1e111111111111111111111111"),
                pe = new L("Sysvar1nstructions1111111111111111111111111"),
                ge = new L("SysvarRecentB1ockHashes11111111111111111111"),
                fe = new L("SysvarRent111111111111111111111111111111111"),
                be = new L("SysvarRewards111111111111111111111111111111"),
                ye = new L("SysvarS1otHashes111111111111111111111111111"),
                me = new L("SysvarS1otHistory11111111111111111111111111"),
                we = new L("SysvarStakeHistory1111111111111111111111111");
            async function ke(e, t, n, r) {
                const o = r && {
                        skipPreflight: r.skipPreflight,
                        preflightCommitment: r.preflightCommitment || r.commitment,
                        maxRetries: r.maxRetries,
                        minContextSlot: r.minContextSlot
                    },
                    i = await e.sendTransaction(t, n, o),
                    s = null != t.recentBlockhash && null != t.lastValidBlockHeight ? (await e.confirmTransaction({
                        signature: i,
                        blockhash: t.recentBlockhash,
                        lastValidBlockHeight: t.lastValidBlockHeight
                    }, r && r.commitment)).value : (await e.confirmTransaction(i, r && r.commitment)).value;
                if (s.err) throw new Error(`Transaction ${i} failed (${JSON.stringify(s)})`);
                return i
            }

            function ve(e) {
                return new Promise(t => setTimeout(t, e))
            }

            function Se(e, t) {
                const n = e.layout.span >= 0 ? e.layout.span : Z(e, t),
                    o = r["Buffer"].alloc(n),
                    i = Object.assign({
                        instruction: e.index
                    }, t);
                return e.layout.encode(i, o), o
            }

            function Ce(e, t) {
                let n;
                try {
                    n = e.layout.decode(t)
                } catch (r) {
                    throw new Error("invalid instruction; " + r)
                }
                if (n.instruction !== e.index) throw new Error(`invalid instruction; instruction index mismatch ${n.instruction} != ${e.index}`);
                return n
            }
            const Ie = h["nu64"]("lamportsPerSignature"),
                Ae = h["struct"]([h["u32"]("version"), h["u32"]("state"), q("authorizedPubkey"), q("nonce"), h["struct"]([Ie], "feeCalculator")]),
                Oe = Ae.span;
            class xe {
                constructor(e) {
                    this.authorizedPubkey = void 0, this.nonce = void 0, this.feeCalculator = void 0, this.authorizedPubkey = e.authorizedPubkey, this.nonce = e.nonce, this.feeCalculator = e.feeCalculator
                }
                static fromAccountData(e) {
                    const t = Ae.decode(x(e), 0);
                    return new xe({
                        authorizedPubkey: new L(t.authorizedPubkey),
                        nonce: new L(t.nonce).toString(),
                        feeCalculator: t.feeCalculator
                    })
                }
            }
            const _e = e => {
                    const t = e.decode.bind(e),
                        n = e.encode.bind(e);
                    return {
                        decode: t,
                        encode: n
                    }
                },
                Ee = e => t => {
                    const n = Object(h["blob"])(e, t),
                        {
                            encode: o,
                            decode: i
                        } = _e(n),
                        s = n;
                    return s.decode = (e, t) => {
                        const n = i(e, t);
                        return Object(p["toBigIntLE"])(r["Buffer"].from(n))
                    }, s.encode = (t, n, r) => {
                        const i = Object(p["toBufferLE"])(t, e);
                        return o(i, n, r)
                    }, s
                },
                Te = Ee(8);
            class Pe {
                constructor() {}
                static decodeInstructionType(e) {
                    this.checkProgramId(e.programId);
                    const t = h["u32"]("instruction"),
                        n = t.decode(e.data);
                    let r;
                    for (const [o, i] of Object.entries(Re))
                        if (i.index == n) {
                            r = o;
                            break
                        }
                    if (!r) throw new Error("Instruction type incorrect; not a SystemInstruction");
                    return r
                }
                static decodeCreateAccount(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
                    const {
                        lamports: t,
                        space: n,
                        programId: r
                    } = Ce(Re.Create, e.data);
                    return {
                        fromPubkey: e.keys[0].pubkey,
                        newAccountPubkey: e.keys[1].pubkey,
                        lamports: t,
                        space: n,
                        programId: new L(r)
                    }
                }
                static decodeTransfer(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
                    const {
                        lamports: t
                    } = Ce(Re.Transfer, e.data);
                    return {
                        fromPubkey: e.keys[0].pubkey,
                        toPubkey: e.keys[1].pubkey,
                        lamports: t
                    }
                }
                static decodeTransferWithSeed(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
                    const {
                        lamports: t,
                        seed: n,
                        programId: r
                    } = Ce(Re.TransferWithSeed, e.data);
                    return {
                        fromPubkey: e.keys[0].pubkey,
                        basePubkey: e.keys[1].pubkey,
                        toPubkey: e.keys[2].pubkey,
                        lamports: t,
                        seed: n,
                        programId: new L(r)
                    }
                }
                static decodeAllocate(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 1);
                    const {
                        space: t
                    } = Ce(Re.Allocate, e.data);
                    return {
                        accountPubkey: e.keys[0].pubkey,
                        space: t
                    }
                }
                static decodeAllocateWithSeed(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 1);
                    const {
                        base: t,
                        seed: n,
                        space: r,
                        programId: o
                    } = Ce(Re.AllocateWithSeed, e.data);
                    return {
                        accountPubkey: e.keys[0].pubkey,
                        basePubkey: new L(t),
                        seed: n,
                        space: r,
                        programId: new L(o)
                    }
                }
                static decodeAssign(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 1);
                    const {
                        programId: t
                    } = Ce(Re.Assign, e.data);
                    return {
                        accountPubkey: e.keys[0].pubkey,
                        programId: new L(t)
                    }
                }
                static decodeAssignWithSeed(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 1);
                    const {
                        base: t,
                        seed: n,
                        programId: r
                    } = Ce(Re.AssignWithSeed, e.data);
                    return {
                        accountPubkey: e.keys[0].pubkey,
                        basePubkey: new L(t),
                        seed: n,
                        programId: new L(r)
                    }
                }
                static decodeCreateWithSeed(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
                    const {
                        base: t,
                        seed: n,
                        lamports: r,
                        space: o,
                        programId: i
                    } = Ce(Re.CreateWithSeed, e.data);
                    return {
                        fromPubkey: e.keys[0].pubkey,
                        newAccountPubkey: e.keys[1].pubkey,
                        basePubkey: new L(t),
                        seed: n,
                        lamports: r,
                        space: o,
                        programId: new L(i)
                    }
                }
                static decodeNonceInitialize(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
                    const {
                        authorized: t
                    } = Ce(Re.InitializeNonceAccount, e.data);
                    return {
                        noncePubkey: e.keys[0].pubkey,
                        authorizedPubkey: new L(t)
                    }
                }
                static decodeNonceAdvance(e) {
                    return this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3), Ce(Re.AdvanceNonceAccount, e.data), {
                        noncePubkey: e.keys[0].pubkey,
                        authorizedPubkey: e.keys[2].pubkey
                    }
                }
                static decodeNonceWithdraw(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 5);
                    const {
                        lamports: t
                    } = Ce(Re.WithdrawNonceAccount, e.data);
                    return {
                        noncePubkey: e.keys[0].pubkey,
                        toPubkey: e.keys[1].pubkey,
                        authorizedPubkey: e.keys[4].pubkey,
                        lamports: t
                    }
                }
                static decodeNonceAuthorize(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
                    const {
                        authorized: t
                    } = Ce(Re.AuthorizeNonceAccount, e.data);
                    return {
                        noncePubkey: e.keys[0].pubkey,
                        authorizedPubkey: e.keys[1].pubkey,
                        newAuthorizedPubkey: new L(t)
                    }
                }
                static checkProgramId(e) {
                    if (!e.equals(je.programId)) throw new Error("invalid instruction; programId is not SystemProgram")
                }
                static checkKeyLength(e, t) {
                    if (e.length < t) throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)
                }
            }
            const Re = Object.freeze({
                Create: {
                    index: 0,
                    layout: h["struct"]([h["u32"]("instruction"), h["ns64"]("lamports"), h["ns64"]("space"), q("programId")])
                },
                Assign: {
                    index: 1,
                    layout: h["struct"]([h["u32"]("instruction"), q("programId")])
                },
                Transfer: {
                    index: 2,
                    layout: h["struct"]([h["u32"]("instruction"), Te("lamports")])
                },
                CreateWithSeed: {
                    index: 3,
                    layout: h["struct"]([h["u32"]("instruction"), q("base"), V("seed"), h["ns64"]("lamports"), h["ns64"]("space"), q("programId")])
                },
                AdvanceNonceAccount: {
                    index: 4,
                    layout: h["struct"]([h["u32"]("instruction")])
                },
                WithdrawNonceAccount: {
                    index: 5,
                    layout: h["struct"]([h["u32"]("instruction"), h["ns64"]("lamports")])
                },
                InitializeNonceAccount: {
                    index: 6,
                    layout: h["struct"]([h["u32"]("instruction"), q("authorized")])
                },
                AuthorizeNonceAccount: {
                    index: 7,
                    layout: h["struct"]([h["u32"]("instruction"), q("authorized")])
                },
                Allocate: {
                    index: 8,
                    layout: h["struct"]([h["u32"]("instruction"), h["ns64"]("space")])
                },
                AllocateWithSeed: {
                    index: 9,
                    layout: h["struct"]([h["u32"]("instruction"), q("base"), V("seed"), h["ns64"]("space"), q("programId")])
                },
                AssignWithSeed: {
                    index: 10,
                    layout: h["struct"]([h["u32"]("instruction"), q("base"), V("seed"), q("programId")])
                },
                TransferWithSeed: {
                    index: 11,
                    layout: h["struct"]([h["u32"]("instruction"), Te("lamports"), V("seed"), q("programId")])
                },
                UpgradeNonceAccount: {
                    index: 12,
                    layout: h["struct"]([h["u32"]("instruction")])
                }
            });
            class je {
                constructor() {}
                static createAccount(e) {
                    const t = Re.Create,
                        n = Se(t, {
                            lamports: e.lamports,
                            space: e.space,
                            programId: x(e.programId.toBuffer())
                        });
                    return new ae({
                        keys: [{
                            pubkey: e.fromPubkey,
                            isSigner: !0,
                            isWritable: !0
                        }, {
                            pubkey: e.newAccountPubkey,
                            isSigner: !0,
                            isWritable: !0
                        }],
                        programId: this.programId,
                        data: n
                    })
                }
                static transfer(e) {
                    let t, n;
                    if ("basePubkey" in e) {
                        const r = Re.TransferWithSeed;
                        t = Se(r, {
                            lamports: BigInt(e.lamports),
                            seed: e.seed,
                            programId: x(e.programId.toBuffer())
                        }), n = [{
                            pubkey: e.fromPubkey,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: e.basePubkey,
                            isSigner: !0,
                            isWritable: !1
                        }, {
                            pubkey: e.toPubkey,
                            isSigner: !1,
                            isWritable: !0
                        }]
                    } else {
                        const r = Re.Transfer;
                        t = Se(r, {
                            lamports: BigInt(e.lamports)
                        }), n = [{
                            pubkey: e.fromPubkey,
                            isSigner: !0,
                            isWritable: !0
                        }, {
                            pubkey: e.toPubkey,
                            isSigner: !1,
                            isWritable: !0
                        }]
                    }
                    return new ae({
                        keys: n,
                        programId: this.programId,
                        data: t
                    })
                }
                static assign(e) {
                    let t, n;
                    if ("basePubkey" in e) {
                        const r = Re.AssignWithSeed;
                        t = Se(r, {
                            base: x(e.basePubkey.toBuffer()),
                            seed: e.seed,
                            programId: x(e.programId.toBuffer())
                        }), n = [{
                            pubkey: e.accountPubkey,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: e.basePubkey,
                            isSigner: !0,
                            isWritable: !1
                        }]
                    } else {
                        const r = Re.Assign;
                        t = Se(r, {
                            programId: x(e.programId.toBuffer())
                        }), n = [{
                            pubkey: e.accountPubkey,
                            isSigner: !0,
                            isWritable: !0
                        }]
                    }
                    return new ae({
                        keys: n,
                        programId: this.programId,
                        data: t
                    })
                }
                static createAccountWithSeed(e) {
                    const t = Re.CreateWithSeed,
                        n = Se(t, {
                            base: x(e.basePubkey.toBuffer()),
                            seed: e.seed,
                            lamports: e.lamports,
                            space: e.space,
                            programId: x(e.programId.toBuffer())
                        });
                    let r = [{
                        pubkey: e.fromPubkey,
                        isSigner: !0,
                        isWritable: !0
                    }, {
                        pubkey: e.newAccountPubkey,
                        isSigner: !1,
                        isWritable: !0
                    }];
                    return e.basePubkey != e.fromPubkey && r.push({
                        pubkey: e.basePubkey,
                        isSigner: !0,
                        isWritable: !1
                    }), new ae({
                        keys: r,
                        programId: this.programId,
                        data: n
                    })
                }
                static createNonceAccount(e) {
                    const t = new ce;
                    "basePubkey" in e && "seed" in e ? t.add(je.createAccountWithSeed({
                        fromPubkey: e.fromPubkey,
                        newAccountPubkey: e.noncePubkey,
                        basePubkey: e.basePubkey,
                        seed: e.seed,
                        lamports: e.lamports,
                        space: Oe,
                        programId: this.programId
                    })) : t.add(je.createAccount({
                        fromPubkey: e.fromPubkey,
                        newAccountPubkey: e.noncePubkey,
                        lamports: e.lamports,
                        space: Oe,
                        programId: this.programId
                    }));
                    const n = {
                        noncePubkey: e.noncePubkey,
                        authorizedPubkey: e.authorizedPubkey
                    };
                    return t.add(this.nonceInitialize(n)), t
                }
                static nonceInitialize(e) {
                    const t = Re.InitializeNonceAccount,
                        n = Se(t, {
                            authorized: x(e.authorizedPubkey.toBuffer())
                        }),
                        r = {
                            keys: [{
                                pubkey: e.noncePubkey,
                                isSigner: !1,
                                isWritable: !0
                            }, {
                                pubkey: ge,
                                isSigner: !1,
                                isWritable: !1
                            }, {
                                pubkey: fe,
                                isSigner: !1,
                                isWritable: !1
                            }],
                            programId: this.programId,
                            data: n
                        };
                    return new ae(r)
                }
                static nonceAdvance(e) {
                    const t = Re.AdvanceNonceAccount,
                        n = Se(t),
                        r = {
                            keys: [{
                                pubkey: e.noncePubkey,
                                isSigner: !1,
                                isWritable: !0
                            }, {
                                pubkey: ge,
                                isSigner: !1,
                                isWritable: !1
                            }, {
                                pubkey: e.authorizedPubkey,
                                isSigner: !0,
                                isWritable: !1
                            }],
                            programId: this.programId,
                            data: n
                        };
                    return new ae(r)
                }
                static nonceWithdraw(e) {
                    const t = Re.WithdrawNonceAccount,
                        n = Se(t, {
                            lamports: e.lamports
                        });
                    return new ae({
                        keys: [{
                            pubkey: e.noncePubkey,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: e.toPubkey,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: ge,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: fe,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: e.authorizedPubkey,
                            isSigner: !0,
                            isWritable: !1
                        }],
                        programId: this.programId,
                        data: n
                    })
                }
                static nonceAuthorize(e) {
                    const t = Re.AuthorizeNonceAccount,
                        n = Se(t, {
                            authorized: x(e.newAuthorizedPubkey.toBuffer())
                        });
                    return new ae({
                        keys: [{
                            pubkey: e.noncePubkey,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: e.authorizedPubkey,
                            isSigner: !0,
                            isWritable: !1
                        }],
                        programId: this.programId,
                        data: n
                    })
                }
                static allocate(e) {
                    let t, n;
                    if ("basePubkey" in e) {
                        const r = Re.AllocateWithSeed;
                        t = Se(r, {
                            base: x(e.basePubkey.toBuffer()),
                            seed: e.seed,
                            space: e.space,
                            programId: x(e.programId.toBuffer())
                        }), n = [{
                            pubkey: e.accountPubkey,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: e.basePubkey,
                            isSigner: !0,
                            isWritable: !1
                        }]
                    } else {
                        const r = Re.Allocate;
                        t = Se(r, {
                            space: e.space
                        }), n = [{
                            pubkey: e.accountPubkey,
                            isSigner: !0,
                            isWritable: !0
                        }]
                    }
                    return new ae({
                        keys: n,
                        programId: this.programId,
                        data: t
                    })
                }
            }
            je.programId = new L("11111111111111111111111111111111");
            const Be = M - 300;
            class Le {
                constructor() {}
                static getMinNumSignatures(e) {
                    return 2 * (Math.ceil(e / Le.chunkSize) + 1 + 1)
                }
                static async load(e, t, n, o, i) {
                    {
                        const r = await e.getMinimumBalanceForRentExemption(i.length),
                            s = await e.getAccountInfo(n.publicKey, "confirmed");
                        let a = null;
                        if (null !== s) {
                            if (s.executable) return console.error("Program load failed, account is already executable"), !1;
                            s.data.length !== i.length && (a = a || new ce, a.add(je.allocate({
                                accountPubkey: n.publicKey,
                                space: i.length
                            }))), s.owner.equals(o) || (a = a || new ce, a.add(je.assign({
                                accountPubkey: n.publicKey,
                                programId: o
                            }))), s.lamports < r && (a = a || new ce, a.add(je.transfer({
                                fromPubkey: t.publicKey,
                                toPubkey: n.publicKey,
                                lamports: r - s.lamports
                            })))
                        } else a = (new ce).add(je.createAccount({
                            fromPubkey: t.publicKey,
                            newAccountPubkey: n.publicKey,
                            lamports: r > 0 ? r : 1,
                            space: i.length,
                            programId: o
                        }));
                        null !== a && await ke(e, a, [t, n], {
                            commitment: "confirmed"
                        })
                    }
                    const s = h["struct"]([h["u32"]("instruction"), h["u32"]("offset"), h["u32"]("bytesLength"), h["u32"]("bytesLengthPadding"), h["seq"](h["u8"]("byte"), h["offset"](h["u32"](), -8), "bytes")]),
                        a = Le.chunkSize;
                    let c = 0,
                        u = i,
                        l = [];
                    while (u.length > 0) {
                        const i = u.slice(0, a),
                            d = r["Buffer"].alloc(a + 16);
                        s.encode({
                            instruction: 0,
                            offset: c,
                            bytes: i,
                            bytesLength: 0,
                            bytesLengthPadding: 0
                        }, d);
                        const h = (new ce).add({
                            keys: [{
                                pubkey: n.publicKey,
                                isSigner: !0,
                                isWritable: !0
                            }],
                            programId: o,
                            data: d
                        });
                        if (l.push(ke(e, h, [t, n], {
                                commitment: "confirmed"
                            })), e._rpcEndpoint.includes("solana.com")) {
                            const e = 4;
                            await ve(1e3 / e)
                        }
                        c += a, u = u.slice(a)
                    }
                    await Promise.all(l); {
                        const i = h["struct"]([h["u32"]("instruction")]),
                            s = r["Buffer"].alloc(i.span);
                        i.encode({
                            instruction: 1
                        }, s);
                        const a = (new ce).add({
                            keys: [{
                                pubkey: n.publicKey,
                                isSigner: !0,
                                isWritable: !0
                            }, {
                                pubkey: fe,
                                isSigner: !1,
                                isWritable: !1
                            }],
                            programId: o,
                            data: s
                        });
                        await ke(e, a, [t, n], {
                            commitment: "confirmed"
                        })
                    }
                    return !0
                }
            }
            Le.chunkSize = Be;
            const We = new L("BPFLoader2111111111111111111111111111111111");
            class Ne {
                static getMinNumSignatures(e) {
                    return Le.getMinNumSignatures(e)
                }
                static load(e, t, n, r, o) {
                    return Le.load(e, t, n, o, r)
                }
            }
            var Me = Object.prototype.toString,
                Ke = Object.keys || function(e) {
                    var t = [];
                    for (var n in e) t.push(n);
                    return t
                };

            function Ue(e, t) {
                var n, r, o, i, s, a, c;
                if (!0 === e) return "true";
                if (!1 === e) return "false";
                switch (typeof e) {
                    case "object":
                        if (null === e) return null;
                        if (e.toJSON && "function" === typeof e.toJSON) return Ue(e.toJSON(), t);
                        if (c = Me.call(e), "[object Array]" === c) {
                            for (o = "[", r = e.length - 1, n = 0; n < r; n++) o += Ue(e[n], !0) + ",";
                            return r > -1 && (o += Ue(e[n], !0)), o + "]"
                        }
                        if ("[object Object]" === c) {
                            i = Ke(e).sort(), r = i.length, o = "", n = 0;
                            while (n < r) s = i[n], a = Ue(e[s], !1), void 0 !== a && (o && (o += ","), o += JSON.stringify(s) + ":" + a), n++;
                            return "{" + o + "}"
                        }
                        return JSON.stringify(e);
                    case "function":
                    case "undefined":
                        return t ? null : void 0;
                    case "string":
                        return JSON.stringify(e);
                    default:
                        return isFinite(e) ? e : null
                }
            }
            var ze = function(e) {
                    var t = Ue(e, !1);
                    if (void 0 !== t) return "" + t
                },
                De = ze;
            const He = 32;

            function qe(e) {
                let t = 0;
                while (e > 1) e /= 2, t++;
                return t
            }

            function $e(e) {
                return 0 === e ? 1 : (e--, e |= e >> 1, e |= e >> 2, e |= e >> 4, e |= e >> 8, e |= e >> 16, e |= e >> 32, e + 1)
            }
            class Ve {
                constructor(e, t, n, r, o) {
                    this.slotsPerEpoch = void 0, this.leaderScheduleSlotOffset = void 0, this.warmup = void 0, this.firstNormalEpoch = void 0, this.firstNormalSlot = void 0, this.slotsPerEpoch = e, this.leaderScheduleSlotOffset = t, this.warmup = n, this.firstNormalEpoch = r, this.firstNormalSlot = o
                }
                getEpoch(e) {
                    return this.getEpochAndSlotIndex(e)[0]
                }
                getEpochAndSlotIndex(e) {
                    if (e < this.firstNormalSlot) {
                        const t = qe($e(e + He + 1)) - qe(He) - 1,
                            n = this.getSlotsInEpoch(t),
                            r = e - (n - He);
                        return [t, r]
                    } {
                        const t = e - this.firstNormalSlot,
                            n = Math.floor(t / this.slotsPerEpoch),
                            r = this.firstNormalEpoch + n,
                            o = t % this.slotsPerEpoch;
                        return [r, o]
                    }
                }
                getFirstSlotInEpoch(e) {
                    return e <= this.firstNormalEpoch ? (Math.pow(2, e) - 1) * He : (e - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot
                }
                getLastSlotInEpoch(e) {
                    return this.getFirstSlotInEpoch(e) + this.getSlotsInEpoch(e) - 1
                }
                getSlotsInEpoch(e) {
                    return e < this.firstNormalEpoch ? Math.pow(2, e + qe(He)) : this.slotsPerEpoch
                }
            }
            class Fe extends Error {
                constructor(e, t) {
                    super(e), this.logs = void 0, this.logs = t
                }
            }
            const Ge = {
                JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
                JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
                JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
                JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
                JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
                JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
                JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
                JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
                JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
                JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
                JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
                JSON_RPC_SCAN_ERROR: -32012,
                JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
                JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
                JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
                JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016
            };
            class Ye extends Error {
                constructor({
                    code: e,
                    message: t,
                    data: n
                }, r) {
                    super(null != r ? `${r}: ${t}` : t), this.code = void 0, this.data = void 0, this.code = e, this.data = n, this.name = "SolanaJSONRPCError"
                }
            }
            var Je = globalThis.fetch;
            const Ze = 160,
                Xe = 64,
                Qe = Ze / Xe,
                et = 1e3 / Qe;

            function tt(e, t) {
                let n;
                try {
                    n = e.layout.decode(t)
                } catch (r) {
                    throw new Error("invalid instruction; " + r)
                }
                if (n.typeIndex !== e.index) throw new Error(`invalid account data; account type mismatch ${n.typeIndex} != ${e.index}`);
                return n
            }
            const nt = 56;
            class rt {
                constructor(e) {
                    this.key = void 0, this.state = void 0, this.key = e.key, this.state = e.state
                }
                isActive() {
                    const e = BigInt("0xffffffffffffffff");
                    return this.state.deactivationSlot === e
                }
                static deserialize(e) {
                    const t = tt(ot, e),
                        n = e.length - nt;
                    ee(n >= 0, "lookup table is invalid"), ee(n % 32 === 0, "lookup table is invalid");
                    const r = n / 32,
                        {
                            addresses: o
                        } = h["struct"]([h["seq"](q(), r, "addresses")]).decode(e.slice(nt));
                    return {
                        deactivationSlot: t.deactivationSlot,
                        lastExtendedSlot: t.lastExtendedSlot,
                        lastExtendedSlotStartIndex: t.lastExtendedStartIndex,
                        authority: 0 !== t.authority.length ? new L(t.authority[0]) : void 0,
                        addresses: o.map(e => new L(e))
                    }
                }
            }
            const ot = {
                    index: 1,
                    layout: h["struct"]([h["u32"]("typeIndex"), Te("deactivationSlot"), h["nu64"]("lastExtendedSlot"), h["u8"]("lastExtendedStartIndex"), h["u8"](), h["seq"](q(), h["offset"](h["u8"](), -1), "authority")])
                },
                it = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;

            function st(e) {
                const t = e.match(it);
                if (null == t) throw TypeError(`Failed to validate endpoint URL \`${e}\``);
                const [n, r, o, i] = t, s = e.startsWith("https:") ? "wss:" : "ws:", a = null == o ? null : parseInt(o.slice(1), 10), c = null == a ? "" : ":" + (a + 1);
                return `${s}//${r}${c}${i}`
            }
            var at;
            const ct = Object(g["coerce"])(Object(g["instance"])(L), Object(g["string"])(), e => new L(e)),
                ut = Object(g["tuple"])([Object(g["string"])(), Object(g["literal"])("base64")]),
                lt = Object(g["coerce"])(Object(g["instance"])(r["Buffer"]), ut, e => r["Buffer"].from(e[0], "base64")),
                dt = 3e4;

            function ht(e) {
                if (!1 === /^https?:/.test(e)) throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
                return e
            }

            function pt(e) {
                let t, n;
                if ("string" === typeof e) t = e;
                else if (e) {
                    const {
                        commitment: r,
                        ...o
                    } = e;
                    t = r, n = o
                }
                return {
                    commitment: t,
                    config: n
                }
            }

            function gt(e) {
                return Object(g["union"])([Object(g["type"])({
                    jsonrpc: Object(g["literal"])("2.0"),
                    id: Object(g["string"])(),
                    result: e
                }), Object(g["type"])({
                    jsonrpc: Object(g["literal"])("2.0"),
                    id: Object(g["string"])(),
                    error: Object(g["type"])({
                        code: Object(g["unknown"])(),
                        message: Object(g["string"])(),
                        data: Object(g["optional"])(Object(g["any"])())
                    })
                })])
            }
            const ft = gt(Object(g["unknown"])());

            function bt(e) {
                return Object(g["coerce"])(gt(e), ft, t => "error" in t ? t : { ...t,
                    result: Object(g["create"])(t.result, e)
                })
            }

            function yt(e) {
                return bt(Object(g["type"])({
                    context: Object(g["type"])({
                        slot: Object(g["number"])()
                    }),
                    value: e
                }))
            }

            function mt(e) {
                return Object(g["type"])({
                    context: Object(g["type"])({
                        slot: Object(g["number"])()
                    }),
                    value: e
                })
            }

            function wt(e, t) {
                return 0 === e ? new re({
                    header: t.header,
                    staticAccountKeys: t.accountKeys.map(e => new L(e)),
                    recentBlockhash: t.recentBlockhash,
                    compiledInstructions: t.instructions.map(e => ({
                        programIdIndex: e.programIdIndex,
                        accountKeyIndexes: e.accounts,
                        data: u.a.decode(e.data)
                    })),
                    addressTableLookups: t.addressTableLookups
                }) : new ne(t)
            }
            const kt = Object(g["type"])({
                    foundation: Object(g["number"])(),
                    foundationTerm: Object(g["number"])(),
                    initial: Object(g["number"])(),
                    taper: Object(g["number"])(),
                    terminal: Object(g["number"])()
                }),
                vt = bt(Object(g["array"])(Object(g["nullable"])(Object(g["type"])({
                    epoch: Object(g["number"])(),
                    effectiveSlot: Object(g["number"])(),
                    amount: Object(g["number"])(),
                    postBalance: Object(g["number"])()
                })))),
                St = Object(g["type"])({
                    epoch: Object(g["number"])(),
                    slotIndex: Object(g["number"])(),
                    slotsInEpoch: Object(g["number"])(),
                    absoluteSlot: Object(g["number"])(),
                    blockHeight: Object(g["optional"])(Object(g["number"])()),
                    transactionCount: Object(g["optional"])(Object(g["number"])())
                }),
                Ct = Object(g["type"])({
                    slotsPerEpoch: Object(g["number"])(),
                    leaderScheduleSlotOffset: Object(g["number"])(),
                    warmup: Object(g["boolean"])(),
                    firstNormalEpoch: Object(g["number"])(),
                    firstNormalSlot: Object(g["number"])()
                }),
                It = Object(g["record"])(Object(g["string"])(), Object(g["array"])(Object(g["number"])())),
                At = Object(g["nullable"])(Object(g["union"])([Object(g["type"])({}), Object(g["string"])()])),
                Ot = Object(g["type"])({
                    err: At
                }),
                xt = Object(g["literal"])("receivedSignature"),
                _t = Object(g["type"])({
                    "solana-core": Object(g["string"])(),
                    "feature-set": Object(g["optional"])(Object(g["number"])())
                }),
                Et = yt(Object(g["type"])({
                    err: Object(g["nullable"])(Object(g["union"])([Object(g["type"])({}), Object(g["string"])()])),
                    logs: Object(g["nullable"])(Object(g["array"])(Object(g["string"])())),
                    accounts: Object(g["optional"])(Object(g["nullable"])(Object(g["array"])(Object(g["nullable"])(Object(g["type"])({
                        executable: Object(g["boolean"])(),
                        owner: Object(g["string"])(),
                        lamports: Object(g["number"])(),
                        data: Object(g["array"])(Object(g["string"])()),
                        rentEpoch: Object(g["optional"])(Object(g["number"])())
                    }))))),
                    unitsConsumed: Object(g["optional"])(Object(g["number"])()),
                    returnData: Object(g["optional"])(Object(g["nullable"])(Object(g["type"])({
                        programId: Object(g["string"])(),
                        data: Object(g["tuple"])([Object(g["string"])(), Object(g["literal"])("base64")])
                    })))
                })),
                Tt = yt(Object(g["type"])({
                    byIdentity: Object(g["record"])(Object(g["string"])(), Object(g["array"])(Object(g["number"])())),
                    range: Object(g["type"])({
                        firstSlot: Object(g["number"])(),
                        lastSlot: Object(g["number"])()
                    })
                }));

            function Pt(e, t, n, r, o) {
                const i = n || Je;
                let s;
                r && (s = async (e, t) => {
                    const n = await new Promise((n, o) => {
                        try {
                            r(e, t, (e, t) => n([e, t]))
                        } catch (i) {
                            o(i)
                        }
                    });
                    return await i(...n)
                });
                const a = new y.a(async (n, r) => {
                    const a = void 0,
                        c = {
                            method: "POST",
                            body: n,
                            agent: a,
                            headers: Object.assign({
                                "Content-Type": "application/json"
                            }, t || {}, $n)
                        };
                    try {
                        let t, n = 5,
                            a = 500;
                        for (;;) {
                            if (t = s ? await s(e, c) : await i(e, c), 429 !== t.status) break;
                            if (!0 === o) break;
                            if (n -= 1, 0 === n) break;
                            console.log(`Server responded with ${t.status} ${t.statusText}.  Retrying after ${a}ms delay...`), await ve(a), a *= 2
                        }
                        const u = await t.text();
                        t.ok ? r(null, u) : r(new Error(`${t.status} ${t.statusText}: ${u}`))
                    } catch (u) {
                        u instanceof Error && r(u)
                    }
                }, {});
                return a
            }

            function Rt(e) {
                return (t, n) => new Promise((r, o) => {
                    e.request(t, n, (e, t) => {
                        e ? o(e) : r(t)
                    })
                })
            }

            function jt(e) {
                return t => new Promise((n, r) => {
                    0 === t.length && n([]);
                    const o = t.map(t => e.request(t.methodName, t.args));
                    e.request(o, (e, t) => {
                        e ? r(e) : n(t)
                    })
                })
            }
            const Bt = bt(kt),
                Lt = bt(St),
                Wt = bt(Ct),
                Nt = bt(It),
                Mt = bt(Object(g["number"])()),
                Kt = yt(Object(g["type"])({
                    total: Object(g["number"])(),
                    circulating: Object(g["number"])(),
                    nonCirculating: Object(g["number"])(),
                    nonCirculatingAccounts: Object(g["array"])(ct)
                })),
                Ut = Object(g["type"])({
                    amount: Object(g["string"])(),
                    uiAmount: Object(g["nullable"])(Object(g["number"])()),
                    decimals: Object(g["number"])(),
                    uiAmountString: Object(g["optional"])(Object(g["string"])())
                }),
                zt = yt(Object(g["array"])(Object(g["type"])({
                    address: ct,
                    amount: Object(g["string"])(),
                    uiAmount: Object(g["nullable"])(Object(g["number"])()),
                    decimals: Object(g["number"])(),
                    uiAmountString: Object(g["optional"])(Object(g["string"])())
                }))),
                Dt = yt(Object(g["array"])(Object(g["type"])({
                    pubkey: ct,
                    account: Object(g["type"])({
                        executable: Object(g["boolean"])(),
                        owner: ct,
                        lamports: Object(g["number"])(),
                        data: lt,
                        rentEpoch: Object(g["number"])()
                    })
                }))),
                Ht = Object(g["type"])({
                    program: Object(g["string"])(),
                    parsed: Object(g["unknown"])(),
                    space: Object(g["number"])()
                }),
                qt = yt(Object(g["array"])(Object(g["type"])({
                    pubkey: ct,
                    account: Object(g["type"])({
                        executable: Object(g["boolean"])(),
                        owner: ct,
                        lamports: Object(g["number"])(),
                        data: Ht,
                        rentEpoch: Object(g["number"])()
                    })
                }))),
                $t = yt(Object(g["array"])(Object(g["type"])({
                    lamports: Object(g["number"])(),
                    address: ct
                }))),
                Vt = Object(g["type"])({
                    executable: Object(g["boolean"])(),
                    owner: ct,
                    lamports: Object(g["number"])(),
                    data: lt,
                    rentEpoch: Object(g["number"])()
                }),
                Ft = Object(g["type"])({
                    pubkey: ct,
                    account: Vt
                }),
                Gt = Object(g["coerce"])(Object(g["union"])([Object(g["instance"])(r["Buffer"]), Ht]), Object(g["union"])([ut, Ht]), e => Array.isArray(e) ? Object(g["create"])(e, lt) : e),
                Yt = Object(g["type"])({
                    executable: Object(g["boolean"])(),
                    owner: ct,
                    lamports: Object(g["number"])(),
                    data: Gt,
                    rentEpoch: Object(g["number"])()
                }),
                Jt = Object(g["type"])({
                    pubkey: ct,
                    account: Yt
                }),
                Zt = Object(g["type"])({
                    state: Object(g["union"])([Object(g["literal"])("active"), Object(g["literal"])("inactive"), Object(g["literal"])("activating"), Object(g["literal"])("deactivating")]),
                    active: Object(g["number"])(),
                    inactive: Object(g["number"])()
                }),
                Xt = bt(Object(g["array"])(Object(g["type"])({
                    signature: Object(g["string"])(),
                    slot: Object(g["number"])(),
                    err: At,
                    memo: Object(g["nullable"])(Object(g["string"])()),
                    blockTime: Object(g["optional"])(Object(g["nullable"])(Object(g["number"])()))
                }))),
                Qt = bt(Object(g["array"])(Object(g["type"])({
                    signature: Object(g["string"])(),
                    slot: Object(g["number"])(),
                    err: At,
                    memo: Object(g["nullable"])(Object(g["string"])()),
                    blockTime: Object(g["optional"])(Object(g["nullable"])(Object(g["number"])()))
                }))),
                en = Object(g["type"])({
                    subscription: Object(g["number"])(),
                    result: mt(Vt)
                }),
                tn = Object(g["type"])({
                    pubkey: ct,
                    account: Vt
                }),
                nn = Object(g["type"])({
                    subscription: Object(g["number"])(),
                    result: mt(tn)
                }),
                rn = Object(g["type"])({
                    parent: Object(g["number"])(),
                    slot: Object(g["number"])(),
                    root: Object(g["number"])()
                }),
                on = Object(g["type"])({
                    subscription: Object(g["number"])(),
                    result: rn
                }),
                sn = Object(g["union"])([Object(g["type"])({
                    type: Object(g["union"])([Object(g["literal"])("firstShredReceived"), Object(g["literal"])("completed"), Object(g["literal"])("optimisticConfirmation"), Object(g["literal"])("root")]),
                    slot: Object(g["number"])(),
                    timestamp: Object(g["number"])()
                }), Object(g["type"])({
                    type: Object(g["literal"])("createdBank"),
                    parent: Object(g["number"])(),
                    slot: Object(g["number"])(),
                    timestamp: Object(g["number"])()
                }), Object(g["type"])({
                    type: Object(g["literal"])("frozen"),
                    slot: Object(g["number"])(),
                    timestamp: Object(g["number"])(),
                    stats: Object(g["type"])({
                        numTransactionEntries: Object(g["number"])(),
                        numSuccessfulTransactions: Object(g["number"])(),
                        numFailedTransactions: Object(g["number"])(),
                        maxTransactionsPerEntry: Object(g["number"])()
                    })
                }), Object(g["type"])({
                    type: Object(g["literal"])("dead"),
                    slot: Object(g["number"])(),
                    timestamp: Object(g["number"])(),
                    err: Object(g["string"])()
                })]),
                an = Object(g["type"])({
                    subscription: Object(g["number"])(),
                    result: sn
                }),
                cn = Object(g["type"])({
                    subscription: Object(g["number"])(),
                    result: mt(Object(g["union"])([Ot, xt]))
                }),
                un = Object(g["type"])({
                    subscription: Object(g["number"])(),
                    result: Object(g["number"])()
                }),
                ln = Object(g["type"])({
                    pubkey: Object(g["string"])(),
                    gossip: Object(g["nullable"])(Object(g["string"])()),
                    tpu: Object(g["nullable"])(Object(g["string"])()),
                    rpc: Object(g["nullable"])(Object(g["string"])()),
                    version: Object(g["nullable"])(Object(g["string"])())
                }),
                dn = Object(g["type"])({
                    votePubkey: Object(g["string"])(),
                    nodePubkey: Object(g["string"])(),
                    activatedStake: Object(g["number"])(),
                    epochVoteAccount: Object(g["boolean"])(),
                    epochCredits: Object(g["array"])(Object(g["tuple"])([Object(g["number"])(), Object(g["number"])(), Object(g["number"])()])),
                    commission: Object(g["number"])(),
                    lastVote: Object(g["number"])(),
                    rootSlot: Object(g["nullable"])(Object(g["number"])())
                }),
                hn = bt(Object(g["type"])({
                    current: Object(g["array"])(dn),
                    delinquent: Object(g["array"])(dn)
                })),
                pn = Object(g["union"])([Object(g["literal"])("processed"), Object(g["literal"])("confirmed"), Object(g["literal"])("finalized")]),
                gn = Object(g["type"])({
                    slot: Object(g["number"])(),
                    confirmations: Object(g["nullable"])(Object(g["number"])()),
                    err: At,
                    confirmationStatus: Object(g["optional"])(pn)
                }),
                fn = yt(Object(g["array"])(Object(g["nullable"])(gn))),
                bn = bt(Object(g["number"])()),
                yn = Object(g["type"])({
                    accountKey: ct,
                    writableIndexes: Object(g["array"])(Object(g["number"])()),
                    readonlyIndexes: Object(g["array"])(Object(g["number"])())
                }),
                mn = Object(g["type"])({
                    signatures: Object(g["array"])(Object(g["string"])()),
                    message: Object(g["type"])({
                        accountKeys: Object(g["array"])(Object(g["string"])()),
                        header: Object(g["type"])({
                            numRequiredSignatures: Object(g["number"])(),
                            numReadonlySignedAccounts: Object(g["number"])(),
                            numReadonlyUnsignedAccounts: Object(g["number"])()
                        }),
                        instructions: Object(g["array"])(Object(g["type"])({
                            accounts: Object(g["array"])(Object(g["number"])()),
                            data: Object(g["string"])(),
                            programIdIndex: Object(g["number"])()
                        })),
                        recentBlockhash: Object(g["string"])(),
                        addressTableLookups: Object(g["optional"])(Object(g["array"])(yn))
                    })
                }),
                wn = Object(g["type"])({
                    parsed: Object(g["unknown"])(),
                    program: Object(g["string"])(),
                    programId: ct
                }),
                kn = Object(g["type"])({
                    accounts: Object(g["array"])(ct),
                    data: Object(g["string"])(),
                    programId: ct
                }),
                vn = Object(g["union"])([kn, wn]),
                Sn = Object(g["union"])([Object(g["type"])({
                    parsed: Object(g["unknown"])(),
                    program: Object(g["string"])(),
                    programId: Object(g["string"])()
                }), Object(g["type"])({
                    accounts: Object(g["array"])(Object(g["string"])()),
                    data: Object(g["string"])(),
                    programId: Object(g["string"])()
                })]),
                Cn = Object(g["coerce"])(vn, Sn, e => "accounts" in e ? Object(g["create"])(e, kn) : Object(g["create"])(e, wn)),
                In = Object(g["type"])({
                    signatures: Object(g["array"])(Object(g["string"])()),
                    message: Object(g["type"])({
                        accountKeys: Object(g["array"])(Object(g["type"])({
                            pubkey: ct,
                            signer: Object(g["boolean"])(),
                            writable: Object(g["boolean"])(),
                            source: Object(g["optional"])(Object(g["union"])([Object(g["literal"])("transaction"), Object(g["literal"])("lookupTable")]))
                        })),
                        instructions: Object(g["array"])(Cn),
                        recentBlockhash: Object(g["string"])(),
                        addressTableLookups: Object(g["optional"])(Object(g["nullable"])(Object(g["array"])(yn)))
                    })
                }),
                An = Object(g["type"])({
                    accountIndex: Object(g["number"])(),
                    mint: Object(g["string"])(),
                    owner: Object(g["optional"])(Object(g["string"])()),
                    uiTokenAmount: Ut
                }),
                On = Object(g["type"])({
                    writable: Object(g["array"])(ct),
                    readonly: Object(g["array"])(ct)
                }),
                xn = Object(g["type"])({
                    err: At,
                    fee: Object(g["number"])(),
                    innerInstructions: Object(g["optional"])(Object(g["nullable"])(Object(g["array"])(Object(g["type"])({
                        index: Object(g["number"])(),
                        instructions: Object(g["array"])(Object(g["type"])({
                            accounts: Object(g["array"])(Object(g["number"])()),
                            data: Object(g["string"])(),
                            programIdIndex: Object(g["number"])()
                        }))
                    })))),
                    preBalances: Object(g["array"])(Object(g["number"])()),
                    postBalances: Object(g["array"])(Object(g["number"])()),
                    logMessages: Object(g["optional"])(Object(g["nullable"])(Object(g["array"])(Object(g["string"])()))),
                    preTokenBalances: Object(g["optional"])(Object(g["nullable"])(Object(g["array"])(An))),
                    postTokenBalances: Object(g["optional"])(Object(g["nullable"])(Object(g["array"])(An))),
                    loadedAddresses: Object(g["optional"])(On),
                    computeUnitsConsumed: Object(g["optional"])(Object(g["number"])())
                }),
                _n = Object(g["type"])({
                    err: At,
                    fee: Object(g["number"])(),
                    innerInstructions: Object(g["optional"])(Object(g["nullable"])(Object(g["array"])(Object(g["type"])({
                        index: Object(g["number"])(),
                        instructions: Object(g["array"])(Cn)
                    })))),
                    preBalances: Object(g["array"])(Object(g["number"])()),
                    postBalances: Object(g["array"])(Object(g["number"])()),
                    logMessages: Object(g["optional"])(Object(g["nullable"])(Object(g["array"])(Object(g["string"])()))),
                    preTokenBalances: Object(g["optional"])(Object(g["nullable"])(Object(g["array"])(An))),
                    postTokenBalances: Object(g["optional"])(Object(g["nullable"])(Object(g["array"])(An))),
                    loadedAddresses: Object(g["optional"])(On),
                    computeUnitsConsumed: Object(g["optional"])(Object(g["number"])())
                }),
                En = Object(g["union"])([Object(g["literal"])(0), Object(g["literal"])("legacy")]),
                Tn = bt(Object(g["nullable"])(Object(g["type"])({
                    blockhash: Object(g["string"])(),
                    previousBlockhash: Object(g["string"])(),
                    parentSlot: Object(g["number"])(),
                    transactions: Object(g["array"])(Object(g["type"])({
                        transaction: mn,
                        meta: Object(g["nullable"])(xn),
                        version: Object(g["optional"])(En)
                    })),
                    rewards: Object(g["optional"])(Object(g["array"])(Object(g["type"])({
                        pubkey: Object(g["string"])(),
                        lamports: Object(g["number"])(),
                        postBalance: Object(g["nullable"])(Object(g["number"])()),
                        rewardType: Object(g["nullable"])(Object(g["string"])())
                    }))),
                    blockTime: Object(g["nullable"])(Object(g["number"])()),
                    blockHeight: Object(g["nullable"])(Object(g["number"])())
                }))),
                Pn = bt(Object(g["nullable"])(Object(g["type"])({
                    blockhash: Object(g["string"])(),
                    previousBlockhash: Object(g["string"])(),
                    parentSlot: Object(g["number"])(),
                    transactions: Object(g["array"])(Object(g["type"])({
                        transaction: In,
                        meta: Object(g["nullable"])(_n),
                        version: Object(g["optional"])(En)
                    })),
                    rewards: Object(g["optional"])(Object(g["array"])(Object(g["type"])({
                        pubkey: Object(g["string"])(),
                        lamports: Object(g["number"])(),
                        postBalance: Object(g["nullable"])(Object(g["number"])()),
                        rewardType: Object(g["nullable"])(Object(g["string"])())
                    }))),
                    blockTime: Object(g["nullable"])(Object(g["number"])()),
                    blockHeight: Object(g["nullable"])(Object(g["number"])())
                }))),
                Rn = bt(Object(g["nullable"])(Object(g["type"])({
                    blockhash: Object(g["string"])(),
                    previousBlockhash: Object(g["string"])(),
                    parentSlot: Object(g["number"])(),
                    transactions: Object(g["array"])(Object(g["type"])({
                        transaction: mn,
                        meta: Object(g["nullable"])(xn)
                    })),
                    rewards: Object(g["optional"])(Object(g["array"])(Object(g["type"])({
                        pubkey: Object(g["string"])(),
                        lamports: Object(g["number"])(),
                        postBalance: Object(g["nullable"])(Object(g["number"])()),
                        rewardType: Object(g["nullable"])(Object(g["string"])())
                    }))),
                    blockTime: Object(g["nullable"])(Object(g["number"])())
                }))),
                jn = bt(Object(g["nullable"])(Object(g["type"])({
                    blockhash: Object(g["string"])(),
                    previousBlockhash: Object(g["string"])(),
                    parentSlot: Object(g["number"])(),
                    signatures: Object(g["array"])(Object(g["string"])()),
                    blockTime: Object(g["nullable"])(Object(g["number"])())
                }))),
                Bn = bt(Object(g["nullable"])(Object(g["type"])({
                    slot: Object(g["number"])(),
                    meta: xn,
                    blockTime: Object(g["optional"])(Object(g["nullable"])(Object(g["number"])())),
                    transaction: mn,
                    version: Object(g["optional"])(En)
                }))),
                Ln = bt(Object(g["nullable"])(Object(g["type"])({
                    slot: Object(g["number"])(),
                    transaction: In,
                    meta: Object(g["nullable"])(_n),
                    blockTime: Object(g["optional"])(Object(g["nullable"])(Object(g["number"])())),
                    version: Object(g["optional"])(En)
                }))),
                Wn = yt(Object(g["type"])({
                    blockhash: Object(g["string"])(),
                    feeCalculator: Object(g["type"])({
                        lamportsPerSignature: Object(g["number"])()
                    })
                })),
                Nn = yt(Object(g["type"])({
                    blockhash: Object(g["string"])(),
                    lastValidBlockHeight: Object(g["number"])()
                })),
                Mn = Object(g["type"])({
                    slot: Object(g["number"])(),
                    numTransactions: Object(g["number"])(),
                    numSlots: Object(g["number"])(),
                    samplePeriodSecs: Object(g["number"])()
                }),
                Kn = bt(Object(g["array"])(Mn)),
                Un = yt(Object(g["nullable"])(Object(g["type"])({
                    feeCalculator: Object(g["type"])({
                        lamportsPerSignature: Object(g["number"])()
                    })
                }))),
                zn = bt(Object(g["string"])()),
                Dn = bt(Object(g["string"])()),
                Hn = Object(g["type"])({
                    err: At,
                    logs: Object(g["array"])(Object(g["string"])()),
                    signature: Object(g["string"])()
                }),
                qn = Object(g["type"])({
                    result: mt(Hn),
                    subscription: Object(g["number"])()
                }),
                $n = {
                    "solana-client": "js/" + (null !== (at = "0.0.0-development") && void 0 !== at ? at : "UNKNOWN")
                };
            class Vn {
                constructor(e, t) {
                    let n, r, o, i, s;
                    this._commitment = void 0, this._confirmTransactionInitialTimeout = void 0, this._rpcEndpoint = void 0, this._rpcWsEndpoint = void 0, this._rpcClient = void 0, this._rpcRequest = void 0, this._rpcBatchRequest = void 0, this._rpcWebSocket = void 0, this._rpcWebSocketConnected = !1, this._rpcWebSocketHeartbeat = null, this._rpcWebSocketIdleTimeout = null, this._rpcWebSocketGeneration = 0, this._disableBlockhashCaching = !1, this._pollingBlockhash = !1, this._blockhashInfo = {
                        latestBlockhash: null,
                        lastFetch: 0,
                        transactionSignatures: [],
                        simulatedSignatures: []
                    }, this._nextClientSubscriptionId = 0, this._subscriptionDisposeFunctionsByClientSubscriptionId = {}, this._subscriptionCallbacksByServerSubscriptionId = {}, this._subscriptionsByHash = {}, this._subscriptionsAutoDisposedByRpc = new Set, t && "string" === typeof t ? this._commitment = t : t && (this._commitment = t.commitment, this._confirmTransactionInitialTimeout = t.confirmTransactionInitialTimeout, n = t.wsEndpoint, r = t.httpHeaders, o = t.fetch, i = t.fetchMiddleware, s = t.disableRetryOnRateLimit), this._rpcEndpoint = ht(e), this._rpcWsEndpoint = n || st(e), this._rpcClient = Pt(e, r, o, i, s), this._rpcRequest = Rt(this._rpcClient), this._rpcBatchRequest = jt(this._rpcClient), this._rpcWebSocket = new f["Client"](this._rpcWsEndpoint, {
                        autoconnect: !1,
                        max_reconnects: 1 / 0
                    }), this._rpcWebSocket.on("open", this._wsOnOpen.bind(this)), this._rpcWebSocket.on("error", this._wsOnError.bind(this)), this._rpcWebSocket.on("close", this._wsOnClose.bind(this)), this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this)), this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this)), this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this)), this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this)), this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this)), this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this)), this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this))
                }
                get commitment() {
                    return this._commitment
                }
                get rpcEndpoint() {
                    return this._rpcEndpoint
                }
                async getBalanceAndContext(e, t) {
                    const {
                        commitment: n,
                        config: r
                    } = pt(t), o = this._buildArgs([e.toBase58()], n, void 0, r), i = await this._rpcRequest("getBalance", o), s = Object(g["create"])(i, yt(Object(g["number"])()));
                    if ("error" in s) throw new Ye(s.error, "failed to get balance for " + e.toBase58());
                    return s.result
                }
                async getBalance(e, t) {
                    return await this.getBalanceAndContext(e, t).then(e => e.value).catch(t => {
                        throw new Error("failed to get balance of account " + e.toBase58() + ": " + t)
                    })
                }
                async getBlockTime(e) {
                    const t = await this._rpcRequest("getBlockTime", [e]),
                        n = Object(g["create"])(t, bt(Object(g["nullable"])(Object(g["number"])())));
                    if ("error" in n) throw new Ye(n.error, "failed to get block time for slot " + e);
                    return n.result
                }
                async getMinimumLedgerSlot() {
                    const e = await this._rpcRequest("minimumLedgerSlot", []),
                        t = Object(g["create"])(e, bt(Object(g["number"])()));
                    if ("error" in t) throw new Ye(t.error, "failed to get minimum ledger slot");
                    return t.result
                }
                async getFirstAvailableBlock() {
                    const e = await this._rpcRequest("getFirstAvailableBlock", []),
                        t = Object(g["create"])(e, Mt);
                    if ("error" in t) throw new Ye(t.error, "failed to get first available block");
                    return t.result
                }
                async getSupply(e) {
                    let t = {};
                    t = "string" === typeof e ? {
                        commitment: e
                    } : e ? { ...e,
                        commitment: e && e.commitment || this.commitment
                    } : {
                        commitment: this.commitment
                    };
                    const n = await this._rpcRequest("getSupply", [t]),
                        r = Object(g["create"])(n, Kt);
                    if ("error" in r) throw new Ye(r.error, "failed to get supply");
                    return r.result
                }
                async getTokenSupply(e, t) {
                    const n = this._buildArgs([e.toBase58()], t),
                        r = await this._rpcRequest("getTokenSupply", n),
                        o = Object(g["create"])(r, yt(Ut));
                    if ("error" in o) throw new Ye(o.error, "failed to get token supply");
                    return o.result
                }
                async getTokenAccountBalance(e, t) {
                    const n = this._buildArgs([e.toBase58()], t),
                        r = await this._rpcRequest("getTokenAccountBalance", n),
                        o = Object(g["create"])(r, yt(Ut));
                    if ("error" in o) throw new Ye(o.error, "failed to get token account balance");
                    return o.result
                }
                async getTokenAccountsByOwner(e, t, n) {
                    const {
                        commitment: r,
                        config: o
                    } = pt(n);
                    let i = [e.toBase58()];
                    "mint" in t ? i.push({
                        mint: t.mint.toBase58()
                    }) : i.push({
                        programId: t.programId.toBase58()
                    });
                    const s = this._buildArgs(i, r, "base64", o),
                        a = await this._rpcRequest("getTokenAccountsByOwner", s),
                        c = Object(g["create"])(a, Dt);
                    if ("error" in c) throw new Ye(c.error, "failed to get token accounts owned by account " + e.toBase58());
                    return c.result
                }
                async getParsedTokenAccountsByOwner(e, t, n) {
                    let r = [e.toBase58()];
                    "mint" in t ? r.push({
                        mint: t.mint.toBase58()
                    }) : r.push({
                        programId: t.programId.toBase58()
                    });
                    const o = this._buildArgs(r, n, "jsonParsed"),
                        i = await this._rpcRequest("getTokenAccountsByOwner", o),
                        s = Object(g["create"])(i, qt);
                    if ("error" in s) throw new Ye(s.error, "failed to get token accounts owned by account " + e.toBase58());
                    return s.result
                }
                async getLargestAccounts(e) {
                    const t = { ...e,
                            commitment: e && e.commitment || this.commitment
                        },
                        n = t.filter || t.commitment ? [t] : [],
                        r = await this._rpcRequest("getLargestAccounts", n),
                        o = Object(g["create"])(r, $t);
                    if ("error" in o) throw new Ye(o.error, "failed to get largest accounts");
                    return o.result
                }
                async getTokenLargestAccounts(e, t) {
                    const n = this._buildArgs([e.toBase58()], t),
                        r = await this._rpcRequest("getTokenLargestAccounts", n),
                        o = Object(g["create"])(r, zt);
                    if ("error" in o) throw new Ye(o.error, "failed to get token largest accounts");
                    return o.result
                }
                async getAccountInfoAndContext(e, t) {
                    const {
                        commitment: n,
                        config: r
                    } = pt(t), o = this._buildArgs([e.toBase58()], n, "base64", r), i = await this._rpcRequest("getAccountInfo", o), s = Object(g["create"])(i, yt(Object(g["nullable"])(Vt)));
                    if ("error" in s) throw new Ye(s.error, "failed to get info about account " + e.toBase58());
                    return s.result
                }
                async getParsedAccountInfo(e, t) {
                    const {
                        commitment: n,
                        config: r
                    } = pt(t), o = this._buildArgs([e.toBase58()], n, "jsonParsed", r), i = await this._rpcRequest("getAccountInfo", o), s = Object(g["create"])(i, yt(Object(g["nullable"])(Yt)));
                    if ("error" in s) throw new Ye(s.error, "failed to get info about account " + e.toBase58());
                    return s.result
                }
                async getAccountInfo(e, t) {
                    try {
                        const n = await this.getAccountInfoAndContext(e, t);
                        return n.value
                    } catch (n) {
                        throw new Error("failed to get info about account " + e.toBase58() + ": " + n)
                    }
                }
                async getMultipleParsedAccounts(e, t) {
                    const {
                        commitment: n,
                        config: r
                    } = pt(t), o = e.map(e => e.toBase58()), i = this._buildArgs([o], n, "jsonParsed", r), s = await this._rpcRequest("getMultipleAccounts", i), a = Object(g["create"])(s, yt(Object(g["array"])(Object(g["nullable"])(Yt))));
                    if ("error" in a) throw new Ye(a.error, "failed to get info for accounts " + o);
                    return a.result
                }
                async getMultipleAccountsInfoAndContext(e, t) {
                    const {
                        commitment: n,
                        config: r
                    } = pt(t), o = e.map(e => e.toBase58()), i = this._buildArgs([o], n, "base64", r), s = await this._rpcRequest("getMultipleAccounts", i), a = Object(g["create"])(s, yt(Object(g["array"])(Object(g["nullable"])(Vt))));
                    if ("error" in a) throw new Ye(a.error, "failed to get info for accounts " + o);
                    return a.result
                }
                async getMultipleAccountsInfo(e, t) {
                    const n = await this.getMultipleAccountsInfoAndContext(e, t);
                    return n.value
                }
                async getStakeActivation(e, t, n) {
                    const {
                        commitment: r,
                        config: o
                    } = pt(t), i = this._buildArgs([e.toBase58()], r, void 0, { ...o,
                        epoch: null != n ? n : null === o || void 0 === o ? void 0 : o.epoch
                    }), s = await this._rpcRequest("getStakeActivation", i), a = Object(g["create"])(s, bt(Zt));
                    if ("error" in a) throw new Ye(a.error, "failed to get Stake Activation " + e.toBase58());
                    return a.result
                }
                async getProgramAccounts(e, t) {
                    const {
                        commitment: n,
                        config: r
                    } = pt(t), {
                        encoding: o,
                        ...i
                    } = r || {}, s = this._buildArgs([e.toBase58()], n, o || "base64", i), a = await this._rpcRequest("getProgramAccounts", s), c = Object(g["create"])(a, bt(Object(g["array"])(Ft)));
                    if ("error" in c) throw new Ye(c.error, "failed to get accounts owned by program " + e.toBase58());
                    return c.result
                }
                async getParsedProgramAccounts(e, t) {
                    const {
                        commitment: n,
                        config: r
                    } = pt(t), o = this._buildArgs([e.toBase58()], n, "jsonParsed", r), i = await this._rpcRequest("getProgramAccounts", o), s = Object(g["create"])(i, bt(Object(g["array"])(Jt)));
                    if ("error" in s) throw new Ye(s.error, "failed to get accounts owned by program " + e.toBase58());
                    return s.result
                }
                async confirmTransaction(e, t) {
                    let n, r;
                    if ("string" == typeof e) n = e;
                    else {
                        const t = e;
                        n = t.signature
                    }
                    try {
                        r = u.a.decode(n)
                    } catch (h) {
                        throw new Error("signature must be base58 encoded: " + n)
                    }
                    ee(64 === r.length, "signature has invalid length");
                    const o = t || this.commitment;
                    let i, s, a = !1;
                    const c = new Promise((e, t) => {
                            try {
                                s = this.onSignature(n, (t, n) => {
                                    s = void 0;
                                    const r = {
                                        context: n,
                                        value: t
                                    };
                                    a = !0, e({
                                        __type: ie.PROCESSED,
                                        response: r
                                    })
                                }, o)
                            } catch (h) {
                                t(h)
                            }
                        }),
                        l = new Promise(n => {
                            if ("string" === typeof e) {
                                let e = this._confirmTransactionInitialTimeout || 6e4;
                                switch (o) {
                                    case "processed":
                                    case "recent":
                                    case "single":
                                    case "confirmed":
                                    case "singleGossip":
                                        e = this._confirmTransactionInitialTimeout || 3e4;
                                        break
                                }
                                i = setTimeout(() => n({
                                    __type: ie.TIMED_OUT,
                                    timeoutMs: e
                                }), e)
                            } else {
                                let r = e;
                                const o = async () => {
                                    try {
                                        const e = await this.getBlockHeight(t);
                                        return e
                                    } catch (e) {
                                        return -1
                                    }
                                };
                                (async () => {
                                    let e = await o();
                                    if (!a) {
                                        while (e <= r.lastValidBlockHeight) {
                                            if (await ve(1e3), a) return;
                                            if (e = await o(), a) return
                                        }
                                        n({
                                            __type: ie.BLOCKHEIGHT_EXCEEDED
                                        })
                                    }
                                })()
                            }
                        });
                    let d;
                    try {
                        const e = await Promise.race([c, l]);
                        switch (e.__type) {
                            case ie.BLOCKHEIGHT_EXCEEDED:
                                throw new z(n);
                            case ie.PROCESSED:
                                d = e.response;
                                break;
                            case ie.TIMED_OUT:
                                throw new D(n, e.timeoutMs / 1e3)
                        }
                    } finally {
                        clearTimeout(i), s && this.removeSignatureListener(s)
                    }
                    return d
                }
                async getClusterNodes() {
                    const e = await this._rpcRequest("getClusterNodes", []),
                        t = Object(g["create"])(e, bt(Object(g["array"])(ln)));
                    if ("error" in t) throw new Ye(t.error, "failed to get cluster nodes");
                    return t.result
                }
                async getVoteAccounts(e) {
                    const t = this._buildArgs([], e),
                        n = await this._rpcRequest("getVoteAccounts", t),
                        r = Object(g["create"])(n, hn);
                    if ("error" in r) throw new Ye(r.error, "failed to get vote accounts");
                    return r.result
                }
                async getSlot(e) {
                    const {
                        commitment: t,
                        config: n
                    } = pt(e), r = this._buildArgs([], t, void 0, n), o = await this._rpcRequest("getSlot", r), i = Object(g["create"])(o, bt(Object(g["number"])()));
                    if ("error" in i) throw new Ye(i.error, "failed to get slot");
                    return i.result
                }
                async getSlotLeader(e) {
                    const {
                        commitment: t,
                        config: n
                    } = pt(e), r = this._buildArgs([], t, void 0, n), o = await this._rpcRequest("getSlotLeader", r), i = Object(g["create"])(o, bt(Object(g["string"])()));
                    if ("error" in i) throw new Ye(i.error, "failed to get slot leader");
                    return i.result
                }
                async getSlotLeaders(e, t) {
                    const n = [e, t],
                        r = await this._rpcRequest("getSlotLeaders", n),
                        o = Object(g["create"])(r, bt(Object(g["array"])(ct)));
                    if ("error" in o) throw new Ye(o.error, "failed to get slot leaders");
                    return o.result
                }
                async getSignatureStatus(e, t) {
                    const {
                        context: n,
                        value: r
                    } = await this.getSignatureStatuses([e], t);
                    ee(1 === r.length);
                    const o = r[0];
                    return {
                        context: n,
                        value: o
                    }
                }
                async getSignatureStatuses(e, t) {
                    const n = [e];
                    t && n.push(t);
                    const r = await this._rpcRequest("getSignatureStatuses", n),
                        o = Object(g["create"])(r, fn);
                    if ("error" in o) throw new Ye(o.error, "failed to get signature status");
                    return o.result
                }
                async getTransactionCount(e) {
                    const {
                        commitment: t,
                        config: n
                    } = pt(e), r = this._buildArgs([], t, void 0, n), o = await this._rpcRequest("getTransactionCount", r), i = Object(g["create"])(o, bt(Object(g["number"])()));
                    if ("error" in i) throw new Ye(i.error, "failed to get transaction count");
                    return i.result
                }
                async getTotalSupply(e) {
                    const t = await this.getSupply({
                        commitment: e,
                        excludeNonCirculatingAccountsList: !0
                    });
                    return t.value.total
                }
                async getInflationGovernor(e) {
                    const t = this._buildArgs([], e),
                        n = await this._rpcRequest("getInflationGovernor", t),
                        r = Object(g["create"])(n, Bt);
                    if ("error" in r) throw new Ye(r.error, "failed to get inflation");
                    return r.result
                }
                async getInflationReward(e, t, n) {
                    const {
                        commitment: r,
                        config: o
                    } = pt(n), i = this._buildArgs([e.map(e => e.toBase58())], r, void 0, { ...o,
                        epoch: null != t ? t : null === o || void 0 === o ? void 0 : o.epoch
                    }), s = await this._rpcRequest("getInflationReward", i), a = Object(g["create"])(s, vt);
                    if ("error" in a) throw new Ye(a.error, "failed to get inflation reward");
                    return a.result
                }
                async getEpochInfo(e) {
                    const {
                        commitment: t,
                        config: n
                    } = pt(e), r = this._buildArgs([], t, void 0, n), o = await this._rpcRequest("getEpochInfo", r), i = Object(g["create"])(o, Lt);
                    if ("error" in i) throw new Ye(i.error, "failed to get epoch info");
                    return i.result
                }
                async getEpochSchedule() {
                    const e = await this._rpcRequest("getEpochSchedule", []),
                        t = Object(g["create"])(e, Wt);
                    if ("error" in t) throw new Ye(t.error, "failed to get epoch schedule");
                    const n = t.result;
                    return new Ve(n.slotsPerEpoch, n.leaderScheduleSlotOffset, n.warmup, n.firstNormalEpoch, n.firstNormalSlot)
                }
                async getLeaderSchedule() {
                    const e = await this._rpcRequest("getLeaderSchedule", []),
                        t = Object(g["create"])(e, Nt);
                    if ("error" in t) throw new Ye(t.error, "failed to get leader schedule");
                    return t.result
                }
                async getMinimumBalanceForRentExemption(e, t) {
                    const n = this._buildArgs([e], t),
                        r = await this._rpcRequest("getMinimumBalanceForRentExemption", n),
                        o = Object(g["create"])(r, bn);
                    return "error" in o ? (console.warn("Unable to fetch minimum balance for rent exemption"), 0) : o.result
                }
                async getRecentBlockhashAndContext(e) {
                    const t = this._buildArgs([], e),
                        n = await this._rpcRequest("getRecentBlockhash", t),
                        r = Object(g["create"])(n, Wn);
                    if ("error" in r) throw new Ye(r.error, "failed to get recent blockhash");
                    return r.result
                }
                async getRecentPerformanceSamples(e) {
                    const t = await this._rpcRequest("getRecentPerformanceSamples", e ? [e] : []),
                        n = Object(g["create"])(t, Kn);
                    if ("error" in n) throw new Ye(n.error, "failed to get recent performance samples");
                    return n.result
                }
                async getFeeCalculatorForBlockhash(e, t) {
                    const n = this._buildArgs([e], t),
                        r = await this._rpcRequest("getFeeCalculatorForBlockhash", n),
                        o = Object(g["create"])(r, Un);
                    if ("error" in o) throw new Ye(o.error, "failed to get fee calculator");
                    const {
                        context: i,
                        value: s
                    } = o.result;
                    return {
                        context: i,
                        value: null !== s ? s.feeCalculator : null
                    }
                }
                async getFeeForMessage(e, t) {
                    const n = e.serialize().toString("base64"),
                        r = this._buildArgs([n], t),
                        o = await this._rpcRequest("getFeeForMessage", r),
                        i = Object(g["create"])(o, yt(Object(g["nullable"])(Object(g["number"])())));
                    if ("error" in i) throw new Ye(i.error, "failed to get fee for message");
                    if (null === i.result) throw new Error("invalid blockhash");
                    return i.result
                }
                async getRecentBlockhash(e) {
                    try {
                        const t = await this.getRecentBlockhashAndContext(e);
                        return t.value
                    } catch (t) {
                        throw new Error("failed to get recent blockhash: " + t)
                    }
                }
                async getLatestBlockhash(e) {
                    try {
                        const t = await this.getLatestBlockhashAndContext(e);
                        return t.value
                    } catch (t) {
                        throw new Error("failed to get recent blockhash: " + t)
                    }
                }
                async getLatestBlockhashAndContext(e) {
                    const {
                        commitment: t,
                        config: n
                    } = pt(e), r = this._buildArgs([], t, void 0, n), o = await this._rpcRequest("getLatestBlockhash", r), i = Object(g["create"])(o, Nn);
                    if ("error" in i) throw new Ye(i.error, "failed to get latest blockhash");
                    return i.result
                }
                async getVersion() {
                    const e = await this._rpcRequest("getVersion", []),
                        t = Object(g["create"])(e, bt(_t));
                    if ("error" in t) throw new Ye(t.error, "failed to get version");
                    return t.result
                }
                async getGenesisHash() {
                    const e = await this._rpcRequest("getGenesisHash", []),
                        t = Object(g["create"])(e, bt(Object(g["string"])()));
                    if ("error" in t) throw new Ye(t.error, "failed to get genesis hash");
                    return t.result
                }
                async getBlock(e, t) {
                    const {
                        commitment: n,
                        config: r
                    } = pt(t), o = this._buildArgsAtLeastConfirmed([e], n, void 0, r), i = await this._rpcRequest("getBlock", o), s = Object(g["create"])(i, Tn);
                    if ("error" in s) throw new Ye(s.error, "failed to get confirmed block");
                    const a = s.result;
                    return a ? { ...a,
                        transactions: a.transactions.map(({
                            transaction: e,
                            meta: t,
                            version: n
                        }) => ({
                            meta: t,
                            transaction: { ...e,
                                message: wt(n, e.message)
                            },
                            version: n
                        }))
                    } : a
                }
                async getParsedBlock(e, t) {
                    const {
                        commitment: n,
                        config: r
                    } = pt(t), o = this._buildArgsAtLeastConfirmed([e], n, "jsonParsed", r), i = await this._rpcRequest("getBlock", o), s = Object(g["create"])(i, Pn);
                    if ("error" in s) throw new Ye(s.error, "failed to get block");
                    return s.result
                }
                async getBlockHeight(e) {
                    const {
                        commitment: t,
                        config: n
                    } = pt(e), r = this._buildArgs([], t, void 0, n), o = await this._rpcRequest("getBlockHeight", r), i = Object(g["create"])(o, bt(Object(g["number"])()));
                    if ("error" in i) throw new Ye(i.error, "failed to get block height information");
                    return i.result
                }
                async getBlockProduction(e) {
                    let t, n;
                    if ("string" === typeof e) n = e;
                    else if (e) {
                        const {
                            commitment: r,
                            ...o
                        } = e;
                        n = r, t = o
                    }
                    const r = this._buildArgs([], n, "base64", t),
                        o = await this._rpcRequest("getBlockProduction", r),
                        i = Object(g["create"])(o, Tt);
                    if ("error" in i) throw new Ye(i.error, "failed to get block production information");
                    return i.result
                }
                async getTransaction(e, t) {
                    const {
                        commitment: n,
                        config: r
                    } = pt(t), o = this._buildArgsAtLeastConfirmed([e], n, void 0, r), i = await this._rpcRequest("getTransaction", o), s = Object(g["create"])(i, Bn);
                    if ("error" in s) throw new Ye(s.error, "failed to get transaction");
                    const a = s.result;
                    return a ? { ...a,
                        transaction: { ...a.transaction,
                            message: wt(a.version, a.transaction.message)
                        }
                    } : a
                }
                async getParsedTransaction(e, t) {
                    const {
                        commitment: n,
                        config: r
                    } = pt(t), o = this._buildArgsAtLeastConfirmed([e], n, "jsonParsed", r), i = await this._rpcRequest("getTransaction", o), s = Object(g["create"])(i, Ln);
                    if ("error" in s) throw new Ye(s.error, "failed to get transaction");
                    return s.result
                }
                async getParsedTransactions(e, t) {
                    const {
                        commitment: n,
                        config: r
                    } = pt(t), o = e.map(e => {
                        const t = this._buildArgsAtLeastConfirmed([e], n, "jsonParsed", r);
                        return {
                            methodName: "getTransaction",
                            args: t
                        }
                    }), i = await this._rpcBatchRequest(o), s = i.map(e => {
                        const t = Object(g["create"])(e, Ln);
                        if ("error" in t) throw new Ye(t.error, "failed to get transactions");
                        return t.result
                    });
                    return s
                }
                async getTransactions(e, t) {
                    const {
                        commitment: n,
                        config: r
                    } = pt(t), o = e.map(e => {
                        const t = this._buildArgsAtLeastConfirmed([e], n, void 0, r);
                        return {
                            methodName: "getTransaction",
                            args: t
                        }
                    }), i = await this._rpcBatchRequest(o), s = i.map(e => {
                        const t = Object(g["create"])(e, Bn);
                        if ("error" in t) throw new Ye(t.error, "failed to get transactions");
                        const n = t.result;
                        return n ? { ...n,
                            transaction: { ...n.transaction,
                                message: wt(n.version, n.transaction.message)
                            }
                        } : n
                    });
                    return s
                }
                async getConfirmedBlock(e, t) {
                    const n = this._buildArgsAtLeastConfirmed([e], t),
                        r = await this._rpcRequest("getConfirmedBlock", n),
                        o = Object(g["create"])(r, Rn);
                    if ("error" in o) throw new Ye(o.error, "failed to get confirmed block");
                    const i = o.result;
                    if (!i) throw new Error("Confirmed block " + e + " not found");
                    const s = { ...i,
                        transactions: i.transactions.map(({
                            transaction: e,
                            meta: t
                        }) => {
                            const n = new ne(e.message);
                            return {
                                meta: t,
                                transaction: { ...e,
                                    message: n
                                }
                            }
                        })
                    };
                    return { ...s,
                        transactions: s.transactions.map(({
                            transaction: e,
                            meta: t
                        }) => ({
                            meta: t,
                            transaction: ce.populate(e.message, e.signatures)
                        }))
                    }
                }
                async getBlocks(e, t, n) {
                    const r = this._buildArgsAtLeastConfirmed(void 0 !== t ? [e, t] : [e], n),
                        o = await this._rpcRequest("getBlocks", r),
                        i = Object(g["create"])(o, bt(Object(g["array"])(Object(g["number"])())));
                    if ("error" in i) throw new Ye(i.error, "failed to get blocks");
                    return i.result
                }
                async getBlockSignatures(e, t) {
                    const n = this._buildArgsAtLeastConfirmed([e], t, void 0, {
                            transactionDetails: "signatures",
                            rewards: !1
                        }),
                        r = await this._rpcRequest("getBlock", n),
                        o = Object(g["create"])(r, jn);
                    if ("error" in o) throw new Ye(o.error, "failed to get block");
                    const i = o.result;
                    if (!i) throw new Error("Block " + e + " not found");
                    return i
                }
                async getConfirmedBlockSignatures(e, t) {
                    const n = this._buildArgsAtLeastConfirmed([e], t, void 0, {
                            transactionDetails: "signatures",
                            rewards: !1
                        }),
                        r = await this._rpcRequest("getConfirmedBlock", n),
                        o = Object(g["create"])(r, jn);
                    if ("error" in o) throw new Ye(o.error, "failed to get confirmed block");
                    const i = o.result;
                    if (!i) throw new Error("Confirmed block " + e + " not found");
                    return i
                }
                async getConfirmedTransaction(e, t) {
                    const n = this._buildArgsAtLeastConfirmed([e], t),
                        r = await this._rpcRequest("getConfirmedTransaction", n),
                        o = Object(g["create"])(r, Bn);
                    if ("error" in o) throw new Ye(o.error, "failed to get transaction");
                    const i = o.result;
                    if (!i) return i;
                    const s = new ne(i.transaction.message),
                        a = i.transaction.signatures;
                    return { ...i,
                        transaction: ce.populate(s, a)
                    }
                }
                async getParsedConfirmedTransaction(e, t) {
                    const n = this._buildArgsAtLeastConfirmed([e], t, "jsonParsed"),
                        r = await this._rpcRequest("getConfirmedTransaction", n),
                        o = Object(g["create"])(r, Ln);
                    if ("error" in o) throw new Ye(o.error, "failed to get confirmed transaction");
                    return o.result
                }
                async getParsedConfirmedTransactions(e, t) {
                    const n = e.map(e => {
                            const n = this._buildArgsAtLeastConfirmed([e], t, "jsonParsed");
                            return {
                                methodName: "getConfirmedTransaction",
                                args: n
                            }
                        }),
                        r = await this._rpcBatchRequest(n),
                        o = r.map(e => {
                            const t = Object(g["create"])(e, Ln);
                            if ("error" in t) throw new Ye(t.error, "failed to get confirmed transactions");
                            return t.result
                        });
                    return o
                }
                async getConfirmedSignaturesForAddress(e, t, n) {
                    let r = {},
                        o = await this.getFirstAvailableBlock();
                    while (!("until" in r)) {
                        if (t--, t <= 0 || t < o) break;
                        try {
                            const e = await this.getConfirmedBlockSignatures(t, "finalized");
                            e.signatures.length > 0 && (r.until = e.signatures[e.signatures.length - 1].toString())
                        } catch (a) {
                            if (a instanceof Error && a.message.includes("skipped")) continue;
                            throw a
                        }
                    }
                    let i = await this.getSlot("finalized");
                    while (!("before" in r)) {
                        if (n++, n > i) break;
                        try {
                            const e = await this.getConfirmedBlockSignatures(n);
                            e.signatures.length > 0 && (r.before = e.signatures[e.signatures.length - 1].toString())
                        } catch (a) {
                            if (a instanceof Error && a.message.includes("skipped")) continue;
                            throw a
                        }
                    }
                    const s = await this.getConfirmedSignaturesForAddress2(e, r);
                    return s.map(e => e.signature)
                }
                async getConfirmedSignaturesForAddress2(e, t, n) {
                    const r = this._buildArgsAtLeastConfirmed([e.toBase58()], n, void 0, t),
                        o = await this._rpcRequest("getConfirmedSignaturesForAddress2", r),
                        i = Object(g["create"])(o, Xt);
                    if ("error" in i) throw new Ye(i.error, "failed to get confirmed signatures for address");
                    return i.result
                }
                async getSignaturesForAddress(e, t, n) {
                    const r = this._buildArgsAtLeastConfirmed([e.toBase58()], n, void 0, t),
                        o = await this._rpcRequest("getSignaturesForAddress", r),
                        i = Object(g["create"])(o, Qt);
                    if ("error" in i) throw new Ye(i.error, "failed to get signatures for address");
                    return i.result
                }
                async getAddressLookupTable(e, t) {
                    const {
                        context: n,
                        value: r
                    } = await this.getAccountInfoAndContext(e, t);
                    let o = null;
                    return null !== r && (o = new rt({
                        key: e,
                        state: rt.deserialize(r.data)
                    })), {
                        context: n,
                        value: o
                    }
                }
                async getNonceAndContext(e, t) {
                    const {
                        context: n,
                        value: r
                    } = await this.getAccountInfoAndContext(e, t);
                    let o = null;
                    return null !== r && (o = xe.fromAccountData(r.data)), {
                        context: n,
                        value: o
                    }
                }
                async getNonce(e, t) {
                    return await this.getNonceAndContext(e, t).then(e => e.value).catch(t => {
                        throw new Error("failed to get nonce for account " + e.toBase58() + ": " + t)
                    })
                }
                async requestAirdrop(e, t) {
                    const n = await this._rpcRequest("requestAirdrop", [e.toBase58(), t]),
                        r = Object(g["create"])(n, zn);
                    if ("error" in r) throw new Ye(r.error, `airdrop to ${e.toBase58()} failed`);
                    return r.result
                }
                async _blockhashWithExpiryBlockHeight(e) {
                    if (!e) {
                        while (this._pollingBlockhash) await ve(100);
                        const e = Date.now() - this._blockhashInfo.lastFetch,
                            t = e >= dt;
                        if (null !== this._blockhashInfo.latestBlockhash && !t) return this._blockhashInfo.latestBlockhash
                    }
                    return await this._pollNewBlockhash()
                }
                async _pollNewBlockhash() {
                    this._pollingBlockhash = !0;
                    try {
                        const e = Date.now(),
                            t = this._blockhashInfo.latestBlockhash,
                            n = t ? t.blockhash : null;
                        for (let r = 0; r < 50; r++) {
                            const e = await this.getLatestBlockhash("finalized");
                            if (n !== e.blockhash) return this._blockhashInfo = {
                                latestBlockhash: e,
                                lastFetch: Date.now(),
                                transactionSignatures: [],
                                simulatedSignatures: []
                            }, e;
                            await ve(et / 2)
                        }
                        throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)
                    } finally {
                        this._pollingBlockhash = !1
                    }
                }
                async getStakeMinimumDelegation(e) {
                    const {
                        commitment: t,
                        config: n
                    } = pt(e), r = this._buildArgs([], t, "base64", n), o = await this._rpcRequest("getStakeMinimumDelegation", r), i = Object(g["create"])(o, yt(Object(g["number"])()));
                    if ("error" in i) throw new Ye(i.error, "failed to get stake minimum delegation");
                    return i.result
                }
                async simulateTransaction(e, t, n) {
                    if ("message" in e) {
                        const o = e,
                            i = o.serialize(),
                            s = r["Buffer"].from(i).toString("base64");
                        if (Array.isArray(t) || void 0 !== n) throw new Error("Invalid arguments");
                        const a = t || {};
                        a.encoding = "base64", "commitment" in a || (a.commitment = this.commitment);
                        const c = [s, a],
                            u = await this._rpcRequest("simulateTransaction", c),
                            l = Object(g["create"])(u, Et);
                        if ("error" in l) throw new Error("failed to simulate transaction: " + l.error.message);
                        return l.result
                    }
                    let o;
                    if (e instanceof ce) {
                        let t = e;
                        o = new ce, o.feePayer = t.feePayer, o.instructions = e.instructions, o.nonceInfo = t.nonceInfo, o.signatures = t.signatures
                    } else o = ce.populate(e), o._message = o._json = void 0;
                    if (void 0 !== t && !Array.isArray(t)) throw new Error("Invalid arguments");
                    const i = t;
                    if (o.nonceInfo && i) o.sign(...i);
                    else {
                        let e = this._disableBlockhashCaching;
                        for (;;) {
                            const t = await this._blockhashWithExpiryBlockHeight(e);
                            if (o.lastValidBlockHeight = t.lastValidBlockHeight, o.recentBlockhash = t.blockhash, !i) break;
                            if (o.sign(...i), !o.signature) throw new Error("!signature");
                            const n = o.signature.toString("base64");
                            if (!this._blockhashInfo.simulatedSignatures.includes(n) && !this._blockhashInfo.transactionSignatures.includes(n)) {
                                this._blockhashInfo.simulatedSignatures.push(n);
                                break
                            }
                            e = !0
                        }
                    }
                    const s = o._compile(),
                        a = s.serialize(),
                        c = o._serialize(a),
                        u = c.toString("base64"),
                        l = {
                            encoding: "base64",
                            commitment: this.commitment
                        };
                    if (n) {
                        const e = (Array.isArray(n) ? n : s.nonProgramIds()).map(e => e.toBase58());
                        l["accounts"] = {
                            encoding: "base64",
                            addresses: e
                        }
                    }
                    i && (l.sigVerify = !0);
                    const d = [u, l],
                        h = await this._rpcRequest("simulateTransaction", d),
                        p = Object(g["create"])(h, Et);
                    if ("error" in p) {
                        let e;
                        if ("data" in p.error && (e = p.error.data.logs, e && Array.isArray(e))) {
                            const t = "\n    ",
                                n = t + e.join(t);
                            console.error(p.error.message, n)
                        }
                        throw new Fe("failed to simulate transaction: " + p.error.message, e)
                    }
                    return p.result
                }
                async sendTransaction(e, t, n) {
                    if ("version" in e) {
                        if (t && Array.isArray(t)) throw new Error("Invalid arguments");
                        const r = e.serialize();
                        return await this.sendRawTransaction(r, n)
                    }
                    if (void 0 === t || !Array.isArray(t)) throw new Error("Invalid arguments");
                    const r = t;
                    if (e.nonceInfo) e.sign(...r);
                    else {
                        let t = this._disableBlockhashCaching;
                        for (;;) {
                            const n = await this._blockhashWithExpiryBlockHeight(t);
                            if (e.lastValidBlockHeight = n.lastValidBlockHeight, e.recentBlockhash = n.blockhash, e.sign(...r), !e.signature) throw new Error("!signature");
                            const o = e.signature.toString("base64");
                            if (!this._blockhashInfo.transactionSignatures.includes(o)) {
                                this._blockhashInfo.transactionSignatures.push(o);
                                break
                            }
                            t = !0
                        }
                    }
                    const o = e.serialize();
                    return await this.sendRawTransaction(o, n)
                }
                async sendRawTransaction(e, t) {
                    const n = x(e).toString("base64"),
                        r = await this.sendEncodedTransaction(n, t);
                    return r
                }
                async sendEncodedTransaction(e, t) {
                    const n = {
                            encoding: "base64"
                        },
                        r = t && t.skipPreflight,
                        o = t && t.preflightCommitment || this.commitment;
                    t && null != t.maxRetries && (n.maxRetries = t.maxRetries), t && null != t.minContextSlot && (n.minContextSlot = t.minContextSlot), r && (n.skipPreflight = r), o && (n.preflightCommitment = o);
                    const i = [e, n],
                        s = await this._rpcRequest("sendTransaction", i),
                        a = Object(g["create"])(s, Dn);
                    if ("error" in a) {
                        let e;
                        throw "data" in a.error && (e = a.error.data.logs), new Fe("failed to send transaction: " + a.error.message, e)
                    }
                    return a.result
                }
                _wsOnOpen() {
                    this._rpcWebSocketConnected = !0, this._rpcWebSocketHeartbeat = setInterval(() => {
                        this._rpcWebSocket.notify("ping").catch(() => {})
                    }, 5e3), this._updateSubscriptions()
                }
                _wsOnError(e) {
                    this._rpcWebSocketConnected = !1, console.error("ws error:", e.message)
                }
                _wsOnClose(e) {
                    this._rpcWebSocketConnected = !1, this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER, this._rpcWebSocketIdleTimeout && (clearTimeout(this._rpcWebSocketIdleTimeout), this._rpcWebSocketIdleTimeout = null), this._rpcWebSocketHeartbeat && (clearInterval(this._rpcWebSocketHeartbeat), this._rpcWebSocketHeartbeat = null), 1e3 !== e ? (this._subscriptionCallbacksByServerSubscriptionId = {}, Object.entries(this._subscriptionsByHash).forEach(([e, t]) => {
                        this._subscriptionsByHash[e] = { ...t,
                            state: "pending"
                        }
                    })) : this._updateSubscriptions()
                }
                async _updateSubscriptions() {
                    if (0 === Object.keys(this._subscriptionsByHash).length) return void(this._rpcWebSocketConnected && (this._rpcWebSocketConnected = !1, this._rpcWebSocketIdleTimeout = setTimeout(() => {
                        this._rpcWebSocketIdleTimeout = null;
                        try {
                            this._rpcWebSocket.close()
                        } catch (e) {
                            e instanceof Error && console.log("Error when closing socket connection: " + e.message)
                        }
                    }, 500)));
                    if (null !== this._rpcWebSocketIdleTimeout && (clearTimeout(this._rpcWebSocketIdleTimeout), this._rpcWebSocketIdleTimeout = null, this._rpcWebSocketConnected = !0), !this._rpcWebSocketConnected) return void this._rpcWebSocket.connect();
                    const e = this._rpcWebSocketGeneration,
                        t = () => e === this._rpcWebSocketGeneration;
                    await Promise.all(Object.keys(this._subscriptionsByHash).map(async e => {
                        const n = this._subscriptionsByHash[e];
                        if (void 0 !== n) switch (n.state) {
                            case "pending":
                            case "unsubscribed":
                                if (0 === n.callbacks.size) return delete this._subscriptionsByHash[e], "unsubscribed" === n.state && delete this._subscriptionCallbacksByServerSubscriptionId[n.serverSubscriptionId], void await this._updateSubscriptions();
                                await (async () => {
                                    const {
                                        args: r,
                                        method: o
                                    } = n;
                                    try {
                                        this._subscriptionsByHash[e] = { ...n,
                                            state: "subscribing"
                                        };
                                        const t = await this._rpcWebSocket.call(o, r);
                                        this._subscriptionsByHash[e] = { ...n,
                                            serverSubscriptionId: t,
                                            state: "subscribed"
                                        }, this._subscriptionCallbacksByServerSubscriptionId[t] = n.callbacks, await this._updateSubscriptions()
                                    } catch (i) {
                                        if (i instanceof Error && console.error(o + " error for argument", r, i.message), !t()) return;
                                        this._subscriptionsByHash[e] = { ...n,
                                            state: "pending"
                                        }, await this._updateSubscriptions()
                                    }
                                })();
                                break;
                            case "subscribed":
                                0 === n.callbacks.size && await (async () => {
                                    const {
                                        serverSubscriptionId: r,
                                        unsubscribeMethod: o
                                    } = n;
                                    if (this._subscriptionsAutoDisposedByRpc.has(r)) this._subscriptionsAutoDisposedByRpc.delete(r);
                                    else {
                                        this._subscriptionsByHash[e] = { ...n,
                                            state: "unsubscribing"
                                        };
                                        try {
                                            await this._rpcWebSocket.call(o, [r])
                                        } catch (i) {
                                            if (i instanceof Error && console.error(o + " error:", i.message), !t()) return;
                                            return this._subscriptionsByHash[e] = { ...n,
                                                state: "subscribed"
                                            }, void await this._updateSubscriptions()
                                        }
                                    }
                                    this._subscriptionsByHash[e] = { ...n,
                                        state: "unsubscribed"
                                    }, await this._updateSubscriptions()
                                })();
                                break
                        }
                    }))
                }
                _handleServerNotification(e, t) {
                    const n = this._subscriptionCallbacksByServerSubscriptionId[e];
                    void 0 !== n && n.forEach(e => {
                        try {
                            e(...t)
                        } catch (n) {
                            console.error(n)
                        }
                    })
                }
                _wsOnAccountNotification(e) {
                    const {
                        result: t,
                        subscription: n
                    } = Object(g["create"])(e, en);
                    this._handleServerNotification(n, [t.value, t.context])
                }
                _makeSubscription(e, t) {
                    const n = this._nextClientSubscriptionId++,
                        r = De([e.method, t], !0),
                        o = this._subscriptionsByHash[r];
                    return void 0 === o ? this._subscriptionsByHash[r] = { ...e,
                        args: t,
                        callbacks: new Set([e.callback]),
                        state: "pending"
                    } : o.callbacks.add(e.callback), this._subscriptionDisposeFunctionsByClientSubscriptionId[n] = async () => {
                        delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n];
                        const t = this._subscriptionsByHash[r];
                        ee(void 0 !== t, "Could not find a `Subscription` when tearing down client subscription #" + n), t.callbacks.delete(e.callback), await this._updateSubscriptions()
                    }, this._updateSubscriptions(), n
                }
                onAccountChange(e, t, n) {
                    const r = this._buildArgs([e.toBase58()], n || this._commitment || "finalized", "base64");
                    return this._makeSubscription({
                        callback: t,
                        method: "accountSubscribe",
                        unsubscribeMethod: "accountUnsubscribe"
                    }, r)
                }
                async removeAccountChangeListener(e) {
                    await this._unsubscribeClientSubscription(e, "account change")
                }
                _wsOnProgramAccountNotification(e) {
                    const {
                        result: t,
                        subscription: n
                    } = Object(g["create"])(e, nn);
                    this._handleServerNotification(n, [{
                        accountId: t.value.pubkey,
                        accountInfo: t.value.account
                    }, t.context])
                }
                onProgramAccountChange(e, t, n, r) {
                    const o = this._buildArgs([e.toBase58()], n || this._commitment || "finalized", "base64", r ? {
                        filters: r
                    } : void 0);
                    return this._makeSubscription({
                        callback: t,
                        method: "programSubscribe",
                        unsubscribeMethod: "programUnsubscribe"
                    }, o)
                }
                async removeProgramAccountChangeListener(e) {
                    await this._unsubscribeClientSubscription(e, "program account change")
                }
                onLogs(e, t, n) {
                    const r = this._buildArgs(["object" === typeof e ? {
                        mentions: [e.toString()]
                    } : e], n || this._commitment || "finalized");
                    return this._makeSubscription({
                        callback: t,
                        method: "logsSubscribe",
                        unsubscribeMethod: "logsUnsubscribe"
                    }, r)
                }
                async removeOnLogsListener(e) {
                    await this._unsubscribeClientSubscription(e, "logs")
                }
                _wsOnLogsNotification(e) {
                    const {
                        result: t,
                        subscription: n
                    } = Object(g["create"])(e, qn);
                    this._handleServerNotification(n, [t.value, t.context])
                }
                _wsOnSlotNotification(e) {
                    const {
                        result: t,
                        subscription: n
                    } = Object(g["create"])(e, on);
                    this._handleServerNotification(n, [t])
                }
                onSlotChange(e) {
                    return this._makeSubscription({
                        callback: e,
                        method: "slotSubscribe",
                        unsubscribeMethod: "slotUnsubscribe"
                    }, [])
                }
                async removeSlotChangeListener(e) {
                    await this._unsubscribeClientSubscription(e, "slot change")
                }
                _wsOnSlotUpdatesNotification(e) {
                    const {
                        result: t,
                        subscription: n
                    } = Object(g["create"])(e, an);
                    this._handleServerNotification(n, [t])
                }
                onSlotUpdate(e) {
                    return this._makeSubscription({
                        callback: e,
                        method: "slotsUpdatesSubscribe",
                        unsubscribeMethod: "slotsUpdatesUnsubscribe"
                    }, [])
                }
                async removeSlotUpdateListener(e) {
                    await this._unsubscribeClientSubscription(e, "slot update")
                }
                async _unsubscribeClientSubscription(e, t) {
                    const n = this._subscriptionDisposeFunctionsByClientSubscriptionId[e];
                    n ? await n() : console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)
                }
                _buildArgs(e, t, n, r) {
                    const o = t || this._commitment;
                    if (o || n || r) {
                        let t = {};
                        n && (t.encoding = n), o && (t.commitment = o), r && (t = Object.assign(t, r)), e.push(t)
                    }
                    return e
                }
                _buildArgsAtLeastConfirmed(e, t, n, r) {
                    const o = t || this._commitment;
                    if (o && !["confirmed", "finalized"].includes(o)) throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
                    return this._buildArgs(e, t, n, r)
                }
                _wsOnSignatureNotification(e) {
                    const {
                        result: t,
                        subscription: n
                    } = Object(g["create"])(e, cn);
                    "receivedSignature" !== t.value && this._subscriptionsAutoDisposedByRpc.add(n), this._handleServerNotification(n, "receivedSignature" === t.value ? [{
                        type: "received"
                    }, t.context] : [{
                        type: "status",
                        result: t.value
                    }, t.context])
                }
                onSignature(e, t, n) {
                    const r = this._buildArgs([e], n || this._commitment || "finalized"),
                        o = this._makeSubscription({
                            callback: (e, n) => {
                                if ("status" === e.type) {
                                    t(e.result, n);
                                    try {
                                        this.removeSignatureListener(o)
                                    } catch (r) {}
                                }
                            },
                            method: "signatureSubscribe",
                            unsubscribeMethod: "signatureUnsubscribe"
                        }, r);
                    return o
                }
                onSignatureWithOptions(e, t, n) {
                    const {
                        commitment: r,
                        ...o
                    } = { ...n,
                        commitment: n && n.commitment || this._commitment || "finalized"
                    }, i = this._buildArgs([e], r, void 0, o), s = this._makeSubscription({
                        callback: (e, n) => {
                            t(e, n);
                            try {
                                this.removeSignatureListener(s)
                            } catch (r) {}
                        },
                        method: "signatureSubscribe",
                        unsubscribeMethod: "signatureUnsubscribe"
                    }, i);
                    return s
                }
                async removeSignatureListener(e) {
                    await this._unsubscribeClientSubscription(e, "signature result")
                }
                _wsOnRootNotification(e) {
                    const {
                        result: t,
                        subscription: n
                    } = Object(g["create"])(e, un);
                    this._handleServerNotification(n, [t])
                }
                onRootChange(e) {
                    return this._makeSubscription({
                        callback: e,
                        method: "rootSubscribe",
                        unsubscribeMethod: "rootUnsubscribe"
                    }, [])
                }
                async removeRootChangeListener(e) {
                    await this._unsubscribeClientSubscription(e, "root change")
                }
            }
            class Fn {
                constructor(e) {
                    this._keypair = void 0, this._keypair = null !== e && void 0 !== e ? e : S()
                }
                static generate() {
                    return new Fn(S())
                }
                static fromSecretKey(e, t) {
                    if (64 !== e.byteLength) throw new Error("bad secret key size");
                    const n = e.slice(32, 64);
                    if (!t || !t.skipValidation) {
                        const t = e.slice(0, 32),
                            r = C(t);
                        for (let e = 0; e < 32; e++)
                            if (n[e] !== r[e]) throw new Error("provided secretKey is invalid")
                    }
                    return new Fn({
                        publicKey: n,
                        secretKey: e
                    })
                }
                static fromSeed(e) {
                    const t = C(e),
                        n = new Uint8Array(64);
                    return n.set(e), n.set(t, 32), new Fn({
                        publicKey: t,
                        secretKey: n
                    })
                }
                get publicKey() {
                    return new L(this._keypair.publicKey)
                }
                get secretKey() {
                    return new Uint8Array(this._keypair.secretKey)
                }
            }
            const Gn = Object.freeze({
                CreateLookupTable: {
                    index: 0,
                    layout: h["struct"]([h["u32"]("instruction"), Te("recentSlot"), h["u8"]("bumpSeed")])
                },
                FreezeLookupTable: {
                    index: 1,
                    layout: h["struct"]([h["u32"]("instruction")])
                },
                ExtendLookupTable: {
                    index: 2,
                    layout: h["struct"]([h["u32"]("instruction"), Te(), h["seq"](q(), h["offset"](h["u32"](), -8), "addresses")])
                },
                DeactivateLookupTable: {
                    index: 3,
                    layout: h["struct"]([h["u32"]("instruction")])
                },
                CloseLookupTable: {
                    index: 4,
                    layout: h["struct"]([h["u32"]("instruction")])
                }
            });
            class Yn {
                constructor() {}
                static decodeInstructionType(e) {
                    this.checkProgramId(e.programId);
                    const t = h["u32"]("instruction"),
                        n = t.decode(e.data);
                    let r;
                    for (const [o, i] of Object.entries(Gn))
                        if (i.index == n) {
                            r = o;
                            break
                        }
                    if (!r) throw new Error("Invalid Instruction. Should be a LookupTable Instruction");
                    return r
                }
                static decodeCreateLookupTable(e) {
                    this.checkProgramId(e.programId), this.checkKeysLength(e.keys, 4);
                    const {
                        recentSlot: t
                    } = Ce(Gn.CreateLookupTable, e.data);
                    return {
                        authority: e.keys[1].pubkey,
                        payer: e.keys[2].pubkey,
                        recentSlot: Number(t)
                    }
                }
                static decodeExtendLookupTable(e) {
                    if (this.checkProgramId(e.programId), e.keys.length < 2) throw new Error(`invalid instruction; found ${e.keys.length} keys, expected at least 2`);
                    const {
                        addresses: t
                    } = Ce(Gn.ExtendLookupTable, e.data);
                    return {
                        lookupTable: e.keys[0].pubkey,
                        authority: e.keys[1].pubkey,
                        payer: e.keys.length > 2 ? e.keys[2].pubkey : void 0,
                        addresses: t.map(e => new L(e))
                    }
                }
                static decodeCloseLookupTable(e) {
                    return this.checkProgramId(e.programId), this.checkKeysLength(e.keys, 3), {
                        lookupTable: e.keys[0].pubkey,
                        authority: e.keys[1].pubkey,
                        recipient: e.keys[2].pubkey
                    }
                }
                static decodeFreezeLookupTable(e) {
                    return this.checkProgramId(e.programId), this.checkKeysLength(e.keys, 2), {
                        lookupTable: e.keys[0].pubkey,
                        authority: e.keys[1].pubkey
                    }
                }
                static decodeDeactivateLookupTable(e) {
                    return this.checkProgramId(e.programId), this.checkKeysLength(e.keys, 2), {
                        lookupTable: e.keys[0].pubkey,
                        authority: e.keys[1].pubkey
                    }
                }
                static checkProgramId(e) {
                    if (!e.equals(Jn.programId)) throw new Error("invalid instruction; programId is not AddressLookupTable Program")
                }
                static checkKeysLength(e, t) {
                    if (e.length < t) throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)
                }
            }
            class Jn {
                constructor() {}
                static createLookupTable(e) {
                    const [t, n] = L.findProgramAddressSync([e.authority.toBuffer(), Object(p["toBufferLE"])(BigInt(e.recentSlot), 8)], this.programId), r = Gn.CreateLookupTable, o = Se(r, {
                        recentSlot: BigInt(e.recentSlot),
                        bumpSeed: n
                    }), i = [{
                        pubkey: t,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: e.authority,
                        isSigner: !0,
                        isWritable: !1
                    }, {
                        pubkey: e.payer,
                        isSigner: !0,
                        isWritable: !0
                    }, {
                        pubkey: je.programId,
                        isSigner: !1,
                        isWritable: !1
                    }];
                    return [new ae({
                        programId: this.programId,
                        keys: i,
                        data: o
                    }), t]
                }
                static freezeLookupTable(e) {
                    const t = Gn.FreezeLookupTable,
                        n = Se(t),
                        r = [{
                            pubkey: e.lookupTable,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: e.authority,
                            isSigner: !0,
                            isWritable: !1
                        }];
                    return new ae({
                        programId: this.programId,
                        keys: r,
                        data: n
                    })
                }
                static extendLookupTable(e) {
                    const t = Gn.ExtendLookupTable,
                        n = Se(t, {
                            addresses: e.addresses.map(e => e.toBytes())
                        }),
                        r = [{
                            pubkey: e.lookupTable,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: e.authority,
                            isSigner: !0,
                            isWritable: !1
                        }];
                    return e.payer && r.push({
                        pubkey: e.payer,
                        isSigner: !0,
                        isWritable: !0
                    }, {
                        pubkey: je.programId,
                        isSigner: !1,
                        isWritable: !1
                    }), new ae({
                        programId: this.programId,
                        keys: r,
                        data: n
                    })
                }
                static deactivateLookupTable(e) {
                    const t = Gn.DeactivateLookupTable,
                        n = Se(t),
                        r = [{
                            pubkey: e.lookupTable,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: e.authority,
                            isSigner: !0,
                            isWritable: !1
                        }];
                    return new ae({
                        programId: this.programId,
                        keys: r,
                        data: n
                    })
                }
                static closeLookupTable(e) {
                    const t = Gn.CloseLookupTable,
                        n = Se(t),
                        r = [{
                            pubkey: e.lookupTable,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: e.authority,
                            isSigner: !0,
                            isWritable: !1
                        }, {
                            pubkey: e.recipient,
                            isSigner: !1,
                            isWritable: !0
                        }];
                    return new ae({
                        programId: this.programId,
                        keys: r,
                        data: n
                    })
                }
            }
            Jn.programId = new L("AddressLookupTab1e1111111111111111111111111");
            class Zn {
                constructor() {}
                static decodeInstructionType(e) {
                    this.checkProgramId(e.programId);
                    const t = h["u8"]("instruction"),
                        n = t.decode(e.data);
                    let r;
                    for (const [o, i] of Object.entries(Xn))
                        if (i.index == n) {
                            r = o;
                            break
                        }
                    if (!r) throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");
                    return r
                }
                static decodeRequestUnits(e) {
                    this.checkProgramId(e.programId);
                    const {
                        units: t,
                        additionalFee: n
                    } = Ce(Xn.RequestUnits, e.data);
                    return {
                        units: t,
                        additionalFee: n
                    }
                }
                static decodeRequestHeapFrame(e) {
                    this.checkProgramId(e.programId);
                    const {
                        bytes: t
                    } = Ce(Xn.RequestHeapFrame, e.data);
                    return {
                        bytes: t
                    }
                }
                static decodeSetComputeUnitLimit(e) {
                    this.checkProgramId(e.programId);
                    const {
                        units: t
                    } = Ce(Xn.SetComputeUnitLimit, e.data);
                    return {
                        units: t
                    }
                }
                static decodeSetComputeUnitPrice(e) {
                    this.checkProgramId(e.programId);
                    const {
                        microLamports: t
                    } = Ce(Xn.SetComputeUnitPrice, e.data);
                    return {
                        microLamports: t
                    }
                }
                static checkProgramId(e) {
                    if (!e.equals(Qn.programId)) throw new Error("invalid instruction; programId is not ComputeBudgetProgram")
                }
            }
            const Xn = Object.freeze({
                RequestUnits: {
                    index: 0,
                    layout: h["struct"]([h["u8"]("instruction"), h["u32"]("units"), h["u32"]("additionalFee")])
                },
                RequestHeapFrame: {
                    index: 1,
                    layout: h["struct"]([h["u8"]("instruction"), h["u32"]("bytes")])
                },
                SetComputeUnitLimit: {
                    index: 2,
                    layout: h["struct"]([h["u8"]("instruction"), h["u32"]("units")])
                },
                SetComputeUnitPrice: {
                    index: 3,
                    layout: h["struct"]([h["u8"]("instruction"), Te("microLamports")])
                }
            });
            class Qn {
                constructor() {}
                static requestUnits(e) {
                    const t = Xn.RequestUnits,
                        n = Se(t, e);
                    return new ae({
                        keys: [],
                        programId: this.programId,
                        data: n
                    })
                }
                static requestHeapFrame(e) {
                    const t = Xn.RequestHeapFrame,
                        n = Se(t, e);
                    return new ae({
                        keys: [],
                        programId: this.programId,
                        data: n
                    })
                }
                static setComputeUnitLimit(e) {
                    const t = Xn.SetComputeUnitLimit,
                        n = Se(t, e);
                    return new ae({
                        keys: [],
                        programId: this.programId,
                        data: n
                    })
                }
                static setComputeUnitPrice(e) {
                    const t = Xn.SetComputeUnitPrice,
                        n = Se(t, {
                            microLamports: BigInt(e.microLamports)
                        });
                    return new ae({
                        keys: [],
                        programId: this.programId,
                        data: n
                    })
                }
            }
            Qn.programId = new L("ComputeBudget111111111111111111111111111111");
            const er = 64,
                tr = 32,
                nr = 64,
                rr = h["struct"]([h["u8"]("numSignatures"), h["u8"]("padding"), h["u16"]("signatureOffset"), h["u16"]("signatureInstructionIndex"), h["u16"]("publicKeyOffset"), h["u16"]("publicKeyInstructionIndex"), h["u16"]("messageDataOffset"), h["u16"]("messageDataSize"), h["u16"]("messageInstructionIndex")]);
            class or {
                constructor() {}
                static createInstructionWithPublicKey(e) {
                    const {
                        publicKey: t,
                        message: n,
                        signature: o,
                        instructionIndex: i
                    } = e;
                    ee(t.length === tr, `Public Key must be ${tr} bytes but received ${t.length} bytes`), ee(o.length === nr, `Signature must be ${nr} bytes but received ${o.length} bytes`);
                    const s = rr.span,
                        a = s + t.length,
                        c = a + o.length,
                        u = 1,
                        l = r["Buffer"].alloc(c + n.length),
                        d = null == i ? 65535 : i;
                    return rr.encode({
                        numSignatures: u,
                        padding: 0,
                        signatureOffset: a,
                        signatureInstructionIndex: d,
                        publicKeyOffset: s,
                        publicKeyInstructionIndex: d,
                        messageDataOffset: c,
                        messageDataSize: n.length,
                        messageInstructionIndex: d
                    }, l), l.fill(t, s), l.fill(o, a), l.fill(n, c), new ae({
                        keys: [],
                        programId: or.programId,
                        data: l
                    })
                }
                static createInstructionWithPrivateKey(e) {
                    const {
                        privateKey: t,
                        message: n,
                        instructionIndex: r
                    } = e;
                    ee(t.length === er, `Private key must be ${er} bytes but received ${t.length} bytes`);
                    try {
                        const e = Fn.fromSecretKey(t),
                            o = e.publicKey.toBytes(),
                            i = A(n, e.secretKey);
                        return this.createInstructionWithPublicKey({
                            publicKey: o,
                            message: n,
                            signature: i,
                            instructionIndex: r
                        })
                    } catch (o) {
                        throw new Error("Error creating instruction; " + o)
                    }
                }
            }
            or.programId = new L("Ed25519SigVerify111111111111111111111111111"), k["utils"].hmacSha256Sync = (e, ...t) => {
                const n = w["hmac"].create(l["sha256"], e);
                return t.forEach(e => n.update(e)), n.digest()
            };
            const ir = (e, t) => k["signSync"](e, t, {
                der: !1,
                recovered: !0
            });
            k["utils"].isValidPrivateKey;
            const sr = k["getPublicKey"],
                ar = 32,
                cr = 20,
                ur = 64,
                lr = 11,
                dr = h["struct"]([h["u8"]("numSignatures"), h["u16"]("signatureOffset"), h["u8"]("signatureInstructionIndex"), h["u16"]("ethAddressOffset"), h["u8"]("ethAddressInstructionIndex"), h["u16"]("messageDataOffset"), h["u16"]("messageDataSize"), h["u8"]("messageInstructionIndex"), h["blob"](20, "ethAddress"), h["blob"](64, "signature"), h["u8"]("recoveryId")]);
            class hr {
                constructor() {}
                static publicKeyToEthAddress(e) {
                    ee(e.length === ur, `Public key must be ${ur} bytes but received ${e.length} bytes`);
                    try {
                        return r["Buffer"].from(Object(m["keccak_256"])(x(e))).slice(-cr)
                    } catch (t) {
                        throw new Error("Error constructing Ethereum address: " + t)
                    }
                }
                static createInstructionWithPublicKey(e) {
                    const {
                        publicKey: t,
                        message: n,
                        signature: r,
                        recoveryId: o,
                        instructionIndex: i
                    } = e;
                    return hr.createInstructionWithEthAddress({
                        ethAddress: hr.publicKeyToEthAddress(t),
                        message: n,
                        signature: r,
                        recoveryId: o,
                        instructionIndex: i
                    })
                }
                static createInstructionWithEthAddress(e) {
                    const {
                        ethAddress: t,
                        message: n,
                        signature: o,
                        recoveryId: i,
                        instructionIndex: s = 0
                    } = e;
                    let a;
                    a = "string" === typeof t ? t.startsWith("0x") ? r["Buffer"].from(t.substr(2), "hex") : r["Buffer"].from(t, "hex") : t, ee(a.length === cr, `Address must be ${cr} bytes but received ${a.length} bytes`);
                    const c = 1 + lr,
                        u = c,
                        l = c + a.length,
                        d = l + o.length + 1,
                        h = 1,
                        p = r["Buffer"].alloc(dr.span + n.length);
                    return dr.encode({
                        numSignatures: h,
                        signatureOffset: l,
                        signatureInstructionIndex: s,
                        ethAddressOffset: u,
                        ethAddressInstructionIndex: s,
                        messageDataOffset: d,
                        messageDataSize: n.length,
                        messageInstructionIndex: s,
                        signature: x(o),
                        ethAddress: x(a),
                        recoveryId: i
                    }, p), p.fill(x(n), dr.span), new ae({
                        keys: [],
                        programId: hr.programId,
                        data: p
                    })
                }
                static createInstructionWithPrivateKey(e) {
                    const {
                        privateKey: t,
                        message: n,
                        instructionIndex: o
                    } = e;
                    ee(t.length === ar, `Private key must be ${ar} bytes but received ${t.length} bytes`);
                    try {
                        const e = x(t),
                            i = sr(e, !1).slice(1),
                            s = r["Buffer"].from(Object(m["keccak_256"])(x(n))),
                            [a, c] = ir(s, e);
                        return this.createInstructionWithPublicKey({
                            publicKey: i,
                            message: n,
                            signature: a,
                            recoveryId: c,
                            instructionIndex: o
                        })
                    } catch (i) {
                        throw new Error("Error creating instruction; " + i)
                    }
                }
            }
            hr.programId = new L("KeccakSecp256k11111111111111111111111111111");
            const pr = new L("StakeConfig11111111111111111111111111111111");
            class gr {
                constructor(e, t) {
                    this.staker = void 0, this.withdrawer = void 0, this.staker = e, this.withdrawer = t
                }
            }
            class fr {
                constructor(e, t, n) {
                    this.unixTimestamp = void 0, this.epoch = void 0, this.custodian = void 0, this.unixTimestamp = e, this.epoch = t, this.custodian = n
                }
            }
            fr.default = new fr(0, 0, L.default);
            class br {
                constructor() {}
                static decodeInstructionType(e) {
                    this.checkProgramId(e.programId);
                    const t = h["u32"]("instruction"),
                        n = t.decode(e.data);
                    let r;
                    for (const [o, i] of Object.entries(yr))
                        if (i.index == n) {
                            r = o;
                            break
                        }
                    if (!r) throw new Error("Instruction type incorrect; not a StakeInstruction");
                    return r
                }
                static decodeInitialize(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
                    const {
                        authorized: t,
                        lockup: n
                    } = Ce(yr.Initialize, e.data);
                    return {
                        stakePubkey: e.keys[0].pubkey,
                        authorized: new gr(new L(t.staker), new L(t.withdrawer)),
                        lockup: new fr(n.unixTimestamp, n.epoch, new L(n.custodian))
                    }
                }
                static decodeDelegate(e) {
                    return this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 6), Ce(yr.Delegate, e.data), {
                        stakePubkey: e.keys[0].pubkey,
                        votePubkey: e.keys[1].pubkey,
                        authorizedPubkey: e.keys[5].pubkey
                    }
                }
                static decodeAuthorize(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
                    const {
                        newAuthorized: t,
                        stakeAuthorizationType: n
                    } = Ce(yr.Authorize, e.data), r = {
                        stakePubkey: e.keys[0].pubkey,
                        authorizedPubkey: e.keys[2].pubkey,
                        newAuthorizedPubkey: new L(t),
                        stakeAuthorizationType: {
                            index: n
                        }
                    };
                    return e.keys.length > 3 && (r.custodianPubkey = e.keys[3].pubkey), r
                }
                static decodeAuthorizeWithSeed(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
                    const {
                        newAuthorized: t,
                        stakeAuthorizationType: n,
                        authoritySeed: r,
                        authorityOwner: o
                    } = Ce(yr.AuthorizeWithSeed, e.data), i = {
                        stakePubkey: e.keys[0].pubkey,
                        authorityBase: e.keys[1].pubkey,
                        authoritySeed: r,
                        authorityOwner: new L(o),
                        newAuthorizedPubkey: new L(t),
                        stakeAuthorizationType: {
                            index: n
                        }
                    };
                    return e.keys.length > 3 && (i.custodianPubkey = e.keys[3].pubkey), i
                }
                static decodeSplit(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
                    const {
                        lamports: t
                    } = Ce(yr.Split, e.data);
                    return {
                        stakePubkey: e.keys[0].pubkey,
                        splitStakePubkey: e.keys[1].pubkey,
                        authorizedPubkey: e.keys[2].pubkey,
                        lamports: t
                    }
                }
                static decodeMerge(e) {
                    return this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3), Ce(yr.Merge, e.data), {
                        stakePubkey: e.keys[0].pubkey,
                        sourceStakePubKey: e.keys[1].pubkey,
                        authorizedPubkey: e.keys[4].pubkey
                    }
                }
                static decodeWithdraw(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 5);
                    const {
                        lamports: t
                    } = Ce(yr.Withdraw, e.data), n = {
                        stakePubkey: e.keys[0].pubkey,
                        toPubkey: e.keys[1].pubkey,
                        authorizedPubkey: e.keys[4].pubkey,
                        lamports: t
                    };
                    return e.keys.length > 5 && (n.custodianPubkey = e.keys[5].pubkey), n
                }
                static decodeDeactivate(e) {
                    return this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3), Ce(yr.Deactivate, e.data), {
                        stakePubkey: e.keys[0].pubkey,
                        authorizedPubkey: e.keys[2].pubkey
                    }
                }
                static checkProgramId(e) {
                    if (!e.equals(wr.programId)) throw new Error("invalid instruction; programId is not StakeProgram")
                }
                static checkKeyLength(e, t) {
                    if (e.length < t) throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)
                }
            }
            const yr = Object.freeze({
                    Initialize: {
                        index: 0,
                        layout: h["struct"]([h["u32"]("instruction"), F(), G()])
                    },
                    Authorize: {
                        index: 1,
                        layout: h["struct"]([h["u32"]("instruction"), q("newAuthorized"), h["u32"]("stakeAuthorizationType")])
                    },
                    Delegate: {
                        index: 2,
                        layout: h["struct"]([h["u32"]("instruction")])
                    },
                    Split: {
                        index: 3,
                        layout: h["struct"]([h["u32"]("instruction"), h["ns64"]("lamports")])
                    },
                    Withdraw: {
                        index: 4,
                        layout: h["struct"]([h["u32"]("instruction"), h["ns64"]("lamports")])
                    },
                    Deactivate: {
                        index: 5,
                        layout: h["struct"]([h["u32"]("instruction")])
                    },
                    Merge: {
                        index: 7,
                        layout: h["struct"]([h["u32"]("instruction")])
                    },
                    AuthorizeWithSeed: {
                        index: 8,
                        layout: h["struct"]([h["u32"]("instruction"), q("newAuthorized"), h["u32"]("stakeAuthorizationType"), V("authoritySeed"), q("authorityOwner")])
                    }
                }),
                mr = Object.freeze({
                    Staker: {
                        index: 0
                    },
                    Withdrawer: {
                        index: 1
                    }
                });
            class wr {
                constructor() {}
                static initialize(e) {
                    const {
                        stakePubkey: t,
                        authorized: n,
                        lockup: r
                    } = e, o = r || fr.default, i = yr.Initialize, s = Se(i, {
                        authorized: {
                            staker: x(n.staker.toBuffer()),
                            withdrawer: x(n.withdrawer.toBuffer())
                        },
                        lockup: {
                            unixTimestamp: o.unixTimestamp,
                            epoch: o.epoch,
                            custodian: x(o.custodian.toBuffer())
                        }
                    }), a = {
                        keys: [{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: fe,
                            isSigner: !1,
                            isWritable: !1
                        }],
                        programId: this.programId,
                        data: s
                    };
                    return new ae(a)
                }
                static createAccountWithSeed(e) {
                    const t = new ce;
                    t.add(je.createAccountWithSeed({
                        fromPubkey: e.fromPubkey,
                        newAccountPubkey: e.stakePubkey,
                        basePubkey: e.basePubkey,
                        seed: e.seed,
                        lamports: e.lamports,
                        space: this.space,
                        programId: this.programId
                    }));
                    const {
                        stakePubkey: n,
                        authorized: r,
                        lockup: o
                    } = e;
                    return t.add(this.initialize({
                        stakePubkey: n,
                        authorized: r,
                        lockup: o
                    }))
                }
                static createAccount(e) {
                    const t = new ce;
                    t.add(je.createAccount({
                        fromPubkey: e.fromPubkey,
                        newAccountPubkey: e.stakePubkey,
                        lamports: e.lamports,
                        space: this.space,
                        programId: this.programId
                    }));
                    const {
                        stakePubkey: n,
                        authorized: r,
                        lockup: o
                    } = e;
                    return t.add(this.initialize({
                        stakePubkey: n,
                        authorized: r,
                        lockup: o
                    }))
                }
                static delegate(e) {
                    const {
                        stakePubkey: t,
                        authorizedPubkey: n,
                        votePubkey: r
                    } = e, o = yr.Delegate, i = Se(o);
                    return (new ce).add({
                        keys: [{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: r,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: de,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: we,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: pr,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: n,
                            isSigner: !0,
                            isWritable: !1
                        }],
                        programId: this.programId,
                        data: i
                    })
                }
                static authorize(e) {
                    const {
                        stakePubkey: t,
                        authorizedPubkey: n,
                        newAuthorizedPubkey: r,
                        stakeAuthorizationType: o,
                        custodianPubkey: i
                    } = e, s = yr.Authorize, a = Se(s, {
                        newAuthorized: x(r.toBuffer()),
                        stakeAuthorizationType: o.index
                    }), c = [{
                        pubkey: t,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: de,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: n,
                        isSigner: !0,
                        isWritable: !1
                    }];
                    return i && c.push({
                        pubkey: i,
                        isSigner: !1,
                        isWritable: !1
                    }), (new ce).add({
                        keys: c,
                        programId: this.programId,
                        data: a
                    })
                }
                static authorizeWithSeed(e) {
                    const {
                        stakePubkey: t,
                        authorityBase: n,
                        authoritySeed: r,
                        authorityOwner: o,
                        newAuthorizedPubkey: i,
                        stakeAuthorizationType: s,
                        custodianPubkey: a
                    } = e, c = yr.AuthorizeWithSeed, u = Se(c, {
                        newAuthorized: x(i.toBuffer()),
                        stakeAuthorizationType: s.index,
                        authoritySeed: r,
                        authorityOwner: x(o.toBuffer())
                    }), l = [{
                        pubkey: t,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: n,
                        isSigner: !0,
                        isWritable: !1
                    }, {
                        pubkey: de,
                        isSigner: !1,
                        isWritable: !1
                    }];
                    return a && l.push({
                        pubkey: a,
                        isSigner: !1,
                        isWritable: !1
                    }), (new ce).add({
                        keys: l,
                        programId: this.programId,
                        data: u
                    })
                }
                static splitInstruction(e) {
                    const {
                        stakePubkey: t,
                        authorizedPubkey: n,
                        splitStakePubkey: r,
                        lamports: o
                    } = e, i = yr.Split, s = Se(i, {
                        lamports: o
                    });
                    return new ae({
                        keys: [{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: r,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: n,
                            isSigner: !0,
                            isWritable: !1
                        }],
                        programId: this.programId,
                        data: s
                    })
                }
                static split(e) {
                    const t = new ce;
                    return t.add(je.createAccount({
                        fromPubkey: e.authorizedPubkey,
                        newAccountPubkey: e.splitStakePubkey,
                        lamports: 0,
                        space: this.space,
                        programId: this.programId
                    })), t.add(this.splitInstruction(e))
                }
                static splitWithSeed(e) {
                    const {
                        stakePubkey: t,
                        authorizedPubkey: n,
                        splitStakePubkey: r,
                        basePubkey: o,
                        seed: i,
                        lamports: s
                    } = e, a = new ce;
                    return a.add(je.allocate({
                        accountPubkey: r,
                        basePubkey: o,
                        seed: i,
                        space: this.space,
                        programId: this.programId
                    })), a.add(this.splitInstruction({
                        stakePubkey: t,
                        authorizedPubkey: n,
                        splitStakePubkey: r,
                        lamports: s
                    }))
                }
                static merge(e) {
                    const {
                        stakePubkey: t,
                        sourceStakePubKey: n,
                        authorizedPubkey: r
                    } = e, o = yr.Merge, i = Se(o);
                    return (new ce).add({
                        keys: [{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: n,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: de,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: we,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: r,
                            isSigner: !0,
                            isWritable: !1
                        }],
                        programId: this.programId,
                        data: i
                    })
                }
                static withdraw(e) {
                    const {
                        stakePubkey: t,
                        authorizedPubkey: n,
                        toPubkey: r,
                        lamports: o,
                        custodianPubkey: i
                    } = e, s = yr.Withdraw, a = Se(s, {
                        lamports: o
                    }), c = [{
                        pubkey: t,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: r,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: de,
                        isSigner: !1,
                        isWritable: !1
                    }, {
                        pubkey: we,
                        isSigner: !1,
                        isWritable: !1
                    }, {
                        pubkey: n,
                        isSigner: !0,
                        isWritable: !1
                    }];
                    return i && c.push({
                        pubkey: i,
                        isSigner: !1,
                        isWritable: !1
                    }), (new ce).add({
                        keys: c,
                        programId: this.programId,
                        data: a
                    })
                }
                static deactivate(e) {
                    const {
                        stakePubkey: t,
                        authorizedPubkey: n
                    } = e, r = yr.Deactivate, o = Se(r);
                    return (new ce).add({
                        keys: [{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: de,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: n,
                            isSigner: !0,
                            isWritable: !1
                        }],
                        programId: this.programId,
                        data: o
                    })
                }
            }
            wr.programId = new L("Stake11111111111111111111111111111111111111"), wr.space = 200;
            class kr {
                constructor(e, t, n, r) {
                    this.nodePubkey = void 0, this.authorizedVoter = void 0, this.authorizedWithdrawer = void 0, this.commission = void 0, this.nodePubkey = e, this.authorizedVoter = t, this.authorizedWithdrawer = n, this.commission = r
                }
            }
            class vr {
                constructor() {}
                static decodeInstructionType(e) {
                    this.checkProgramId(e.programId);
                    const t = h["u32"]("instruction"),
                        n = t.decode(e.data);
                    let r;
                    for (const [o, i] of Object.entries(Sr))
                        if (i.index == n) {
                            r = o;
                            break
                        }
                    if (!r) throw new Error("Instruction type incorrect; not a VoteInstruction");
                    return r
                }
                static decodeInitializeAccount(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 4);
                    const {
                        voteInit: t
                    } = Ce(Sr.InitializeAccount, e.data);
                    return {
                        votePubkey: e.keys[0].pubkey,
                        nodePubkey: e.keys[3].pubkey,
                        voteInit: new kr(new L(t.nodePubkey), new L(t.authorizedVoter), new L(t.authorizedWithdrawer), t.commission)
                    }
                }
                static decodeAuthorize(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
                    const {
                        newAuthorized: t,
                        voteAuthorizationType: n
                    } = Ce(Sr.Authorize, e.data);
                    return {
                        votePubkey: e.keys[0].pubkey,
                        authorizedPubkey: e.keys[2].pubkey,
                        newAuthorizedPubkey: new L(t),
                        voteAuthorizationType: {
                            index: n
                        }
                    }
                }
                static decodeAuthorizeWithSeed(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
                    const {
                        voteAuthorizeWithSeedArgs: {
                            currentAuthorityDerivedKeyOwnerPubkey: t,
                            currentAuthorityDerivedKeySeed: n,
                            newAuthorized: r,
                            voteAuthorizationType: o
                        }
                    } = Ce(Sr.AuthorizeWithSeed, e.data);
                    return {
                        currentAuthorityDerivedKeyBasePubkey: e.keys[2].pubkey,
                        currentAuthorityDerivedKeyOwnerPubkey: new L(t),
                        currentAuthorityDerivedKeySeed: n,
                        newAuthorizedPubkey: new L(r),
                        voteAuthorizationType: {
                            index: o
                        },
                        votePubkey: e.keys[0].pubkey
                    }
                }
                static decodeWithdraw(e) {
                    this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
                    const {
                        lamports: t
                    } = Ce(Sr.Withdraw, e.data);
                    return {
                        votePubkey: e.keys[0].pubkey,
                        authorizedWithdrawerPubkey: e.keys[2].pubkey,
                        lamports: t,
                        toPubkey: e.keys[1].pubkey
                    }
                }
                static checkProgramId(e) {
                    if (!e.equals(Ir.programId)) throw new Error("invalid instruction; programId is not VoteProgram")
                }
                static checkKeyLength(e, t) {
                    if (e.length < t) throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)
                }
            }
            const Sr = Object.freeze({
                    InitializeAccount: {
                        index: 0,
                        layout: h["struct"]([h["u32"]("instruction"), Y()])
                    },
                    Authorize: {
                        index: 1,
                        layout: h["struct"]([h["u32"]("instruction"), q("newAuthorized"), h["u32"]("voteAuthorizationType")])
                    },
                    Withdraw: {
                        index: 3,
                        layout: h["struct"]([h["u32"]("instruction"), h["ns64"]("lamports")])
                    },
                    AuthorizeWithSeed: {
                        index: 10,
                        layout: h["struct"]([h["u32"]("instruction"), J()])
                    }
                }),
                Cr = Object.freeze({
                    Voter: {
                        index: 0
                    },
                    Withdrawer: {
                        index: 1
                    }
                });
            class Ir {
                constructor() {}
                static initializeAccount(e) {
                    const {
                        votePubkey: t,
                        nodePubkey: n,
                        voteInit: r
                    } = e, o = Sr.InitializeAccount, i = Se(o, {
                        voteInit: {
                            nodePubkey: x(r.nodePubkey.toBuffer()),
                            authorizedVoter: x(r.authorizedVoter.toBuffer()),
                            authorizedWithdrawer: x(r.authorizedWithdrawer.toBuffer()),
                            commission: r.commission
                        }
                    }), s = {
                        keys: [{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: fe,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: de,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: n,
                            isSigner: !0,
                            isWritable: !1
                        }],
                        programId: this.programId,
                        data: i
                    };
                    return new ae(s)
                }
                static createAccount(e) {
                    const t = new ce;
                    return t.add(je.createAccount({
                        fromPubkey: e.fromPubkey,
                        newAccountPubkey: e.votePubkey,
                        lamports: e.lamports,
                        space: this.space,
                        programId: this.programId
                    })), t.add(this.initializeAccount({
                        votePubkey: e.votePubkey,
                        nodePubkey: e.voteInit.nodePubkey,
                        voteInit: e.voteInit
                    }))
                }
                static authorize(e) {
                    const {
                        votePubkey: t,
                        authorizedPubkey: n,
                        newAuthorizedPubkey: r,
                        voteAuthorizationType: o
                    } = e, i = Sr.Authorize, s = Se(i, {
                        newAuthorized: x(r.toBuffer()),
                        voteAuthorizationType: o.index
                    }), a = [{
                        pubkey: t,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: de,
                        isSigner: !1,
                        isWritable: !1
                    }, {
                        pubkey: n,
                        isSigner: !0,
                        isWritable: !1
                    }];
                    return (new ce).add({
                        keys: a,
                        programId: this.programId,
                        data: s
                    })
                }
                static authorizeWithSeed(e) {
                    const {
                        currentAuthorityDerivedKeyBasePubkey: t,
                        currentAuthorityDerivedKeyOwnerPubkey: n,
                        currentAuthorityDerivedKeySeed: r,
                        newAuthorizedPubkey: o,
                        voteAuthorizationType: i,
                        votePubkey: s
                    } = e, a = Sr.AuthorizeWithSeed, c = Se(a, {
                        voteAuthorizeWithSeedArgs: {
                            currentAuthorityDerivedKeyOwnerPubkey: x(n.toBuffer()),
                            currentAuthorityDerivedKeySeed: r,
                            newAuthorized: x(o.toBuffer()),
                            voteAuthorizationType: i.index
                        }
                    }), u = [{
                        pubkey: s,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: de,
                        isSigner: !1,
                        isWritable: !1
                    }, {
                        pubkey: t,
                        isSigner: !0,
                        isWritable: !1
                    }];
                    return (new ce).add({
                        keys: u,
                        programId: this.programId,
                        data: c
                    })
                }
                static withdraw(e) {
                    const {
                        votePubkey: t,
                        authorizedWithdrawerPubkey: n,
                        lamports: r,
                        toPubkey: o
                    } = e, i = Sr.Withdraw, s = Se(i, {
                        lamports: r
                    }), a = [{
                        pubkey: t,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: o,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: n,
                        isSigner: !0,
                        isWritable: !1
                    }];
                    return (new ce).add({
                        keys: a,
                        programId: this.programId,
                        data: s
                    })
                }
                static safeWithdraw(e, t, n) {
                    if (e.lamports > t - n) throw new Error("Withdraw will leave vote account with insuffcient funds.");
                    return Ir.withdraw(e)
                }
            }
            Ir.programId = new L("Vote111111111111111111111111111111111111111"), Ir.space = 3731;
            const Ar = new L("Va1idator1nfo111111111111111111111111111111"),
                Or = Object(g["type"])({
                    name: Object(g["string"])(),
                    website: Object(g["optional"])(Object(g["string"])()),
                    details: Object(g["optional"])(Object(g["string"])()),
                    keybaseUsername: Object(g["optional"])(Object(g["string"])())
                });
            class xr {
                constructor(e, t) {
                    this.key = void 0, this.info = void 0, this.key = e, this.info = t
                }
                static fromConfigData(e) {
                    let t = [...e];
                    const n = X(t);
                    if (2 !== n) return null;
                    const o = [];
                    for (let r = 0; r < 2; r++) {
                        const e = new L(t.slice(0, R));
                        t = t.slice(R);
                        const n = 1 === t.slice(0, 1)[0];
                        t = t.slice(1), o.push({
                            publicKey: e,
                            isSigner: n
                        })
                    }
                    if (o[0].publicKey.equals(Ar) && o[1].isSigner) {
                        const e = V().decode(r["Buffer"].from(t)),
                            n = JSON.parse(e);
                        return Object(g["assert"])(n, Or), new xr(o[1].publicKey, n)
                    }
                    return null
                }
            }
            const _r = new L("Vote111111111111111111111111111111111111111"),
                Er = h["struct"]([q("nodePubkey"), q("authorizedWithdrawer"), h["u8"]("commission"), h["nu64"](), h["seq"](h["struct"]([h["nu64"]("slot"), h["u32"]("confirmationCount")]), h["offset"](h["u32"](), -8), "votes"), h["u8"]("rootSlotValid"), h["nu64"]("rootSlot"), h["nu64"](), h["seq"](h["struct"]([h["nu64"]("epoch"), q("authorizedVoter")]), h["offset"](h["u32"](), -8), "authorizedVoters"), h["struct"]([h["seq"](h["struct"]([q("authorizedPubkey"), h["nu64"]("epochOfLastAuthorizedSwitch"), h["nu64"]("targetEpoch")]), 32, "buf"), h["nu64"]("idx"), h["u8"]("isEmpty")], "priorVoters"), h["nu64"](), h["seq"](h["struct"]([h["nu64"]("epoch"), h["nu64"]("credits"), h["nu64"]("prevCredits")]), h["offset"](h["u32"](), -8), "epochCredits"), h["struct"]([h["nu64"]("slot"), h["nu64"]("timestamp")], "lastTimestamp")]);
            class Tr {
                constructor(e) {
                    this.nodePubkey = void 0, this.authorizedWithdrawer = void 0, this.commission = void 0, this.rootSlot = void 0, this.votes = void 0, this.authorizedVoters = void 0, this.priorVoters = void 0, this.epochCredits = void 0, this.lastTimestamp = void 0, this.nodePubkey = e.nodePubkey, this.authorizedWithdrawer = e.authorizedWithdrawer, this.commission = e.commission, this.rootSlot = e.rootSlot, this.votes = e.votes, this.authorizedVoters = e.authorizedVoters, this.priorVoters = e.priorVoters, this.epochCredits = e.epochCredits, this.lastTimestamp = e.lastTimestamp
                }
                static fromAccountData(e) {
                    const t = 4,
                        n = Er.decode(x(e), t);
                    let r = n.rootSlot;
                    return n.rootSlotValid || (r = null), new Tr({
                        nodePubkey: new L(n.nodePubkey),
                        authorizedWithdrawer: new L(n.authorizedWithdrawer),
                        commission: n.commission,
                        votes: n.votes,
                        rootSlot: r,
                        authorizedVoters: n.authorizedVoters.map(Pr),
                        priorVoters: jr(n.priorVoters),
                        epochCredits: n.epochCredits,
                        lastTimestamp: n.lastTimestamp
                    })
                }
            }

            function Pr({
                authorizedVoter: e,
                epoch: t
            }) {
                return {
                    epoch: t,
                    authorizedVoter: new L(e)
                }
            }

            function Rr({
                authorizedPubkey: e,
                epochOfLastAuthorizedSwitch: t,
                targetEpoch: n
            }) {
                return {
                    authorizedPubkey: new L(e),
                    epochOfLastAuthorizedSwitch: t,
                    targetEpoch: n
                }
            }

            function jr({
                buf: e,
                idx: t,
                isEmpty: n
            }) {
                return n ? [] : [...e.slice(t + 1).map(Rr), ...e.slice(0, t).map(Rr)]
            }
            const Br = {
                http: {
                    devnet: "http://api.devnet.solana.com",
                    testnet: "http://api.testnet.solana.com",
                    "mainnet-beta": "http://api.mainnet-beta.solana.com/"
                },
                https: {
                    devnet: "https://api.devnet.solana.com",
                    testnet: "https://api.testnet.solana.com",
                    "mainnet-beta": "https://api.mainnet-beta.solana.com/"
                }
            };

            function Lr(e, t) {
                const n = !1 === t ? "http" : "https";
                if (!e) return Br[n]["devnet"];
                const r = Br[n][e];
                if (!r) throw new Error(`Unknown ${n} cluster: ${e}`);
                return r
            }
            async function Wr(e, t, n, r) {
                let o, i;
                n && Object.prototype.hasOwnProperty.call(n, "lastValidBlockHeight") ? (o = n, i = r) : i = n;
                const s = i && {
                        skipPreflight: i.skipPreflight,
                        preflightCommitment: i.preflightCommitment || i.commitment,
                        minContextSlot: i.minContextSlot
                    },
                    a = await e.sendRawTransaction(t, s),
                    c = i && i.commitment,
                    u = o ? e.confirmTransaction(o, c) : e.confirmTransaction(a, c),
                    l = (await u).value;
                if (l.err) throw new Error(`Raw transaction ${a} failed (${JSON.stringify(l)})`);
                return a
            }
            const Nr = 1e9
        },
        "6b27": function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.add5L = t.add5H = t.add4H = t.add4L = t.add3H = t.add3L = t.add = t.rotlBL = t.rotlBH = t.rotlSL = t.rotlSH = t.rotr32L = t.rotr32H = t.rotrBL = t.rotrBH = t.rotrSL = t.rotrSH = t.shrSL = t.shrSH = t.toBig = t.split = t.fromBig = void 0;
            const r = BigInt(2 ** 32 - 1),
                o = BigInt(32);

            function i(e, t = !1) {
                return t ? {
                    h: Number(e & r),
                    l: Number(e >> o & r)
                } : {
                    h: 0 | Number(e >> o & r),
                    l: 0 | Number(e & r)
                }
            }

            function s(e, t = !1) {
                let n = new Uint32Array(e.length),
                    r = new Uint32Array(e.length);
                for (let o = 0; o < e.length; o++) {
                    const {
                        h: s,
                        l: a
                    } = i(e[o], t);
                    [n[o], r[o]] = [s, a]
                }
                return [n, r]
            }
            t.fromBig = i, t.split = s;
            const a = (e, t) => BigInt(e >>> 0) << o | BigInt(t >>> 0);
            t.toBig = a;
            const c = (e, t, n) => e >>> n;
            t.shrSH = c;
            const u = (e, t, n) => e << 32 - n | t >>> n;
            t.shrSL = u;
            const l = (e, t, n) => e >>> n | t << 32 - n;
            t.rotrSH = l;
            const d = (e, t, n) => e << 32 - n | t >>> n;
            t.rotrSL = d;
            const h = (e, t, n) => e << 64 - n | t >>> n - 32;
            t.rotrBH = h;
            const p = (e, t, n) => e >>> n - 32 | t << 64 - n;
            t.rotrBL = p;
            const g = (e, t) => t;
            t.rotr32H = g;
            const f = (e, t) => e;
            t.rotr32L = f;
            const b = (e, t, n) => e << n | t >>> 32 - n;
            t.rotlSH = b;
            const y = (e, t, n) => t << n | e >>> 32 - n;
            t.rotlSL = y;
            const m = (e, t, n) => t << n - 32 | e >>> 64 - n;
            t.rotlBH = m;
            const w = (e, t, n) => e << n - 32 | t >>> 64 - n;

            function k(e, t, n, r) {
                const o = (t >>> 0) + (r >>> 0);
                return {
                    h: e + n + (o / 2 ** 32 | 0) | 0,
                    l: 0 | o
                }
            }
            t.rotlBL = w, t.add = k;
            const v = (e, t, n) => (e >>> 0) + (t >>> 0) + (n >>> 0);
            t.add3L = v;
            const S = (e, t, n, r) => t + n + r + (e / 2 ** 32 | 0) | 0;
            t.add3H = S;
            const C = (e, t, n, r) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0);
            t.add4L = C;
            const I = (e, t, n, r, o) => t + n + r + o + (e / 2 ** 32 | 0) | 0;
            t.add4H = I;
            const A = (e, t, n, r, o) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0) + (o >>> 0);
            t.add5L = A;
            const O = (e, t, n, r, o, i) => t + n + r + o + i + (e / 2 ** 32 | 0) | 0;
            t.add5H = O;
            const x = {
                fromBig: i,
                split: s,
                toBig: a,
                shrSH: c,
                shrSL: u,
                rotrSH: l,
                rotrSL: d,
                rotrBH: h,
                rotrBL: p,
                rotr32H: g,
                rotr32L: f,
                rotlSH: b,
                rotlSL: y,
                rotlBH: m,
                rotlBL: w,
                add: k,
                add3L: v,
                add3H: S,
                add4L: C,
                add4H: I,
                add5H: O,
                add5L: A
            };
            t.default = x
        },
        "730b": function(e, t, n) {
            "use strict";
            (function(e) {
                n.d(t, "a", (function() {
                    return i
                }));
                var r = n("0276"),
                    o = n("4ae8");

                function i(t, n, i, s, a = o["c"], c = o["a"]) {
                    const u = [{
                        pubkey: t,
                        isSigner: !0,
                        isWritable: !0
                    }, {
                        pubkey: n,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: i,
                        isSigner: !1,
                        isWritable: !1
                    }, {
                        pubkey: s,
                        isSigner: !1,
                        isWritable: !1
                    }, {
                        pubkey: r["SystemProgram"].programId,
                        isSigner: !1,
                        isWritable: !1
                    }, {
                        pubkey: a,
                        isSigner: !1,
                        isWritable: !1
                    }, {
                        pubkey: r["SYSVAR_RENT_PUBKEY"],
                        isSigner: !1,
                        isWritable: !1
                    }];
                    return new r["TransactionInstruction"]({
                        keys: u,
                        programId: c,
                        data: e.alloc(0)
                    })
                }
            }).call(this, n("b639").Buffer)
        },
        "7d1c": function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.publicKey = void 0;
            const r = n("8df2"),
                o = n("64b9"),
                i = n("ee73"),
                s = e => {
                    const t = (0, r.blob)(32, e),
                        {
                            encode: n,
                            decode: s
                        } = (0, i.encodeDecode)(t),
                        a = t;
                    return a.decode = (e, t) => {
                        const n = s(e, t);
                        return new o.PublicKey(n)
                    }, a.encode = (e, t, r) => {
                        const o = e.toBuffer();
                        return n(o, t, r)
                    }, a
                };
            t.publicKey = s
        },
        "8df2": function(e, t, n) {
            "use strict";
            /**
             * Support for translating between Uint8Array instances and JavaScript
             * native types.
             *
             * {@link module:Layout~Layout|Layout} is the basis of a class
             * hierarchy that associates property names with sequences of encoded
             * bytes.
             *
             * Layouts are supported for these scalar (numeric) types:
             * * {@link module:Layout~UInt|Unsigned integers in little-endian
             *   format} with {@link module:Layout.u8|8-bit}, {@link
             *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
             *   {@link module:Layout.u32|32-bit}, {@link
             *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
             *   representation ranges;
             * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
             *   format} with {@link module:Layout.u16be|16-bit}, {@link
             *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
             *   {@link module:Layout.u40be|40-bit}, and {@link
             *   module:Layout.u48be|48-bit} representation ranges;
             * * {@link module:Layout~Int|Signed integers in little-endian
             *   format} with {@link module:Layout.s8|8-bit}, {@link
             *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
             *   {@link module:Layout.s32|32-bit}, {@link
             *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
             *   representation ranges;
             * * {@link module:Layout~IntBE|Signed integers in big-endian format}
             *   with {@link module:Layout.s16be|16-bit}, {@link
             *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
             *   {@link module:Layout.s40be|40-bit}, and {@link
             *   module:Layout.s48be|48-bit} representation ranges;
             * * 64-bit integral values that decode to an exact (if magnitude is
             *   less than 2^53) or nearby integral Number in {@link
             *   module:Layout.nu64|unsigned little-endian}, {@link
             *   module:Layout.nu64be|unsigned big-endian}, {@link
             *   module:Layout.ns64|signed little-endian}, and {@link
             *   module:Layout.ns64be|unsigned big-endian} encodings;
             * * 32-bit floating point values with {@link
             *   module:Layout.f32|little-endian} and {@link
             *   module:Layout.f32be|big-endian} representations;
             * * 64-bit floating point values with {@link
             *   module:Layout.f64|little-endian} and {@link
             *   module:Layout.f64be|big-endian} representations;
             * * {@link module:Layout.const|Constants} that take no space in the
             *   encoded expression.
             *
             * and for these aggregate types:
             * * {@link module:Layout.seq|Sequence}s of instances of a {@link
             *   module:Layout~Layout|Layout}, with JavaScript representation as
             *   an Array and constant or data-dependent {@link
             *   module:Layout~Sequence#count|length};
             * * {@link module:Layout.struct|Structure}s that aggregate a
             *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
             *   instances, with JavaScript representation as an Object;
             * * {@link module:Layout.union|Union}s that support multiple {@link
             *   module:Layout~VariantLayout|variant layouts} over a fixed
             *   (padded) or variable (not padded) span of bytes, using an
             *   unsigned integer at the start of the data or a separate {@link
             *   module:Layout.unionLayoutDiscriminator|layout element} to
             *   determine which layout to use when interpreting the buffer
             *   contents;
             * * {@link module:Layout.bits|BitStructure}s that contain a sequence
             *   of individual {@link
             *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
             *   16, 24, or 32-bit unsigned integer starting at the least- or
             *   most-significant bit;
             * * {@link module:Layout.cstr|C strings} of varying length;
             * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
             *   module:Layout~Blob#length|length} raw data.
             *
             * All {@link module:Layout~Layout|Layout} instances are immutable
             * after construction, to prevent internal state from becoming
             * inconsistent.
             *
             * @local Layout
             * @local ExternalLayout
             * @local GreedyCount
             * @local OffsetLayout
             * @local UInt
             * @local UIntBE
             * @local Int
             * @local IntBE
             * @local NearUInt64
             * @local NearUInt64BE
             * @local NearInt64
             * @local NearInt64BE
             * @local Float
             * @local FloatBE
             * @local Double
             * @local DoubleBE
             * @local Sequence
             * @local Structure
             * @local UnionDiscriminator
             * @local UnionLayoutDiscriminator
             * @local Union
             * @local VariantLayout
             * @local BitStructure
             * @local BitField
             * @local Boolean
             * @local Blob
             * @local CString
             * @local Constant
             * @local bindConstructorLayout
             * @module Layout
             * @license MIT
             * @author Peter A. Bigot
             * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
             */
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.s16 = t.s8 = t.nu64be = t.u48be = t.u40be = t.u32be = t.u24be = t.u16be = t.nu64 = t.u48 = t.u40 = t.u32 = t.u24 = t.u16 = t.u8 = t.offset = t.greedy = t.Constant = t.UTF8 = t.CString = t.Blob = t.Boolean = t.BitField = t.BitStructure = t.VariantLayout = t.Union = t.UnionLayoutDiscriminator = t.UnionDiscriminator = t.Structure = t.Sequence = t.DoubleBE = t.Double = t.FloatBE = t.Float = t.NearInt64BE = t.NearInt64 = t.NearUInt64BE = t.NearUInt64 = t.IntBE = t.Int = t.UIntBE = t.UInt = t.OffsetLayout = t.GreedyCount = t.ExternalLayout = t.bindConstructorLayout = t.nameWithProperty = t.Layout = t.uint8ArrayToBuffer = t.checkUint8Array = void 0, t.constant = t.utf8 = t.cstr = t.blob = t.unionLayoutDiscriminator = t.union = t.seq = t.bits = t.struct = t.f64be = t.f64 = t.f32be = t.f32 = t.ns64be = t.s48be = t.s40be = t.s32be = t.s24be = t.s16be = t.ns64 = t.s48 = t.s40 = t.s32 = t.s24 = void 0;
            const r = n("b639");

            function o(e) {
                if (!(e instanceof Uint8Array)) throw new TypeError("b must be a Uint8Array")
            }

            function i(e) {
                return o(e), r.Buffer.from(e.buffer, e.byteOffset, e.length)
            }
            t.checkUint8Array = o, t.uint8ArrayToBuffer = i;
            class s {
                constructor(e, t) {
                    if (!Number.isInteger(e)) throw new TypeError("span must be an integer");
                    this.span = e, this.property = t
                }
                makeDestinationObject() {
                    return {}
                }
                getSpan(e, t) {
                    if (0 > this.span) throw new RangeError("indeterminate span");
                    return this.span
                }
                replicate(e) {
                    const t = Object.create(this.constructor.prototype);
                    return Object.assign(t, this), t.property = e, t
                }
                fromArray(e) {}
            }

            function a(e, t) {
                return t.property ? e + "[" + t.property + "]" : e
            }

            function c(e, t) {
                if ("function" !== typeof e) throw new TypeError("Class must be constructor");
                if (Object.prototype.hasOwnProperty.call(e, "layout_")) throw new Error("Class is already bound to a layout");
                if (!(t && t instanceof s)) throw new TypeError("layout must be a Layout");
                if (Object.prototype.hasOwnProperty.call(t, "boundConstructor_")) throw new Error("layout is already bound to a constructor");
                e.layout_ = t, t.boundConstructor_ = e, t.makeDestinationObject = () => new e, Object.defineProperty(e.prototype, "encode", {
                    value(e, n) {
                        return t.encode(this, e, n)
                    },
                    writable: !0
                }), Object.defineProperty(e, "decode", {
                    value(e, n) {
                        return t.decode(e, n)
                    },
                    writable: !0
                })
            }
            t.Layout = s, t.nameWithProperty = a, t.bindConstructorLayout = c;
            class u extends s {
                isCount() {
                    throw new Error("ExternalLayout is abstract")
                }
            }
            t.ExternalLayout = u;
            class l extends u {
                constructor(e = 1, t) {
                    if (!Number.isInteger(e) || 0 >= e) throw new TypeError("elementSpan must be a (positive) integer");
                    super(-1, t), this.elementSpan = e
                }
                isCount() {
                    return !0
                }
                decode(e, t = 0) {
                    o(e);
                    const n = e.length - t;
                    return Math.floor(n / this.elementSpan)
                }
                encode(e, t, n) {
                    return 0
                }
            }
            t.GreedyCount = l;
            class d extends u {
                constructor(e, t = 0, n) {
                    if (!(e instanceof s)) throw new TypeError("layout must be a Layout");
                    if (!Number.isInteger(t)) throw new TypeError("offset must be integer or undefined");
                    super(e.span, n || e.property), this.layout = e, this.offset = t
                }
                isCount() {
                    return this.layout instanceof h || this.layout instanceof p
                }
                decode(e, t = 0) {
                    return this.layout.decode(e, t + this.offset)
                }
                encode(e, t, n = 0) {
                    return this.layout.encode(e, t, n + this.offset)
                }
            }
            t.OffsetLayout = d;
            class h extends s {
                constructor(e, t) {
                    if (super(e, t), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
                }
                decode(e, t = 0) {
                    return i(e).readUIntLE(t, this.span)
                }
                encode(e, t, n = 0) {
                    return i(t).writeUIntLE(e, n, this.span), this.span
                }
            }
            t.UInt = h;
            class p extends s {
                constructor(e, t) {
                    if (super(e, t), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
                }
                decode(e, t = 0) {
                    return i(e).readUIntBE(t, this.span)
                }
                encode(e, t, n = 0) {
                    return i(t).writeUIntBE(e, n, this.span), this.span
                }
            }
            t.UIntBE = p;
            class g extends s {
                constructor(e, t) {
                    if (super(e, t), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
                }
                decode(e, t = 0) {
                    return i(e).readIntLE(t, this.span)
                }
                encode(e, t, n = 0) {
                    return i(t).writeIntLE(e, n, this.span), this.span
                }
            }
            t.Int = g;
            class f extends s {
                constructor(e, t) {
                    if (super(e, t), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
                }
                decode(e, t = 0) {
                    return i(e).readIntBE(t, this.span)
                }
                encode(e, t, n = 0) {
                    return i(t).writeIntBE(e, n, this.span), this.span
                }
            }
            t.IntBE = f;
            const b = Math.pow(2, 32);

            function y(e) {
                const t = Math.floor(e / b),
                    n = e - t * b;
                return {
                    hi32: t,
                    lo32: n
                }
            }

            function m(e, t) {
                return e * b + t
            }
            class w extends s {
                constructor(e) {
                    super(8, e)
                }
                decode(e, t = 0) {
                    const n = i(e),
                        r = n.readUInt32LE(t),
                        o = n.readUInt32LE(t + 4);
                    return m(o, r)
                }
                encode(e, t, n = 0) {
                    const r = y(e),
                        o = i(t);
                    return o.writeUInt32LE(r.lo32, n), o.writeUInt32LE(r.hi32, n + 4), 8
                }
            }
            t.NearUInt64 = w;
            class k extends s {
                constructor(e) {
                    super(8, e)
                }
                decode(e, t = 0) {
                    const n = i(e),
                        r = n.readUInt32BE(t),
                        o = n.readUInt32BE(t + 4);
                    return m(r, o)
                }
                encode(e, t, n = 0) {
                    const r = y(e),
                        o = i(t);
                    return o.writeUInt32BE(r.hi32, n), o.writeUInt32BE(r.lo32, n + 4), 8
                }
            }
            t.NearUInt64BE = k;
            class v extends s {
                constructor(e) {
                    super(8, e)
                }
                decode(e, t = 0) {
                    const n = i(e),
                        r = n.readUInt32LE(t),
                        o = n.readInt32LE(t + 4);
                    return m(o, r)
                }
                encode(e, t, n = 0) {
                    const r = y(e),
                        o = i(t);
                    return o.writeUInt32LE(r.lo32, n), o.writeInt32LE(r.hi32, n + 4), 8
                }
            }
            t.NearInt64 = v;
            class S extends s {
                constructor(e) {
                    super(8, e)
                }
                decode(e, t = 0) {
                    const n = i(e),
                        r = n.readInt32BE(t),
                        o = n.readUInt32BE(t + 4);
                    return m(r, o)
                }
                encode(e, t, n = 0) {
                    const r = y(e),
                        o = i(t);
                    return o.writeInt32BE(r.hi32, n), o.writeUInt32BE(r.lo32, n + 4), 8
                }
            }
            t.NearInt64BE = S;
            class C extends s {
                constructor(e) {
                    super(4, e)
                }
                decode(e, t = 0) {
                    return i(e).readFloatLE(t)
                }
                encode(e, t, n = 0) {
                    return i(t).writeFloatLE(e, n), 4
                }
            }
            t.Float = C;
            class I extends s {
                constructor(e) {
                    super(4, e)
                }
                decode(e, t = 0) {
                    return i(e).readFloatBE(t)
                }
                encode(e, t, n = 0) {
                    return i(t).writeFloatBE(e, n), 4
                }
            }
            t.FloatBE = I;
            class A extends s {
                constructor(e) {
                    super(8, e)
                }
                decode(e, t = 0) {
                    return i(e).readDoubleLE(t)
                }
                encode(e, t, n = 0) {
                    return i(t).writeDoubleLE(e, n), 8
                }
            }
            t.Double = A;
            class O extends s {
                constructor(e) {
                    super(8, e)
                }
                decode(e, t = 0) {
                    return i(e).readDoubleBE(t)
                }
                encode(e, t, n = 0) {
                    return i(t).writeDoubleBE(e, n), 8
                }
            }
            t.DoubleBE = O;
            class x extends s {
                constructor(e, t, n) {
                    if (!(e instanceof s)) throw new TypeError("elementLayout must be a Layout");
                    if (!(t instanceof u && t.isCount() || Number.isInteger(t) && 0 <= t)) throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
                    let r = -1;
                    !(t instanceof u) && 0 < e.span && (r = t * e.span), super(r, n), this.elementLayout = e, this.count = t
                }
                getSpan(e, t = 0) {
                    if (0 <= this.span) return this.span;
                    let n = 0,
                        r = this.count;
                    if (r instanceof u && (r = r.decode(e, t)), 0 < this.elementLayout.span) n = r * this.elementLayout.span;
                    else {
                        let o = 0;
                        while (o < r) n += this.elementLayout.getSpan(e, t + n), ++o
                    }
                    return n
                }
                decode(e, t = 0) {
                    const n = [];
                    let r = 0,
                        o = this.count;
                    o instanceof u && (o = o.decode(e, t));
                    while (r < o) n.push(this.elementLayout.decode(e, t)), t += this.elementLayout.getSpan(e, t), r += 1;
                    return n
                }
                encode(e, t, n = 0) {
                    const r = this.elementLayout,
                        o = e.reduce((e, o) => e + r.encode(o, t, n + e), 0);
                    return this.count instanceof u && this.count.encode(e.length, t, n), o
                }
            }
            t.Sequence = x;
            class _ extends s {
                constructor(e, t, n) {
                    if (!Array.isArray(e) || !e.reduce((e, t) => e && t instanceof s, !0)) throw new TypeError("fields must be array of Layout instances");
                    "boolean" === typeof t && void 0 === n && (n = t, t = void 0);
                    for (const i of e)
                        if (0 > i.span && void 0 === i.property) throw new Error("fields cannot contain unnamed variable-length layout");
                    let r = -1;
                    try {
                        r = e.reduce((e, t) => e + t.getSpan(), 0)
                    } catch (o) {}
                    super(r, t), this.fields = e, this.decodePrefixes = !!n
                }
                getSpan(e, t = 0) {
                    if (0 <= this.span) return this.span;
                    let n = 0;
                    try {
                        n = this.fields.reduce((n, r) => {
                            const o = r.getSpan(e, t);
                            return t += o, n + o
                        }, 0)
                    } catch (r) {
                        throw new RangeError("indeterminate span")
                    }
                    return n
                }
                decode(e, t = 0) {
                    o(e);
                    const n = this.makeDestinationObject();
                    for (const r of this.fields)
                        if (void 0 !== r.property && (n[r.property] = r.decode(e, t)), t += r.getSpan(e, t), this.decodePrefixes && e.length === t) break;
                    return n
                }
                encode(e, t, n = 0) {
                    const r = n;
                    let o = 0,
                        i = 0;
                    for (const s of this.fields) {
                        let r = s.span;
                        if (i = 0 < r ? r : 0, void 0 !== s.property) {
                            const o = e[s.property];
                            void 0 !== o && (i = s.encode(o, t, n), 0 > r && (r = s.getSpan(t, n)))
                        }
                        o = n, n += r
                    }
                    return o + i - r
                }
                fromArray(e) {
                    const t = this.makeDestinationObject();
                    for (const n of this.fields) void 0 !== n.property && 0 < e.length && (t[n.property] = e.shift());
                    return t
                }
                layoutFor(e) {
                    if ("string" !== typeof e) throw new TypeError("property must be string");
                    for (const t of this.fields)
                        if (t.property === e) return t
                }
                offsetOf(e) {
                    if ("string" !== typeof e) throw new TypeError("property must be string");
                    let t = 0;
                    for (const n of this.fields) {
                        if (n.property === e) return t;
                        0 > n.span ? t = -1 : 0 <= t && (t += n.span)
                    }
                }
            }
            t.Structure = _;
            class E {
                constructor(e) {
                    this.property = e
                }
                decode(e, t) {
                    throw new Error("UnionDiscriminator is abstract")
                }
                encode(e, t, n) {
                    throw new Error("UnionDiscriminator is abstract")
                }
            }
            t.UnionDiscriminator = E;
            class T extends E {
                constructor(e, t) {
                    if (!(e instanceof u && e.isCount())) throw new TypeError("layout must be an unsigned integer ExternalLayout");
                    super(t || e.property || "variant"), this.layout = e
                }
                decode(e, t) {
                    return this.layout.decode(e, t)
                }
                encode(e, t, n) {
                    return this.layout.encode(e, t, n)
                }
            }
            t.UnionLayoutDiscriminator = T;
            class P extends s {
                constructor(e, t, n) {
                    let r;
                    if (e instanceof h || e instanceof p) r = new T(new d(e));
                    else if (e instanceof u && e.isCount()) r = new T(e);
                    else {
                        if (!(e instanceof E)) throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
                        r = e
                    }
                    if (void 0 === t && (t = null), !(null === t || t instanceof s)) throw new TypeError("defaultLayout must be null or a Layout");
                    if (null !== t) {
                        if (0 > t.span) throw new Error("defaultLayout must have constant span");
                        void 0 === t.property && (t = t.replicate("content"))
                    }
                    let o = -1;
                    t && (o = t.span, 0 <= o && (e instanceof h || e instanceof p) && (o += r.layout.span)), super(o, n), this.discriminator = r, this.usesPrefixDiscriminator = e instanceof h || e instanceof p, this.defaultLayout = t, this.registry = {};
                    let i = this.defaultGetSourceVariant.bind(this);
                    this.getSourceVariant = function(e) {
                        return i(e)
                    }, this.configGetSourceVariant = function(e) {
                        i = e.bind(this)
                    }
                }
                getSpan(e, t = 0) {
                    if (0 <= this.span) return this.span;
                    const n = this.getVariant(e, t);
                    if (!n) throw new Error("unable to determine span for unrecognized variant");
                    return n.getSpan(e, t)
                }
                defaultGetSourceVariant(e) {
                    if (Object.prototype.hasOwnProperty.call(e, this.discriminator.property)) {
                        if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(e, this.defaultLayout.property)) return;
                        const t = this.registry[e[this.discriminator.property]];
                        if (t && (!t.layout || t.property && Object.prototype.hasOwnProperty.call(e, t.property))) return t
                    } else
                        for (const t in this.registry) {
                            const n = this.registry[t];
                            if (n.property && Object.prototype.hasOwnProperty.call(e, n.property)) return n
                        }
                    throw new Error("unable to infer src variant")
                }
                decode(e, t = 0) {
                    let n;
                    const r = this.discriminator,
                        o = r.decode(e, t),
                        i = this.registry[o];
                    if (void 0 === i) {
                        const i = this.defaultLayout;
                        let s = 0;
                        this.usesPrefixDiscriminator && (s = r.layout.span), n = this.makeDestinationObject(), n[r.property] = o, n[i.property] = i.decode(e, t + s)
                    } else n = i.decode(e, t);
                    return n
                }
                encode(e, t, n = 0) {
                    const r = this.getSourceVariant(e);
                    if (void 0 === r) {
                        const r = this.discriminator,
                            o = this.defaultLayout;
                        let i = 0;
                        return this.usesPrefixDiscriminator && (i = r.layout.span), r.encode(e[r.property], t, n), i + o.encode(e[o.property], t, n + i)
                    }
                    return r.encode(e, t, n)
                }
                addVariant(e, t, n) {
                    const r = new R(this, e, t, n);
                    return this.registry[e] = r, r
                }
                getVariant(e, t = 0) {
                    let n;
                    return n = e instanceof Uint8Array ? this.discriminator.decode(e, t) : e, this.registry[n]
                }
            }
            t.Union = P;
            class R extends s {
                constructor(e, t, n, r) {
                    if (!(e instanceof P)) throw new TypeError("union must be a Union");
                    if (!Number.isInteger(t) || 0 > t) throw new TypeError("variant must be a (non-negative) integer");
                    if ("string" === typeof n && void 0 === r && (r = n, n = null), n) {
                        if (!(n instanceof s)) throw new TypeError("layout must be a Layout");
                        if (null !== e.defaultLayout && 0 <= n.span && n.span > e.defaultLayout.span) throw new Error("variant span exceeds span of containing union");
                        if ("string" !== typeof r) throw new TypeError("variant must have a String property")
                    }
                    let o = e.span;
                    0 > e.span && (o = n ? n.span : 0, 0 <= o && e.usesPrefixDiscriminator && (o += e.discriminator.layout.span)), super(o, r), this.union = e, this.variant = t, this.layout = n || null
                }
                getSpan(e, t = 0) {
                    if (0 <= this.span) return this.span;
                    let n = 0;
                    this.union.usesPrefixDiscriminator && (n = this.union.discriminator.layout.span);
                    let r = 0;
                    return this.layout && (r = this.layout.getSpan(e, t + n)), n + r
                }
                decode(e, t = 0) {
                    const n = this.makeDestinationObject();
                    if (this !== this.union.getVariant(e, t)) throw new Error("variant mismatch");
                    let r = 0;
                    return this.union.usesPrefixDiscriminator && (r = this.union.discriminator.layout.span), this.layout ? n[this.property] = this.layout.decode(e, t + r) : this.property ? n[this.property] = !0 : this.union.usesPrefixDiscriminator && (n[this.union.discriminator.property] = this.variant), n
                }
                encode(e, t, n = 0) {
                    let r = 0;
                    if (this.union.usesPrefixDiscriminator && (r = this.union.discriminator.layout.span), this.layout && !Object.prototype.hasOwnProperty.call(e, this.property)) throw new TypeError("variant lacks property " + this.property);
                    this.union.discriminator.encode(this.variant, t, n);
                    let o = r;
                    if (this.layout && (this.layout.encode(e[this.property], t, n + r), o += this.layout.getSpan(t, n + r), 0 <= this.union.span && o > this.union.span)) throw new Error("encoded variant overruns containing union");
                    return o
                }
                fromArray(e) {
                    if (this.layout) return this.layout.fromArray(e)
                }
            }

            function j(e) {
                return 0 > e && (e += 4294967296), e
            }
            t.VariantLayout = R;
            class B extends s {
                constructor(e, t, n) {
                    if (!(e instanceof h || e instanceof p)) throw new TypeError("word must be a UInt or UIntBE layout");
                    if ("string" === typeof t && void 0 === n && (n = t, t = !1), 4 < e.span) throw new RangeError("word cannot exceed 32 bits");
                    super(e.span, n), this.word = e, this.msb = !!t, this.fields = [];
                    let r = 0;
                    this._packedSetValue = function(e) {
                        return r = j(e), this
                    }, this._packedGetValue = function() {
                        return r
                    }
                }
                decode(e, t = 0) {
                    const n = this.makeDestinationObject(),
                        r = this.word.decode(e, t);
                    this._packedSetValue(r);
                    for (const o of this.fields) void 0 !== o.property && (n[o.property] = o.decode(e));
                    return n
                }
                encode(e, t, n = 0) {
                    const r = this.word.decode(t, n);
                    this._packedSetValue(r);
                    for (const o of this.fields)
                        if (void 0 !== o.property) {
                            const t = e[o.property];
                            void 0 !== t && o.encode(t)
                        }
                    return this.word.encode(this._packedGetValue(), t, n)
                }
                addField(e, t) {
                    const n = new L(this, e, t);
                    return this.fields.push(n), n
                }
                addBoolean(e) {
                    const t = new W(this, e);
                    return this.fields.push(t), t
                }
                fieldFor(e) {
                    if ("string" !== typeof e) throw new TypeError("property must be string");
                    for (const t of this.fields)
                        if (t.property === e) return t
                }
            }
            t.BitStructure = B;
            class L {
                constructor(e, t, n) {
                    if (!(e instanceof B)) throw new TypeError("container must be a BitStructure");
                    if (!Number.isInteger(t) || 0 >= t) throw new TypeError("bits must be positive integer");
                    const r = 8 * e.span,
                        o = e.fields.reduce((e, t) => e + t.bits, 0);
                    if (t + o > r) throw new Error("bits too long for span remainder (" + (r - o) + " of " + r + " remain)");
                    this.container = e, this.bits = t, this.valueMask = (1 << t) - 1, 32 === t && (this.valueMask = 4294967295), this.start = o, this.container.msb && (this.start = r - o - t), this.wordMask = j(this.valueMask << this.start), this.property = n
                }
                decode(e, t) {
                    const n = this.container._packedGetValue(),
                        r = j(n & this.wordMask),
                        o = r >>> this.start;
                    return o
                }
                encode(e) {
                    if ("number" !== typeof e || !Number.isInteger(e) || e !== j(e & this.valueMask)) throw new TypeError(a("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
                    const t = this.container._packedGetValue(),
                        n = j(e << this.start);
                    this.container._packedSetValue(j(t & ~this.wordMask) | n)
                }
            }
            t.BitField = L;
            class W extends L {
                constructor(e, t) {
                    super(e, 1, t)
                }
                decode(e, t) {
                    return !!super.decode(e, t)
                }
                encode(e) {
                    "boolean" === typeof e && (e = +e), super.encode(e)
                }
            }
            t.Boolean = W;
            class N extends s {
                constructor(e, t) {
                    if (!(e instanceof u && e.isCount() || Number.isInteger(e) && 0 <= e)) throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
                    let n = -1;
                    e instanceof u || (n = e), super(n, t), this.length = e
                }
                getSpan(e, t) {
                    let n = this.span;
                    return 0 > n && (n = this.length.decode(e, t)), n
                }
                decode(e, t = 0) {
                    let n = this.span;
                    return 0 > n && (n = this.length.decode(e, t)), i(e).slice(t, t + n)
                }
                encode(e, t, n) {
                    let r = this.length;
                    if (this.length instanceof u && (r = e.length), !(e instanceof Uint8Array && r === e.length)) throw new TypeError(a("Blob.encode", this) + " requires (length " + r + ") Uint8Array as src");
                    if (n + r > t.length) throw new RangeError("encoding overruns Uint8Array");
                    const o = i(e);
                    return i(t).write(o.toString("hex"), n, r, "hex"), this.length instanceof u && this.length.encode(r, t, n), r
                }
            }
            t.Blob = N;
            class M extends s {
                constructor(e) {
                    super(-1, e)
                }
                getSpan(e, t = 0) {
                    o(e);
                    let n = t;
                    while (n < e.length && 0 !== e[n]) n += 1;
                    return 1 + n - t
                }
                decode(e, t = 0) {
                    const n = this.getSpan(e, t);
                    return i(e).slice(t, t + n - 1).toString("utf-8")
                }
                encode(e, t, n = 0) {
                    "string" !== typeof e && (e = String(e));
                    const o = r.Buffer.from(e, "utf8"),
                        s = o.length;
                    if (n + s > t.length) throw new RangeError("encoding overruns Buffer");
                    const a = i(t);
                    return o.copy(a, n), a[n + s] = 0, s + 1
                }
            }
            t.CString = M;
            class K extends s {
                constructor(e, t) {
                    if ("string" === typeof e && void 0 === t && (t = e, e = void 0), void 0 === e) e = -1;
                    else if (!Number.isInteger(e)) throw new TypeError("maxSpan must be an integer");
                    super(-1, t), this.maxSpan = e
                }
                getSpan(e, t = 0) {
                    return o(e), e.length - t
                }
                decode(e, t = 0) {
                    const n = this.getSpan(e, t);
                    if (0 <= this.maxSpan && this.maxSpan < n) throw new RangeError("text length exceeds maxSpan");
                    return i(e).slice(t, t + n).toString("utf-8")
                }
                encode(e, t, n = 0) {
                    "string" !== typeof e && (e = String(e));
                    const o = r.Buffer.from(e, "utf8"),
                        s = o.length;
                    if (0 <= this.maxSpan && this.maxSpan < s) throw new RangeError("text length exceeds maxSpan");
                    if (n + s > t.length) throw new RangeError("encoding overruns Buffer");
                    return o.copy(i(t), n), s
                }
            }
            t.UTF8 = K;
            class U extends s {
                constructor(e, t) {
                    super(0, t), this.value = e
                }
                decode(e, t) {
                    return this.value
                }
                encode(e, t, n) {
                    return 0
                }
            }
            t.Constant = U, t.greedy = (e, t) => new l(e, t), t.offset = (e, t, n) => new d(e, t, n), t.u8 = e => new h(1, e), t.u16 = e => new h(2, e), t.u24 = e => new h(3, e), t.u32 = e => new h(4, e), t.u40 = e => new h(5, e), t.u48 = e => new h(6, e), t.nu64 = e => new w(e), t.u16be = e => new p(2, e), t.u24be = e => new p(3, e), t.u32be = e => new p(4, e), t.u40be = e => new p(5, e), t.u48be = e => new p(6, e), t.nu64be = e => new k(e), t.s8 = e => new g(1, e), t.s16 = e => new g(2, e), t.s24 = e => new g(3, e), t.s32 = e => new g(4, e), t.s40 = e => new g(5, e), t.s48 = e => new g(6, e), t.ns64 = e => new v(e), t.s16be = e => new f(2, e), t.s24be = e => new f(3, e), t.s32be = e => new f(4, e), t.s40be = e => new f(5, e), t.s48be = e => new f(6, e), t.ns64be = e => new S(e), t.f32 = e => new C(e), t.f32be = e => new I(e), t.f64 = e => new A(e), t.f64be = e => new O(e), t.struct = (e, t, n) => new _(e, t, n), t.bits = (e, t, n) => new B(e, t, n), t.seq = (e, t, n) => new x(e, t, n), t.union = (e, t, n) => new P(e, t, n), t.unionLayoutDiscriminator = (e, t) => new T(e, t), t.blob = (e, t) => new N(e, t), t.cstr = e => new M(e), t.utf8 = (e, t) => new K(e, t), t.constant = (e, t) => new U(e, t)
        },
        9085: function(e, t, n) {
            "use strict";
            (function(e) {
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var r = n("21fa");
                /*! *****************************************************************************
                Copyright (c) Microsoft Corporation.

                Permission to use, copy, modify, and/or distribute this software for any
                purpose with or without fee is hereby granted.

                THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
                REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
                AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
                INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
                LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
                OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
                PERFORMANCE OF THIS SOFTWARE.
                ***************************************************************************** */
                function o(e, t) {
                    var n = {};
                    for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
                    if (null != e && "function" === typeof Object.getOwnPropertySymbols) {
                        var o = 0;
                        for (r = Object.getOwnPropertySymbols(e); o < r.length; o++) t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]])
                    }
                    return n
                }

                function i(e, t, n, r) {
                    function o(e) {
                        return e instanceof n ? e : new n((function(t) {
                            t(e)
                        }))
                    }
                    return new(n || (n = Promise))((function(n, i) {
                        function s(e) {
                            try {
                                c(r.next(e))
                            } catch (t) {
                                i(t)
                            }
                        }

                        function a(e) {
                            try {
                                c(r["throw"](e))
                            } catch (t) {
                                i(t)
                            }
                        }

                        function c(e) {
                            e.done ? n(e.value) : o(e.value).then(s, a)
                        }
                        c((r = r.apply(e, t || [])).next())
                    }))
                }
                n("e4cc"), n("f632");
                class s extends Error {
                    constructor(e, t) {
                        super(e, t), this.message = `${s.prefix} ${this.constructor.name}${this.info?": "+this.info:""}${e?"\n"+e:""}`, Object.setPrototypeOf(this, s.prototype)
                    }
                    get info() {
                        return ""
                    }
                }
                s.prefix = "[TON_CONNECT_SDK_ERROR]";
                class a extends s {
                    get info() {
                        return "Passed DappMetadata is in incorrect format."
                    }
                    constructor(...e) {
                        super(...e), Object.setPrototypeOf(this, a.prototype)
                    }
                }
                class c extends s {
                    get info() {
                        return "Passed `tonconnect-manifest.json` contains errors. Check format of your manifest. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest"
                    }
                    constructor(...e) {
                        super(...e), Object.setPrototypeOf(this, c.prototype)
                    }
                }
                class u extends s {
                    get info() {
                        return "Manifest not found. Make sure you added `tonconnect-manifest.json` to the root of your app or passed correct manifestUrl. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest"
                    }
                    constructor(...e) {
                        super(...e), Object.setPrototypeOf(this, u.prototype)
                    }
                }
                class l extends s {
                    get info() {
                        return "Wallet connection called but wallet already connected. To avoid the error, disconnect the wallet before doing a new connection."
                    }
                    constructor(...e) {
                        super(...e), Object.setPrototypeOf(this, l.prototype)
                    }
                }
                class d extends s {
                    get info() {
                        return "Send transaction or other protocol methods called while wallet is not connected."
                    }
                    constructor(...e) {
                        super(...e), Object.setPrototypeOf(this, d.prototype)
                    }
                }

                function h(e) {
                    return "jsBridgeKey" in e
                }
                class p extends s {
                    get info() {
                        return "User rejects the action in the wallet."
                    }
                    constructor(...e) {
                        super(...e), Object.setPrototypeOf(this, p.prototype)
                    }
                }
                class g extends s {
                    get info() {
                        return "Request to the wallet contains errors."
                    }
                    constructor(...e) {
                        super(...e), Object.setPrototypeOf(this, g.prototype)
                    }
                }
                class f extends s {
                    get info() {
                        return "App tries to send rpc request to the injected wallet while not connected."
                    }
                    constructor(...e) {
                        super(...e), Object.setPrototypeOf(this, f.prototype)
                    }
                }
                class b extends s {
                    get info() {
                        return "There is an attempt to connect to the injected wallet while it is not exists in the webpage."
                    }
                    constructor(...e) {
                        super(...e), Object.setPrototypeOf(this, b.prototype)
                    }
                }
                class y extends s {
                    get info() {
                        return "Storage was not specified in the `DappMetadata` and default `localStorage` was not detected in the environment."
                    }
                    constructor(...e) {
                        super(...e), Object.setPrototypeOf(this, y.prototype)
                    }
                }
                class m extends s {
                    get info() {
                        return "An error occurred while fetching the wallets list."
                    }
                    constructor(...e) {
                        super(...e), Object.setPrototypeOf(this, m.prototype)
                    }
                }
                class w extends s {
                    get info() {
                        return "Passed address is in incorrect format."
                    }
                    constructor(...e) {
                        super(...e), Object.setPrototypeOf(this, w.prototype)
                    }
                }
                class k extends s {
                    get info() {
                        return "Passed hex is in incorrect format."
                    }
                    constructor(...e) {
                        super(...e), Object.setPrototypeOf(this, k.prototype)
                    }
                }
                class v extends s {
                    constructor(...e) {
                        super(...e), Object.setPrototypeOf(this, v.prototype)
                    }
                }
                const S = {
                    [r.CONNECT_EVENT_ERROR_CODES.UNKNOWN_ERROR]: v,
                    [r.CONNECT_EVENT_ERROR_CODES.USER_REJECTS_ERROR]: p,
                    [r.CONNECT_EVENT_ERROR_CODES.BAD_REQUEST_ERROR]: g,
                    [r.CONNECT_EVENT_ERROR_CODES.UNKNOWN_APP_ERROR]: f,
                    [r.CONNECT_EVENT_ERROR_CODES.MANIFEST_NOT_FOUND_ERROR]: u,
                    [r.CONNECT_EVENT_ERROR_CODES.MANIFEST_CONTENT_ERROR]: c
                };
                class C {
                    parseError(e) {
                        let t = v;
                        return e.code in S && (t = S[e.code] || v), new t(e.message)
                    }
                }
                const I = new C;
                class A {
                    isError(e) {
                        return "error" in e
                    }
                }
                const O = {
                    [r.SEND_TRANSACTION_ERROR_CODES.UNKNOWN_ERROR]: v,
                    [r.SEND_TRANSACTION_ERROR_CODES.USER_REJECTS_ERROR]: p,
                    [r.SEND_TRANSACTION_ERROR_CODES.BAD_REQUEST_ERROR]: g,
                    [r.SEND_TRANSACTION_ERROR_CODES.UNKNOWN_APP_ERROR]: f
                };
                class x extends A {
                    convertToRpcRequest(e) {
                        return {
                            method: "sendTransaction",
                            params: [JSON.stringify(e)]
                        }
                    }
                    parseAndThrowError(e) {
                        let t = v;
                        throw e.error.code in O && (t = O[e.error.code] || v), new t(e.error.message)
                    }
                    convertFromRpcResponse(e) {
                        return {
                            boc: e.result
                        }
                    }
                }
                const _ = new x;
                class E {
                    constructor(e, t) {
                        this.storage = e, this.storeKey = "ton-connect-storage_http-bridge-gateway::" + t
                    }
                    storeLastEventId(e) {
                        return i(this, void 0, void 0, (function*() {
                            return this.storage.setItem(this.storeKey, e)
                        }))
                    }
                    removeLastEventId() {
                        return i(this, void 0, void 0, (function*() {
                            return this.storage.removeItem(this.storeKey)
                        }))
                    }
                    getLastEventId() {
                        return i(this, void 0, void 0, (function*() {
                            const e = yield this.storage.getItem(this.storeKey);
                            return e || null
                        }))
                    }
                }

                function T(e) {
                    return "/" === e.slice(-1) ? e.slice(0, -1) : e
                }

                function P(e, t) {
                    return T(e) + "/" + t
                }

                function R(e) {
                    if (!e) return !1;
                    const t = new URL(e);
                    return "tg:" === t.protocol || "t.me" === t.hostname
                }

                function j(e) {
                    return e.replaceAll(".", "%2E").replaceAll("-", "%2D").replaceAll("_", "%5F").replaceAll("&", "-").replaceAll("=", "__").replaceAll("%", "--")
                }

                function B(e, t) {
                    return i(this, void 0, void 0, (function*() {
                        return new Promise((n, r) => {
                            var o, i;
                            if (null === (o = null === t || void 0 === t ? void 0 : t.signal) || void 0 === o ? void 0 : o.aborted) return void r(new s("Delay aborted"));
                            const a = setTimeout(() => n(), e);
                            null === (i = null === t || void 0 === t ? void 0 : t.signal) || void 0 === i || i.addEventListener("abort", () => {
                                clearTimeout(a), r(new s("Delay aborted"))
                            })
                        })
                    }))
                }

                function L(e) {
                    const t = new AbortController;
                    return (null === e || void 0 === e ? void 0 : e.aborted) ? t.abort() : null === e || void 0 === e || e.addEventListener("abort", () => t.abort(), {
                        once: !0
                    }), t
                }

                function W(e, t) {
                    var n, r;
                    return i(this, void 0, void 0, (function*() {
                        const o = null !== (n = null === t || void 0 === t ? void 0 : t.attempts) && void 0 !== n ? n : 10,
                            i = null !== (r = null === t || void 0 === t ? void 0 : t.delayMs) && void 0 !== r ? r : 200,
                            a = L(null === t || void 0 === t ? void 0 : t.signal);
                        if ("function" !== typeof e) throw new s("Expected a function, got " + typeof e);
                        let c, u = 0;
                        while (u < o) {
                            if (a.signal.aborted) throw new s("Aborted after attempts " + u);
                            try {
                                return yield e({
                                    signal: a.signal
                                })
                            } catch (l) {
                                c = l, u++, u < o && (yield B(i))
                            }
                        }
                        throw c
                    }))
                }

                function N(...e) {
                    try {
                        console.debug("[TON_CONNECT_SDK]", ...e)
                    } catch (t) {}
                }

                function M(...e) {
                    try {
                        console.error("[TON_CONNECT_SDK]", ...e)
                    } catch (t) {}
                }

                function K(...e) {
                    try {
                        console.warn("[TON_CONNECT_SDK]", ...e)
                    } catch (t) {}
                }

                function U(e, t) {
                    let n = null,
                        r = null,
                        o = null,
                        a = null,
                        c = null;
                    const u = (u, ...l) => i(this, void 0, void 0, (function*() {
                            if (a = null !== u && void 0 !== u ? u : null, null === c || void 0 === c || c.abort(), c = L(u), c.signal.aborted) throw new s("Resource creation was aborted");
                            r = null !== l && void 0 !== l ? l : null;
                            const i = e(c.signal, ...l);
                            o = i;
                            const d = yield i;
                            if (o !== i && d !== n) throw yield t(d), new s("Resource creation was aborted by a new resource creation");
                            return n = d, n
                        })),
                        l = () => null !== n && void 0 !== n ? n : null,
                        d = () => i(this, void 0, void 0, (function*() {
                            try {
                                const r = n;
                                n = null;
                                const i = o;
                                o = null;
                                try {
                                    null === c || void 0 === c || c.abort()
                                } catch (e) {}
                                yield Promise.allSettled([r ? t(r) : Promise.resolve(), i ? t(yield i) : Promise.resolve()])
                            } catch (e) {}
                        })),
                        h = e => i(this, void 0, void 0, (function*() {
                            const t = n,
                                i = o,
                                c = r,
                                l = a;
                            if (yield B(e), t === n && i === o && c === r && l === a) return yield u(a, ...null !== c && void 0 !== c ? c : []);
                            throw new s("Resource recreation was aborted by a new resource creation")
                        }));
                    return {
                        create: u,
                        current: l,
                        dispose: d,
                        recreate: h
                    }
                }

                function z(e, t) {
                    const n = null === t || void 0 === t ? void 0 : t.timeout,
                        r = null === t || void 0 === t ? void 0 : t.signal,
                        o = L(r);
                    return new Promise((t, r) => {
                        if (o.signal.aborted) return void r(new s("Operation aborted"));
                        let i;
                        "undefined" !== typeof n && (i = setTimeout(() => {
                            o.abort(), r(new s(`Timeout after ${n}ms`))
                        }, n)), o.signal.addEventListener("abort", () => {
                            clearTimeout(i), r(new s("Operation aborted"))
                        }, {
                            once: !0
                        });
                        const a = {
                            timeout: n,
                            abort: o.signal
                        };
                        e(t, r, a).finally(() => clearTimeout(i))
                    })
                }
                class D {
                    constructor(e, t, n, r, o) {
                        this.bridgeUrl = t, this.sessionId = n, this.listener = r, this.errorsListener = o, this.ssePath = "events", this.postPath = "message", this.heartbeatMessage = "heartbeat", this.defaultTtl = 300, this.defaultReconnectDelay = 5e3, this.eventSource = U((e, t) => i(this, void 0, void 0, (function*() {
                            const n = {
                                bridgeUrl: this.bridgeUrl,
                                ssePath: this.ssePath,
                                sessionId: this.sessionId,
                                bridgeGatewayStorage: this.bridgeGatewayStorage,
                                errorHandler: this.errorsHandler.bind(this),
                                messageHandler: this.messagesHandler.bind(this),
                                signal: e,
                                openingDeadlineMS: t
                            };
                            return yield H(n)
                        })), e => i(this, void 0, void 0, (function*() {
                            e.close()
                        }))), this.bridgeGatewayStorage = new E(e, t)
                    }
                    get isReady() {
                        const e = this.eventSource.current();
                        return (null === e || void 0 === e ? void 0 : e.readyState) === EventSource.OPEN
                    }
                    get isClosed() {
                        const e = this.eventSource.current();
                        return (null === e || void 0 === e ? void 0 : e.readyState) !== EventSource.OPEN
                    }
                    get isConnecting() {
                        const e = this.eventSource.current();
                        return (null === e || void 0 === e ? void 0 : e.readyState) === EventSource.CONNECTING
                    }
                    registerSession(e) {
                        return i(this, void 0, void 0, (function*() {
                            yield this.eventSource.create(null === e || void 0 === e ? void 0 : e.signal, null === e || void 0 === e ? void 0 : e.openingDeadlineMS)
                        }))
                    }
                    send(e, t, n, o) {
                        var a;
                        return i(this, void 0, void 0, (function*() {
                            const c = {};
                            "number" === typeof o ? c.ttl = o : (c.ttl = null === o || void 0 === o ? void 0 : o.ttl, c.signal = null === o || void 0 === o ? void 0 : o.signal, c.attempts = null === o || void 0 === o ? void 0 : o.attempts);
                            const u = new URL(P(this.bridgeUrl, this.postPath));
                            u.searchParams.append("client_id", this.sessionId), u.searchParams.append("to", t), u.searchParams.append("ttl", ((null === c || void 0 === c ? void 0 : c.ttl) || this.defaultTtl).toString()), u.searchParams.append("topic", n);
                            const l = r.Base64.encode(e);
                            yield W(e => i(this, void 0, void 0, (function*() {
                                const t = yield this.post(u, l, e.signal);
                                if (!t.ok) throw new s("Bridge send failed, status " + t.status)
                            })), {
                                attempts: null !== (a = null === c || void 0 === c ? void 0 : c.attempts) && void 0 !== a ? a : Number.MAX_SAFE_INTEGER,
                                delayMs: 5e3,
                                signal: null === c || void 0 === c ? void 0 : c.signal
                            })
                        }))
                    }
                    pause() {
                        this.eventSource.dispose().catch(e => M("Bridge pause failed, " + e))
                    }
                    unPause() {
                        return i(this, void 0, void 0, (function*() {
                            const e = 0;
                            yield this.eventSource.recreate(e)
                        }))
                    }
                    close() {
                        return i(this, void 0, void 0, (function*() {
                            yield this.eventSource.dispose().catch(e => M("Bridge close failed, " + e))
                        }))
                    }
                    setListener(e) {
                        this.listener = e
                    }
                    setErrorsListener(e) {
                        this.errorsListener = e
                    }
                    post(e, t, n) {
                        return i(this, void 0, void 0, (function*() {
                            const r = yield fetch(e, {
                                method: "post",
                                body: t,
                                signal: n
                            });
                            if (!r.ok) throw new s("Bridge send failed, status " + r.status);
                            return r
                        }))
                    }
                    errorsHandler(e, t) {
                        return i(this, void 0, void 0, (function*() {
                            if (this.isConnecting) M("Bridge error", JSON.stringify(t));
                            else {
                                if (!this.isReady) {
                                    if (this.isClosed) return e.close(), N(`Bridge reconnecting, ${this.defaultReconnectDelay}ms delay`), yield this.eventSource.recreate(this.defaultReconnectDelay);
                                    throw new s("Bridge error, unknown state")
                                }
                                try {
                                    this.errorsListener(t)
                                } catch (t) {}
                            }
                        }))
                    }
                    messagesHandler(e) {
                        return i(this, void 0, void 0, (function*() {
                            if (e.data === this.heartbeatMessage) return;
                            if (yield this.bridgeGatewayStorage.storeLastEventId(e.lastEventId), this.isClosed) return;
                            let t;
                            try {
                                t = JSON.parse(e.data)
                            } catch (e) {
                                throw new s("Bridge message parse failed, message " + e.data)
                            }
                            this.listener(t)
                        }))
                    }
                }

                function H(e) {
                    return i(this, void 0, void 0, (function*() {
                        return yield z((t, n, r) => i(this, void 0, void 0, (function*() {
                            var o;
                            const a = L(r.signal),
                                c = a.signal;
                            if (c.aborted) return void n(new s("Bridge connection aborted"));
                            const u = new URL(P(e.bridgeUrl, e.ssePath));
                            u.searchParams.append("client_id", e.sessionId);
                            const l = yield e.bridgeGatewayStorage.getLastEventId();
                            if (l && u.searchParams.append("last_event_id", l), c.aborted) return void n(new s("Bridge connection aborted"));
                            const d = new EventSource(u.toString());
                            d.onerror = r => i(this, void 0, void 0, (function*() {
                                if (c.aborted) return d.close(), void n(new s("Bridge connection aborted"));
                                try {
                                    const n = yield e.errorHandler(d, r);
                                    n !== d && d.close(), n && n !== d && t(n)
                                } catch (o) {
                                    d.close(), n(o)
                                }
                            })), d.onopen = () => {
                                if (c.aborted) return d.close(), void n(new s("Bridge connection aborted"));
                                t(d)
                            }, d.onmessage = t => {
                                if (c.aborted) return d.close(), void n(new s("Bridge connection aborted"));
                                e.messageHandler(t)
                            }, null === (o = e.signal) || void 0 === o || o.addEventListener("abort", () => {
                                d.close(), n(new s("Bridge connection aborted"))
                            })
                        })), {
                            timeout: e.openingDeadlineMS,
                            signal: e.signal
                        })
                    }))
                }

                function q(e) {
                    return !("connectEvent" in e)
                }
                class $ {
                    constructor(e) {
                        this.storage = e, this.storeKey = "ton-connect-storage_bridge-connection"
                    }
                    storeConnection(e) {
                        return i(this, void 0, void 0, (function*() {
                            if ("injected" === e.type) return this.storage.setItem(this.storeKey, JSON.stringify(e));
                            if (!q(e)) {
                                const t = {
                                        sessionKeyPair: e.session.sessionCrypto.stringifyKeypair(),
                                        walletPublicKey: e.session.walletPublicKey,
                                        bridgeUrl: e.session.bridgeUrl
                                    },
                                    n = {
                                        type: "http",
                                        connectEvent: e.connectEvent,
                                        session: t,
                                        lastWalletEventId: e.lastWalletEventId,
                                        nextRpcRequestId: e.nextRpcRequestId
                                    };
                                return this.storage.setItem(this.storeKey, JSON.stringify(n))
                            }
                            const t = {
                                type: "http",
                                connectionSource: e.connectionSource,
                                sessionCrypto: e.sessionCrypto.stringifyKeypair()
                            };
                            return this.storage.setItem(this.storeKey, JSON.stringify(t))
                        }))
                    }
                    removeConnection() {
                        return i(this, void 0, void 0, (function*() {
                            return this.storage.removeItem(this.storeKey)
                        }))
                    }
                    getConnection() {
                        return i(this, void 0, void 0, (function*() {
                            const e = yield this.storage.getItem(this.storeKey);
                            if (!e) return null;
                            const t = JSON.parse(e);
                            if ("injected" === t.type) return t;
                            if ("connectEvent" in t) {
                                const e = new r.SessionCrypto(t.session.sessionKeyPair);
                                return {
                                    type: "http",
                                    connectEvent: t.connectEvent,
                                    lastWalletEventId: t.lastWalletEventId,
                                    nextRpcRequestId: t.nextRpcRequestId,
                                    session: {
                                        sessionCrypto: e,
                                        bridgeUrl: t.session.bridgeUrl,
                                        walletPublicKey: t.session.walletPublicKey
                                    }
                                }
                            }
                            return {
                                type: "http",
                                sessionCrypto: new r.SessionCrypto(t.sessionCrypto),
                                connectionSource: t.connectionSource
                            }
                        }))
                    }
                    getHttpConnection() {
                        return i(this, void 0, void 0, (function*() {
                            const e = yield this.getConnection();
                            if (!e) throw new s("Trying to read HTTP connection source while nothing is stored");
                            if ("injected" === e.type) throw new s("Trying to read HTTP connection source while injected connection is stored");
                            return e
                        }))
                    }
                    getHttpPendingConnection() {
                        return i(this, void 0, void 0, (function*() {
                            const e = yield this.getConnection();
                            if (!e) throw new s("Trying to read HTTP connection source while nothing is stored");
                            if ("injected" === e.type) throw new s("Trying to read HTTP connection source while injected connection is stored");
                            if (!q(e)) throw new s("Trying to read HTTP-pending connection while http connection is stored");
                            return e
                        }))
                    }
                    getInjectedConnection() {
                        return i(this, void 0, void 0, (function*() {
                            const e = yield this.getConnection();
                            if (!e) throw new s("Trying to read Injected bridge connection source while nothing is stored");
                            if ("http" === (null === e || void 0 === e ? void 0 : e.type)) throw new s("Trying to read Injected bridge connection source while HTTP connection is stored");
                            return e
                        }))
                    }
                    storedConnectionType() {
                        return i(this, void 0, void 0, (function*() {
                            const e = yield this.storage.getItem(this.storeKey);
                            if (!e) return null;
                            const t = JSON.parse(e);
                            return t.type
                        }))
                    }
                    storeLastWalletEventId(e) {
                        return i(this, void 0, void 0, (function*() {
                            const t = yield this.getConnection();
                            if (t && "http" === t.type && !q(t)) return t.lastWalletEventId = e, this.storeConnection(t)
                        }))
                    }
                    getLastWalletEventId() {
                        return i(this, void 0, void 0, (function*() {
                            const e = yield this.getConnection();
                            if (e && "lastWalletEventId" in e) return e.lastWalletEventId
                        }))
                    }
                    increaseNextRpcRequestId() {
                        return i(this, void 0, void 0, (function*() {
                            const e = yield this.getConnection();
                            if (e && "nextRpcRequestId" in e) {
                                const t = e.nextRpcRequestId || 0;
                                return e.nextRpcRequestId = t + 1, this.storeConnection(e)
                            }
                        }))
                    }
                    getNextRpcRequestId() {
                        return i(this, void 0, void 0, (function*() {
                            const e = yield this.getConnection();
                            return e && "nextRpcRequestId" in e && e.nextRpcRequestId || 0
                        }))
                    }
                }
                const V = 2;
                class F {
                    constructor(e, t) {
                        this.storage = e, this.walletConnectionSource = t, this.type = "http", this.standardUniversalLink = "tc://", this.pendingRequests = new Map, this.session = null, this.gateway = null, this.pendingGateways = [], this.listeners = [], this.defaultOpeningDeadlineMS = 5e3, this.connectionStorage = new $(e)
                    }
                    static fromStorage(e) {
                        return i(this, void 0, void 0, (function*() {
                            const t = new $(e),
                                n = yield t.getHttpConnection();
                            return q(n) ? new F(e, n.connectionSource) : new F(e, {
                                bridgeUrl: n.session.bridgeUrl
                            })
                        }))
                    }
                    connect(e, t) {
                        var n;
                        const o = L(null === t || void 0 === t ? void 0 : t.signal);
                        null === (n = this.abortController) || void 0 === n || n.abort(), this.abortController = o, this.closeGateways();
                        const s = new r.SessionCrypto;
                        this.session = {
                            sessionCrypto: s,
                            bridgeUrl: "bridgeUrl" in this.walletConnectionSource ? this.walletConnectionSource.bridgeUrl : ""
                        }, this.connectionStorage.storeConnection({
                            type: "http",
                            connectionSource: this.walletConnectionSource,
                            sessionCrypto: s
                        }).then(() => i(this, void 0, void 0, (function*() {
                            o.signal.aborted || (yield W(e => this.openGateways(s, {
                                openingDeadlineMS: null === t || void 0 === t ? void 0 : t.openingDeadlineMS,
                                signal: null === e || void 0 === e ? void 0 : e.signal
                            }), {
                                attempts: Number.MAX_SAFE_INTEGER,
                                delayMs: 5e3,
                                signal: o.signal
                            }))
                        })));
                        const a = "universalLink" in this.walletConnectionSource && this.walletConnectionSource.universalLink ? this.walletConnectionSource.universalLink : this.standardUniversalLink;
                        return this.generateUniversalLink(a, e)
                    }
                    restoreConnection(e) {
                        var t, n;
                        return i(this, void 0, void 0, (function*() {
                            const r = L(null === e || void 0 === e ? void 0 : e.signal);
                            if (null === (t = this.abortController) || void 0 === t || t.abort(), this.abortController = r, r.signal.aborted) return;
                            this.closeGateways();
                            const o = yield this.connectionStorage.getHttpConnection();
                            if (!o) return;
                            if (r.signal.aborted) return;
                            const i = null !== (n = null === e || void 0 === e ? void 0 : e.openingDeadlineMS) && void 0 !== n ? n : this.defaultOpeningDeadlineMS;
                            if (q(o)) return this.session = {
                                sessionCrypto: o.sessionCrypto,
                                bridgeUrl: "bridgeUrl" in this.walletConnectionSource ? this.walletConnectionSource.bridgeUrl : ""
                            }, yield this.openGateways(o.sessionCrypto, {
                                openingDeadlineMS: i,
                                signal: null === r || void 0 === r ? void 0 : r.signal
                            });
                            if (Array.isArray(this.walletConnectionSource)) throw new s("Internal error. Connection source is array while WalletConnectionSourceHTTP was expected.");
                            if (this.session = o.session, this.gateway && (N("Gateway is already opened, closing previous gateway"), yield this.gateway.close()), this.gateway = new D(this.storage, this.walletConnectionSource.bridgeUrl, o.session.sessionCrypto.sessionId, this.gatewayListener.bind(this), this.gatewayErrorsListener.bind(this)), !r.signal.aborted) {
                                this.listeners.forEach(e => e(o.connectEvent));
                                try {
                                    yield W(e => this.gateway.registerSession({
                                        openingDeadlineMS: i,
                                        signal: e.signal
                                    }), {
                                        attempts: Number.MAX_SAFE_INTEGER,
                                        delayMs: 5e3,
                                        signal: r.signal
                                    })
                                } catch (a) {
                                    return void(yield this.disconnect({
                                        signal: r.signal
                                    }))
                                }
                            }
                        }))
                    }
                    sendRequest(e, t) {
                        const n = {};
                        return "function" === typeof t ? n.onRequestSent = t : (n.onRequestSent = null === t || void 0 === t ? void 0 : t.onRequestSent, n.signal = null === t || void 0 === t ? void 0 : t.signal, n.attempts = null === t || void 0 === t ? void 0 : t.attempts), new Promise((t, o) => i(this, void 0, void 0, (function*() {
                            var i;
                            if (!this.gateway || !this.session || !("walletPublicKey" in this.session)) throw new s("Trying to send bridge request without session");
                            const a = (yield this.connectionStorage.getNextRpcRequestId()).toString();
                            yield this.connectionStorage.increaseNextRpcRequestId(), N("Send http-bridge request:", Object.assign(Object.assign({}, e), {
                                id: a
                            }));
                            const c = this.session.sessionCrypto.encrypt(JSON.stringify(Object.assign(Object.assign({}, e), {
                                id: a
                            })), r.hexToByteArray(this.session.walletPublicKey));
                            try {
                                yield this.gateway.send(c, this.session.walletPublicKey, e.method, {
                                    attempts: null === n || void 0 === n ? void 0 : n.attempts,
                                    signal: null === n || void 0 === n ? void 0 : n.signal
                                }), null === (i = null === n || void 0 === n ? void 0 : n.onRequestSent) || void 0 === i || i.call(n), this.pendingRequests.set(a.toString(), t)
                            } catch (u) {
                                o(u)
                            }
                        })))
                    }
                    closeConnection() {
                        this.closeGateways(), this.listeners = [], this.session = null, this.gateway = null
                    }
                    disconnect(e) {
                        return i(this, void 0, void 0, (function*() {
                            return new Promise(t => i(this, void 0, void 0, (function*() {
                                let n = !1,
                                    r = null;
                                const o = () => {
                                    n || (n = !0, this.removeBridgeAndSession().then(t))
                                };
                                try {
                                    this.closeGateways();
                                    const t = L(null === e || void 0 === e ? void 0 : e.signal);
                                    r = setTimeout(() => {
                                        t.abort()
                                    }, this.defaultOpeningDeadlineMS), yield this.sendRequest({
                                        method: "disconnect",
                                        params: []
                                    }, {
                                        onRequestSent: o,
                                        signal: t.signal,
                                        attempts: 1
                                    })
                                } catch (i) {
                                    N("Disconnect error:", i), n || this.removeBridgeAndSession().then(t)
                                } finally {
                                    r && clearTimeout(r), o()
                                }
                            })))
                        }))
                    }
                    listen(e) {
                        return this.listeners.push(e), () => this.listeners = this.listeners.filter(t => t !== e)
                    }
                    pause() {
                        var e;
                        null === (e = this.gateway) || void 0 === e || e.pause(), this.pendingGateways.forEach(e => e.pause())
                    }
                    unPause() {
                        return i(this, void 0, void 0, (function*() {
                            const e = this.pendingGateways.map(e => e.unPause());
                            this.gateway && e.push(this.gateway.unPause()), yield Promise.all(e)
                        }))
                    }
                    pendingGatewaysListener(e, t, n) {
                        return i(this, void 0, void 0, (function*() {
                            if (this.pendingGateways.includes(e)) return this.closeGateways({
                                except: e
                            }), this.gateway && (N("Gateway is already opened, closing previous gateway"), yield this.gateway.close()), this.session.bridgeUrl = t, this.gateway = e, this.gateway.setErrorsListener(this.gatewayErrorsListener.bind(this)), this.gateway.setListener(this.gatewayListener.bind(this)), this.gatewayListener(n);
                            yield e.close()
                        }))
                    }
                    gatewayListener(e) {
                        return i(this, void 0, void 0, (function*() {
                            const t = JSON.parse(this.session.sessionCrypto.decrypt(r.Base64.decode(e.message).toUint8Array(), r.hexToByteArray(e.from)));
                            if (N("Wallet message received:", t), !("event" in t)) {
                                const e = t.id.toString(),
                                    n = this.pendingRequests.get(e);
                                return n ? (n(t), void this.pendingRequests.delete(e)) : void N(`Response id ${e} doesn't match any request's id`)
                            }
                            if (void 0 !== t.id) {
                                const e = yield this.connectionStorage.getLastWalletEventId();
                                if (void 0 !== e && t.id <= e) return void M(`Received event id (=${t.id}) must be greater than stored last wallet event id (=${e}) `);
                                "connect" !== t.event && (yield this.connectionStorage.storeLastWalletEventId(t.id))
                            }
                            const n = this.listeners;
                            "connect" === t.event && (yield this.updateSession(t, e.from)), "disconnect" === t.event && (N("Removing bridge and session: received disconnect event"), yield this.removeBridgeAndSession()), n.forEach(e => e(t))
                        }))
                    }
                    gatewayErrorsListener(e) {
                        return i(this, void 0, void 0, (function*() {
                            throw new s("Bridge error " + JSON.stringify(e))
                        }))
                    }
                    updateSession(e, t) {
                        return i(this, void 0, void 0, (function*() {
                            this.session = Object.assign(Object.assign({}, this.session), {
                                walletPublicKey: t
                            });
                            const n = e.payload.items.find(e => "ton_addr" === e.name),
                                r = Object.assign(Object.assign({}, e), {
                                    payload: Object.assign(Object.assign({}, e.payload), {
                                        items: [n]
                                    })
                                });
                            yield this.connectionStorage.storeConnection({
                                type: "http",
                                session: this.session,
                                lastWalletEventId: e.id,
                                connectEvent: r,
                                nextRpcRequestId: 0
                            })
                        }))
                    }
                    removeBridgeAndSession() {
                        return i(this, void 0, void 0, (function*() {
                            this.closeConnection(), yield this.connectionStorage.removeConnection()
                        }))
                    }
                    generateUniversalLink(e, t) {
                        return R(e) ? this.generateTGUniversalLink(e, t) : this.generateRegularUniversalLink(e, t)
                    }
                    generateRegularUniversalLink(e, t) {
                        const n = new URL(e);
                        return n.searchParams.append("v", V.toString()), n.searchParams.append("id", this.session.sessionCrypto.sessionId), n.searchParams.append("r", JSON.stringify(t)), n.toString()
                    }
                    generateTGUniversalLink(e, t) {
                        const n = this.generateRegularUniversalLink("about:blank", t),
                            r = n.split("?")[1],
                            o = "tonconnect-" + j(r),
                            i = this.convertToDirectLink(e),
                            s = new URL(i);
                        return s.searchParams.append("startapp", o), s.toString()
                    }
                    convertToDirectLink(e) {
                        const t = new URL(e);
                        return t.searchParams.has("attach") && (t.searchParams.delete("attach"), t.pathname += "/start"), t.toString()
                    }
                    openGateways(e, t) {
                        return i(this, void 0, void 0, (function*() {
                            return Array.isArray(this.walletConnectionSource) ? (this.pendingGateways.map(e => e.close().catch()), this.pendingGateways = this.walletConnectionSource.map(t => {
                                const n = new D(this.storage, t.bridgeUrl, e.sessionId, () => {}, () => {});
                                return n.setListener(e => this.pendingGatewaysListener(n, t.bridgeUrl, e)), n
                            }), void(yield Promise.allSettled(this.pendingGateways.map(e => W(n => this.pendingGateways.some(t => t === e) ? e.registerSession({
                                openingDeadlineMS: null === t || void 0 === t ? void 0 : t.openingDeadlineMS,
                                signal: n.signal
                            }) : e.close(), {
                                attempts: Number.MAX_SAFE_INTEGER,
                                delayMs: 5e3,
                                signal: null === t || void 0 === t ? void 0 : t.signal
                            }))))) : (this.gateway && (N("Gateway is already opened, closing previous gateway"), yield this.gateway.close()), this.gateway = new D(this.storage, this.walletConnectionSource.bridgeUrl, e.sessionId, this.gatewayListener.bind(this), this.gatewayErrorsListener.bind(this)), yield this.gateway.registerSession({
                                openingDeadlineMS: null === t || void 0 === t ? void 0 : t.openingDeadlineMS,
                                signal: null === t || void 0 === t ? void 0 : t.signal
                            }))
                        }))
                    }
                    closeGateways(e) {
                        var t;
                        null === (t = this.gateway) || void 0 === t || t.close(), this.pendingGateways.filter(t => t !== (null === e || void 0 === e ? void 0 : e.except)).forEach(e => e.close()), this.pendingGateways = []
                    }
                }

                function G(e, t) {
                    return Y(e, [t])
                }

                function Y(e, t) {
                    return !(!e || "object" !== typeof e) && t.every(t => t in e)
                }

                function J(e) {
                    try {
                        return !(!G(e, "tonconnect") || !G(e.tonconnect, "walletInfo")) && Y(e.tonconnect.walletInfo, ["name", "app_name", "image", "about_url", "platforms"])
                    } catch (t) {
                        return !1
                    }
                }
                class Z {
                    constructor() {
                        this.storage = {}
                    }
                    static getInstance() {
                        return Z.instance || (Z.instance = new Z), Z.instance
                    }
                    get length() {
                        return Object.keys(this.storage).length
                    }
                    clear() {
                        this.storage = {}
                    }
                    getItem(e) {
                        var t;
                        return null !== (t = this.storage[e]) && void 0 !== t ? t : null
                    }
                    key(e) {
                        var t;
                        const n = Object.keys(this.storage);
                        return e < 0 || e >= n.length ? null : null !== (t = n[e]) && void 0 !== t ? t : null
                    }
                    removeItem(e) {
                        delete this.storage[e]
                    }
                    setItem(e, t) {
                        this.storage[e] = t
                    }
                }

                function X() {
                    if ("undefined" !== typeof window) return window
                }

                function Q() {
                    const e = X();
                    if (!e) return [];
                    try {
                        return Object.keys(e)
                    } catch (t) {
                        return []
                    }
                }

                function ee() {
                    if ("undefined" !== typeof document) return document
                }

                function te() {
                    var e;
                    const t = null === (e = X()) || void 0 === e ? void 0 : e.location.origin;
                    return t ? t + "/tonconnect-manifest.json" : ""
                }

                function ne() {
                    if (re()) return localStorage;
                    if (oe()) throw new s("`localStorage` is unavailable, but it is required for TonConnect. For more details, see https://github.com/ton-connect/sdk/tree/main/packages/sdk#init-connector");
                    return Z.getInstance()
                }

                function re() {
                    try {
                        return "undefined" !== typeof localStorage
                    } catch (e) {
                        return !1
                    }
                }

                function oe() {
                    return "undefined" !== typeof e && null != e.versions && null != e.versions.node
                }
                class ie {
                    constructor(e, t) {
                        this.injectedWalletKey = t, this.type = "injected", this.unsubscribeCallback = null, this.listenSubscriptions = !1, this.listeners = [];
                        const n = ie.window;
                        if (!ie.isWindowContainsWallet(n, t)) throw new b;
                        this.connectionStorage = new $(e), this.injectedWallet = n[t].tonconnect
                    }
                    static fromStorage(e) {
                        return i(this, void 0, void 0, (function*() {
                            const t = new $(e),
                                n = yield t.getInjectedConnection();
                            return new ie(e, n.jsBridgeKey)
                        }))
                    }
                    static isWalletInjected(e) {
                        return ie.isWindowContainsWallet(this.window, e)
                    }
                    static isInsideWalletBrowser(e) {
                        return !!ie.isWindowContainsWallet(this.window, e) && this.window[e].tonconnect.isWalletBrowser
                    }
                    static getCurrentlyInjectedWallets() {
                        if (!this.window) return [];
                        const e = Q(),
                            t = e.filter(([e, t]) => J(t));
                        return t.map(([e, t]) => ({
                            name: t.tonconnect.walletInfo.name,
                            appName: t.tonconnect.walletInfo.app_name,
                            aboutUrl: t.tonconnect.walletInfo.about_url,
                            imageUrl: t.tonconnect.walletInfo.image,
                            tondns: t.tonconnect.walletInfo.tondns,
                            jsBridgeKey: e,
                            injected: !0,
                            embedded: t.tonconnect.isWalletBrowser,
                            platforms: t.tonconnect.walletInfo.platforms
                        }))
                    }
                    static isWindowContainsWallet(e, t) {
                        return !!e && t in e && "object" === typeof e[t] && "tonconnect" in e[t]
                    }
                    connect(e) {
                        this._connect(V, e)
                    }
                    restoreConnection() {
                        return i(this, void 0, void 0, (function*() {
                            try {
                                N("Injected Provider restoring connection...");
                                const e = yield this.injectedWallet.restoreConnection();
                                N("Injected Provider restoring connection response", e), "connect" === e.event ? (this.makeSubscriptions(), this.listeners.forEach(t => t(e))) : yield this.connectionStorage.removeConnection()
                            } catch (e) {
                                yield this.connectionStorage.removeConnection(), console.error(e)
                            }
                        }))
                    }
                    closeConnection() {
                        this.listenSubscriptions && this.injectedWallet.disconnect(), this.closeAllListeners()
                    }
                    disconnect() {
                        return i(this, void 0, void 0, (function*() {
                            return new Promise(e => {
                                const t = () => {
                                    this.closeAllListeners(), this.connectionStorage.removeConnection().then(e)
                                };
                                try {
                                    this.injectedWallet.disconnect(), t()
                                } catch (n) {
                                    N(n), this.sendRequest({
                                        method: "disconnect",
                                        params: []
                                    }, t)
                                }
                            })
                        }))
                    }
                    closeAllListeners() {
                        var e;
                        this.listenSubscriptions = !1, this.listeners = [], null === (e = this.unsubscribeCallback) || void 0 === e || e.call(this)
                    }
                    listen(e) {
                        return this.listeners.push(e), () => this.listeners = this.listeners.filter(t => t !== e)
                    }
                    sendRequest(e, t) {
                        var n;
                        return i(this, void 0, void 0, (function*() {
                            const r = {};
                            "function" === typeof t ? r.onRequestSent = t : (r.onRequestSent = null === t || void 0 === t ? void 0 : t.onRequestSent, r.signal = null === t || void 0 === t ? void 0 : t.signal);
                            const o = (yield this.connectionStorage.getNextRpcRequestId()).toString();
                            yield this.connectionStorage.increaseNextRpcRequestId(), N("Send injected-bridge request:", Object.assign(Object.assign({}, e), {
                                id: o
                            }));
                            const i = this.injectedWallet.send(Object.assign(Object.assign({}, e), {
                                id: o
                            }));
                            return i.then(e => N("Wallet message received:", e)), null === (n = null === r || void 0 === r ? void 0 : r.onRequestSent) || void 0 === n || n.call(r), i
                        }))
                    }
                    _connect(e, t) {
                        return i(this, void 0, void 0, (function*() {
                            try {
                                N(`Injected Provider connect request: protocolVersion: ${e}, message:`, t);
                                const n = yield this.injectedWallet.connect(e, t);
                                N("Injected Provider connect response:", n), "connect" === n.event && (yield this.updateSession(), this.makeSubscriptions()), this.listeners.forEach(e => e(n))
                            } catch (n) {
                                N("Injected Provider connect error:", n);
                                const e = {
                                    event: "connect_error",
                                    payload: {
                                        code: 0,
                                        message: null === n || void 0 === n ? void 0 : n.toString()
                                    }
                                };
                                this.listeners.forEach(t => t(e))
                            }
                        }))
                    }
                    makeSubscriptions() {
                        this.listenSubscriptions = !0, this.unsubscribeCallback = this.injectedWallet.listen(e => {
                            N("Wallet message received:", e), this.listenSubscriptions && this.listeners.forEach(t => t(e)), "disconnect" === e.event && this.disconnect()
                        })
                    }
                    updateSession() {
                        return this.connectionStorage.storeConnection({
                            type: "injected",
                            jsBridgeKey: this.injectedWalletKey,
                            nextRpcRequestId: 0
                        })
                    }
                }
                ie.window = X();
                class se {
                    constructor() {
                        this.localStorage = ne()
                    }
                    getItem(e) {
                        return i(this, void 0, void 0, (function*() {
                            return this.localStorage.getItem(e)
                        }))
                    }
                    removeItem(e) {
                        return i(this, void 0, void 0, (function*() {
                            this.localStorage.removeItem(e)
                        }))
                    }
                    setItem(e, t) {
                        return i(this, void 0, void 0, (function*() {
                            this.localStorage.setItem(e, t)
                        }))
                    }
                }

                function ae(e) {
                    return ue(e) && e.injected
                }

                function ce(e) {
                    return ae(e) && e.embedded
                }

                function ue(e) {
                    return "jsBridgeKey" in e
                }

                function le(e) {
                    return "bridgeUrl" in e
                }

                function de(e) {
                    return "jsBridgeKey" in e
                }
                const he = [{
                    app_name: "telegram-wallet",
                    name: "Wallet",
                    image: "https://wallet.tg/images/logo-288.png",
                    about_url: "https://wallet.tg/",
                    universal_url: "https://t.me/wallet?attach=wallet",
                    bridge: [{
                        type: "sse",
                        url: "https://bridge.tonapi.io/bridge"
                    }],
                    platforms: ["ios", "android", "macos", "windows", "linux"]
                }, {
                    app_name: "tonkeeper",
                    name: "Tonkeeper",
                    image: "https://tonkeeper.com/assets/tonconnect-icon.png",
                    tondns: "tonkeeper.ton",
                    about_url: "https://tonkeeper.com",
                    universal_url: "https://app.tonkeeper.com/ton-connect",
                    deepLink: "tonkeeper-tc://",
                    bridge: [{
                        type: "sse",
                        url: "https://bridge.tonapi.io/bridge"
                    }, {
                        type: "js",
                        key: "tonkeeper"
                    }],
                    platforms: ["ios", "android", "chrome", "firefox", "macos"]
                }, {
                    app_name: "mytonwallet",
                    name: "MyTonWallet",
                    image: "https://mytonwallet.io/icon-256.png",
                    about_url: "https://mytonwallet.io",
                    universal_url: "https://connect.mytonwallet.org",
                    bridge: [{
                        type: "js",
                        key: "mytonwallet"
                    }, {
                        type: "sse",
                        url: "https://tonconnectbridge.mytonwallet.org/bridge/"
                    }],
                    platforms: ["chrome", "windows", "macos", "linux", "ios", "android", "firefox"]
                }, {
                    app_name: "openmask",
                    name: "OpenMask",
                    image: "https://raw.githubusercontent.com/OpenProduct/openmask-extension/main/public/openmask-logo-288.png",
                    about_url: "https://www.openmask.app/",
                    bridge: [{
                        type: "js",
                        key: "openmask"
                    }],
                    platforms: ["chrome"]
                }, {
                    app_name: "tonhub",
                    name: "Tonhub",
                    image: "https://tonhub.com/tonconnect_logo.png",
                    about_url: "https://tonhub.com",
                    universal_url: "https://tonhub.com/ton-connect",
                    bridge: [{
                        type: "js",
                        key: "tonhub"
                    }, {
                        type: "sse",
                        url: "https://connect.tonhubapi.com/tonconnect"
                    }],
                    platforms: ["ios", "android"]
                }, {
                    app_name: "dewallet",
                    name: "DeWallet",
                    image: "https://app.delabwallet.com/logo_black.png",
                    about_url: "https://delabwallet.com",
                    bridge: [{
                        type: "js",
                        key: "dewallet"
                    }],
                    platforms: ["chrome"]
                }, {
                    app_name: "xtonwallet",
                    name: "XTONWallet",
                    image: "https://xtonwallet.com/assets/img/icon-256-back.png",
                    about_url: "https://xtonwallet.com",
                    bridge: [{
                        type: "js",
                        key: "xtonwallet"
                    }],
                    platforms: ["chrome", "firefox"]
                }, {
                    app_name: "tonwallet",
                    name: "TON Wallet",
                    image: "https://wallet.ton.org/assets/ui/qr-logo.png",
                    about_url: "https://chrome.google.com/webstore/detail/ton-wallet/nphplpgoakhhjchkkhmiggakijnkhfnd",
                    bridge: [{
                        type: "js",
                        key: "tonwallet"
                    }],
                    platforms: ["chrome"]
                }];
                class pe {
                    constructor(e) {
                        this.walletsListCache = null, this.walletsListCacheCreationTimestamp = null, this.walletsListSource = "https://raw.githubusercontent.com/ton-blockchain/wallets-list/main/wallets-v2.json", (null === e || void 0 === e ? void 0 : e.walletsListSource) && (this.walletsListSource = e.walletsListSource), (null === e || void 0 === e ? void 0 : e.cacheTTLMs) && (this.cacheTTLMs = e.cacheTTLMs)
                    }
                    getWallets() {
                        return i(this, void 0, void 0, (function*() {
                            return this.cacheTTLMs && this.walletsListCacheCreationTimestamp && Date.now() > this.walletsListCacheCreationTimestamp + this.cacheTTLMs && (this.walletsListCache = null), this.walletsListCache || (this.walletsListCache = this.fetchWalletsList(), this.walletsListCache.then(() => {
                                this.walletsListCacheCreationTimestamp = Date.now()
                            }).catch(() => {
                                this.walletsListCache = null, this.walletsListCacheCreationTimestamp = null
                            })), this.walletsListCache
                        }))
                    }
                    getEmbeddedWallet() {
                        return i(this, void 0, void 0, (function*() {
                            const e = yield this.getWallets(), t = e.filter(ce);
                            return 1 !== t.length ? null : t[0]
                        }))
                    }
                    fetchWalletsList() {
                        return i(this, void 0, void 0, (function*() {
                            let e = [];
                            try {
                                const t = yield fetch(this.walletsListSource);
                                if (e = yield t.json(), !Array.isArray(e)) throw new m("Wrong wallets list format, wallets list must be an array.");
                                const n = e.filter(e => !this.isCorrectWalletConfigDTO(e));
                                n.length && (M(`Wallet(s) ${n.map(e=>e.name).join(", ")} config format is wrong. They were removed from the wallets list.`), e = e.filter(e => this.isCorrectWalletConfigDTO(e)))
                            } catch (n) {
                                M(n), e = he
                            }
                            let t = [];
                            try {
                                t = ie.getCurrentlyInjectedWallets()
                            } catch (n) {
                                M(n)
                            }
                            return this.mergeWalletsLists(this.walletConfigDTOListToWalletConfigList(e), t)
                        }))
                    }
                    walletConfigDTOListToWalletConfigList(e) {
                        return e.map(e => {
                            const t = {
                                    name: e.name,
                                    appName: e.app_name,
                                    imageUrl: e.image,
                                    aboutUrl: e.about_url,
                                    tondns: e.tondns,
                                    platforms: e.platforms
                                },
                                n = t;
                            return e.bridge.forEach(t => {
                                if ("sse" === t.type && (n.bridgeUrl = t.url, n.universalLink = e.universal_url, n.deepLink = e.deepLink), "js" === t.type) {
                                    const e = t.key;
                                    n.jsBridgeKey = e, n.injected = ie.isWalletInjected(e), n.embedded = ie.isInsideWalletBrowser(e)
                                }
                            }), n
                        })
                    }
                    mergeWalletsLists(e, t) {
                        const n = new Set(e.concat(t).map(e => e.name));
                        return [...n.values()].map(n => {
                            const r = e.find(e => e.name === n),
                                o = t.find(e => e.name === n);
                            return Object.assign(Object.assign({}, r && Object.assign({}, r)), o && Object.assign({}, o))
                        })
                    }
                    isCorrectWalletConfigDTO(e) {
                        if (!e || "object" !== typeof e) return !1;
                        const t = "name" in e,
                            n = "app_name" in e,
                            r = "image" in e,
                            o = "about_url" in e,
                            i = "platforms" in e;
                        if (!t || !r || !o || !i || !n) return !1;
                        if (!e.platforms || !Array.isArray(e.platforms) || !e.platforms.length) return !1;
                        if (!("bridge" in e) || !Array.isArray(e.bridge) || !e.bridge.length) return !1;
                        const s = e.bridge;
                        if (s.some(e => !e || "object" !== typeof e || !("type" in e))) return !1;
                        const a = s.find(e => "sse" === e.type);
                        if (a && (!("url" in a) || !a.url || !e.universal_url)) return !1;
                        const c = s.find(e => "js" === e.type);
                        return !!(!c || "key" in c && c.key)
                    }
                }
                class ge extends s {
                    get info() {
                        return "Wallet doesn't support requested feature method."
                    }
                    constructor(...e) {
                        super(...e), Object.setPrototypeOf(this, ge.prototype)
                    }
                }

                function fe(e, t) {
                    const n = e.includes("SendTransaction"),
                        r = e.find(e => e && "object" === typeof e && "SendTransaction" === e.name);
                    if (!n && !r) throw new ge("Wallet doesn't support SendTransaction feature.");
                    if (r && void 0 !== r.maxMessages) {
                        if (r.maxMessages < t.requiredMessagesNumber) throw new ge(`Wallet is not able to handle such SendTransaction request. Max support messages number is ${r.maxMessages}, but ${t.requiredMessagesNumber} is required.`)
                    } else K("Connected wallet didn't provide information about max allowed messages in the SendTransaction request. Request may be rejected by the wallet.")
                }

                function be() {
                    return {
                        type: "request-version"
                    }
                }

                function ye(e) {
                    return {
                        type: "response-version",
                        version: e
                    }
                }

                function me(e) {
                    return {
                        ton_connect_sdk_lib: e.ton_connect_sdk_lib,
                        ton_connect_ui_lib: e.ton_connect_ui_lib
                    }
                }

                function we(e, t) {
                    var n, r, o, i, s, a, c, u;
                    const l = (null === (n = null === t || void 0 === t ? void 0 : t.connectItems) || void 0 === n ? void 0 : n.tonProof) && "proof" in t.connectItems.tonProof,
                        d = l ? "ton_proof" : "ton_addr";
                    return {
                        wallet_address: null !== (o = null === (r = null === t || void 0 === t ? void 0 : t.account) || void 0 === r ? void 0 : r.address) && void 0 !== o ? o : null,
                        wallet_type: null !== (i = null === t || void 0 === t ? void 0 : t.device.appName) && void 0 !== i ? i : null,
                        wallet_version: null !== (s = null === t || void 0 === t ? void 0 : t.device.appVersion) && void 0 !== s ? s : null,
                        auth_type: d,
                        custom_data: Object.assign({
                            chain_id: null !== (c = null === (a = null === t || void 0 === t ? void 0 : t.account) || void 0 === a ? void 0 : a.chain) && void 0 !== c ? c : null,
                            provider: null !== (u = null === t || void 0 === t ? void 0 : t.provider) && void 0 !== u ? u : null
                        }, me(e))
                    }
                }

                function ke(e) {
                    return {
                        type: "connection-started",
                        custom_data: me(e)
                    }
                }

                function ve(e, t) {
                    return Object.assign({
                        type: "connection-completed",
                        is_success: !0
                    }, we(e, t))
                }

                function Se(e, t, n) {
                    return {
                        type: "connection-error",
                        is_success: !1,
                        error_message: t,
                        error_code: null !== n && void 0 !== n ? n : null,
                        custom_data: me(e)
                    }
                }

                function Ce(e) {
                    return {
                        type: "connection-restoring-started",
                        custom_data: me(e)
                    }
                }

                function Ie(e, t) {
                    return Object.assign({
                        type: "connection-restoring-completed",
                        is_success: !0
                    }, we(e, t))
                }

                function Ae(e, t) {
                    return {
                        type: "connection-restoring-error",
                        is_success: !1,
                        error_message: t,
                        custom_data: me(e)
                    }
                }

                function Oe(e, t) {
                    var n, r, o, i;
                    return {
                        valid_until: null !== (n = String(t.validUntil)) && void 0 !== n ? n : null,
                        from: null !== (i = null !== (r = t.from) && void 0 !== r ? r : null === (o = null === e || void 0 === e ? void 0 : e.account) || void 0 === o ? void 0 : o.address) && void 0 !== i ? i : null,
                        messages: t.messages.map(e => {
                            var t, n;
                            return {
                                address: null !== (t = e.address) && void 0 !== t ? t : null,
                                amount: null !== (n = e.amount) && void 0 !== n ? n : null
                            }
                        })
                    }
                }

                function xe(e, t, n) {
                    return Object.assign(Object.assign({
                        type: "transaction-sent-for-signature"
                    }, we(e, t)), Oe(t, n))
                }

                function _e(e, t, n, r) {
                    return Object.assign(Object.assign({
                        type: "transaction-signed",
                        is_success: !0,
                        signed_transaction: r.boc
                    }, we(e, t)), Oe(t, n))
                }

                function Ee(e, t, n, r, o) {
                    return Object.assign(Object.assign({
                        type: "transaction-signing-failed",
                        is_success: !1,
                        error_message: r,
                        error_code: null !== o && void 0 !== o ? o : null
                    }, we(e, t)), Oe(t, n))
                }

                function Te(e, t, n) {
                    return Object.assign({
                        type: "disconnection",
                        scope: n
                    }, we(e, t))
                }
                class Pe {
                    constructor() {
                        this.window = X()
                    }
                    dispatchEvent(e, t) {
                        var n;
                        return i(this, void 0, void 0, (function*() {
                            const r = new CustomEvent(e, {
                                detail: t
                            });
                            null === (n = this.window) || void 0 === n || n.dispatchEvent(r)
                        }))
                    }
                    addEventListener(e, t, n) {
                        var r;
                        return i(this, void 0, void 0, (function*() {
                            return null === (r = this.window) || void 0 === r || r.addEventListener(e, t, n), () => {
                                var n;
                                return null === (n = this.window) || void 0 === n ? void 0 : n.removeEventListener(e, t)
                            }
                        }))
                    }
                }
                class Re {
                    constructor(e) {
                        var t;
                        this.eventPrefix = "ton-connect-", this.tonConnectUiVersion = null, this.eventDispatcher = null !== (t = null === e || void 0 === e ? void 0 : e.eventDispatcher) && void 0 !== t ? t : new Pe, this.tonConnectSdkVersion = e.tonConnectSdkVersion, this.init().catch()
                    }
                    get version() {
                        return me({
                            ton_connect_sdk_lib: this.tonConnectSdkVersion,
                            ton_connect_ui_lib: this.tonConnectUiVersion
                        })
                    }
                    init() {
                        return i(this, void 0, void 0, (function*() {
                            try {
                                yield this.setRequestVersionHandler(), this.tonConnectUiVersion = yield this.requestTonConnectUiVersion()
                            } catch (e) {}
                        }))
                    }
                    setRequestVersionHandler() {
                        return i(this, void 0, void 0, (function*() {
                            yield this.eventDispatcher.addEventListener("ton-connect-request-version", () => i(this, void 0, void 0, (function*() {
                                yield this.eventDispatcher.dispatchEvent("ton-connect-response-version", ye(this.tonConnectSdkVersion))
                            })))
                        }))
                    }
                    requestTonConnectUiVersion() {
                        return i(this, void 0, void 0, (function*() {
                            return new Promise((e, t) => i(this, void 0, void 0, (function*() {
                                try {
                                    yield this.eventDispatcher.addEventListener("ton-connect-ui-response-version", t => {
                                        e(t.detail.version)
                                    }, {
                                        once: !0
                                    }), yield this.eventDispatcher.dispatchEvent("ton-connect-ui-request-version", be())
                                } catch (n) {
                                    t(n)
                                }
                            })))
                        }))
                    }
                    dispatchUserActionEvent(e) {
                        try {
                            this.eventDispatcher.dispatchEvent(`${this.eventPrefix}${e.type}`, e).catch()
                        } catch (t) {}
                    }
                    trackConnectionStarted(...e) {
                        try {
                            const t = ke(this.version, ...e);
                            this.dispatchUserActionEvent(t)
                        } catch (t) {}
                    }
                    trackConnectionCompleted(...e) {
                        try {
                            const t = ve(this.version, ...e);
                            this.dispatchUserActionEvent(t)
                        } catch (t) {}
                    }
                    trackConnectionError(...e) {
                        try {
                            const t = Se(this.version, ...e);
                            this.dispatchUserActionEvent(t)
                        } catch (t) {}
                    }
                    trackConnectionRestoringStarted(...e) {
                        try {
                            const t = Ce(this.version, ...e);
                            this.dispatchUserActionEvent(t)
                        } catch (t) {}
                    }
                    trackConnectionRestoringCompleted(...e) {
                        try {
                            const t = Ie(this.version, ...e);
                            this.dispatchUserActionEvent(t)
                        } catch (t) {}
                    }
                    trackConnectionRestoringError(...e) {
                        try {
                            const t = Ae(this.version, ...e);
                            this.dispatchUserActionEvent(t)
                        } catch (t) {}
                    }
                    trackDisconnection(...e) {
                        try {
                            const t = Te(this.version, ...e);
                            this.dispatchUserActionEvent(t)
                        } catch (t) {}
                    }
                    trackTransactionSentForSignature(...e) {
                        try {
                            const t = xe(this.version, ...e);
                            this.dispatchUserActionEvent(t)
                        } catch (t) {}
                    }
                    trackTransactionSigned(...e) {
                        try {
                            const t = _e(this.version, ...e);
                            this.dispatchUserActionEvent(t)
                        } catch (t) {}
                    }
                    trackTransactionSigningFailed(...e) {
                        try {
                            const t = Ee(this.version, ...e);
                            this.dispatchUserActionEvent(t)
                        } catch (t) {}
                    }
                }
                const je = "3.0.3";
                class Be {
                    constructor(e) {
                        if (this.walletsList = new pe, this._wallet = null, this.provider = null, this.statusChangeSubscriptions = [], this.statusChangeErrorSubscriptions = [], this.dappSettings = {
                                manifestUrl: (null === e || void 0 === e ? void 0 : e.manifestUrl) || te(),
                                storage: (null === e || void 0 === e ? void 0 : e.storage) || new se
                            }, this.walletsList = new pe({
                                walletsListSource: null === e || void 0 === e ? void 0 : e.walletsListSource,
                                cacheTTLMs: null === e || void 0 === e ? void 0 : e.walletsListCacheTTLMs
                            }), this.tracker = new Re({
                                eventDispatcher: null === e || void 0 === e ? void 0 : e.eventDispatcher,
                                tonConnectSdkVersion: je
                            }), !this.dappSettings.manifestUrl) throw new a("Dapp tonconnect-manifest.json must be specified if window.location.origin is undefined. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest");
                        this.bridgeConnectionStorage = new $(this.dappSettings.storage), (null === e || void 0 === e ? void 0 : e.disableAutoPauseConnection) || this.addWindowFocusAndBlurSubscriptions()
                    }
                    static getWallets() {
                        return this.walletsList.getWallets()
                    }
                    get connected() {
                        return null !== this._wallet
                    }
                    get account() {
                        var e;
                        return (null === (e = this._wallet) || void 0 === e ? void 0 : e.account) || null
                    }
                    get wallet() {
                        return this._wallet
                    }
                    set wallet(e) {
                        this._wallet = e, this.statusChangeSubscriptions.forEach(e => e(this._wallet))
                    }
                    getWallets() {
                        return this.walletsList.getWallets()
                    }
                    onStatusChange(e, t) {
                        return this.statusChangeSubscriptions.push(e), t && this.statusChangeErrorSubscriptions.push(t), () => {
                            this.statusChangeSubscriptions = this.statusChangeSubscriptions.filter(t => t !== e), t && (this.statusChangeErrorSubscriptions = this.statusChangeErrorSubscriptions.filter(e => e !== t))
                        }
                    }
                    connect(e, t) {
                        var n, r;
                        const o = {};
                        if ("object" === typeof t && "tonProof" in t && (o.request = t), "object" === typeof t && ("openingDeadlineMS" in t || "signal" in t || "request" in t) && (o.request = null === t || void 0 === t ? void 0 : t.request, o.openingDeadlineMS = null === t || void 0 === t ? void 0 : t.openingDeadlineMS, o.signal = null === t || void 0 === t ? void 0 : t.signal), this.connected) throw new l;
                        const i = L(null === o || void 0 === o ? void 0 : o.signal);
                        if (null === (n = this.abortController) || void 0 === n || n.abort(), this.abortController = i, i.signal.aborted) throw new s("Connection was aborted");
                        return null === (r = this.provider) || void 0 === r || r.closeConnection(), this.provider = this.createProvider(e), i.signal.addEventListener("abort", () => {
                            var e;
                            null === (e = this.provider) || void 0 === e || e.closeConnection(), this.provider = null
                        }), this.tracker.trackConnectionStarted(), this.provider.connect(this.createConnectRequest(null === o || void 0 === o ? void 0 : o.request), {
                            openingDeadlineMS: null === o || void 0 === o ? void 0 : o.openingDeadlineMS,
                            signal: i.signal
                        })
                    }
                    restoreConnection(e) {
                        var t, n;
                        return i(this, void 0, void 0, (function*() {
                            this.tracker.trackConnectionRestoringStarted();
                            const r = L(null === e || void 0 === e ? void 0 : e.signal);
                            if (null === (t = this.abortController) || void 0 === t || t.abort(), this.abortController = r, r.signal.aborted) return void this.tracker.trackConnectionRestoringError("Connection restoring was aborted");
                            const [o, s] = yield Promise.all([this.bridgeConnectionStorage.storedConnectionType(), this.walletsList.getEmbeddedWallet()]);
                            if (r.signal.aborted) return void this.tracker.trackConnectionRestoringError("Connection restoring was aborted");
                            let a = null;
                            try {
                                switch (o) {
                                    case "http":
                                        a = yield F.fromStorage(this.dappSettings.storage);
                                        break;
                                    case "injected":
                                        a = yield ie.fromStorage(this.dappSettings.storage);
                                        break;
                                    default:
                                        if (!s) return;
                                        a = this.createProvider(s)
                                }
                            } catch (u) {
                                return this.tracker.trackConnectionRestoringError("Provider is not restored"), yield this.bridgeConnectionStorage.removeConnection(), null === a || void 0 === a || a.closeConnection(), void(a = null)
                            }
                            if (r.signal.aborted) return null === a || void 0 === a || a.closeConnection(), void this.tracker.trackConnectionRestoringError("Connection restoring was aborted");
                            if (!a) return M("Provider is not restored"), void this.tracker.trackConnectionRestoringError("Provider is not restored");
                            null === (n = this.provider) || void 0 === n || n.closeConnection(), this.provider = a, a.listen(this.walletEventsListener.bind(this));
                            const c = () => {
                                this.tracker.trackConnectionRestoringError("Connection restoring was aborted"), null === a || void 0 === a || a.closeConnection(), a = null
                            };
                            return r.signal.addEventListener("abort", c), yield W(t => i(this, void 0, void 0, (function*() {
                                yield null === a || void 0 === a ? void 0 : a.restoreConnection({
                                    openingDeadlineMS: null === e || void 0 === e ? void 0 : e.openingDeadlineMS,
                                    signal: t.signal
                                }), r.signal.removeEventListener("abort", c), this.connected ? this.tracker.trackConnectionRestoringCompleted(this.wallet) : this.tracker.trackConnectionRestoringError("Connection restoring failed")
                            })), {
                                attempts: Number.MAX_SAFE_INTEGER,
                                delayMs: 5e3,
                                signal: null === e || void 0 === e ? void 0 : e.signal
                            })
                        }))
                    }
                    sendTransaction(e, t) {
                        return i(this, void 0, void 0, (function*() {
                            const n = {};
                            "function" === typeof t ? n.onRequestSent = t : (n.onRequestSent = null === t || void 0 === t ? void 0 : t.onRequestSent, n.signal = null === t || void 0 === t ? void 0 : t.signal);
                            const r = L(null === n || void 0 === n ? void 0 : n.signal);
                            if (r.signal.aborted) throw new s("Transaction sending was aborted");
                            this.checkConnection(), fe(this.wallet.device.features, {
                                requiredMessagesNumber: e.messages.length
                            }), this.tracker.trackTransactionSentForSignature(this.wallet, e);
                            const {
                                validUntil: i
                            } = e, a = o(e, ["validUntil"]), c = e.from || this.account.address, u = e.network || this.account.chain, l = yield this.provider.sendRequest(_.convertToRpcRequest(Object.assign(Object.assign({}, a), {
                                valid_until: i,
                                from: c,
                                network: u
                            })), {
                                onRequestSent: n.onRequestSent,
                                signal: r.signal
                            });
                            if (_.isError(l)) return this.tracker.trackTransactionSigningFailed(this.wallet, e, l.error.message, l.error.code), _.parseAndThrowError(l);
                            const d = _.convertFromRpcResponse(l);
                            return this.tracker.trackTransactionSigned(this.wallet, e, d), d
                        }))
                    }
                    disconnect(e) {
                        var t;
                        return i(this, void 0, void 0, (function*() {
                            if (!this.connected) throw new d;
                            const n = L(null === e || void 0 === e ? void 0 : e.signal),
                                r = this.abortController;
                            if (this.abortController = n, n.signal.aborted) throw new s("Disconnect was aborted");
                            this.onWalletDisconnected("dapp"), yield null === (t = this.provider) || void 0 === t ? void 0 : t.disconnect({
                                signal: n.signal
                            }), null === r || void 0 === r || r.abort()
                        }))
                    }
                    pauseConnection() {
                        var e;
                        "http" === (null === (e = this.provider) || void 0 === e ? void 0 : e.type) && this.provider.pause()
                    }
                    unPauseConnection() {
                        var e;
                        return "http" !== (null === (e = this.provider) || void 0 === e ? void 0 : e.type) ? Promise.resolve() : this.provider.unPause()
                    }
                    addWindowFocusAndBlurSubscriptions() {
                        const e = ee();
                        if (e) try {
                            e.addEventListener("visibilitychange", () => {
                                e.hidden ? this.pauseConnection() : this.unPauseConnection().catch()
                            })
                        } catch (t) {
                            M("Cannot subscribe to the document.visibilitychange: ", t)
                        }
                    }
                    createProvider(e) {
                        let t;
                        return t = !Array.isArray(e) && h(e) ? new ie(this.dappSettings.storage, e.jsBridgeKey) : new F(this.dappSettings.storage, e), t.listen(this.walletEventsListener.bind(this)), t
                    }
                    walletEventsListener(e) {
                        switch (e.event) {
                            case "connect":
                                this.onWalletConnected(e.payload);
                                break;
                            case "connect_error":
                                this.onWalletConnectError(e.payload);
                                break;
                            case "disconnect":
                                this.onWalletDisconnected("wallet")
                        }
                    }
                    onWalletConnected(e) {
                        const t = e.items.find(e => "ton_addr" === e.name),
                            n = e.items.find(e => "ton_proof" === e.name);
                        if (!t) throw new s("ton_addr connection item was not found");
                        const r = {
                            device: e.device,
                            provider: this.provider.type,
                            account: {
                                address: t.address,
                                chain: t.network,
                                walletStateInit: t.walletStateInit,
                                publicKey: t.publicKey
                            }
                        };
                        n && (r.connectItems = {
                            tonProof: n
                        }), this.wallet = r, this.tracker.trackConnectionCompleted(r)
                    }
                    onWalletConnectError(e) {
                        const t = I.parseError(e);
                        if (this.statusChangeErrorSubscriptions.forEach(e => e(t)), N(t), this.tracker.trackConnectionError(e.message, e.code), t instanceof u || t instanceof c) throw M(t), t
                    }
                    onWalletDisconnected(e) {
                        this.tracker.trackDisconnection(this.wallet, e), this.wallet = null
                    }
                    checkConnection() {
                        if (!this.connected) throw new d
                    }
                    createConnectRequest(e) {
                        const t = [{
                            name: "ton_addr"
                        }];
                        return (null === e || void 0 === e ? void 0 : e.tonProof) && t.push({
                            name: "ton_proof",
                            payload: e.tonProof
                        }), {
                            manifestUrl: this.dappSettings.manifestUrl,
                            items: t
                        }
                    }
                }
                Be.walletsList = new pe, Be.isWalletInjected = e => ie.isWalletInjected(e), Be.isInsideWalletBrowser = e => ie.isInsideWalletBrowser(e);
                const Le = 81,
                    We = 128;

                function Ne(e, t = !1) {
                    const {
                        wc: n,
                        hex: o
                    } = Me(e);
                    let i = Le;
                    t && (i |= We);
                    const s = new Int8Array(34);
                    s[0] = i, s[1] = n, s.set(o, 2);
                    const a = new Uint8Array(36);
                    a.set(s), a.set(Ke(s), 34);
                    let c = r.Base64.encode(a);
                    return c.replace(/\+/g, "-").replace(/\//g, "_")
                }

                function Me(e) {
                    if (!e.includes(":")) throw new w(`Wrong address ${e}. Address must include ":".`);
                    const t = e.split(":");
                    if (2 !== t.length) throw new w(`Wrong address ${e}. Address must include ":" only once.`);
                    const n = parseInt(t[0]);
                    if (0 !== n && -1 !== n) throw new w(`Wrong address ${e}. WC must be eq 0 or -1, but ${n} received.`);
                    const r = t[1];
                    if (64 !== (null === r || void 0 === r ? void 0 : r.length)) throw new w(`Wrong address ${e}. Hex part must be 64bytes length, but ${null===r||void 0===r?void 0:r.length} received.`);
                    return {
                        wc: n,
                        hex: ze(r)
                    }
                }

                function Ke(e) {
                    const t = 4129;
                    let n = 0;
                    const r = new Uint8Array(e.length + 2);
                    r.set(e);
                    for (let o of r) {
                        let e = 128;
                        while (e > 0) n <<= 1, o & e && (n += 1), e >>= 1, n > 65535 && (n &= 65535, n ^= t)
                    }
                    return new Uint8Array([Math.floor(n / 256), n % 256])
                }
                const Ue = {};
                for (let t = 0; t <= 255; t++) {
                    let e = t.toString(16);
                    e.length < 2 && (e = "0" + e), Ue[e] = t
                }

                function ze(e) {
                    e = e.toLowerCase();
                    const t = e.length;
                    if (t % 2 !== 0) throw new k("Hex string must have length a multiple of 2: " + e);
                    const n = t / 2,
                        r = new Uint8Array(n);
                    for (let o = 0; o < n; o++) {
                        const t = 2 * o,
                            n = e.substring(t, t + 2);
                        if (!Ue.hasOwnProperty(n)) throw new k("Invalid hex character: " + n);
                        r[o] = Ue[n]
                    }
                    return r
                }
                Object.defineProperty(t, "CHAIN", {
                    enumerable: !0,
                    get: function() {
                        return r.CHAIN
                    }
                }), Object.defineProperty(t, "CONNECT_EVENT_ERROR_CODES", {
                    enumerable: !0,
                    get: function() {
                        return r.CONNECT_EVENT_ERROR_CODES
                    }
                }), Object.defineProperty(t, "CONNECT_ITEM_ERROR_CODES", {
                    enumerable: !0,
                    get: function() {
                        return r.CONNECT_ITEM_ERROR_CODES
                    }
                }), Object.defineProperty(t, "SEND_TRANSACTION_ERROR_CODES", {
                    enumerable: !0,
                    get: function() {
                        return r.SEND_TRANSACTION_ERROR_CODES
                    }
                }), t.BadRequestError = g, t.BrowserEventDispatcher = Pe, t.FetchWalletsError = m, t.LocalstorageNotFoundError = y, t.ParseHexError = k, t.TonConnect = Be, t.TonConnectError = s, t.UnknownAppError = f, t.UnknownError = v, t.UserRejectsError = p, t.WalletAlreadyConnectedError = l, t.WalletNotConnectedError = d, t.WalletNotInjectedError = b, t.WalletsListManager = pe, t.WrongAddressError = w, t.createConnectionCompletedEvent = ve, t.createConnectionErrorEvent = Se, t.createConnectionRestoringCompletedEvent = Ie, t.createConnectionRestoringErrorEvent = Ae, t.createConnectionRestoringStartedEvent = Ce, t.createConnectionStartedEvent = ke, t.createDisconnectionEvent = Te, t.createRequestVersionEvent = be, t.createResponseVersionEvent = ye, t.createTransactionSentForSignatureEvent = xe, t.createTransactionSignedEvent = _e, t.createTransactionSigningFailedEvent = Ee, t.createVersionInfo = me, t["default"] = Be, t.encodeTelegramUrlParameters = j, t.isTelegramUrl = R, t.isWalletInfoCurrentlyEmbedded = ce, t.isWalletInfoCurrentlyInjected = ae, t.isWalletInfoInjectable = ue, t.isWalletInfoInjected = de, t.isWalletInfoRemote = le, t.toUserFriendlyAddress = Ne
            }).call(this, n("4362"))
        },
        "9d51": function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.HashMD = t.Maj = t.Chi = void 0;
            const r = n("0067"),
                o = n("1700");

            function i(e, t, n, r) {
                if ("function" === typeof e.setBigUint64) return e.setBigUint64(t, n, r);
                const o = BigInt(32),
                    i = BigInt(4294967295),
                    s = Number(n >> o & i),
                    a = Number(n & i),
                    c = r ? 4 : 0,
                    u = r ? 0 : 4;
                e.setUint32(t + c, s, r), e.setUint32(t + u, a, r)
            }
            const s = (e, t, n) => e & t ^ ~e & n;
            t.Chi = s;
            const a = (e, t, n) => e & t ^ e & n ^ t & n;
            t.Maj = a;
            class c extends o.Hash {
                constructor(e, t, n, r) {
                    super(), this.blockLen = e, this.outputLen = t, this.padOffset = n, this.isLE = r, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = (0, o.createView)(this.buffer)
                }
                update(e) {
                    (0, r.exists)(this);
                    const {
                        view: t,
                        buffer: n,
                        blockLen: i
                    } = this;
                    e = (0, o.toBytes)(e);
                    const s = e.length;
                    for (let r = 0; r < s;) {
                        const a = Math.min(i - this.pos, s - r);
                        if (a !== i) n.set(e.subarray(r, r + a), this.pos), this.pos += a, r += a, this.pos === i && (this.process(t, 0), this.pos = 0);
                        else {
                            const t = (0, o.createView)(e);
                            for (; i <= s - r; r += i) this.process(t, r)
                        }
                    }
                    return this.length += e.length, this.roundClean(), this
                }
                digestInto(e) {
                    (0, r.exists)(this), (0, r.output)(e, this), this.finished = !0;
                    const {
                        buffer: t,
                        view: n,
                        blockLen: s,
                        isLE: a
                    } = this;
                    let {
                        pos: c
                    } = this;
                    t[c++] = 128, this.buffer.subarray(c).fill(0), this.padOffset > s - c && (this.process(n, 0), c = 0);
                    for (let r = c; r < s; r++) t[r] = 0;
                    i(n, s - 8, BigInt(8 * this.length), a), this.process(n, 0);
                    const u = (0, o.createView)(e),
                        l = this.outputLen;
                    if (l % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
                    const d = l / 4,
                        h = this.get();
                    if (d > h.length) throw new Error("_sha2: outputLen bigger than state");
                    for (let r = 0; r < d; r++) u.setUint32(4 * r, h[r], a)
                }
                digest() {
                    const {
                        buffer: e,
                        outputLen: t
                    } = this;
                    this.digestInto(e);
                    const n = e.slice(0, t);
                    return this.destroy(), n
                }
                _cloneInto(e) {
                    e || (e = new this.constructor), e.set(...this.get());
                    const {
                        blockLen: t,
                        buffer: n,
                        length: r,
                        finished: o,
                        destroyed: i,
                        pos: s
                    } = this;
                    return e.length = r, e.pos = s, e.finished = o, e.destroyed = i, r % t && e.buffer.set(n), e
                }
            }
            t.HashMD = c
        },
        "9e49": function(e, t, n) {
            "use strict";
            (function(e) {
                n.d(t, "a", (function() {
                    return l
                })), n.d(t, "b", (function() {
                    return d
                })), n.d(t, "c", (function() {
                    return h
                })), n.d(t, "d", (function() {
                    return p
                }));
                var r = n("8df2"),
                    o = n("1c54"),
                    i = n("0276"),
                    s = n("4ae8"),
                    a = n("a15d"),
                    c = n("0609"),
                    u = n("5762");
                const l = Object(r["struct"])([Object(r["u8"])("instruction"), Object(o["u64"])("amount")]);

                function d(t, n, r, o, a = [], d = s["c"]) {
                    const h = Object(c["a"])([{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: n,
                            isSigner: !1,
                            isWritable: !1
                        }], r, a),
                        p = e.alloc(l.span);
                    return l.encode({
                        instruction: u["a"].Approve,
                        amount: BigInt(o)
                    }, p), new i["TransactionInstruction"]({
                        keys: h,
                        programId: d,
                        data: p
                    })
                }

                function h(e, t = s["c"]) {
                    if (!e.programId.equals(t)) throw new a["g"];
                    if (e.data.length !== l.span) throw new a["e"];
                    const {
                        keys: {
                            account: n,
                            delegate: r,
                            owner: o,
                            multiSigners: i
                        },
                        data: c
                    } = p(e);
                    if (c.instruction !== u["a"].Approve) throw new a["h"];
                    if (!n || !r || !o) throw new a["f"];
                    return {
                        programId: t,
                        keys: {
                            account: n,
                            delegate: r,
                            owner: o,
                            multiSigners: i
                        },
                        data: c
                    }
                }

                function p({
                    programId: e,
                    keys: [t, n, r, ...o],
                    data: i
                }) {
                    return {
                        programId: e,
                        keys: {
                            account: t,
                            delegate: n,
                            owner: r,
                            multiSigners: o
                        },
                        data: l.decode(i)
                    }
                }
            }).call(this, n("b639").Buffer)
        },
        "9f7c": function(e, t, n) {
            "use strict";
            (function(e) {
                n.d(t, "a", (function() {
                    return r
                })), n.d(t, "e", (function() {
                    return d
                })), n.d(t, "b", (function() {
                    return h
                })), n.d(t, "c", (function() {
                    return p
                })), n.d(t, "d", (function() {
                    return g
                }));
                var r, o = n("8df2"),
                    i = n("1c54"),
                    s = n("0276"),
                    a = n("4ae8"),
                    c = n("a15d"),
                    u = n("0609"),
                    l = n("5762");
                (function(e) {
                    e[e["MintTokens"] = 0] = "MintTokens", e[e["FreezeAccount"] = 1] = "FreezeAccount", e[e["AccountOwner"] = 2] = "AccountOwner", e[e["CloseAccount"] = 3] = "CloseAccount"
                })(r || (r = {}));
                const d = Object(o["struct"])([Object(o["u8"])("instruction"), Object(o["u8"])("authorityType"), Object(o["u8"])("newAuthorityOption"), Object(i["publicKey"])("newAuthority")]);

                function h(t, n, r, o, i = [], c = a["c"]) {
                    const h = Object(u["a"])([{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }], n, i),
                        p = e.alloc(d.span);
                    return d.encode({
                        instruction: l["a"].SetAuthority,
                        authorityType: r,
                        newAuthorityOption: o ? 1 : 0,
                        newAuthority: o || new s["PublicKey"](0)
                    }, p), new s["TransactionInstruction"]({
                        keys: h,
                        programId: c,
                        data: p
                    })
                }

                function p(e, t = a["c"]) {
                    if (!e.programId.equals(t)) throw new c["g"];
                    if (e.data.length !== d.span) throw new c["e"];
                    const {
                        keys: {
                            account: n,
                            currentAuthority: r,
                            multiSigners: o
                        },
                        data: i
                    } = g(e);
                    if (i.instruction !== l["a"].SetAuthority) throw new c["h"];
                    if (!n || !r) throw new c["f"];
                    return {
                        programId: t,
                        keys: {
                            account: n,
                            currentAuthority: r,
                            multiSigners: o
                        },
                        data: i
                    }
                }

                function g({
                    programId: e,
                    keys: [t, n, ...r],
                    data: o
                }) {
                    const {
                        instruction: i,
                        authorityType: s,
                        newAuthorityOption: a,
                        newAuthority: c
                    } = d.decode(o);
                    return {
                        programId: e,
                        keys: {
                            account: t,
                            currentAuthority: n,
                            multiSigners: r
                        },
                        data: {
                            instruction: i,
                            authorityType: s,
                            newAuthority: a ? c : null
                        }
                    }
                }
            }).call(this, n("b639").Buffer)
        },
        a15d: function(e, t, n) {
            "use strict";
            n.d(t, "b", (function() {
                return r
            })), n.d(t, "a", (function() {
                return o
            })), n.d(t, "c", (function() {
                return i
            })), n.d(t, "d", (function() {
                return s
            })), n.d(t, "i", (function() {
                return a
            })), n.d(t, "j", (function() {
                return c
            })), n.d(t, "k", (function() {
                return u
            })), n.d(t, "g", (function() {
                return l
            })), n.d(t, "f", (function() {
                return d
            })), n.d(t, "e", (function() {
                return h
            })), n.d(t, "h", (function() {
                return p
            }));
            class r extends Error {
                constructor(e) {
                    super(e)
                }
            }
            class o extends r {
                constructor() {
                    super(...arguments), this.name = "TokenAccountNotFoundError"
                }
            }
            class i extends r {
                constructor() {
                    super(...arguments), this.name = "TokenInvalidAccountOwnerError"
                }
            }
            class s extends r {
                constructor() {
                    super(...arguments), this.name = "TokenInvalidAccountSizeError"
                }
            }
            class a extends r {
                constructor() {
                    super(...arguments), this.name = "TokenInvalidMintError"
                }
            }
            class c extends r {
                constructor() {
                    super(...arguments), this.name = "TokenInvalidOwnerError"
                }
            }
            class u extends r {
                constructor() {
                    super(...arguments), this.name = "TokenOwnerOffCurveError"
                }
            }
            class l extends r {
                constructor() {
                    super(...arguments), this.name = "TokenInvalidInstructionProgramError"
                }
            }
            class d extends r {
                constructor() {
                    super(...arguments), this.name = "TokenInvalidInstructionKeysError"
                }
            }
            class h extends r {
                constructor() {
                    super(...arguments), this.name = "TokenInvalidInstructionDataError"
                }
            }
            class p extends r {
                constructor() {
                    super(...arguments), this.name = "TokenInvalidInstructionTypeError"
                }
            }
        },
        a6c0: function(e, t, n) {
            "use strict";
            (function(e) {
                n.d(t, "a", (function() {
                    return l
                })), n.d(t, "b", (function() {
                    return d
                })), n.d(t, "c", (function() {
                    return h
                })), n.d(t, "d", (function() {
                    return p
                }));
                var r = n("8df2"),
                    o = n("1c54"),
                    i = n("0276"),
                    s = n("4ae8"),
                    a = n("a15d"),
                    c = n("0609"),
                    u = n("5762");
                const l = Object(r["struct"])([Object(r["u8"])("instruction"), Object(o["u64"])("amount"), Object(r["u8"])("decimals")]);

                function d(t, n, r, o, a, d, h = [], p = s["c"]) {
                    const g = Object(c["a"])([{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: n,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: r,
                            isSigner: !1,
                            isWritable: !1
                        }], o, h),
                        f = e.alloc(l.span);
                    return l.encode({
                        instruction: u["a"].ApproveChecked,
                        amount: BigInt(a),
                        decimals: d
                    }, f), new i["TransactionInstruction"]({
                        keys: g,
                        programId: p,
                        data: f
                    })
                }

                function h(e, t = s["c"]) {
                    if (!e.programId.equals(t)) throw new a["g"];
                    if (e.data.length !== l.span) throw new a["e"];
                    const {
                        keys: {
                            account: n,
                            mint: r,
                            delegate: o,
                            owner: i,
                            multiSigners: c
                        },
                        data: d
                    } = p(e);
                    if (d.instruction !== u["a"].ApproveChecked) throw new a["h"];
                    if (!n || !r || !o || !i) throw new a["f"];
                    return {
                        programId: t,
                        keys: {
                            account: n,
                            mint: r,
                            delegate: o,
                            owner: i,
                            multiSigners: c
                        },
                        data: d
                    }
                }

                function p({
                    programId: e,
                    keys: [t, n, r, o, ...i],
                    data: s
                }) {
                    return {
                        programId: e,
                        keys: {
                            account: t,
                            mint: n,
                            delegate: r,
                            owner: o,
                            multiSigners: i
                        },
                        data: l.decode(s)
                    }
                }
            }).call(this, n("b639").Buffer)
        },
        a763: function(e, t, n) {
            "use strict";
            (function(e) {
                n.d(t, "d", (function() {
                    return u
                })), n.d(t, "a", (function() {
                    return l
                })), n.d(t, "b", (function() {
                    return d
                })), n.d(t, "c", (function() {
                    return h
                }));
                var r = n("8df2"),
                    o = n("0276"),
                    i = n("4ae8"),
                    s = n("a15d"),
                    a = n("0609"),
                    c = n("5762");
                const u = Object(r["struct"])([Object(r["u8"])("instruction")]);

                function l(t, n, r, s = [], l = i["c"]) {
                    const d = Object(a["a"])([{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: n,
                            isSigner: !1,
                            isWritable: !1
                        }], r, s),
                        h = e.alloc(u.span);
                    return u.encode({
                        instruction: c["a"].ThawAccount
                    }, h), new o["TransactionInstruction"]({
                        keys: d,
                        programId: l,
                        data: h
                    })
                }

                function d(e, t = i["c"]) {
                    if (!e.programId.equals(t)) throw new s["g"];
                    if (e.data.length !== u.span) throw new s["e"];
                    const {
                        keys: {
                            account: n,
                            mint: r,
                            authority: o,
                            multiSigners: a
                        },
                        data: l
                    } = h(e);
                    if (l.instruction !== c["a"].ThawAccount) throw new s["h"];
                    if (!n || !r || !o) throw new s["f"];
                    return {
                        programId: t,
                        keys: {
                            account: n,
                            mint: r,
                            authority: o,
                            multiSigners: a
                        },
                        data: l
                    }
                }

                function h({
                    programId: e,
                    keys: [t, n, r, ...o],
                    data: i
                }) {
                    return {
                        programId: e,
                        keys: {
                            account: t,
                            mint: n,
                            authority: r,
                            multiSigners: o
                        },
                        data: u.decode(i)
                    }
                }
            }).call(this, n("b639").Buffer)
        },
        ab84: function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.sha224 = t.sha256 = void 0;
            const r = n("9d51"),
                o = n("1700"),
                i = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),
                s = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
                a = new Uint32Array(64);
            class c extends r.HashMD {
                constructor() {
                    super(64, 32, 8, !1), this.A = 0 | s[0], this.B = 0 | s[1], this.C = 0 | s[2], this.D = 0 | s[3], this.E = 0 | s[4], this.F = 0 | s[5], this.G = 0 | s[6], this.H = 0 | s[7]
                }
                get() {
                    const {
                        A: e,
                        B: t,
                        C: n,
                        D: r,
                        E: o,
                        F: i,
                        G: s,
                        H: a
                    } = this;
                    return [e, t, n, r, o, i, s, a]
                }
                set(e, t, n, r, o, i, s, a) {
                    this.A = 0 | e, this.B = 0 | t, this.C = 0 | n, this.D = 0 | r, this.E = 0 | o, this.F = 0 | i, this.G = 0 | s, this.H = 0 | a
                }
                process(e, t) {
                    for (let r = 0; r < 16; r++, t += 4) a[r] = e.getUint32(t, !1);
                    for (let r = 16; r < 64; r++) {
                        const e = a[r - 15],
                            t = a[r - 2],
                            n = (0, o.rotr)(e, 7) ^ (0, o.rotr)(e, 18) ^ e >>> 3,
                            i = (0, o.rotr)(t, 17) ^ (0, o.rotr)(t, 19) ^ t >>> 10;
                        a[r] = i + a[r - 7] + n + a[r - 16] | 0
                    }
                    let {
                        A: n,
                        B: s,
                        C: c,
                        D: u,
                        E: l,
                        F: d,
                        G: h,
                        H: p
                    } = this;
                    for (let g = 0; g < 64; g++) {
                        const e = (0, o.rotr)(l, 6) ^ (0, o.rotr)(l, 11) ^ (0, o.rotr)(l, 25),
                            t = p + e + (0, r.Chi)(l, d, h) + i[g] + a[g] | 0,
                            f = (0, o.rotr)(n, 2) ^ (0, o.rotr)(n, 13) ^ (0, o.rotr)(n, 22),
                            b = f + (0, r.Maj)(n, s, c) | 0;
                        p = h, h = d, d = l, l = u + t | 0, u = c, c = s, s = n, n = t + b | 0
                    }
                    n = n + this.A | 0, s = s + this.B | 0, c = c + this.C | 0, u = u + this.D | 0, l = l + this.E | 0, d = d + this.F | 0, h = h + this.G | 0, p = p + this.H | 0, this.set(n, s, c, u, l, d, h, p)
                }
                roundClean() {
                    a.fill(0)
                }
                destroy() {
                    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0)
                }
            }
            class u extends c {
                constructor() {
                    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28
                }
            }
            t.sha256 = (0, o.wrapConstructor)(() => new c), t.sha224 = (0, o.wrapConstructor)(() => new u)
        },
        abce: function(e, t, n) {
            "use strict";
            (function(e) {
                n.d(t, "d", (function() {
                    return c
                })), n.d(t, "a", (function() {
                    return u
                })), n.d(t, "b", (function() {
                    return l
                })), n.d(t, "c", (function() {
                    return d
                }));
                var r = n("8df2"),
                    o = n("0276"),
                    i = n("4ae8"),
                    s = n("a15d"),
                    a = n("5762");
                const c = Object(r["struct"])([Object(r["u8"])("instruction"), Object(r["u8"])("m")]);

                function u(t, n, r, s = i["c"]) {
                    const u = [{
                        pubkey: t,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: o["SYSVAR_RENT_PUBKEY"],
                        isSigner: !1,
                        isWritable: !1
                    }];
                    for (const e of n) u.push({
                        pubkey: e,
                        isSigner: !1,
                        isWritable: !1
                    });
                    const l = e.alloc(c.span);
                    return c.encode({
                        instruction: a["a"].InitializeMultisig,
                        m: r
                    }, l), new o["TransactionInstruction"]({
                        keys: u,
                        programId: s,
                        data: l
                    })
                }

                function l(e, t = i["c"]) {
                    if (!e.programId.equals(t)) throw new s["g"];
                    if (e.data.length !== c.span) throw new s["e"];
                    const {
                        keys: {
                            account: n,
                            rent: r,
                            signers: o
                        },
                        data: u
                    } = d(e);
                    if (u.instruction !== a["a"].InitializeMultisig) throw new s["h"];
                    if (!n || !r || !o.length) throw new s["f"];
                    return {
                        programId: t,
                        keys: {
                            account: n,
                            rent: r,
                            signers: o
                        },
                        data: u
                    }
                }

                function d({
                    programId: e,
                    keys: [t, n, ...r],
                    data: o
                }) {
                    return {
                        programId: e,
                        keys: {
                            account: t,
                            rent: n,
                            signers: r
                        },
                        data: c.decode(o)
                    }
                }
            }).call(this, n("b639").Buffer)
        },
        afea: function(e, t, n) {
            "use strict";
            (function(e) {
                n.d(t, "a", (function() {
                    return u
                })), n.d(t, "b", (function() {
                    return l
                })), n.d(t, "c", (function() {
                    return d
                })), n.d(t, "d", (function() {
                    return h
                }));
                var r = n("8df2"),
                    o = n("0276"),
                    i = n("4ae8"),
                    s = n("a15d"),
                    a = n("0609"),
                    c = n("5762");
                const u = Object(r["struct"])([Object(r["u8"])("instruction")]);

                function l(t, n, r, s = [], l = i["c"]) {
                    const d = Object(a["a"])([{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: n,
                            isSigner: !1,
                            isWritable: !0
                        }], r, s),
                        h = e.alloc(u.span);
                    return u.encode({
                        instruction: c["a"].CloseAccount
                    }, h), new o["TransactionInstruction"]({
                        keys: d,
                        programId: l,
                        data: h
                    })
                }

                function d(e, t = i["c"]) {
                    if (!e.programId.equals(t)) throw new s["g"];
                    if (e.data.length !== u.span) throw new s["e"];
                    const {
                        keys: {
                            account: n,
                            destination: r,
                            authority: o,
                            multiSigners: a
                        },
                        data: l
                    } = h(e);
                    if (l.instruction !== c["a"].CloseAccount) throw new s["h"];
                    if (!n || !r || !o) throw new s["f"];
                    return {
                        programId: t,
                        keys: {
                            account: n,
                            destination: r,
                            authority: o,
                            multiSigners: a
                        },
                        data: l
                    }
                }

                function h({
                    programId: e,
                    keys: [t, n, r, ...o],
                    data: i
                }) {
                    return {
                        programId: e,
                        keys: {
                            account: t,
                            destination: n,
                            authority: r,
                            multiSigners: o
                        },
                        data: u.decode(i)
                    }
                }
            }).call(this, n("b639").Buffer)
        },
        b192: function(e, t, n) {
            "use strict";
            (function(e) {
                n.d(t, "d", (function() {
                    return l
                })), n.d(t, "a", (function() {
                    return d
                })), n.d(t, "b", (function() {
                    return h
                })), n.d(t, "c", (function() {
                    return p
                }));
                var r = n("8df2"),
                    o = n("1c54"),
                    i = n("0276"),
                    s = n("4ae8"),
                    a = n("a15d"),
                    c = n("0609"),
                    u = n("5762");
                const l = Object(r["struct"])([Object(r["u8"])("instruction"), Object(o["u64"])("amount"), Object(r["u8"])("decimals")]);

                function d(t, n, r, o, a, d = [], h = s["c"]) {
                    const p = Object(c["a"])([{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: n,
                            isSigner: !1,
                            isWritable: !0
                        }], r, d),
                        g = e.alloc(l.span);
                    return l.encode({
                        instruction: u["a"].MintToChecked,
                        amount: BigInt(o),
                        decimals: a
                    }, g), new i["TransactionInstruction"]({
                        keys: p,
                        programId: h,
                        data: g
                    })
                }

                function h(e, t = s["c"]) {
                    if (!e.programId.equals(t)) throw new a["g"];
                    if (e.data.length !== l.span) throw new a["e"];
                    const {
                        keys: {
                            mint: n,
                            destination: r,
                            authority: o,
                            multiSigners: i
                        },
                        data: c
                    } = p(e);
                    if (c.instruction !== u["a"].MintToChecked) throw new a["h"];
                    if (!n || !r || !o) throw new a["f"];
                    return {
                        programId: t,
                        keys: {
                            mint: n,
                            destination: r,
                            authority: o,
                            multiSigners: i
                        },
                        data: c
                    }
                }

                function p({
                    programId: e,
                    keys: [t, n, r, ...o],
                    data: i
                }) {
                    return {
                        programId: e,
                        keys: {
                            mint: t,
                            destination: n,
                            authority: r,
                            multiSigners: o
                        },
                        data: l.decode(i)
                    }
                }
            }).call(this, n("b639").Buffer)
        },
        b962: function(e, t, n) {
            "use strict";
            (function(e) {
                n.d(t, "d", (function() {
                    return u
                })), n.d(t, "a", (function() {
                    return l
                })), n.d(t, "b", (function() {
                    return d
                })), n.d(t, "c", (function() {
                    return h
                }));
                var r = n("8df2"),
                    o = n("0276"),
                    i = n("4ae8"),
                    s = n("a15d"),
                    a = n("0609"),
                    c = n("5762");
                const u = Object(r["struct"])([Object(r["u8"])("instruction")]);

                function l(t, n, r = [], s = i["c"]) {
                    const l = Object(a["a"])([{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }], n, r),
                        d = e.alloc(u.span);
                    return u.encode({
                        instruction: c["a"].Revoke
                    }, d), new o["TransactionInstruction"]({
                        keys: l,
                        programId: s,
                        data: d
                    })
                }

                function d(e, t = i["c"]) {
                    if (!e.programId.equals(t)) throw new s["g"];
                    if (e.data.length !== u.span) throw new s["e"];
                    const {
                        keys: {
                            account: n,
                            owner: r,
                            multiSigners: o
                        },
                        data: a
                    } = h(e);
                    if (a.instruction !== c["a"].Revoke) throw new s["h"];
                    if (!n || !r) throw new s["f"];
                    return {
                        programId: t,
                        keys: {
                            account: n,
                            owner: r,
                            multiSigners: o
                        },
                        data: a
                    }
                }

                function h({
                    programId: e,
                    keys: [t, n, ...r],
                    data: o
                }) {
                    return {
                        programId: e,
                        keys: {
                            account: t,
                            owner: n,
                            multiSigners: r
                        },
                        data: u.decode(o)
                    }
                }
            }).call(this, n("b639").Buffer)
        },
        bd88: function(e, t, n) {
            "use strict";
            (function(e) {
                n.d(t, "THEME", (function() {
                    return It
                })), n.d(t, "TonConnectUI", (function() {
                    return Bl
                }));
                var r, o, i, s, a, c, u, l, d = n("9085"),
                    h = n("2b80"),
                    p = n.n(h),
                    g = n("d845"),
                    f = n.n(g),
                    b = n("4d26"),
                    y = n.n(b),
                    m = Object.defineProperty,
                    w = Object.defineProperties,
                    k = Object.getOwnPropertyDescriptors,
                    v = Object.getOwnPropertySymbols,
                    S = Object.prototype.hasOwnProperty,
                    C = Object.prototype.propertyIsEnumerable,
                    I = (e, t, n) => t in e ? m(e, t, {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: n
                    }) : e[t] = n,
                    A = (e, t) => {
                        for (var n in t || (t = {})) S.call(t, n) && I(e, n, t[n]);
                        if (v)
                            for (var n of v(t)) C.call(t, n) && I(e, n, t[n]);
                        return e
                    },
                    O = (e, t) => w(e, k(t)),
                    x = (e, t, n) => (I(e, "symbol" !== typeof t ? t + "" : t, n), n),
                    _ = (e, t, n) => new Promise((r, o) => {
                        var i = e => {
                                try {
                                    a(n.next(e))
                                } catch (t) {
                                    o(t)
                                }
                            },
                            s = e => {
                                try {
                                    a(n.throw(e))
                                } catch (t) {
                                    o(t)
                                }
                            },
                            a = e => e.done ? r(e.value) : Promise.resolve(e.value).then(i, s);
                        a((n = n.apply(e, t)).next())
                    });
                const E = {};

                function T(e) {
                    E.context = e
                }
                const P = (e, t) => e === t,
                    R = Symbol("solid-proxy"),
                    j = Symbol("solid-track"),
                    B = {
                        equals: P
                    };
                let L = me;
                const W = 1,
                    N = 2,
                    M = {
                        owned: null,
                        cleanups: null,
                        context: null,
                        owner: null
                    },
                    K = {};
                var U = null;
                let z, D = null,
                    H = null,
                    q = null,
                    $ = null,
                    V = 0;

                function F(e, t) {
                    const n = H,
                        r = U,
                        o = 0 === e.length,
                        i = o ? M : {
                            owned: null,
                            cleanups: null,
                            context: null,
                            owner: void 0 === t ? r : t
                        },
                        s = o ? e : () => e(() => te(() => Se(i)));
                    U = i, H = null;
                    try {
                        return be(s, !0)
                    } finally {
                        H = n, U = r
                    }
                }

                function G(e, t) {
                    t = t ? Object.assign({}, B, t) : B;
                    const n = {
                            value: e,
                            observers: null,
                            observerSlots: null,
                            comparator: t.equals || void 0
                        },
                        r = e => ("function" === typeof e && (e = e(n.value)), de(n, e));
                    return [le.bind(n), r]
                }

                function Y(e, t, n) {
                    const r = ge(e, t, !0, W);
                    he(r)
                }

                function J(e, t, n) {
                    const r = ge(e, t, !1, W);
                    he(r)
                }

                function Z(e, t, n) {
                    L = we;
                    const r = ge(e, t, !1, W);
                    r.user = !0, $ ? $.push(r) : he(r)
                }

                function X(e, t, n) {
                    n = n ? Object.assign({}, B, n) : B;
                    const r = ge(e, t, !0, 0);
                    return r.observers = null, r.observerSlots = null, r.comparator = n.equals || void 0, he(r), le.bind(r)
                }

                function Q(e, t, n) {
                    let r, o, i;
                    2 === arguments.length && "object" === typeof t || 1 === arguments.length ? (r = !0, o = e, i = t || {}) : (r = e, o = t, i = n || {});
                    let s = null,
                        a = K,
                        c = null,
                        u = !1,
                        l = "initialValue" in i,
                        d = "function" === typeof r && X(r);
                    const h = new Set,
                        [p, g] = (i.storage || G)(i.initialValue),
                        [f, b] = G(void 0),
                        [y, m] = G(void 0, {
                            equals: !1
                        }),
                        [w, k] = G(l ? "ready" : "unresolved");
                    if (E.context) {
                        let e;
                        c = `${E.context.id}${E.context.count++}`, "initial" === i.ssrLoadFrom ? a = i.initialValue : E.load && (e = E.load(c)) && (a = e[0])
                    }

                    function v(e, t, n, r) {
                        return s === e && (s = null, l = !0, e !== a && t !== a || !i.onHydrated || queueMicrotask(() => i.onHydrated(r, {
                            value: t
                        })), a = K, S(t, n)), t
                    }

                    function S(e, t) {
                        be(() => {
                            void 0 === t && g(() => e), k(void 0 !== t ? "errored" : "ready"), b(t);
                            for (const e of h.keys()) e.decrement();
                            h.clear()
                        }, !1)
                    }

                    function C() {
                        const e = z,
                            t = p(),
                            n = f();
                        if (void 0 !== n && !s) throw n;
                        return H && !H.user && e && Y(() => {
                            y(), s && (e.resolved || h.has(e) || (e.increment(), h.add(e)))
                        }), t
                    }

                    function I(e = !0) {
                        if (!1 !== e && u) return;
                        u = !1;
                        const t = d ? d() : r;
                        if (null == t || !1 === t) return void v(s, te(p));
                        const n = a !== K ? a : te(() => o(t, {
                            value: p(),
                            refetching: e
                        }));
                        return "object" === typeof n && n && "then" in n ? (s = n, u = !0, queueMicrotask(() => u = !1), be(() => {
                            k(l ? "refreshing" : "pending"), m()
                        }, !1), n.then(e => v(n, e, void 0, t), e => v(n, void 0, Ce(e), t))) : (v(s, n, void 0, t), n)
                    }
                    return Object.defineProperties(C, {
                        state: {
                            get: () => w()
                        },
                        error: {
                            get: () => f()
                        },
                        loading: {
                            get() {
                                const e = w();
                                return "pending" === e || "refreshing" === e
                            }
                        },
                        latest: {
                            get() {
                                if (!l) return C();
                                const e = f();
                                if (e && !s) throw e;
                                return p()
                            }
                        }
                    }), d ? Y(() => I(!1)) : I(!1), [C, {
                        refetch: I,
                        mutate: g
                    }]
                }

                function ee(e) {
                    return be(e, !1)
                }

                function te(e) {
                    if (null === H) return e();
                    const t = H;
                    H = null;
                    try {
                        return e()
                    } finally {
                        H = t
                    }
                }

                function ne(e, t, n) {
                    const r = Array.isArray(e);
                    let o, i = n && n.defer;
                    return n => {
                        let s;
                        if (r) {
                            s = Array(e.length);
                            for (let t = 0; t < e.length; t++) s[t] = e[t]()
                        } else s = e();
                        if (i) return void(i = !1);
                        const a = te(() => t(s, o, n));
                        return o = s, a
                    }
                }

                function re(e) {
                    Z(() => te(e))
                }

                function oe(e) {
                    return null === U || (null === U.cleanups ? U.cleanups = [e] : U.cleanups.push(e)), e
                }

                function ie() {
                    return H
                }

                function se() {
                    return U
                }

                function ae(e, t) {
                    const n = Symbol("context");
                    return {
                        id: n,
                        Provider: xe(n),
                        defaultValue: e
                    }
                }

                function ce(e) {
                    let t;
                    return void 0 !== (t = Ae(U, e.id)) ? t : e.defaultValue
                }

                function ue(e) {
                    const t = X(e),
                        n = X(() => Oe(t()));
                    return n.toArray = () => {
                        const e = n();
                        return Array.isArray(e) ? e : null != e ? [e] : []
                    }, n
                }

                function le() {
                    const e = D;
                    if (this.sources && (this.state || e))
                        if (this.state === W || e) he(this);
                        else {
                            const e = q;
                            q = null, be(() => ke(this), !1), q = e
                        }
                    if (H) {
                        const e = this.observers ? this.observers.length : 0;
                        H.sources ? (H.sources.push(this), H.sourceSlots.push(e)) : (H.sources = [this], H.sourceSlots = [e]), this.observers ? (this.observers.push(H), this.observerSlots.push(H.sources.length - 1)) : (this.observers = [H], this.observerSlots = [H.sources.length - 1])
                    }
                    return this.value
                }

                function de(e, t, n) {
                    let r = e.value;
                    return e.comparator && e.comparator(r, t) || (e.value = t, e.observers && e.observers.length && be(() => {
                        for (let t = 0; t < e.observers.length; t += 1) {
                            const n = e.observers[t],
                                r = D && D.running;
                            r && D.disposed.has(n), (r && !n.tState || !r && !n.state) && (n.pure ? q.push(n) : $.push(n), n.observers && ve(n)), r || (n.state = W)
                        }
                        if (q.length > 1e6) throw q = [], new Error
                    }, !1)), t
                }

                function he(e) {
                    if (!e.fn) return;
                    Se(e);
                    const t = U,
                        n = H,
                        r = V;
                    H = U = e, pe(e, e.value, r), H = n, U = t
                }

                function pe(e, t, n) {
                    let r;
                    try {
                        r = e.fn(t)
                    } catch (o) {
                        e.pure && (e.state = W, e.owned && e.owned.forEach(Se), e.owned = null), Ie(o)
                    }(!e.updatedAt || e.updatedAt <= n) && (null != e.updatedAt && "observers" in e ? de(e, r) : e.value = r, e.updatedAt = n)
                }

                function ge(e, t, n, r = W, o) {
                    const i = {
                        fn: e,
                        state: r,
                        updatedAt: null,
                        owned: null,
                        sources: null,
                        sourceSlots: null,
                        cleanups: null,
                        value: t,
                        owner: U,
                        context: null,
                        pure: n
                    };
                    return null === U || U !== M && (U.owned ? U.owned.push(i) : U.owned = [i]), i
                }

                function fe(e) {
                    const t = D;
                    if (0 === e.state || t) return;
                    if (e.state === N || t) return ke(e);
                    if (e.suspense && te(e.suspense.inFallback)) return e.suspense.effects.push(e);
                    const n = [e];
                    while ((e = e.owner) && (!e.updatedAt || e.updatedAt < V))(e.state || t) && n.push(e);
                    for (let r = n.length - 1; r >= 0; r--)
                        if (e = n[r], e.state === W || t) he(e);
                        else if (e.state === N || t) {
                        const t = q;
                        q = null, be(() => ke(e, n[0]), !1), q = t
                    }
                }

                function be(e, t) {
                    if (q) return e();
                    let n = !1;
                    t || (q = []), $ ? n = !0 : $ = [], V++;
                    try {
                        const t = e();
                        return ye(n), t
                    } catch (r) {
                        n || ($ = null), q = null, Ie(r)
                    }
                }

                function ye(e) {
                    if (q && (me(q), q = null), e) return;
                    const t = $;
                    $ = null, t.length && be(() => L(t), !1)
                }

                function me(e) {
                    for (let t = 0; t < e.length; t++) fe(e[t])
                }

                function we(e) {
                    let t, n = 0;
                    for (t = 0; t < e.length; t++) {
                        const r = e[t];
                        r.user ? e[n++] = r : fe(r)
                    }
                    for (E.context && T(), t = 0; t < n; t++) fe(e[t])
                }

                function ke(e, t) {
                    const n = D;
                    e.state = 0;
                    for (let r = 0; r < e.sources.length; r += 1) {
                        const o = e.sources[r];
                        o.sources && (o.state === W || n ? o !== t && fe(o) : (o.state === N || n) && ke(o, t))
                    }
                }

                function ve(e) {
                    const t = D;
                    for (let n = 0; n < e.observers.length; n += 1) {
                        const r = e.observers[n];
                        r.state && !t || (r.state = N, r.pure ? q.push(r) : $.push(r), r.observers && ve(r))
                    }
                }

                function Se(e) {
                    let t;
                    if (e.sources)
                        while (e.sources.length) {
                            const t = e.sources.pop(),
                                n = e.sourceSlots.pop(),
                                r = t.observers;
                            if (r && r.length) {
                                const e = r.pop(),
                                    o = t.observerSlots.pop();
                                n < r.length && (e.sourceSlots[o] = n, r[n] = e, t.observerSlots[n] = o)
                            }
                        }
                    if (e.owned) {
                        for (t = 0; t < e.owned.length; t++) Se(e.owned[t]);
                        e.owned = null
                    }
                    if (e.cleanups) {
                        for (t = 0; t < e.cleanups.length; t++) e.cleanups[t]();
                        e.cleanups = null
                    }
                    e.state = 0, e.context = null
                }

                function Ce(e) {
                    return e instanceof Error || "string" === typeof e ? e : new Error("Unknown error")
                }

                function Ie(e) {
                    throw e = Ce(e), e
                }

                function Ae(e, t) {
                    return e ? e.context && void 0 !== e.context[t] ? e.context[t] : Ae(e.owner, t) : void 0
                }

                function Oe(e) {
                    if ("function" === typeof e && !e.length) return Oe(e());
                    if (Array.isArray(e)) {
                        const t = [];
                        for (let n = 0; n < e.length; n++) {
                            const r = Oe(e[n]);
                            Array.isArray(r) ? t.push.apply(t, r) : t.push(r)
                        }
                        return t
                    }
                    return e
                }

                function xe(e, t) {
                    return function(t) {
                        let n;
                        return J(() => n = te(() => (U.context = {
                            [e]: t.value
                        }, ue(() => t.children))), void 0), n
                    }
                }
                const _e = Symbol("fallback");

                function Ee(e) {
                    for (let t = 0; t < e.length; t++) e[t]()
                }

                function Te(e, t, n = {}) {
                    let r = [],
                        o = [],
                        i = [],
                        s = 0,
                        a = t.length > 1 ? [] : null;
                    return oe(() => Ee(i)), () => {
                        let c, u, l = e() || [];
                        return l[j], te(() => {
                            let e, t, h, p, g, f, b, y, m, w = l.length;
                            if (0 === w) 0 !== s && (Ee(i), i = [], r = [], o = [], s = 0, a && (a = [])), n.fallback && (r = [_e], o[0] = F(e => (i[0] = e, n.fallback())), s = 1);
                            else if (0 === s) {
                                for (o = new Array(w), u = 0; u < w; u++) r[u] = l[u], o[u] = F(d);
                                s = w
                            } else {
                                for (h = new Array(w), p = new Array(w), a && (g = new Array(w)), f = 0, b = Math.min(s, w); f < b && r[f] === l[f]; f++);
                                for (b = s - 1, y = w - 1; b >= f && y >= f && r[b] === l[y]; b--, y--) h[y] = o[b], p[y] = i[b], a && (g[y] = a[b]);
                                for (e = new Map, t = new Array(y + 1), u = y; u >= f; u--) m = l[u], c = e.get(m), t[u] = void 0 === c ? -1 : c, e.set(m, u);
                                for (c = f; c <= b; c++) m = r[c], u = e.get(m), void 0 !== u && -1 !== u ? (h[u] = o[c], p[u] = i[c], a && (g[u] = a[c]), u = t[u], e.set(m, u)) : i[c]();
                                for (u = f; u < w; u++) u in h ? (o[u] = h[u], i[u] = p[u], a && (a[u] = g[u], a[u](u))) : o[u] = F(d);
                                o = o.slice(0, s = w), r = l.slice(0)
                            }
                            return o
                        });

                        function d(e) {
                            if (i[u] = e, a) {
                                const [e, n] = G(u);
                                return a[u] = n, t(l[u], e)
                            }
                            return t(l[u])
                        }
                    }
                }

                function Pe(e, t) {
                    return te(() => e(t || {}))
                }

                function Re() {
                    return !0
                }
                const je = {
                    get(e, t, n) {
                        return t === R ? n : e.get(t)
                    },
                    has(e, t) {
                        return t === R || e.has(t)
                    },
                    set: Re,
                    deleteProperty: Re,
                    getOwnPropertyDescriptor(e, t) {
                        return {
                            configurable: !0,
                            enumerable: !0,
                            get() {
                                return e.get(t)
                            },
                            set: Re,
                            deleteProperty: Re
                        }
                    },
                    ownKeys(e) {
                        return e.keys()
                    }
                };

                function Be(e) {
                    return (e = "function" === typeof e ? e() : e) ? e : {}
                }

                function Le(...e) {
                    let t = !1;
                    for (let r = 0; r < e.length; r++) {
                        const n = e[r];
                        t = t || !!n && R in n, e[r] = "function" === typeof n ? (t = !0, X(n)) : n
                    }
                    if (t) return new Proxy({
                        get(t) {
                            for (let n = e.length - 1; n >= 0; n--) {
                                const r = Be(e[n])[t];
                                if (void 0 !== r) return r
                            }
                        },
                        has(t) {
                            for (let n = e.length - 1; n >= 0; n--)
                                if (t in Be(e[n])) return !0;
                            return !1
                        },
                        keys() {
                            const t = [];
                            for (let n = 0; n < e.length; n++) t.push(...Object.keys(Be(e[n])));
                            return [...new Set(t)]
                        }
                    }, je);
                    const n = {};
                    for (let r = e.length - 1; r >= 0; r--)
                        if (e[r]) {
                            const t = Object.getOwnPropertyDescriptors(e[r]);
                            for (const r in t) r in n || Object.defineProperty(n, r, {
                                enumerable: !0,
                                get() {
                                    for (let t = e.length - 1; t >= 0; t--) {
                                        const n = (e[t] || {})[r];
                                        if (void 0 !== n) return n
                                    }
                                }
                            })
                        }
                    return n
                }

                function We(e, ...t) {
                    const n = new Set(t.flat());
                    if (R in e) {
                        const r = t.map(t => new Proxy({
                            get(n) {
                                return t.includes(n) ? e[n] : void 0
                            },
                            has(n) {
                                return t.includes(n) && n in e
                            },
                            keys() {
                                return t.filter(t => t in e)
                            }
                        }, je));
                        return r.push(new Proxy({
                            get(t) {
                                return n.has(t) ? void 0 : e[t]
                            },
                            has(t) {
                                return !n.has(t) && t in e
                            },
                            keys() {
                                return Object.keys(e).filter(e => !n.has(e))
                            }
                        }, je)), r
                    }
                    const r = Object.getOwnPropertyDescriptors(e);
                    return t.push(Object.keys(r).filter(e => !n.has(e))), t.map(t => {
                        const n = {};
                        for (let o = 0; o < t.length; o++) {
                            const i = t[o];
                            i in e && Object.defineProperty(n, i, r[i] ? r[i] : {
                                get() {
                                    return e[i]
                                },
                                set() {
                                    return !0
                                },
                                enumerable: !0
                            })
                        }
                        return n
                    })
                }

                function Ne(e) {
                    const t = "fallback" in e && {
                        fallback: () => e.fallback
                    };
                    return X(Te(() => e.each, e.children, t || void 0))
                }

                function Me(e) {
                    let t = !1;
                    const n = e.keyed,
                        r = X(() => e.when, void 0, {
                            equals: (e, n) => t ? e === n : !e === !n
                        });
                    return X(() => {
                        const o = r();
                        if (o) {
                            const r = e.children,
                                i = "function" === typeof r && r.length > 0;
                            return t = n || i, i ? te(() => r(o)) : r
                        }
                        return e.fallback
                    }, void 0, void 0)
                }

                function Ke(e) {
                    let t = !1,
                        n = !1;
                    const r = (e, n) => e[0] === n[0] && (t ? e[1] === n[1] : !e[1] === !n[1]) && e[2] === n[2],
                        o = ue(() => e.children),
                        i = X(() => {
                            let e = o();
                            Array.isArray(e) || (e = [e]);
                            for (let t = 0; t < e.length; t++) {
                                const r = e[t].when;
                                if (r) return n = !!e[t].keyed, [t, r, e[t]]
                            }
                            return [-1]
                        }, void 0, {
                            equals: r
                        });
                    return X(() => {
                        const [r, o, s] = i();
                        if (r < 0) return e.fallback;
                        const a = s.children,
                            c = "function" === typeof a && a.length > 0;
                        return t = n || c, c ? te(() => a(o)) : a
                    }, void 0, void 0)
                }

                function Ue(e) {
                    return e
                }
                const ze = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "controls", "default", "disabled", "formnovalidate", "hidden", "indeterminate", "ismap", "loop", "multiple", "muted", "nomodule", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "seamless", "selected"],
                    De = new Set(["className", "value", "readOnly", "formNoValidate", "isMap", "noModule", "playsInline", ...ze]),
                    He = new Set(["innerHTML", "textContent", "innerText", "children"]),
                    qe = Object.assign(Object.create(null), {
                        className: "class",
                        htmlFor: "for"
                    }),
                    $e = Object.assign(Object.create(null), {
                        class: "className",
                        formnovalidate: "formNoValidate",
                        ismap: "isMap",
                        nomodule: "noModule",
                        playsinline: "playsInline",
                        readonly: "readOnly"
                    }),
                    Ve = new Set(["beforeinput", "click", "dblclick", "contextmenu", "focusin", "focusout", "input", "keydown", "keyup", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "pointerdown", "pointermove", "pointerout", "pointerover", "pointerup", "touchend", "touchmove", "touchstart"]),
                    Fe = new Set(["altGlyph", "altGlyphDef", "altGlyphItem", "animate", "animateColor", "animateMotion", "animateTransform", "circle", "clipPath", "color-profile", "cursor", "defs", "desc", "ellipse", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "filter", "font", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignObject", "g", "glyph", "glyphRef", "hkern", "image", "line", "linearGradient", "marker", "mask", "metadata", "missing-glyph", "mpath", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "set", "stop", "svg", "switch", "symbol", "text", "textPath", "tref", "tspan", "use", "view", "vkern"]),
                    Ge = {
                        xlink: "http://www.w3.org/1999/xlink",
                        xml: "http://www.w3.org/XML/1998/namespace"
                    };

                function Ye(e, t, n) {
                    let r = n.length,
                        o = t.length,
                        i = r,
                        s = 0,
                        a = 0,
                        c = t[o - 1].nextSibling,
                        u = null;
                    while (s < o || a < i)
                        if (t[s] !== n[a]) {
                            while (t[o - 1] === n[i - 1]) o--, i--;
                            if (o === s) {
                                const t = i < r ? a ? n[a - 1].nextSibling : n[i - a] : c;
                                while (a < i) e.insertBefore(n[a++], t)
                            } else if (i === a)
                                while (s < o) u && u.has(t[s]) || t[s].remove(), s++;
                            else if (t[s] === n[i - 1] && n[a] === t[o - 1]) {
                                const r = t[--o].nextSibling;
                                e.insertBefore(n[a++], t[s++].nextSibling), e.insertBefore(n[--i], r), t[o] = n[i]
                            } else {
                                if (!u) {
                                    u = new Map;
                                    let e = a;
                                    while (e < i) u.set(n[e], e++)
                                }
                                const r = u.get(t[s]);
                                if (null != r)
                                    if (a < r && r < i) {
                                        let c, l = s,
                                            d = 1;
                                        while (++l < o && l < i) {
                                            if (null == (c = u.get(t[l])) || c !== r + d) break;
                                            d++
                                        }
                                        if (d > r - a) {
                                            const o = t[s];
                                            while (a < r) e.insertBefore(n[a++], o)
                                        } else e.replaceChild(n[a++], t[s++])
                                    } else s++;
                                else t[s++].remove()
                            }
                        } else s++, a++
                }
                const Je = "_$DX_DELEGATE";

                function Ze(e, t, n, r = {}) {
                    let o;
                    return F(r => {
                        o = r, t === document ? e() : ct(t, e(), t.firstChild ? null : void 0, n)
                    }, r.owner), () => {
                        o(), t.textContent = ""
                    }
                }

                function Xe(e, t, n) {
                    if ("undefined" === typeof window) return null;
                    const r = document.createElement("template");
                    r.innerHTML = e;
                    let o = r.content.firstChild;
                    return n && (o = o.firstChild), o
                }

                function Qe(e, t = window.document) {
                    const n = t[Je] || (t[Je] = new Set);
                    for (let r = 0, o = e.length; r < o; r++) {
                        const o = e[r];
                        n.has(o) || (n.add(o), t.addEventListener(o, gt))
                    }
                }

                function et(e, t, n) {
                    null == n ? e.removeAttribute(t) : e.setAttribute(t, n)
                }

                function tt(e, t, n, r) {
                    null == r ? e.removeAttributeNS(t, n) : e.setAttributeNS(t, n, r)
                }

                function nt(e, t) {
                    null == t ? e.removeAttribute("class") : e.className = t
                }

                function rt(e, t, n, r) {
                    if (r) Array.isArray(n) ? (e["$$" + t] = n[0], e[`$$${t}Data`] = n[1]) : e["$$" + t] = n;
                    else if (Array.isArray(n)) {
                        const r = n[0];
                        e.addEventListener(t, n[0] = t => r.call(e, n[1], t))
                    } else e.addEventListener(t, n)
                }

                function ot(e, t, n = {}) {
                    const r = Object.keys(t || {}),
                        o = Object.keys(n);
                    let i, s;
                    for (i = 0, s = o.length; i < s; i++) {
                        const r = o[i];
                        r && "undefined" !== r && !t[r] && (ht(e, r, !1), delete n[r])
                    }
                    for (i = 0, s = r.length; i < s; i++) {
                        const o = r[i],
                            s = !!t[o];
                        o && "undefined" !== o && n[o] !== s && s && (ht(e, o, !0), n[o] = s)
                    }
                    return n
                }

                function it(e, t, n) {
                    if (!t) return n ? et(e, "style") : t;
                    const r = e.style;
                    if ("string" === typeof t) return r.cssText = t;
                    let o, i;
                    for (i in "string" === typeof n && (r.cssText = n = void 0), n || (n = {}), t || (t = {}), n) null == t[i] && r.removeProperty(i), delete n[i];
                    for (i in t) o = t[i], o !== n[i] && (r.setProperty(i, o), n[i] = o);
                    return n
                }

                function st(e, t = {}, n, r) {
                    const o = {};
                    return r || J(() => o.children = ft(e, t.children, o.children)), J(() => t.ref && t.ref(e)), J(() => ut(e, t, n, !0, o, !0)), o
                }

                function at(e, t, n) {
                    return te(() => e(t, n))
                }

                function ct(e, t, n, r) {
                    if (void 0 === n || r || (r = []), "function" !== typeof t) return ft(e, t, r, n);
                    J(r => ft(e, t(), r, n), r)
                }

                function ut(e, t, n, r, o = {}, i = !1) {
                    t || (t = {});
                    for (const s in o)
                        if (!(s in t)) {
                            if ("children" === s) continue;
                            o[s] = pt(e, s, null, o[s], n, i)
                        }
                    for (const s in t) {
                        if ("children" === s) {
                            r || ft(e, t.children);
                            continue
                        }
                        const a = t[s];
                        o[s] = pt(e, s, a, o[s], n, i)
                    }
                }

                function lt(e) {
                    let t, n;
                    return E.context && (t = E.registry.get(n = wt())) ? (E.completed && E.completed.add(t), E.registry.delete(n), t) : e.cloneNode(!0)
                }

                function dt(e) {
                    return e.toLowerCase().replace(/-([a-z])/g, (e, t) => t.toUpperCase())
                }

                function ht(e, t, n) {
                    const r = t.trim().split(/\s+/);
                    for (let o = 0, i = r.length; o < i; o++) e.classList.toggle(r[o], n)
                }

                function pt(e, t, n, r, o, i) {
                    let s, a, c;
                    if ("style" === t) return it(e, n, r);
                    if ("classList" === t) return ot(e, n, r);
                    if (n === r) return r;
                    if ("ref" === t) i || n(e);
                    else if ("on:" === t.slice(0, 3)) {
                        const o = t.slice(3);
                        r && e.removeEventListener(o, r), n && e.addEventListener(o, n)
                    } else if ("oncapture:" === t.slice(0, 10)) {
                        const o = t.slice(10);
                        r && e.removeEventListener(o, r, !0), n && e.addEventListener(o, n, !0)
                    } else if ("on" === t.slice(0, 2)) {
                        const o = t.slice(2).toLowerCase(),
                            i = Ve.has(o);
                        if (!i && r) {
                            const t = Array.isArray(r) ? r[0] : r;
                            e.removeEventListener(o, t)
                        }(i || n) && (rt(e, o, n, i), i && Qe([o]))
                    } else if ((c = He.has(t)) || !o && ($e[t] || (a = De.has(t))) || (s = e.nodeName.includes("-"))) "class" === t || "className" === t ? nt(e, n) : !s || a || c ? e[$e[t] || t] = n : e[dt(t)] = n;
                    else {
                        const r = o && t.indexOf(":") > -1 && Ge[t.split(":")[0]];
                        r ? tt(e, r, t, n) : et(e, qe[t] || t, n)
                    }
                    return n
                }

                function gt(e) {
                    const t = "$$" + e.type;
                    let n = e.composedPath && e.composedPath()[0] || e.target;
                    e.target !== n && Object.defineProperty(e, "target", {
                        configurable: !0,
                        value: n
                    }), Object.defineProperty(e, "currentTarget", {
                        configurable: !0,
                        get() {
                            return n || document
                        }
                    }), E.registry && !E.done && (E.done = !0, document.querySelectorAll("[id^=pl-]").forEach(t => {
                        while (t && 8 !== t.nodeType && t.nodeValue !== "pl-" + e) {
                            let e = t.nextSibling;
                            t.remove(), t = e
                        }
                        t && t.remove()
                    }));
                    while (n) {
                        const r = n[t];
                        if (r && !n.disabled) {
                            const o = n[t + "Data"];
                            if (void 0 !== o ? r.call(n, o, e) : r.call(n, e), e.cancelBubble) return
                        }
                        n = n._$host || n.parentNode || n.host
                    }
                }

                function ft(e, t, n, r, o) {
                    E.context && !n && (n = [...e.childNodes]);
                    while ("function" === typeof n) n = n();
                    if (t === n) return n;
                    const i = typeof t,
                        s = void 0 !== r;
                    if (e = s && n[0] && n[0].parentNode || e, "string" === i || "number" === i) {
                        if (E.context) return n;
                        if ("number" === i && (t = t.toString()), s) {
                            let o = n[0];
                            o && 3 === o.nodeType ? o.data = t : o = document.createTextNode(t), n = mt(e, n, r, o)
                        } else n = "" !== n && "string" === typeof n ? e.firstChild.data = t : e.textContent = t
                    } else if (null == t || "boolean" === i) {
                        if (E.context) return n;
                        n = mt(e, n, r)
                    } else {
                        if ("function" === i) return J(() => {
                            let o = t();
                            while ("function" === typeof o) o = o();
                            n = ft(e, o, n, r)
                        }), () => n;
                        if (Array.isArray(t)) {
                            const i = [],
                                a = n && Array.isArray(n);
                            if (bt(i, t, n, o)) return J(() => n = ft(e, i, n, r, !0)), () => n;
                            if (E.context) {
                                if (!i.length) return n;
                                for (let e = 0; e < i.length; e++)
                                    if (i[e].parentNode) return n = i
                            }
                            if (0 === i.length) {
                                if (n = mt(e, n, r), s) return n
                            } else a ? 0 === n.length ? yt(e, i, r) : Ye(e, n, i) : (n && mt(e), yt(e, i));
                            n = i
                        } else if (t instanceof Node) {
                            if (E.context && t.parentNode) return n = s ? [t] : t;
                            if (Array.isArray(n)) {
                                if (s) return n = mt(e, n, r, t);
                                mt(e, n, null, t)
                            } else null != n && "" !== n && e.firstChild ? e.replaceChild(t, e.firstChild) : e.appendChild(t);
                            n = t
                        }
                    }
                    return n
                }

                function bt(e, t, n, r) {
                    let o = !1;
                    for (let i = 0, s = t.length; i < s; i++) {
                        let s = t[i],
                            a = n && n[i];
                        if (s instanceof Node) e.push(s);
                        else if (null == s || !0 === s || !1 === s);
                        else if (Array.isArray(s)) o = bt(e, s, a) || o;
                        else if ("function" === typeof s)
                            if (r) {
                                while ("function" === typeof s) s = s();
                                o = bt(e, Array.isArray(s) ? s : [s], Array.isArray(a) ? a : [a]) || o
                            } else e.push(s), o = !0;
                        else {
                            const t = String(s);
                            a && 3 === a.nodeType && a.data === t ? e.push(a) : e.push(document.createTextNode(t))
                        }
                    }
                    return o
                }

                function yt(e, t, n = null) {
                    for (let r = 0, o = t.length; r < o; r++) e.insertBefore(t[r], n)
                }

                function mt(e, t, n, r) {
                    if (void 0 === n) return e.textContent = "";
                    const o = r || document.createTextNode("");
                    if (t.length) {
                        let r = !1;
                        for (let i = t.length - 1; i >= 0; i--) {
                            const s = t[i];
                            if (o !== s) {
                                const t = s.parentNode === e;
                                r || i ? t && s.remove() : t ? e.replaceChild(o, s) : e.insertBefore(o, n)
                            } else r = !0
                        }
                    } else e.insertBefore(o, n);
                    return [o]
                }

                function wt() {
                    const e = E.context;
                    return `${e.id}${e.count++}`
                }
                const kt = "http://www.w3.org/2000/svg";

                function vt(e, t = !1) {
                    return t ? document.createElementNS(kt, e) : document.createElement(e)
                }

                function St(e) {
                    const {
                        useShadow: t
                    } = e, n = document.createTextNode(""), r = e.mount || document.body;

                    function o() {
                        if (E.context) {
                            const [t, n] = G(!1);
                            return queueMicrotask(() => n(!0)), () => t() && e.children
                        }
                        return () => e.children
                    }
                    if (r instanceof HTMLHeadElement) {
                        const [e, t] = G(!1), n = () => t(!0);
                        F(t => ct(r, () => e() ? t() : o()(), null)), oe(() => {
                            E.context ? queueMicrotask(n) : n()
                        })
                    } else {
                        const i = vt(e.isSVG ? "g" : "div", e.isSVG),
                            s = t && i.attachShadow ? i.attachShadow({
                                mode: "open"
                            }) : i;
                        Object.defineProperty(i, "_$host", {
                            get() {
                                return n.parentNode
                            },
                            configurable: !0
                        }), ct(s, o()), r.appendChild(i), e.ref && e.ref(i), oe(() => r.removeChild(i))
                    }
                    return n
                }

                function Ct(e) {
                    const [t, n] = We(e, ["component"]), r = X(() => t.component);
                    return X(() => {
                        const e = r();
                        switch (typeof e) {
                            case "function":
                                return te(() => e(n));
                            case "string":
                                const t = Fe.has(e),
                                    r = E.context ? lt() : vt(e, t);
                                return st(r, n, t), r
                        }
                    })
                }
                var It = (e => (e["DARK"] = "DARK", e["LIGHT"] = "LIGHT", e))(It || {});
                let At = {
                        data: ""
                    },
                    Ot = e => "object" == typeof window ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), {
                        innerHTML: " ",
                        id: "_goober"
                    })).firstChild : e || At,
                    xt = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g,
                    _t = /\/\*[^]*?\*\/|  +/g,
                    Et = /\n+/g,
                    Tt = (e, t) => {
                        let n = "",
                            r = "",
                            o = "";
                        for (let i in e) {
                            let s = e[i];
                            "@" == i[0] ? "i" == i[1] ? n = i + " " + s + ";" : r += "f" == i[1] ? Tt(s, i) : i + "{" + Tt(s, "k" == i[1] ? "" : t) + "}" : "object" == typeof s ? r += Tt(s, t ? t.replace(/([^,])+/g, e => i.replace(/(^:.*)|([^,])+/g, t => /&/.test(t) ? t.replace(/&/g, e) : e ? e + " " + t : t)) : i) : null != s && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += Tt.p ? Tt.p(i, s) : i + ":" + s + ";")
                        }
                        return n + (t && o ? t + "{" + o + "}" : o) + r
                    },
                    Pt = {},
                    Rt = e => {
                        if ("object" == typeof e) {
                            let t = "";
                            for (let n in e) t += n + Rt(e[n]);
                            return t
                        }
                        return e
                    },
                    jt = (e, t, n, r, o) => {
                        let i = Rt(e),
                            s = Pt[i] || (Pt[i] = (e => {
                                let t = 0,
                                    n = 11;
                                for (; t < e.length;) n = 101 * n + e.charCodeAt(t++) >>> 0;
                                return "go" + n
                            })(i));
                        if (!Pt[s]) {
                            let t = i !== e ? e : (e => {
                                let t, n, r = [{}];
                                for (; t = xt.exec(e.replace(_t, ""));) t[4] ? r.shift() : t[3] ? (n = t[3].replace(Et, " ").trim(), r.unshift(r[0][n] = r[0][n] || {})) : r[0][t[1]] = t[2].replace(Et, " ").trim();
                                return r[0]
                            })(e);
                            Pt[s] = Tt(o ? {
                                ["@keyframes " + s]: t
                            } : t, n ? "" : "." + s)
                        }
                        let a = n && Pt.g ? Pt.g : null;
                        return n && (Pt.g = Pt[s]), ((e, t, n, r) => {
                            r ? t.data = t.data.replace(r, e) : -1 === t.data.indexOf(e) && (t.data = n ? e + t.data : t.data + e)
                        })(Pt[s], t, r, a), s
                    },
                    Bt = (e, t, n) => e.reduce((e, r, o) => {
                        let i = t[o];
                        if (i && i.call) {
                            let e = i(n),
                                t = e && e.props && e.props.className || /^go/.test(e) && e;
                            i = t ? "." + t : e && "object" == typeof e ? e.props ? "" : Tt(e, "") : !1 === e ? "" : e
                        }
                        return e + r + (null == i ? "" : i)
                    }, "");

                function Lt(e) {
                    let t = this || {},
                        n = e.call ? e(t.p) : e;
                    return jt(n.unshift ? n.raw ? Bt(n, [].slice.call(arguments, 1), t.p) : n.reduce((e, n) => Object.assign(e, n && n.call ? n(t.p) : n), {}) : n, Ot(t.target), t.g, t.o, t.k)
                }
                Lt.bind({
                    g: 1
                });
                let Wt = Lt.bind({
                    k: 1
                });
                const Nt = ae();

                function Mt(e) {
                    return Pe(Nt.Provider, {
                        value: e.theme,
                        get children() {
                            return e.children
                        }
                    })
                }

                function Kt() {
                    return ce(Nt)
                }

                function Ut(e) {
                    let t = this || {};
                    return (...n) => {
                        const r = r => {
                            const o = ce(Nt),
                                i = Le(r, {
                                    theme: o
                                }),
                                s = Le(i, {
                                    get class() {
                                        const e = i.class,
                                            r = "class" in i && /^go[0-9]+/.test(e);
                                        let o = Lt.apply({
                                            target: t.target,
                                            o: r,
                                            p: i,
                                            g: t.g
                                        }, n);
                                        return [e, o].filter(Boolean).join(" ")
                                    }
                                }),
                                [a, c] = We(s, ["as", "theme"]),
                                u = c,
                                l = a.as || e;
                            let d;
                            return "function" === typeof l ? d = l(u) : 1 == t.g ? (d = document.createElement(l), st(d, u)) : d = Ct(Le({
                                component: l
                            }, u)), d
                        };
                        return r.class = e => te(() => Lt.apply({
                            target: t.target,
                            p: e,
                            g: t.g
                        }, n)), r
                    }
                }
                const zt = new Proxy(Ut, {
                    get(e, t) {
                        return e(t)
                    }
                });

                function Dt() {
                    const e = Ut.call({
                        g: 1
                    }, "div").apply(null, arguments);
                    return function(t) {
                        return e(t), null
                    }
                }
                const Ht = "tc-root",
                    qt = "tc-disable-scroll",
                    $t = "tc-using-mouse",
                    Vt = () => {
                        document.body.addEventListener("mousedown", () => document.body.classList.add($t)), document.body.addEventListener("keydown", e => {
                            "Tab" === e.key && document.body.classList.remove($t)
                        });
                        const e = Dt `
    ${Ht} * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        
        font-family: -apple-system, BlinkMacSystemFont, 'Roboto', 'Helvetica Neue', Arial, Tahoma, Verdana, sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;        
        -webkit-tap-highlight-color: transparent;
    }
    
    ${Ht} img {
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }   
 
    ${Ht} *:focus {
        outline: #08f auto 2px;
    }
    
    ${Ht} li {
        list-style: none;
    }
    
    ${Ht} button {
        outline: none;
    }
    
    body.${qt} {
        position: fixed; 
        overflow-y: scroll;
        right: 0;
        left: 0;
    }
    
    body.${$t} ${Ht} *:focus {
        outline: none;
    }
`;
                        return Pe(e, {})
                    };

                function Ft(e) {
                    "#" === e[0] && (e = e.slice(1));
                    const t = parseInt(e, 16),
                        n = t >> 16 & 255,
                        r = t >> 8 & 255,
                        o = 255 & t;
                    return [n, r, o].join(",")
                }

                function Gt(e, t) {
                    return "#" === e[0] && (e = Ft(e)), `rgba(${e}, ${t})`
                }

                function Yt(e) {
                    return e.toString() + "px"
                }
                const Jt = class {
                    constructor() {
                        x(this, "storage", {})
                    }
                    static getInstance() {
                        return Jt.instance || (Jt.instance = new Jt), Jt.instance
                    }
                    get length() {
                        return Object.keys(this.storage).length
                    }
                    clear() {
                        this.storage = {}
                    }
                    getItem(e) {
                        var t;
                        return null != (t = this.storage[e]) ? t : null
                    }
                    key(e) {
                        var t;
                        const n = Object.keys(this.storage);
                        return e < 0 || e >= n.length ? null : null != (t = n[e]) ? t : null
                    }
                    removeItem(e) {
                        delete this.storage[e]
                    }
                    setItem(e, t) {
                        this.storage[e] = t
                    }
                };
                let Zt = Jt;
                x(Zt, "instance");
                class Xt extends d["TonConnectError"] {
                    constructor(...e) {
                        super(...e), Object.setPrototypeOf(this, Xt.prototype)
                    }
                }

                function Qt(...e) {
                    try {
                        console.debug("[TON_CONNECT_UI]", ...e)
                    } catch (t) {}
                }

                function en(...e) {
                    try {
                        console.error("[TON_CONNECT_UI]", ...e)
                    } catch (t) {}
                }

                function tn(...e) {
                    try {
                        console.warn("[TON_CONNECT_UI]", ...e)
                    } catch (t) {}
                }

                function nn(e, t = "_self") {
                    Qt("openLink", e, t), window.open(e, t, "noopener noreferrer")
                }

                function rn(e) {
                    nn(e, "_blank")
                }

                function on(e, t) {
                    const n = () => {
                            vn("safari") || kn("android") && vn("firefox") || t()
                        },
                        r = setTimeout(() => n(), 200);
                    window.addEventListener("blur", () => clearTimeout(r), {
                        once: !0
                    }), nn(e, "_self")
                }

                function sn() {
                    return window.matchMedia && window.matchMedia("(prefers-color-scheme: light)").matches ? It.LIGHT : It.DARK
                }

                function an(e) {
                    const t = t => e(t.matches ? It.DARK : It.LIGHT);
                    return window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", t), () => window.matchMedia("(prefers-color-scheme: dark)").removeEventListener("change", t)
                }

                function cn() {
                    document.documentElement.scrollHeight !== document.documentElement.clientHeight && (document.body.style.top = Yt(-document.documentElement.scrollTop), document.body.classList.add(qt))
                }

                function un() {
                    document.body.classList.remove(qt), document.documentElement.scrollTo({
                        top: -parseFloat(getComputedStyle(document.body).top)
                    }), document.body.style.top = "auto"
                }

                function ln() {
                    document.body.hasAttribute("ontouchstart") || document.body.setAttribute("ontouchstart", "")
                }

                function dn() {
                    customElements.define(Ht, class extends HTMLElement {})
                }

                function hn(e) {
                    return _(this, null, (function*() {
                        yield new Promise(e => requestAnimationFrame(e)), e()
                    }))
                }

                function pn(e) {
                    return _(this, null, (function*() {
                        return yield new Promise(e => requestAnimationFrame(e)), e()
                    }))
                }

                function gn(e) {
                    "complete" !== document.readyState ? window.addEventListener("load", () => hn(() => gn(e)), {
                        once: !0
                    }) : e.forEach(e => {
                        const t = new window.Image;
                        t.src = e
                    })
                }

                function fn() {
                    if ("undefined" !== typeof window) return window
                }

                function bn() {
                    if (yn()) return localStorage;
                    if (mn()) throw new Xt("`localStorage` is unavailable, but it is required for TonConnect. For more details, see https://github.com/ton-connect/sdk/tree/main/packages/sdk#init-connector");
                    return Zt.getInstance()
                }

                function yn() {
                    try {
                        return "undefined" !== typeof localStorage
                    } catch (e) {
                        return !1
                    }
                }

                function mn() {
                    return "undefined" !== typeof e && null != e.versions && null != e.versions.node
                }

                function wn() {
                    var e, t, n;
                    const r = (new p.a).getResult(),
                        o = null == (e = r.os.name) ? void 0 : e.toLowerCase(),
                        i = null == (t = r.device.model) ? void 0 : t.toLowerCase();
                    let s;
                    switch (!0) {
                        case "ipad" === i:
                            s = "ipad";
                            break;
                        case "ios" === o:
                            s = "ios";
                            break;
                        case "android" === o:
                            s = "android";
                            break;
                        case "mac os" === o:
                            s = "macos";
                            break;
                        case "linux" === o:
                            s = "linux";
                            break;
                        case null == o ? void 0:
                            o.includes("windows"): s = "windows";
                            break
                    }
                    const a = null == (n = r.browser.name) ? void 0 : n.toLowerCase();
                    let c;
                    switch (!0) {
                        case "chrome" === a:
                            c = "chrome";
                            break;
                        case "firefox" === a:
                            c = "firefox";
                            break;
                        case null == a ? void 0:
                            a.includes("safari"): c = "safari";
                            break;
                        case null == a ? void 0:
                            a.includes("opera"): c = "opera";
                            break
                    }
                    return {
                        os: s,
                        browser: c
                    }
                }

                function kn(...e) {
                    return e.includes(wn().os)
                }

                function vn(...e) {
                    return e.includes(wn().browser)
                }

                function Sn(e, t) {
                    const n = new URL(e);
                    return t + n.search
                }
                class Cn {
                    constructor() {
                        x(this, "localStorage"), x(this, "storageKey", "ton-connect-ui_wallet-info"), this.localStorage = bn()
                    }
                    setWalletInfo(e) {
                        this.localStorage.setItem(this.storageKey, JSON.stringify(e))
                    }
                    getWalletInfo() {
                        const e = this.localStorage.getItem(this.storageKey);
                        return e ? JSON.parse(e) : null
                    }
                    removeWalletInfo() {
                        this.localStorage.removeItem(this.storageKey)
                    }
                }
                class In {
                    constructor() {
                        x(this, "localStorage"), x(this, "storageKey", "ton-connect-ui_preferred-wallet"), this.localStorage = bn()
                    }
                    setPreferredWalletAppName(e) {
                        this.localStorage.setItem(this.storageKey, e)
                    }
                    getPreferredWalletAppName() {
                        return this.localStorage.getItem(this.storageKey) || void 0
                    }
                }
                class An {
                    constructor() {
                        x(this, "localStorage"), x(this, "storageKey", "ton-connect-ui_last-selected-wallet-info"), this.localStorage = bn()
                    }
                    setLastSelectedWalletInfo(e) {
                        this.localStorage.setItem(this.storageKey, JSON.stringify(e))
                    }
                    getLastSelectedWalletInfo() {
                        const e = this.localStorage.getItem(this.storageKey);
                        return e ? JSON.parse(e) : null
                    }
                    removeLastSelectedWalletInfo() {
                        this.localStorage.removeItem(this.storageKey)
                    }
                }
                const [On, xn] = G({
                    status: "closed",
                    closeReason: null
                }), _n = X(() => "opened" === On().status), [En, Tn] = G({
                    status: "closed",
                    closeReason: null
                }), Pn = X(() => "opened" === En().status), Rn = X(() => {
                    const e = En();
                    return "opened" === e.status ? e.walletInfo : null
                });
                let jn = "undefined" !== typeof window ? new An : void 0;
                const [Bn, Ln] = G((null == jn ? void 0 : jn.getLastSelectedWalletInfo()) || null), Wn = e => {
                    jn || (jn = new An), e ? jn.setLastSelectedWalletInfo(e) : jn.removeLastSelectedWalletInfo(), Ln(e)
                }, [Nn, Mn] = G(null), Kn = {
                    close: "Close",
                    openWallet: "Open wallet",
                    copyLink: "Copy Link",
                    linkCopied: "Link Copied",
                    copied: "Copied",
                    yourWallet: "Your Wallet",
                    retry: "Retry",
                    get: "GET",
                    mobile: "Mobile",
                    browserExtension: "Browser Extension",
                    desktop: "Desktop"
                }, Un = {
                    connectWallet: "Connect Wallet",
                    dropdown: {
                        copy: "Copy address",
                        copied: "Address copied!",
                        disconnect: "Disconnect"
                    }
                }, zn = {
                    confirm: {
                        header: "Open {{ name }} toconfirm thetransaction."
                    },
                    transactionSent: {
                        header: "Transaction sent",
                        text: "Your transactionwill beprocessed inafew seconds."
                    },
                    transactionCanceled: {
                        header: "Transaction canceled",
                        text: "There will be no changes toyour account."
                    }
                }, Dn = {
                    walletOn: "Wallet On",
                    recent: "Recent",
                    installed: "Installed",
                    popular: "Popular"
                }, Hn = {
                    loading: "Loading wallets",
                    wallets: "Wallets",
                    mobileUniversalModal: {
                        connectYourWallet: "Connect your wallet",
                        openWalletOnTelegramOrSelect: "Open Wallet in Telegram or select your wallet to connect",
                        openWalletOnTelegram: "Open Wallet in Telegram",
                        openLink: "Open Link",
                        scan: "Scan with your mobile wallet"
                    },
                    desktopUniversalModal: {
                        connectYourWallet: "Connect your wallet",
                        scan: "Scan with your mobile wallet",
                        availableWallets: "Available wallets"
                    },
                    mobileConnectionModal: {
                        showQR: "Show QR Code",
                        scanQR: "Scan theQR code below with your phonesor{{ name }}s camera",
                        continueIn: "Continue in {{ name }}",
                        connectionDeclined: "Connection declined"
                    },
                    desktopConnectionModal: {
                        scanQR: "Scan theQR code below with your phonesor{{ name }}s camera",
                        continueInExtension: "Continue in{{ name }} browser extension",
                        dontHaveExtension: "Seems you don't have installed {{ name }}browserextension",
                        getWallet: "Get {{ name }}",
                        continueOnDesktop: "Continue in{{ name }} on desktop",
                        openWalletOnTelegram: "Open Wallet in Telegram on desktop",
                        connectionDeclined: "Connection declined"
                    },
                    infoModal: {
                        whatIsAWallet: "What is a wallet",
                        secureDigitalAssets: "Secure digital assets storage",
                        walletProtects: "A wallet protects and manages your digital assetsincluding TON, tokens and collectables.",
                        controlIdentity: "Control your Web3 identity",
                        manageIdentity: "Manage your digital identity and access decentralized applications with ease. Maintain control over your data and engage securely intheblockchain ecosystem.",
                        effortlessCryptoTransactions: "Effortless crypto transactions",
                        easilySend: "Easily send, receive, monitor your cryptocurrencies.Streamline your operations withdecentralized applications.",
                        getAWallet: "Get a Wallet"
                    }
                }, qn = {
                    confirmTransaction: {
                        header: "Confirm thetransaction in{{ name }}",
                        text: "It will only take amoment."
                    },
                    transactionSent: "$notifications.transactionSent",
                    transactionCanceled: "$notifications.transactionCanceled"
                }, $n = {
                    common: Kn,
                    button: Un,
                    notifications: zn,
                    walletItem: Dn,
                    walletModal: Hn,
                    actionModal: qn
                }, Vn = {
                    close: "",
                    openWallet: " ",
                    copyLink: " ",
                    linkCopied: " ",
                    copied: " ",
                    yourWallet: " ",
                    retry: "",
                    get: "",
                    mobile: "",
                    browserExtension: "",
                    desktop: ""
                }, Fn = {
                    connectWallet: " ",
                    dropdown: {
                        copy: " ",
                        copied: " !",
                        disconnect: " "
                    }
                }, Gn = {
                    confirm: {
                        header: " {{ name }},  ."
                    },
                    transactionSent: {
                        header: " ",
                        text: "    ."
                    },
                    transactionCanceled: {
                        header: " ",
                        text: "   ."
                    }
                }, Yn = {
                    walletOn: "Wallet ",
                    recent: "",
                    installed: "",
                    popular: ""
                }, Jn = {
                    loading: " ",
                    wallets: "",
                    mobileUniversalModal: {
                        connectYourWallet: " ",
                        openWalletOnTelegramOrSelect: " Wallet Telegram   ",
                        openWalletOnTelegram: " Wallet  Telegram",
                        openLink: " ",
                        scan: "  "
                    },
                    desktopUniversalModal: {
                        connectYourWallet: " ",
                        scan: " QR-  ",
                        availableWallets: " "
                    },
                    mobileConnectionModal: {
                        showQR: " QR-",
                        scanQR: " QR-    {{ name }},  ",
                        continueIn: "  {{ name }}",
                        connectionDeclined: " "
                    },
                    desktopConnectionModal: {
                        scanQR: " QR-    {{ name }},  ",
                        continueInExtension: "   {{ name }}",
                        dontHaveExtension: ",    {{ name }}",
                        getWallet: " {{ name }}",
                        continueOnDesktop: " {{ name }} ",
                        openWalletOnTelegram: " Wallet Telegram",
                        connectionDeclined: " "
                    },
                    infoModal: {
                        whatIsAWallet: "  ?",
                        secureDigitalAssets: "   ",
                        walletProtects: "    ,  TON,   ,  .",
                        controlIdentity: "   Web3",
                        manageIdentity: "        .       .",
                        effortlessCryptoTransactions: " ",
                        easilySend: " ,    .      .",
                        getAWallet: " "
                    }
                }, Zn = {
                    confirmTransaction: {
                        header: "  {{ name }}",
                        text: "   ."
                    },
                    transactionSent: "$notifications.transactionSent",
                    transactionCanceled: "$notifications.transactionCanceled"
                }, Xn = {
                    common: Vn,
                    button: Fn,
                    notifications: Gn,
                    walletItem: Yn,
                    walletModal: Jn,
                    actionModal: Zn
                }, Qn = {
                    en: er($n),
                    ru: er(Xn)
                };

                function er(e) {
                    const t = "$",
                        n = r => {
                            Object.entries(r).forEach(([o, i]) => {
                                if ("object" === typeof i && i) return n(i);
                                if ("string" === typeof i) {
                                    if (i[0] === t) {
                                        const t = i.slice(1).split(".");
                                        let n = e;
                                        t.forEach(e => {
                                            if (!(e in n)) throw new Error(`Cannot parse translations: there is no property ${e} in translation`);
                                            n = n[e]
                                        }), r[o] = n
                                    }
                                    i.slice(0, 2) === "\\" + t && (r[o] = i.slice(1))
                                }
                            })
                        };
                    return n(e), e
                }
                const tr = ae(),
                    nr = Symbol("store-raw"),
                    rr = Symbol("store-node"),
                    or = Symbol("store-name");

                function ir(e, t) {
                    let n = e[R];
                    if (!n && (Object.defineProperty(e, R, {
                            value: n = new Proxy(e, gr)
                        }), !Array.isArray(e))) {
                        const t = Object.keys(e),
                            r = Object.getOwnPropertyDescriptors(e);
                        for (let o = 0, i = t.length; o < i; o++) {
                            const i = t[o];
                            r[i].get && Object.defineProperty(e, i, {
                                enumerable: r[i].enumerable,
                                get: r[i].get.bind(n)
                            })
                        }
                    }
                    return n
                }

                function sr(e) {
                    let t;
                    return null != e && "object" === typeof e && (e[R] || !(t = Object.getPrototypeOf(e)) || t === Object.prototype || Array.isArray(e))
                }

                function ar(e, t = new Set) {
                    let n, r, o, i;
                    if (n = null != e && e[nr]) return n;
                    if (!sr(e) || t.has(e)) return e;
                    if (Array.isArray(e)) {
                        Object.isFrozen(e) ? e = e.slice(0) : t.add(e);
                        for (let n = 0, i = e.length; n < i; n++) o = e[n], (r = ar(o, t)) !== o && (e[n] = r)
                    } else {
                        Object.isFrozen(e) ? e = Object.assign({}, e) : t.add(e);
                        const n = Object.keys(e),
                            s = Object.getOwnPropertyDescriptors(e);
                        for (let a = 0, c = n.length; a < c; a++) i = n[a], s[i].get || (o = e[i], (r = ar(o, t)) !== o && (e[i] = r))
                    }
                    return e
                }

                function cr(e) {
                    let t = e[rr];
                    return t || Object.defineProperty(e, rr, {
                        value: t = {}
                    }), t
                }

                function ur(e, t, n) {
                    return e[t] || (e[t] = pr(n))
                }

                function lr(e, t) {
                    const n = Reflect.getOwnPropertyDescriptor(e, t);
                    return n && !n.get && n.configurable && t !== R && t !== rr && t !== or ? (delete n.value, delete n.writable, n.get = () => e[R][t], n) : n
                }

                function dr(e) {
                    if (ie()) {
                        const t = cr(e);
                        (t._ || (t._ = pr()))()
                    }
                }

                function hr(e) {
                    return dr(e), Reflect.ownKeys(e)
                }

                function pr(e) {
                    const [t, n] = G(e, {
                        equals: !1,
                        internal: !0
                    });
                    return t.$ = n, t
                }
                const gr = {
                    get(e, t, n) {
                        if (t === nr) return e;
                        if (t === R) return n;
                        if (t === j) return dr(e), n;
                        const r = cr(e),
                            o = r.hasOwnProperty(t);
                        let i = o ? r[t]() : e[t];
                        if (t === rr || "__proto__" === t) return i;
                        if (!o) {
                            const n = Object.getOwnPropertyDescriptor(e, t);
                            !ie() || "function" === typeof i && !e.hasOwnProperty(t) || n && n.get || (i = ur(r, t, i)())
                        }
                        return sr(i) ? ir(i) : i
                    },
                    has(e, t) {
                        return t === nr || t === R || t === j || t === rr || "__proto__" === t || (this.get(e, t, e), t in e)
                    },
                    set() {
                        return !0
                    },
                    deleteProperty() {
                        return !0
                    },
                    ownKeys: hr,
                    getOwnPropertyDescriptor: lr
                };

                function fr(e, t, n, r = !1) {
                    if (!r && e[t] === n) return;
                    const o = e[t],
                        i = e.length;
                    void 0 === n ? delete e[t] : e[t] = n;
                    let s, a = cr(e);
                    (s = ur(a, t, o)) && s.$(() => n), Array.isArray(e) && e.length !== i && (s = ur(a, "length", i)) && s.$(e.length), (s = a._) && s.$()
                }

                function br(e, t) {
                    const n = Object.keys(t);
                    for (let r = 0; r < n.length; r += 1) {
                        const o = n[r];
                        fr(e, o, t[o])
                    }
                }

                function yr(e, t) {
                    if ("function" === typeof t && (t = t(e)), t = ar(t), Array.isArray(t)) {
                        if (e === t) return;
                        let n = 0,
                            r = t.length;
                        for (; n < r; n++) {
                            const r = t[n];
                            e[n] !== r && fr(e, n, r)
                        }
                        fr(e, "length", r)
                    } else br(e, t)
                }

                function mr(e, t, n = []) {
                    let r, o = e;
                    if (t.length > 1) {
                        r = t.shift();
                        const i = typeof r,
                            s = Array.isArray(e);
                        if (Array.isArray(r)) {
                            for (let o = 0; o < r.length; o++) mr(e, [r[o]].concat(t), n);
                            return
                        }
                        if (s && "function" === i) {
                            for (let o = 0; o < e.length; o++) r(e[o], o) && mr(e, [o].concat(t), n);
                            return
                        }
                        if (s && "object" === i) {
                            const {
                                from: o = 0,
                                to: i = e.length - 1,
                                by: s = 1
                            } = r;
                            for (let r = o; r <= i; r += s) mr(e, [r].concat(t), n);
                            return
                        }
                        if (t.length > 1) return void mr(e[r], t, [r].concat(n));
                        o = e[r], n = [r].concat(n)
                    }
                    let i = t[0];
                    "function" === typeof i && (i = i(o, n), i === o) || void 0 === r && void 0 == i || (i = ar(i), void 0 === r || sr(o) && sr(i) && !Array.isArray(i) ? br(o, i) : fr(e, r, i))
                }

                function wr(...[e, t]) {
                    const n = ar(e || {}),
                        r = Array.isArray(n),
                        o = ir(n);

                    function i(...e) {
                        ee(() => {
                            r && 1 === e.length ? yr(n, e[0]) : mr(n, e)
                        })
                    }
                    return [o, i]
                }
                const kr = {
                        constant: {
                            black: "#000000",
                            white: "#FFFFFF"
                        },
                        connectButton: {
                            background: "#0098EA",
                            foreground: "#FFFFFF"
                        },
                        accent: "#0098EA",
                        telegramButton: "#0098EA",
                        icon: {
                            primary: "#0F0F0F",
                            secondary: "#7A8999",
                            tertiary: "#C1CAD2",
                            success: "#29CC6A",
                            error: "#F5A73B"
                        },
                        background: {
                            primary: "#FFFFFF",
                            secondary: "#F1F3F5",
                            segment: "#FFFFFF",
                            tint: "#F1F3F5",
                            qr: "#F1F3F5"
                        },
                        text: {
                            primary: "#0F0F0F",
                            secondary: "#6A7785"
                        }
                    },
                    vr = {
                        constant: {
                            black: "#000000",
                            white: "#FFFFFF"
                        },
                        connectButton: {
                            background: "#0098EA",
                            foreground: "#FFFFFF"
                        },
                        accent: "#E5E5EA",
                        telegramButton: "#31A6F5",
                        icon: {
                            primary: "#E5E5EA",
                            secondary: "#909099",
                            tertiary: "#434347",
                            success: "#29CC6A",
                            error: "#F5A73B"
                        },
                        background: {
                            primary: "#121214",
                            secondary: "#18181A",
                            segment: "#262629",
                            tint: "#222224",
                            qr: "#FFFFFF"
                        },
                        text: {
                            primary: "#E5E5EA",
                            secondary: "#7D7D85"
                        }
                    };
                /*!
                 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
                 *
                 * Copyright (c) 2014-2017, Jon Schlinkert.
                 * Released under the MIT License.
                 */
                function Sr(e) {
                    return "[object Object]" === Object.prototype.toString.call(e)
                }

                function Cr(e) {
                    var t, n;
                    return !1 !== Sr(e) && (t = e.constructor, void 0 === t || (n = t.prototype, !1 !== Sr(n) && !1 !== n.hasOwnProperty("isPrototypeOf")))
                }

                function Ir(e, t) {
                    if (!e) return t;
                    const n = (e, t, n) => t;
                    return f()(t, e, {
                        arrayMerge: n,
                        isMergeableObject: Cr
                    })
                }
                const [Ar, Or] = wr({
                    theme: It.LIGHT,
                    colors: kr,
                    borderRadius: "m"
                }), xr = {
                    [It.LIGHT]: kr,
                    [It.DARK]: vr
                }, _r = {
                    [It.LIGHT]: void 0,
                    [It.DARK]: void 0
                };

                function Er(e, t) {
                    t && (_r[It.DARK] = Ir(t[It.DARK], _r[It.DARK]), _r[It.LIGHT] = Ir(t[It.LIGHT], _r[It.LIGHT])), Or({
                        theme: e,
                        colors: Ir(_r[e], xr[e])
                    })
                }

                function Tr(e) {
                    Or({
                        borderRadius: e
                    })
                }

                function Pr(e) {
                    _r[It.DARK] = Ir(e[It.DARK], _r[It.DARK]), _r[It.LIGHT] = Ir(e[It.LIGHT], _r[It.LIGHT]), Or(e => ({
                        colors: Ir(_r[e.theme], xr[e.theme])
                    }))
                }
                const Rr = zt.div `
    background-color: ${e=>e.theme.colors.background.secondary};
`,
                    jr = e => {
                        let t;
                        const [n, r] = G(null);
                        return Z(() => {
                            const t = new window.Image;
                            return t.src = e.src, t.alt = e.alt || "", t.setAttribute("draggable", "false"), e.class && t.classList.add(e.class), t.complete ? r(t) : (t.addEventListener("load", () => r(t)), () => t.removeEventListener("load", () => r(t)))
                        }), [Pe(Me, {
                            get when() {
                                return n()
                            },
                            get children() {
                                return n()
                            }
                        }), Pe(Me, {
                            get when() {
                                return !n()
                            },
                            get children() {
                                return Pe(Rr, {
                                    get ["class"]() {
                                        return e.class
                                    },
                                    ref(e) {
                                        const n = t;
                                        "function" === typeof n ? n(e) : t = e
                                    }
                                })
                            }
                        })]
                    };
                let Br = {};
                try {
                    let e = location.hash.toString();
                    Br = Hr(e)
                } catch (Ll) {}
                let Lr = "unknown";
                if ((null == Br ? void 0 : Br.tgWebAppPlatform) && (Lr = null != (r = Br.tgWebAppPlatform) ? r : "unknown"), "unknown" === Lr) {
                    const e = fn();
                    Lr = null != (s = null == (i = null == (o = null == e ? void 0 : e.Telegram) ? void 0 : o.WebApp) ? void 0 : i.platform) ? s : "unknown"
                }
                let Wr = "6.0";
                if ((null == Br ? void 0 : Br.tgWebAppVersion) && (Wr = Br.tgWebAppVersion), !Wr) {
                    const e = fn();
                    Wr = null != (u = null == (c = null == (a = null == e ? void 0 : e.Telegram) ? void 0 : a.WebApp) ? void 0 : c.version) ? u : "6.0"
                }

                function Nr(...e) {
                    return e.includes(Lr)
                }

                function Mr() {
                    var e;
                    return "unknown" !== Lr || !!(null == (e = fn()) ? void 0 : e.TelegramWebviewProxy)
                }

                function Kr() {
                    Dr("web_app_expand", {})
                }

                function Ur(e, t) {
                    const n = new URL(e);
                    if ("http:" !== n.protocol && "https:" !== n.protocol) {
                        if (t) return t();
                        throw new Xt("Url protocol is not supported: " + n)
                    }
                    if ("t.me" !== n.hostname) {
                        if (t) return t();
                        throw new Xt("Url host is not supported: " + n)
                    }
                    const r = n.pathname + n.search;
                    zr() || Fr("6.1") ? Dr("web_app_open_tg_link", {
                        path_full: r
                    }) : rn("https://t.me" + r)
                }

                function zr() {
                    try {
                        const e = fn();
                        return !!e && (null != e.parent && e !== e.parent)
                    } catch (Ll) {
                        return !1
                    }
                }

                function Dr(e, t) {
                    try {
                        const n = fn();
                        if (!n) throw new Xt("Can't post event to parent window: window is not defined");
                        if (void 0 !== n.TelegramWebviewProxy) Qt("postEvent", e, t), n.TelegramWebviewProxy.postEvent(e, JSON.stringify(t));
                        else if (n.external && "notify" in n.external) Qt("postEvent", e, t), n.external.notify(JSON.stringify({
                            eventType: e,
                            eventData: t
                        }));
                        else {
                            if (!zr()) throw new Xt("Can't post event to TMA"); {
                                const r = "*",
                                    o = JSON.stringify({
                                        eventType: e,
                                        eventData: t
                                    });
                                Qt("postEvent", e, t), n.parent.postMessage(o, r)
                            }
                        }
                    } catch (Ll) {
                        en("Can't post event to parent window: " + Ll)
                    }
                }

                function Hr(e) {
                    e = e.replace(/^#/, "");
                    let t = {};
                    if (!e.length) return t;
                    if (e.indexOf("=") < 0 && e.indexOf("?") < 0) return t._path = qr(e), t;
                    let n = e.indexOf("?");
                    if (n >= 0) {
                        let r = e.substr(0, n);
                        t._path = qr(r), e = e.substr(n + 1)
                    }
                    let r = $r(e);
                    for (let o in r) t[o] = r[o];
                    return t
                }

                function qr(e) {
                    try {
                        return e = e.replace(/\+/g, "%20"), decodeURIComponent(e)
                    } catch (Ll) {
                        return e
                    }
                }

                function $r(e) {
                    let t = {};
                    if (!e.length) return t;
                    let n, r, o, i, s = e.split("&");
                    for (n = 0; n < s.length; n++) r = s[n].split("="), o = qr(r[0]), i = null == r[1] ? null : qr(r[1]), t[o] = i;
                    return t
                }

                function Vr(e, t) {
                    "string" !== typeof e && (e = ""), "string" !== typeof t && (t = "");
                    let n, r, o, i, s = e.replace(/^\s+|\s+$/g, "").split("."),
                        a = t.replace(/^\s+|\s+$/g, "").split(".");
                    for (n = Math.max(s.length, a.length), r = 0; r < n; r++)
                        if (o = parseInt(s[r]) || 0, i = parseInt(a[r]) || 0, o !== i) return o > i ? 1 : -1;
                    return 0
                }

                function Fr(e) {
                    return Vr(Wr, e) >= 0
                }
                const Gr = {
                    mobile: 440,
                    tablet: 1020
                };

                function Yr(e) {
                    const t = fn();
                    if (!t) return "desktop" === e;
                    if (Nr("weba")) return !0;
                    const n = t.innerWidth;
                    switch (e) {
                        case "desktop":
                            return n > Gr.tablet;
                        case "tablet":
                            return n > Gr.mobile;
                        default:
                        case "mobile":
                            return n <= Gr.mobile || kn("ios", "android", "ipad")
                    }
                }

                function Jr(e) {
                    switch (e) {
                        case "mobile":
                            return `@media (max-width: ${Gr.mobile}px)`;
                        case "tablet":
                            return `@media (max-width: ${Gr.tablet}px) (min-width: ${Gr.mobile}px)`;
                        default:
                        case "desktop":
                            return `@media (min-width: ${Gr.tablet}px)`
                    }
                }
                const Zr = "@media (hover: none)",
                    Xr = "@media not all and (hover: none)",
                    Qr = {
                        m: "100vh",
                        s: "8px",
                        none: "0"
                    },
                    eo = {
                        s: .02,
                        m: .04
                    },
                    to = zt.button `
    display: ${e=>e.leftIcon||e.rightIcon?"flex":"inline-block"};
    gap: ${e=>e.leftIcon||e.rightIcon?"6px":"unset"};
    align-items: ${e=>e.leftIcon||e.rightIcon?"center":"unset"};
    justify-content: ${e=>e.leftIcon||e.rightIcon?"space-between":"unset"};
    background-color: ${e=>"flat"===e.appearance?"transparent":"secondary"===e.appearance?e.theme.colors.background.tint:Gt(e.theme.colors.accent,.12)};
    color: ${e=>"secondary"===e.appearance?e.theme.colors.text.primary:e.theme.colors.accent};

    padding: ${e=>"flat"===e.appearance?"0":"9px 16px"};
    padding-left: ${e=>e.leftIcon&&"flat"!==e.appearance?"12px":"16px"};
    padding-right: ${e=>e.rightIcon&&"flat"!==e.appearance?"12px":"16px"};
    border: none;
    border-radius: ${e=>Qr[e.theme.borderRadius]};
    cursor: ${e=>e.disabled?"not-allowed":"pointer"};

    font-size: 14px;
    font-weight: 590;
    line-height: 18px;

    transition: transform 0.125s ease-in-out;

    ${Xr} {
        &:hover {
            transform: ${e=>e.disabled?"unset":`scale(${1+eo[e.scale]})`};
        }
    }

    &:active {
        transform: ${e=>e.disabled?"unset":`scale(${1-eo[e.scale]})`};
    }

    ${Zr} {
        &:active {
            transform: ${e=>e.disabled?"unset":`scale(${1-2*eo[e.scale]})`};
        }
    }
`;

                function no(e) {
                    const t = te(() => Object.keys(e).filter(e => e.startsWith("data-"))),
                        [n] = We(e, t);
                    return n
                }
                const ro = e => {
                    const t = no(e);
                    return Pe(to, Le({
                        get appearance() {
                            return e.appearance || "primary"
                        },
                        get ["class"]() {
                            return e.class
                        },
                        onClick: t => {
                            var n;
                            return null == (n = e.onClick) ? void 0 : n.call(e, t)
                        },
                        onMouseEnter: t => {
                            var n;
                            return null == (n = e.onMouseEnter) ? void 0 : n.call(e, t)
                        },
                        onMouseLeave: t => {
                            var n;
                            return null == (n = e.onMouseLeave) ? void 0 : n.call(e, t)
                        },
                        ref(t) {
                            const n = e.ref;
                            "function" === typeof n ? n(t) : e.ref = t
                        },
                        get disabled() {
                            return e.disabled
                        },
                        get scale() {
                            return e.scale || "m"
                        },
                        get leftIcon() {
                            return !!e.leftIcon
                        },
                        get rightIcon() {
                            return !!e.rightIcon
                        },
                        "data-tc-button": "true"
                    }, t, {
                        get children() {
                            return [X(() => e.leftIcon), X(() => e.children), X(() => e.rightIcon)]
                        }
                    }))
                };

                function oo(e) {
                    requestAnimationFrame(() => {
                        requestAnimationFrame(e)
                    })
                }
                const io = e => {
                    let t, n = !0;
                    const [r, o] = G(), [i, s] = G(), a = ue(() => e.children), {
                        onBeforeEnter: c,
                        onEnter: u,
                        onAfterEnter: l,
                        onBeforeExit: d,
                        onExit: h,
                        onAfterExit: p
                    } = e, g = X(() => {
                        const t = e.name || "s";
                        return {
                            enterActiveClass: e.enterActiveClass || t + "-enter-active",
                            enterClass: e.enterClass || t + "-enter",
                            enterToClass: e.enterToClass || t + "-enter-to",
                            exitActiveClass: e.exitActiveClass || t + "-exit-active",
                            exitClass: e.exitClass || t + "-exit",
                            exitToClass: e.exitToClass || t + "-exit-to"
                        }
                    });

                    function f(t, a) {
                        if (!n || e.appear) {
                            let n = function(c) {
                                !t || c && c.target !== t || (t.removeEventListener("transitionend", n), t.removeEventListener("animationend", n), t.classList.remove(...h), t.classList.remove(...p), ee(() => {
                                    r() !== t && o(t), i() === t && s(void 0)
                                }), l && l(t), "inout" === e.mode && b(t, a))
                            };
                            const d = g().enterClass.split(" "),
                                h = g().enterActiveClass.split(" "),
                                p = g().enterToClass.split(" ");
                            c && c(t), t.classList.add(...d), t.classList.add(...h), oo(() => {
                                t.classList.remove(...d), t.classList.add(...p), u && u(t, () => n()), (!u || u.length < 2) && (t.addEventListener("transitionend", n), t.addEventListener("animationend", n))
                            })
                        }
                        a && !e.mode ? s(t) : o(t)
                    }

                    function b(t, n) {
                        const i = g().exitClass.split(" "),
                            s = g().exitActiveClass.split(" "),
                            a = g().exitToClass.split(" ");
                        if (!n.parentNode) return c();

                        function c(i) {
                            i && i.target !== n || (n.removeEventListener("transitionend", c), n.removeEventListener("animationend", c), n.classList.remove(...s), n.classList.remove(...a), r() === n && o(void 0), p && p(n), "outin" === e.mode && f(t, n))
                        }
                        d && d(n), n.classList.add(...i), n.classList.add(...s), oo(() => {
                            n.classList.remove(...i), n.classList.add(...a)
                        }), h && h(n, () => c()), (!h || h.length < 2) && (n.addEventListener("transitionend", c), n.addEventListener("animationend", c))
                    }
                    return Y(r => {
                        t = a();
                        while ("function" === typeof t) t = t();
                        return te(() => (t && t !== r && ("outin" !== e.mode ? f(t, r) : n && o(t)), r && r !== t && "inout" !== e.mode && b(t, r), n = !1, t))
                    }), [r, i]
                };

                function so(e) {
                    const {
                        top: t,
                        bottom: n,
                        left: r,
                        right: o,
                        width: i,
                        height: s
                    } = e.getBoundingClientRect(), a = e.parentNode.getBoundingClientRect();
                    return {
                        top: t - a.top,
                        bottom: n,
                        left: r - a.left,
                        right: o,
                        width: i,
                        height: s
                    }
                }
                const ao = e => {
                    const t = ue(() => e.children),
                        n = X(() => {
                            const t = e.name || "s";
                            return {
                                enterActiveClass: e.enterActiveClass || t + "-enter-active",
                                enterClass: e.enterClass || t + "-enter",
                                enterToClass: e.enterToClass || t + "-enter-to",
                                exitActiveClass: e.exitActiveClass || t + "-exit-active",
                                exitClass: e.exitClass || t + "-exit",
                                exitToClass: e.exitToClass || t + "-exit-to",
                                moveClass: e.moveClass || t + "-move"
                            }
                        }),
                        {
                            onBeforeEnter: r,
                            onEnter: o,
                            onAfterEnter: i,
                            onBeforeExit: s,
                            onExit: a,
                            onAfterExit: c
                        } = e,
                        [u, l] = G();
                    let d = [],
                        h = !0;
                    return Y(() => {
                        const e = t(),
                            u = [...e],
                            p = new Set(e),
                            g = new Set(d),
                            f = n().enterClass.split(" "),
                            b = n().enterActiveClass.split(" "),
                            y = n().enterToClass.split(" "),
                            m = n().exitClass.split(" "),
                            w = n().exitActiveClass.split(" "),
                            k = n().exitToClass.split(" ");
                        for (let t = 0; t < e.length; t++) {
                            const n = e[t];
                            if (!h && !g.has(n)) {
                                let e = function(t) {
                                    !n || t && t.target !== n || (n.removeEventListener("transitionend", e), n.removeEventListener("animationend", e), n.classList.remove(...b), n.classList.remove(...y), i && i(n))
                                };
                                r && r(n), n.classList.add(...f), n.classList.add(...b), oo(() => {
                                    n.classList.remove(...f), n.classList.add(...y), o && o(n, () => e()), (!o || o.length < 2) && (n.addEventListener("transitionend", e), n.addEventListener("animationend", e))
                                })
                            }
                        }
                        for (let t = 0; t < d.length; t++) {
                            const e = d[t];
                            if (!p.has(e) && e.parentNode) {
                                let n = function(t) {
                                    t && t.target !== e || (e.removeEventListener("transitionend", n), e.removeEventListener("animationend", n), e.classList.remove(...w), e.classList.remove(...k), c && c(e), d = d.filter(t => t !== e), l(d))
                                };
                                u.splice(t, 0, e), s && s(e), e.classList.add(...m), e.classList.add(...w), oo(() => {
                                    e.classList.remove(...m), e.classList.add(...k)
                                }), a && a(e, () => n()), (!a || a.length < 2) && (e.addEventListener("transitionend", n), e.addEventListener("animationend", n))
                            }
                        }
                        d = u, l(u)
                    }), Z(e => {
                        const t = u();
                        return t.forEach(t => {
                            let n;
                            (n = e.get(t)) ? n.new && (n.new = !1, n.newPos = so(t)): e.set(t, n = {
                                pos: so(t),
                                new: !h
                            }), n.new && t.addEventListener("transitionend", () => {
                                n.new = !1, t.parentNode && (n.newPos = so(t))
                            }, {
                                once: !0
                            }), n.newPos && (n.pos = n.newPos), n.newPos = so(t)
                        }), h ? (h = !1, e) : (t.forEach(t => {
                            const n = e.get(t),
                                r = n.pos,
                                o = n.newPos,
                                i = r.left - o.left,
                                s = r.top - o.top;
                            if (i || s) {
                                n.moved = !0;
                                const e = t.style;
                                e.transform = `translate(${i}px,${s}px)`, e.transitionDuration = "0s"
                            }
                        }), document.body.offsetHeight, t.forEach(t => {
                            const r = e.get(t);
                            if (r.moved) {
                                let e = function(n) {
                                    n && n.target !== t || !t.parentNode || n && !/transform$/.test(n.propertyName) || (t.removeEventListener("transitionend", e), t.classList.remove(...i))
                                };
                                r.moved = !1;
                                const o = t.style,
                                    i = n().moveClass.split(" ");
                                t.classList.add(...i), o.transform = o.transitionDuration = "", t.addEventListener("transitionend", e)
                            }
                        }), e)
                    }, new Map), u
                };

                function co(e, t) {
                    const n = n => {
                        var r;
                        return !e.contains(n.target) && (null == (r = t()) ? void 0 : r())
                    };
                    document.body.addEventListener("click", n), oe(() => document.body.removeEventListener("click", n))
                }

                function uo(e, t) {
                    const n = e => {
                        var n, r;
                        "Escape" === e.key && (null == (n = document.activeElement) || n.blur(), null == (r = t()) || r())
                    };
                    document.body.addEventListener("keydown", n), oe(() => document.body.removeEventListener("keydown", n))
                }

                function lo(e, t) {
                    const {
                        isEnabled: n,
                        onClose: r
                    } = t();
                    if (!n) return;
                    const o = "android" === wn().os;
                    if (!o) return;
                    window.history.pushState(po, "");
                    const i = e => {
                        e.preventDefault(), r()
                    };
                    window.addEventListener("popstate", i, {
                        once: !0
                    }), oe(() => {
                        window.removeEventListener("popstate", i), hn(() => {
                            var e;
                            !0 === (null == (e = window.history.state) ? void 0 : e[ho]) && window.history.back()
                        })
                    })
                }
                const ho = "androidBackHandler",
                    po = {
                        [ho]: !0
                    },
                    go = Xe('<svg><path fill-rule="evenodd" clip-rule="evenodd" d="M10.2122 14.3407C10.5384 14.0854 10.5959 13.614 10.3406 13.2878L6.20237 8.00003L10.3406 2.71227C10.5959 2.38607 10.5384 1.91469 10.2122 1.6594C9.88604 1.40412 9.41465 1.46161 9.15937 1.7878L4.65937 7.5378C4.44688 7.80932 4.44688 8.19074 4.65937 8.46226L9.15937 14.2123C9.41465 14.5385 9.88604 14.5959 10.2122 14.3407Z"></path></svg>', 4, !0),
                    fo = {
                        left: 0,
                        top: 90,
                        right: 180,
                        bottom: 270
                    },
                    bo = e => {
                        const t = Kt(),
                            n = () => e.fill || t.colors.icon.secondary,
                            r = () => e.direction || "left",
                            o = zt("svg")
                        `
        transform: rotate(${e=>fo[e.svgDirection]}deg);
        transition: transform 0.1s ease-in-out;
    `;
                        return Pe(o, {
                            xmlns: "http://www.w3.org/2000/svg",
                            width: "16",
                            height: "16",
                            viewBox: "0 0 16 16",
                            fill: "none",
                            get svgDirection() {
                                return r()
                            },
                            get children() {
                                const e = go.cloneNode(!0);
                                return J(() => et(e, "fill", n())), e
                            }
                        })
                    },
                    yo = Xe('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M2.71966 2.71968C3.01255 2.42678 3.48743 2.42677 3.78032 2.71966L8.00002 6.93925L12.2197 2.71967C12.5126 2.42677 12.9874 2.42678 13.2803 2.71967C13.5732 3.01257 13.5732 3.48744 13.2803 3.78033L9.06068 7.99991L13.2803 12.2197C13.5732 12.5126 13.5732 12.9874 13.2803 13.2803C12.9874 13.5732 12.5126 13.5732 12.2197 13.2803L8.00002 9.06057L3.78033 13.2803C3.48744 13.5732 3.01257 13.5732 2.71967 13.2803C2.42678 12.9874 2.42677 12.5126 2.71967 12.2197L6.93936 7.99991L2.71968 3.78034C2.42678 3.48745 2.42677 3.01257 2.71966 2.71968Z"></path></svg>'),
                    mo = e => {
                        const t = Kt(),
                            n = () => e.fill || t.colors.icon.secondary;
                        return (() => {
                            const e = yo.cloneNode(!0),
                                t = e.firstChild;
                            return J(() => et(t, "fill", n())), e
                        })()
                    },
                    wo = zt.button `
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background-color: ${e=>e.theme.colors.background.tint};
    border: none;
    cursor: pointer;

    transition: transform 0.125s ease-in-out;

    ${Xr} {
        &:hover {
            transform: scale(1.04);
        }
    }

    &:active {
        transform: scale(0.96);
    }

    ${Zr} {
        &:active {
            transform: scale(0.92);
        }
    }
`,
                    ko = e => {
                        const t = no(e),
                            n = () => e.icon || "close";
                        return Pe(wo, Le({
                            get ["class"]() {
                                return e.class
                            },
                            onClick: () => e.onClick(),
                            "data-tc-icon-button": "true"
                        }, t, {
                            get children() {
                                return [Pe(Me, {
                                    get when() {
                                        return !!e.children
                                    },
                                    get children() {
                                        return e.children
                                    }
                                }), Pe(Me, {
                                    get when() {
                                        return !e.children
                                    },
                                    get children() {
                                        return Pe(Ke, {
                                            get children() {
                                                return [Pe(Ue, {
                                                    get when() {
                                                        return "close" === n()
                                                    },
                                                    get children() {
                                                        return Pe(mo, {
                                                            get fill() {
                                                                return e.fill
                                                            }
                                                        })
                                                    }
                                                }), Pe(Ue, {
                                                    get when() {
                                                        return "arrow" === n()
                                                    },
                                                    get children() {
                                                        return Pe(bo, {
                                                            get fill() {
                                                                return e.fill
                                                            }
                                                        })
                                                    }
                                                }), Pe(Ue, {
                                                    get when() {
                                                        return "question" === n()
                                                    },
                                                    get children() {
                                                        return Pe(Zi, {
                                                            get fill() {
                                                                return e.fill
                                                            }
                                                        })
                                                    }
                                                }), Pe(Ue, {
                                                    get when() {
                                                        return "string" !== typeof n()
                                                    },
                                                    get children() {
                                                        return n()
                                                    }
                                                })]
                                            }
                                        })
                                    }
                                })]
                            }
                        }))
                    },
                    vo = {
                        m: "24px",
                        s: "16px",
                        none: "0"
                    },
                    So = zt.div `
    display: flex;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.4);
    padding: 20px 0;
    overflow-y: auto;

    ${Jr("mobile")} {
        padding-bottom: 0;
    }
`,
                    Co = Lt `
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08), 0 16px 64px rgba(0, 0, 0, 0.16);
    width: fit-content;
    margin: auto;

    ${Jr("mobile")} {
        width: 100%;
        height: fit-content;
        margin: auto 0 0 0;
    }
`,
                    Io = zt.div `
    position: relative;
    min-height: 100px;
    width: 416px;
    padding: 44px 56px 24px;

    box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.04);

    background-color: ${e=>e.theme.colors.background.primary};
    border-radius: ${e=>vo[e.theme.borderRadius]};

    ${Jr("mobile")} {
        width: 100%;
    }
`,
                    Ao = zt(ko)
                `
    position: absolute;
    right: 16px;
    top: 16px;
`, Oo = zt.div `
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px 16px 16px 18px;
    border-radius: 0 0 ${e=>vo[e.theme.borderRadius]}
        ${e=>vo[e.theme.borderRadius]};
`, xo = zt(ko)
                `
    background-color: ${e=>Gt(e.theme.colors.icon.secondary,.12)};
`;
                class _o {
                    constructor() {
                        x(this, "currentTime", 0)
                    }
                }
                const Eo = class {
                    constructor() {
                        x(this, "currentTime", 0), x(this, "playbackRate", 1), x(this, "startTime", null), x(this, "timeline", new _o), x(this, "finished", Promise.resolve(this)), x(this, "effect", null), x(this, "id", ""), x(this, "pending", !1), x(this, "playState", "finished"), x(this, "replaceState", "active"), x(this, "ready", Promise.resolve(this)), x(this, "oncancel", null), x(this, "onfinish", null), x(this, "onremove", null)
                    }
                    static create() {
                        return Eo._instance || (tn("Animation is not supported in this environment: please consider using the `web-animations-js` polyfill to provide a fallback implementation of the Web Animations API."), Eo._instance = new Eo), Eo._instance
                    }
                    cancel() {}
                    finish() {}
                    pause() {}
                    play() {}
                    reverse() {}
                    addEventListener(e, t, n) {}
                    dispatchEvent(e) {
                        return !1
                    }
                    removeEventListener(e, t, n) {}
                    updatePlaybackRate(e) {}
                    commitStyles() {}
                    persist() {}
                };
                let To = Eo;

                function Po(e, t, n) {
                    return "animate" in e ? e.animate(t, n) : To.create()
                }
                x(To, "_instance", null);
                const Ro = Xe("<div></div>"),
                    jo = co,
                    Bo = uo,
                    Lo = lo,
                    Wo = e => {
                        const t = Kt(),
                            n = no(e);
                        return Z(() => {
                            e.opened ? cn() : un()
                        }), Pe(io, {
                            onBeforeEnter: e => {
                                const t = Yr("mobile") ? 200 : 100;
                                Po(e, [{
                                    opacity: 0
                                }, {
                                    opacity: 1
                                }], {
                                    duration: t
                                }), Yr("mobile") && Po(e.firstElementChild, [{
                                    transform: "translateY(390px)"
                                }, {
                                    transform: "translateY(0)"
                                }], {
                                    duration: t
                                })
                            },
                            onExit: (e, t) => {
                                const n = Yr("mobile") ? 200 : 100,
                                    r = Po(e, [{
                                        opacity: 1
                                    }, {
                                        opacity: 0
                                    }], {
                                        duration: n
                                    });
                                if (Yr("mobile")) {
                                    const o = Po(e.firstElementChild, [{
                                        transform: "translateY(0)"
                                    }, {
                                        transform: "translateY(390px)"
                                    }], {
                                        duration: n
                                    });
                                    Promise.all([r.finished, o.finished]).then(t)
                                } else r.finished.then(t)
                            },
                            get children() {
                                return Pe(Me, {
                                    get when() {
                                        return e.opened
                                    },
                                    get children() {
                                        return Pe(So, Le({
                                            "data-tc-modal": "true"
                                        }, n, {
                                            get children() {
                                                const n = Ro.cloneNode(!0);
                                                return at(Lo, n, () => ({
                                                    isEnabled: e.enableAndroidBackHandler,
                                                    onClose: () => e.onClose()
                                                })), at(Bo, n, () => () => e.onClose()), at(jo, n, () => () => e.onClose()), ct(n, Pe(Io, {
                                                    get ["class"]() {
                                                        return e.class
                                                    },
                                                    get children() {
                                                        return [Pe(Ao, {
                                                            icon: "close",
                                                            onClick: () => e.onClose()
                                                        }), X(() => e.children)]
                                                    }
                                                }), null), ct(n, Pe(Me, {
                                                    get when() {
                                                        return e.onClickQuestion
                                                    },
                                                    get children() {
                                                        return Pe(Oo, {
                                                            get children() {
                                                                return [Pe(Yi, {}), Pe(xo, {
                                                                    get onClick() {
                                                                        return e.onClickQuestion
                                                                    },
                                                                    icon: "question"
                                                                })]
                                                            }
                                                        })
                                                    }
                                                }), null), J(() => nt(n, y()(Co, Lt `
                                border-radius: ${vo[t.borderRadius]};
                                background-color: ${t.colors.background.tint};

                                ${Jr("mobile")} {
                                    border-radius: ${vo[t.borderRadius]}
                                        ${vo[t.borderRadius]} 0 0;
                                }
                            `))), n
                                            }
                                        }))
                                    }
                                })
                            }
                        })
                    },
                    No = {
                        m: "22px",
                        s: "12px",
                        none: "0"
                    },
                    Mo = {
                        m: "18px",
                        s: "8px",
                        none: "0"
                    },
                    Ko = zt.div `
    display: grid;
    grid-template: 1fr / 1fr 1fr;
    width: fit-content;
    justify-items: center;
    gap: 4px;

    position: relative;
    padding: 4px;
    border-radius: ${e=>No[e.theme.borderRadius]};

    background-color: ${e=>e.theme.colors.background.secondary};
`,
                    Uo = zt.div `
    position: absolute;
    top: 4px;
    left: 4px;

    height: calc(100% - 8px);
    width: calc(50% - 4px);

    border-radius: ${e=>Mo[e.theme.borderRadius]};
    background-color: ${e=>e.theme.colors.background.segment};

    transform: ${e=>e.right?"translateX(100%)":"translateX(0)"};

    transition: transform 0.13s ease-in-out;
`,
                    zo = zt.input `
    display: none;
`,
                    Do = zt.label `
    padding: 9px 12px;
    z-index: 1;

    cursor: ${e=>e.isActive?"default":"pointer"};

    transition: transform 0.13s ease-in-out;

    &:hover {
        transform: ${e=>e.isActive?"none":"scale(1.025)"};
    }

    > * {
        ${e=>e.isActive?"":`color: ${e.theme.colors.text.secondary};`}
    }
`,
                    Ho = e => {
                        const t = "tabBar" + Math.floor(1e4 * Math.random());
                        return Pe(Ko, {
                            get ["class"]() {
                                return e.class
                            },
                            "data-tc-tab-bar": "true",
                            get children() {
                                return [Pe(Uo, {
                                    get right() {
                                        return 1 === e.selectedTabIndex
                                    }
                                }), Pe(Do, {
                                    get isActive() {
                                        return 0 === e.selectedTabIndex
                                    },
                                    get children() {
                                        return [Pe(zo, {
                                            type: "radio",
                                            name: t,
                                            get checked() {
                                                return 0 === e.selectedTabIndex
                                            },
                                            onInput: () => {
                                                var t;
                                                return null == (t = e.onSelectedTabIndexChange) ? void 0 : t.call(e, 0)
                                            }
                                        }), X(() => e.tab1)]
                                    }
                                }), Pe(Do, {
                                    get isActive() {
                                        return 1 === e.selectedTabIndex
                                    },
                                    get children() {
                                        return [Pe(zo, {
                                            type: "radio",
                                            get checked() {
                                                return 1 === e.selectedTabIndex
                                            },
                                            name: t,
                                            onInput: () => {
                                                var t;
                                                return null == (t = e.onSelectedTabIndexChange) ? void 0 : t.call(e, 1)
                                            }
                                        }), X(() => e.tab2)]
                                    }
                                })]
                            }
                        })
                    },
                    qo = {
                        m: "16px",
                        s: "12px",
                        none: "0"
                    },
                    $o = {
                        m: "12px",
                        s: "8px",
                        none: "0"
                    },
                    Vo = 256,
                    Fo = 60,
                    Go = 48,
                    Yo = 24,
                    Jo = zt.div `
    width: 52px;
    height: 52px;
    background: transparent;
    position: absolute;
    right: 0;
    bottom: 0;

    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.125s ease-in-out;
`,
                    Zo = zt.button `
    display: flex;
    align-items: center;
    position: relative;
    background-color: ${e=>e.theme.colors.background.qr};
    border-radius: ${e=>qo[e.theme.borderRadius]};
    padding: ${Yt(Yo)} 0;
    height: ${Yt(Vo+2*Yo)};
    width: 100%;

    overflow: hidden;
    cursor: pointer;
    border: none;

    ${Xr} {
        &:hover {
            ${Jo.class} {
                transform: scale(1.04);
            }
        }
    }

    &:active {
        ${Jo.class} {
            transform: scale(0.96);
        }
    }

    ${Zr} {
        &:active {
            ${Jo.class} {
                transform: scale(0.92);
            }
        }
    }
`,
                    Xo = zt.div `
    position: relative;

    width: fit-content;
    margin: 0 auto;

    > div:first-child {
        display: flex;
        align-items: center;
        justify-content: center;
    }

    rect {
        fill: transparent;
    }

    path {
        fill: ${e=>e.theme.colors.constant.black};
    }
`,
                    Qo = zt.div `
    position: absolute;
    width: ${Yt(Fo)};
    height: ${Yt(Fo)};
    background: ${e=>e.theme.colors.background.qr};

    display: flex;
    align-items: center;
    justify-content: center;
`,
                    ei = zt(jr)
                `
    width: ${e=>Yt(e.size)};
    height: ${e=>Yt(e.size)};
    border-radius: ${e=>$o[e.theme.borderRadius]};
    background-color: ${e=>e.theme.colors.background.qr};
`, ti = zt.div `
    position: absolute;
    bottom: 14px;
    left: 50%;
    transform: translate(-50%, 0);

    display: flex;
    gap: 6px;
    align-items: center;
    border-radius: 18px;
    min-width: 126px;
    padding: 9px 16px 9px 10px;

    filter: drop-shadow(0px 2px 8px rgba(0, 0, 0, 0.08));
    background-color: ${e=>e.theme.colors.background.segment};
`;
                var ni = {
                    exports: {}
                };
                (function(e, t) {
                    var n = function() {
                        var e = function(e, t) {
                            var r = 236,
                                i = 17,
                                p = e,
                                g = n[t],
                                f = null,
                                b = 0,
                                m = null,
                                w = [],
                                k = {},
                                v = function(e, t) {
                                    b = 4 * p + 17, f = function(e) {
                                        for (var t = new Array(e), n = 0; n < e; n += 1) {
                                            t[n] = new Array(e);
                                            for (var r = 0; r < e; r += 1) t[n][r] = null
                                        }
                                        return t
                                    }(b), S(0, 0), S(b - 7, 0), S(0, b - 7), A(), I(), x(e, t), p >= 7 && O(e), null == m && (m = T(p, g, w)), _(m, t)
                                },
                                S = function(e, t) {
                                    for (var n = -1; n <= 7; n += 1)
                                        if (!(e + n <= -1 || b <= e + n))
                                            for (var r = -1; r <= 7; r += 1) t + r <= -1 || b <= t + r || (f[e + n][t + r] = 0 <= n && n <= 6 && (0 == r || 6 == r) || 0 <= r && r <= 6 && (0 == n || 6 == n) || 2 <= n && n <= 4 && 2 <= r && r <= 4)
                                },
                                C = function() {
                                    for (var e = 0, t = 0, n = 0; n < 8; n += 1) {
                                        v(!0, n);
                                        var r = o.getLostPoint(k);
                                        (0 == n || e > r) && (e = r, t = n)
                                    }
                                    return t
                                },
                                I = function() {
                                    for (var e = 8; e < b - 8; e += 1) null == f[e][6] && (f[e][6] = e % 2 == 0);
                                    for (var t = 8; t < b - 8; t += 1) null == f[6][t] && (f[6][t] = t % 2 == 0)
                                },
                                A = function() {
                                    for (var e = o.getPatternPosition(p), t = 0; t < e.length; t += 1)
                                        for (var n = 0; n < e.length; n += 1) {
                                            var r = e[t],
                                                i = e[n];
                                            if (null == f[r][i])
                                                for (var s = -2; s <= 2; s += 1)
                                                    for (var a = -2; a <= 2; a += 1) f[r + s][i + a] = -2 == s || 2 == s || -2 == a || 2 == a || 0 == s && 0 == a
                                        }
                                },
                                O = function(e) {
                                    for (var t = o.getBCHTypeNumber(p), n = 0; n < 18; n += 1) {
                                        var r = !e && 1 == (t >> n & 1);
                                        f[Math.floor(n / 3)][n % 3 + b - 8 - 3] = r
                                    }
                                    for (n = 0; n < 18; n += 1) {
                                        r = !e && 1 == (t >> n & 1);
                                        f[n % 3 + b - 8 - 3][Math.floor(n / 3)] = r
                                    }
                                },
                                x = function(e, t) {
                                    for (var n = g << 3 | t, r = o.getBCHTypeInfo(n), i = 0; i < 15; i += 1) {
                                        var s = !e && 1 == (r >> i & 1);
                                        i < 6 ? f[i][8] = s : i < 8 ? f[i + 1][8] = s : f[b - 15 + i][8] = s
                                    }
                                    for (i = 0; i < 15; i += 1) {
                                        s = !e && 1 == (r >> i & 1);
                                        i < 8 ? f[8][b - i - 1] = s : i < 9 ? f[8][15 - i - 1 + 1] = s : f[8][15 - i - 1] = s
                                    }
                                    f[b - 8][8] = !e
                                },
                                _ = function(e, t) {
                                    for (var n = -1, r = b - 1, i = 7, s = 0, a = o.getMaskFunction(t), c = b - 1; c > 0; c -= 2) {
                                        6 == c && (c -= 1);
                                        while (1) {
                                            for (var u = 0; u < 2; u += 1)
                                                if (null == f[r][c - u]) {
                                                    var l = !1;
                                                    s < e.length && (l = 1 == (e[s] >>> i & 1));
                                                    var d = a(r, c - u);
                                                    d && (l = !l), f[r][c - u] = l, i -= 1, -1 == i && (s += 1, i = 7)
                                                }
                                            if (r += n, r < 0 || b <= r) {
                                                r -= n, n = -n;
                                                break
                                            }
                                        }
                                    }
                                },
                                E = function(e, t) {
                                    for (var n = 0, r = 0, i = 0, a = new Array(t.length), c = new Array(t.length), u = 0; u < t.length; u += 1) {
                                        var l = t[u].dataCount,
                                            d = t[u].totalCount - l;
                                        r = Math.max(r, l), i = Math.max(i, d), a[u] = new Array(l);
                                        for (var h = 0; h < a[u].length; h += 1) a[u][h] = 255 & e.getBuffer()[h + n];
                                        n += l;
                                        var p = o.getErrorCorrectPolynomial(d),
                                            g = s(a[u], p.getLength() - 1),
                                            f = g.mod(p);
                                        c[u] = new Array(p.getLength() - 1);
                                        for (h = 0; h < c[u].length; h += 1) {
                                            var b = h + f.getLength() - c[u].length;
                                            c[u][h] = b >= 0 ? f.getAt(b) : 0
                                        }
                                    }
                                    var y = 0;
                                    for (h = 0; h < t.length; h += 1) y += t[h].totalCount;
                                    var m = new Array(y),
                                        w = 0;
                                    for (h = 0; h < r; h += 1)
                                        for (u = 0; u < t.length; u += 1) h < a[u].length && (m[w] = a[u][h], w += 1);
                                    for (h = 0; h < i; h += 1)
                                        for (u = 0; u < t.length; u += 1) h < c[u].length && (m[w] = c[u][h], w += 1);
                                    return m
                                },
                                T = function(e, t, n) {
                                    for (var s = a.getRSBlocks(e, t), u = c(), l = 0; l < n.length; l += 1) {
                                        var d = n[l];
                                        u.put(d.getMode(), 4), u.put(d.getLength(), o.getLengthInBits(d.getMode(), e)), d.write(u)
                                    }
                                    var h = 0;
                                    for (l = 0; l < s.length; l += 1) h += s[l].dataCount;
                                    if (u.getLengthInBits() > 8 * h) throw "code length overflow. (" + u.getLengthInBits() + ">" + 8 * h + ")";
                                    u.getLengthInBits() + 4 <= 8 * h && u.put(0, 4);
                                    while (u.getLengthInBits() % 8 != 0) u.putBit(!1);
                                    while (1) {
                                        if (u.getLengthInBits() >= 8 * h) break;
                                        if (u.put(r, 8), u.getLengthInBits() >= 8 * h) break;
                                        u.put(i, 8)
                                    }
                                    return E(u, s)
                                };
                            k.addData = function(e, t) {
                                t = t || "Byte";
                                var n = null;
                                switch (t) {
                                    case "Numeric":
                                        n = u(e);
                                        break;
                                    case "Alphanumeric":
                                        n = l(e);
                                        break;
                                    case "Byte":
                                        n = d(e);
                                        break;
                                    case "Kanji":
                                        n = h(e);
                                        break;
                                    default:
                                        throw "mode:" + t
                                }
                                w.push(n), m = null
                            }, k.isDark = function(e, t) {
                                if (e < 0 || b <= e || t < 0 || b <= t) throw e + "," + t;
                                return f[e][t]
                            }, k.getModuleCount = function() {
                                return b
                            }, k.make = function() {
                                if (p < 1) {
                                    for (var e = 1; e < 40; e++) {
                                        for (var t = a.getRSBlocks(e, g), n = c(), r = 0; r < w.length; r++) {
                                            var i = w[r];
                                            n.put(i.getMode(), 4), n.put(i.getLength(), o.getLengthInBits(i.getMode(), e)), i.write(n)
                                        }
                                        var s = 0;
                                        for (r = 0; r < t.length; r++) s += t[r].dataCount;
                                        if (n.getLengthInBits() <= 8 * s) break
                                    }
                                    p = e
                                }
                                v(!1, C())
                            }, k.createTableTag = function(e, t) {
                                e = e || 2, t = "undefined" == typeof t ? 4 * e : t;
                                var n = "";
                                n += '<table style="', n += " border-width: 0px; border-style: none;", n += " border-collapse: collapse;", n += " padding: 0px; margin: " + t + "px;", n += '">', n += "<tbody>";
                                for (var r = 0; r < k.getModuleCount(); r += 1) {
                                    n += "<tr>";
                                    for (var o = 0; o < k.getModuleCount(); o += 1) n += '<td style="', n += " border-width: 0px; border-style: none;", n += " border-collapse: collapse;", n += " padding: 0px; margin: 0px;", n += " width: " + e + "px;", n += " height: " + e + "px;", n += " background-color: ", n += k.isDark(r, o) ? "#000000" : "#ffffff", n += ";", n += '"/>';
                                    n += "</tr>"
                                }
                                return n += "</tbody>", n += "</table>", n
                            }, k.createSvgTag = function(e, t, n, r) {
                                var o = {};
                                "object" == typeof arguments[0] && (o = arguments[0], e = o.cellSize, t = o.margin, n = o.alt, r = o.title), e = e || 2, t = "undefined" == typeof t ? 4 * e : t, n = "string" === typeof n ? {
                                    text: n
                                } : n || {}, n.text = n.text || null, n.id = n.text ? n.id || "qrcode-description" : null, r = "string" === typeof r ? {
                                    text: r
                                } : r || {}, r.text = r.text || null, r.id = r.text ? r.id || "qrcode-title" : null;
                                var i, s, a, c, u, l = k.getModuleCount() * e + 2 * t,
                                    d = "";
                                for (u = "l" + e + ",0 0," + e + " -" + e + ",0 0,-" + e + "z ", d += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"', d += o.scalable ? "" : ' width="' + l + 'px" height="' + l + 'px"', d += ' viewBox="0 0 ' + l + " " + l + '" ', d += ' preserveAspectRatio="xMinYMin meet"', d += r.text || n.text ? ' role="img" aria-labelledby="' + P([r.id, n.id].join(" ").trim()) + '"' : "", d += ">", d += r.text ? '<title id="' + P(r.id) + '">' + P(r.text) + "</title>" : "", d += n.text ? '<description id="' + P(n.id) + '">' + P(n.text) + "</description>" : "", d += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>', d += '<path d="', a = 0; a < k.getModuleCount(); a += 1)
                                    for (c = a * e + t, i = 0; i < k.getModuleCount(); i += 1) k.isDark(a, i) && (s = i * e + t, d += "M" + s + "," + c + u);
                                return d += '" stroke="transparent" fill="black"/>', d += "</svg>", d
                            }, k.createDataURL = function(e, t) {
                                e = e || 2, t = "undefined" == typeof t ? 4 * e : t;
                                var n = k.getModuleCount() * e + 2 * t,
                                    r = t,
                                    o = n - t;
                                return y(n, n, (function(t, n) {
                                    if (r <= t && t < o && r <= n && n < o) {
                                        var i = Math.floor((t - r) / e),
                                            s = Math.floor((n - r) / e);
                                        return k.isDark(s, i) ? 0 : 1
                                    }
                                    return 1
                                }))
                            }, k.createImgTag = function(e, t, n) {
                                e = e || 2, t = "undefined" == typeof t ? 4 * e : t;
                                var r = k.getModuleCount() * e + 2 * t,
                                    o = "";
                                return o += "<img", o += ' src="', o += k.createDataURL(e, t), o += '"', o += ' width="', o += r, o += '"', o += ' height="', o += r, o += '"', n && (o += ' alt="', o += P(n), o += '"'), o += "/>", o
                            };
                            var P = function(e) {
                                    for (var t = "", n = 0; n < e.length; n += 1) {
                                        var r = e.charAt(n);
                                        switch (r) {
                                            case "<":
                                                t += "&lt;";
                                                break;
                                            case ">":
                                                t += "&gt;";
                                                break;
                                            case "&":
                                                t += "&amp;";
                                                break;
                                            case '"':
                                                t += "&quot;";
                                                break;
                                            default:
                                                t += r;
                                                break
                                        }
                                    }
                                    return t
                                },
                                R = function(e) {
                                    var t = 1;
                                    e = "undefined" == typeof e ? 2 * t : e;
                                    var n, r, o, i, s, a = k.getModuleCount() * t + 2 * e,
                                        c = e,
                                        u = a - e,
                                        l = {
                                            "": "",
                                            " ": "",
                                            " ": "",
                                            "  ": " "
                                        },
                                        d = {
                                            "": "",
                                            " ": "",
                                            " ": " ",
                                            "  ": " "
                                        },
                                        h = "";
                                    for (n = 0; n < a; n += 2) {
                                        for (o = Math.floor((n - c) / t), i = Math.floor((n + 1 - c) / t), r = 0; r < a; r += 1) s = "", c <= r && r < u && c <= n && n < u && k.isDark(o, Math.floor((r - c) / t)) && (s = " "), c <= r && r < u && c <= n + 1 && n + 1 < u && k.isDark(i, Math.floor((r - c) / t)) ? s += " " : s += "", h += e < 1 && n + 1 >= u ? d[s] : l[s];
                                        h += "\n"
                                    }
                                    return a % 2 && e > 0 ? h.substring(0, h.length - a - 1) + Array(a + 1).join("") : h.substring(0, h.length - 1)
                                };
                            return k.createASCII = function(e, t) {
                                if (e = e || 1, e < 2) return R(t);
                                e -= 1, t = "undefined" == typeof t ? 2 * e : t;
                                var n, r, o, i, s = k.getModuleCount() * e + 2 * t,
                                    a = t,
                                    c = s - t,
                                    u = Array(e + 1).join(""),
                                    l = Array(e + 1).join("  "),
                                    d = "",
                                    h = "";
                                for (n = 0; n < s; n += 1) {
                                    for (o = Math.floor((n - a) / e), h = "", r = 0; r < s; r += 1) i = 1, a <= r && r < c && a <= n && n < c && k.isDark(o, Math.floor((r - a) / e)) && (i = 0), h += i ? u : l;
                                    for (o = 0; o < e; o += 1) d += h + "\n"
                                }
                                return d.substring(0, d.length - 1)
                            }, k.renderTo2dContext = function(e, t) {
                                t = t || 2;
                                for (var n = k.getModuleCount(), r = 0; r < n; r++)
                                    for (var o = 0; o < n; o++) e.fillStyle = k.isDark(r, o) ? "black" : "white", e.fillRect(r * t, o * t, t, t)
                            }, k
                        };
                        e.stringToBytesFuncs = {
                            default: function(e) {
                                for (var t = [], n = 0; n < e.length; n += 1) {
                                    var r = e.charCodeAt(n);
                                    t.push(255 & r)
                                }
                                return t
                            }
                        }, e.stringToBytes = e.stringToBytesFuncs["default"], e.createStringToBytes = function(e, t) {
                            var n = function() {
                                    var n = f(e),
                                        r = function() {
                                            var e = n.read();
                                            if (-1 == e) throw "eof";
                                            return e
                                        },
                                        o = 0,
                                        i = {};
                                    while (1) {
                                        var s = n.read();
                                        if (-1 == s) break;
                                        var a = r(),
                                            c = r(),
                                            u = r(),
                                            l = String.fromCharCode(s << 8 | a),
                                            d = c << 8 | u;
                                        i[l] = d, o += 1
                                    }
                                    if (o != t) throw o + " != " + t;
                                    return i
                                }(),
                                r = "?".charCodeAt(0);
                            return function(e) {
                                for (var t = [], o = 0; o < e.length; o += 1) {
                                    var i = e.charCodeAt(o);
                                    if (i < 128) t.push(i);
                                    else {
                                        var s = n[e.charAt(o)];
                                        "number" == typeof s ? (255 & s) == s ? t.push(s) : (t.push(s >>> 8), t.push(255 & s)) : t.push(r)
                                    }
                                }
                                return t
                            }
                        };
                        var t = {
                                MODE_NUMBER: 1,
                                MODE_ALPHA_NUM: 2,
                                MODE_8BIT_BYTE: 4,
                                MODE_KANJI: 8
                            },
                            n = {
                                L: 1,
                                M: 0,
                                Q: 3,
                                H: 2
                            },
                            r = {
                                PATTERN000: 0,
                                PATTERN001: 1,
                                PATTERN010: 2,
                                PATTERN011: 3,
                                PATTERN100: 4,
                                PATTERN101: 5,
                                PATTERN110: 6,
                                PATTERN111: 7
                            },
                            o = function() {
                                var e = [
                                        [],
                                        [6, 18],
                                        [6, 22],
                                        [6, 26],
                                        [6, 30],
                                        [6, 34],
                                        [6, 22, 38],
                                        [6, 24, 42],
                                        [6, 26, 46],
                                        [6, 28, 50],
                                        [6, 30, 54],
                                        [6, 32, 58],
                                        [6, 34, 62],
                                        [6, 26, 46, 66],
                                        [6, 26, 48, 70],
                                        [6, 26, 50, 74],
                                        [6, 30, 54, 78],
                                        [6, 30, 56, 82],
                                        [6, 30, 58, 86],
                                        [6, 34, 62, 90],
                                        [6, 28, 50, 72, 94],
                                        [6, 26, 50, 74, 98],
                                        [6, 30, 54, 78, 102],
                                        [6, 28, 54, 80, 106],
                                        [6, 32, 58, 84, 110],
                                        [6, 30, 58, 86, 114],
                                        [6, 34, 62, 90, 118],
                                        [6, 26, 50, 74, 98, 122],
                                        [6, 30, 54, 78, 102, 126],
                                        [6, 26, 52, 78, 104, 130],
                                        [6, 30, 56, 82, 108, 134],
                                        [6, 34, 60, 86, 112, 138],
                                        [6, 30, 58, 86, 114, 142],
                                        [6, 34, 62, 90, 118, 146],
                                        [6, 30, 54, 78, 102, 126, 150],
                                        [6, 24, 50, 76, 102, 128, 154],
                                        [6, 28, 54, 80, 106, 132, 158],
                                        [6, 32, 58, 84, 110, 136, 162],
                                        [6, 26, 54, 82, 110, 138, 166],
                                        [6, 30, 58, 86, 114, 142, 170]
                                    ],
                                    n = 1335,
                                    o = 7973,
                                    a = 21522,
                                    c = {},
                                    u = function(e) {
                                        var t = 0;
                                        while (0 != e) t += 1, e >>>= 1;
                                        return t
                                    };
                                return c.getBCHTypeInfo = function(e) {
                                    var t = e << 10;
                                    while (u(t) - u(n) >= 0) t ^= n << u(t) - u(n);
                                    return (e << 10 | t) ^ a
                                }, c.getBCHTypeNumber = function(e) {
                                    var t = e << 12;
                                    while (u(t) - u(o) >= 0) t ^= o << u(t) - u(o);
                                    return e << 12 | t
                                }, c.getPatternPosition = function(t) {
                                    return e[t - 1]
                                }, c.getMaskFunction = function(e) {
                                    switch (e) {
                                        case r.PATTERN000:
                                            return function(e, t) {
                                                return (e + t) % 2 == 0
                                            };
                                        case r.PATTERN001:
                                            return function(e, t) {
                                                return e % 2 == 0
                                            };
                                        case r.PATTERN010:
                                            return function(e, t) {
                                                return t % 3 == 0
                                            };
                                        case r.PATTERN011:
                                            return function(e, t) {
                                                return (e + t) % 3 == 0
                                            };
                                        case r.PATTERN100:
                                            return function(e, t) {
                                                return (Math.floor(e / 2) + Math.floor(t / 3)) % 2 == 0
                                            };
                                        case r.PATTERN101:
                                            return function(e, t) {
                                                return e * t % 2 + e * t % 3 == 0
                                            };
                                        case r.PATTERN110:
                                            return function(e, t) {
                                                return (e * t % 2 + e * t % 3) % 2 == 0
                                            };
                                        case r.PATTERN111:
                                            return function(e, t) {
                                                return (e * t % 3 + (e + t) % 2) % 2 == 0
                                            };
                                        default:
                                            throw "bad maskPattern:" + e
                                    }
                                }, c.getErrorCorrectPolynomial = function(e) {
                                    for (var t = s([1], 0), n = 0; n < e; n += 1) t = t.multiply(s([1, i.gexp(n)], 0));
                                    return t
                                }, c.getLengthInBits = function(e, n) {
                                    if (1 <= n && n < 10) switch (e) {
                                        case t.MODE_NUMBER:
                                            return 10;
                                        case t.MODE_ALPHA_NUM:
                                            return 9;
                                        case t.MODE_8BIT_BYTE:
                                            return 8;
                                        case t.MODE_KANJI:
                                            return 8;
                                        default:
                                            throw "mode:" + e
                                    } else if (n < 27) switch (e) {
                                        case t.MODE_NUMBER:
                                            return 12;
                                        case t.MODE_ALPHA_NUM:
                                            return 11;
                                        case t.MODE_8BIT_BYTE:
                                            return 16;
                                        case t.MODE_KANJI:
                                            return 10;
                                        default:
                                            throw "mode:" + e
                                    } else {
                                        if (!(n < 41)) throw "type:" + n;
                                        switch (e) {
                                            case t.MODE_NUMBER:
                                                return 14;
                                            case t.MODE_ALPHA_NUM:
                                                return 13;
                                            case t.MODE_8BIT_BYTE:
                                                return 16;
                                            case t.MODE_KANJI:
                                                return 12;
                                            default:
                                                throw "mode:" + e
                                        }
                                    }
                                }, c.getLostPoint = function(e) {
                                    for (var t = e.getModuleCount(), n = 0, r = 0; r < t; r += 1)
                                        for (var o = 0; o < t; o += 1) {
                                            for (var i = 0, s = e.isDark(r, o), a = -1; a <= 1; a += 1)
                                                if (!(r + a < 0 || t <= r + a))
                                                    for (var c = -1; c <= 1; c += 1) o + c < 0 || t <= o + c || 0 == a && 0 == c || s == e.isDark(r + a, o + c) && (i += 1);
                                            i > 5 && (n += 3 + i - 5)
                                        }
                                    for (r = 0; r < t - 1; r += 1)
                                        for (o = 0; o < t - 1; o += 1) {
                                            var u = 0;
                                            e.isDark(r, o) && (u += 1), e.isDark(r + 1, o) && (u += 1), e.isDark(r, o + 1) && (u += 1), e.isDark(r + 1, o + 1) && (u += 1), 0 != u && 4 != u || (n += 3)
                                        }
                                    for (r = 0; r < t; r += 1)
                                        for (o = 0; o < t - 6; o += 1) e.isDark(r, o) && !e.isDark(r, o + 1) && e.isDark(r, o + 2) && e.isDark(r, o + 3) && e.isDark(r, o + 4) && !e.isDark(r, o + 5) && e.isDark(r, o + 6) && (n += 40);
                                    for (o = 0; o < t; o += 1)
                                        for (r = 0; r < t - 6; r += 1) e.isDark(r, o) && !e.isDark(r + 1, o) && e.isDark(r + 2, o) && e.isDark(r + 3, o) && e.isDark(r + 4, o) && !e.isDark(r + 5, o) && e.isDark(r + 6, o) && (n += 40);
                                    var l = 0;
                                    for (o = 0; o < t; o += 1)
                                        for (r = 0; r < t; r += 1) e.isDark(r, o) && (l += 1);
                                    var d = Math.abs(100 * l / t / t - 50) / 5;
                                    return n += 10 * d, n
                                }, c
                            }(),
                            i = function() {
                                for (var e = new Array(256), t = new Array(256), n = 0; n < 8; n += 1) e[n] = 1 << n;
                                for (n = 8; n < 256; n += 1) e[n] = e[n - 4] ^ e[n - 5] ^ e[n - 6] ^ e[n - 8];
                                for (n = 0; n < 255; n += 1) t[e[n]] = n;
                                var r = {
                                    glog: function(e) {
                                        if (e < 1) throw "glog(" + e + ")";
                                        return t[e]
                                    },
                                    gexp: function(t) {
                                        while (t < 0) t += 255;
                                        while (t >= 256) t -= 255;
                                        return e[t]
                                    }
                                };
                                return r
                            }();

                        function s(e, t) {
                            if ("undefined" == typeof e.length) throw e.length + "/" + t;
                            var n = function() {
                                    var n = 0;
                                    while (n < e.length && 0 == e[n]) n += 1;
                                    for (var r = new Array(e.length - n + t), o = 0; o < e.length - n; o += 1) r[o] = e[o + n];
                                    return r
                                }(),
                                r = {
                                    getAt: function(e) {
                                        return n[e]
                                    },
                                    getLength: function() {
                                        return n.length
                                    },
                                    multiply: function(e) {
                                        for (var t = new Array(r.getLength() + e.getLength() - 1), n = 0; n < r.getLength(); n += 1)
                                            for (var o = 0; o < e.getLength(); o += 1) t[n + o] ^= i.gexp(i.glog(r.getAt(n)) + i.glog(e.getAt(o)));
                                        return s(t, 0)
                                    },
                                    mod: function(e) {
                                        if (r.getLength() - e.getLength() < 0) return r;
                                        for (var t = i.glog(r.getAt(0)) - i.glog(e.getAt(0)), n = new Array(r.getLength()), o = 0; o < r.getLength(); o += 1) n[o] = r.getAt(o);
                                        for (o = 0; o < e.getLength(); o += 1) n[o] ^= i.gexp(i.glog(e.getAt(o)) + t);
                                        return s(n, 0).mod(e)
                                    }
                                };
                            return r
                        }
                        var a = function() {
                                var e = [
                                        [1, 26, 19],
                                        [1, 26, 16],
                                        [1, 26, 13],
                                        [1, 26, 9],
                                        [1, 44, 34],
                                        [1, 44, 28],
                                        [1, 44, 22],
                                        [1, 44, 16],
                                        [1, 70, 55],
                                        [1, 70, 44],
                                        [2, 35, 17],
                                        [2, 35, 13],
                                        [1, 100, 80],
                                        [2, 50, 32],
                                        [2, 50, 24],
                                        [4, 25, 9],
                                        [1, 134, 108],
                                        [2, 67, 43],
                                        [2, 33, 15, 2, 34, 16],
                                        [2, 33, 11, 2, 34, 12],
                                        [2, 86, 68],
                                        [4, 43, 27],
                                        [4, 43, 19],
                                        [4, 43, 15],
                                        [2, 98, 78],
                                        [4, 49, 31],
                                        [2, 32, 14, 4, 33, 15],
                                        [4, 39, 13, 1, 40, 14],
                                        [2, 121, 97],
                                        [2, 60, 38, 2, 61, 39],
                                        [4, 40, 18, 2, 41, 19],
                                        [4, 40, 14, 2, 41, 15],
                                        [2, 146, 116],
                                        [3, 58, 36, 2, 59, 37],
                                        [4, 36, 16, 4, 37, 17],
                                        [4, 36, 12, 4, 37, 13],
                                        [2, 86, 68, 2, 87, 69],
                                        [4, 69, 43, 1, 70, 44],
                                        [6, 43, 19, 2, 44, 20],
                                        [6, 43, 15, 2, 44, 16],
                                        [4, 101, 81],
                                        [1, 80, 50, 4, 81, 51],
                                        [4, 50, 22, 4, 51, 23],
                                        [3, 36, 12, 8, 37, 13],
                                        [2, 116, 92, 2, 117, 93],
                                        [6, 58, 36, 2, 59, 37],
                                        [4, 46, 20, 6, 47, 21],
                                        [7, 42, 14, 4, 43, 15],
                                        [4, 133, 107],
                                        [8, 59, 37, 1, 60, 38],
                                        [8, 44, 20, 4, 45, 21],
                                        [12, 33, 11, 4, 34, 12],
                                        [3, 145, 115, 1, 146, 116],
                                        [4, 64, 40, 5, 65, 41],
                                        [11, 36, 16, 5, 37, 17],
                                        [11, 36, 12, 5, 37, 13],
                                        [5, 109, 87, 1, 110, 88],
                                        [5, 65, 41, 5, 66, 42],
                                        [5, 54, 24, 7, 55, 25],
                                        [11, 36, 12, 7, 37, 13],
                                        [5, 122, 98, 1, 123, 99],
                                        [7, 73, 45, 3, 74, 46],
                                        [15, 43, 19, 2, 44, 20],
                                        [3, 45, 15, 13, 46, 16],
                                        [1, 135, 107, 5, 136, 108],
                                        [10, 74, 46, 1, 75, 47],
                                        [1, 50, 22, 15, 51, 23],
                                        [2, 42, 14, 17, 43, 15],
                                        [5, 150, 120, 1, 151, 121],
                                        [9, 69, 43, 4, 70, 44],
                                        [17, 50, 22, 1, 51, 23],
                                        [2, 42, 14, 19, 43, 15],
                                        [3, 141, 113, 4, 142, 114],
                                        [3, 70, 44, 11, 71, 45],
                                        [17, 47, 21, 4, 48, 22],
                                        [9, 39, 13, 16, 40, 14],
                                        [3, 135, 107, 5, 136, 108],
                                        [3, 67, 41, 13, 68, 42],
                                        [15, 54, 24, 5, 55, 25],
                                        [15, 43, 15, 10, 44, 16],
                                        [4, 144, 116, 4, 145, 117],
                                        [17, 68, 42],
                                        [17, 50, 22, 6, 51, 23],
                                        [19, 46, 16, 6, 47, 17],
                                        [2, 139, 111, 7, 140, 112],
                                        [17, 74, 46],
                                        [7, 54, 24, 16, 55, 25],
                                        [34, 37, 13],
                                        [4, 151, 121, 5, 152, 122],
                                        [4, 75, 47, 14, 76, 48],
                                        [11, 54, 24, 14, 55, 25],
                                        [16, 45, 15, 14, 46, 16],
                                        [6, 147, 117, 4, 148, 118],
                                        [6, 73, 45, 14, 74, 46],
                                        [11, 54, 24, 16, 55, 25],
                                        [30, 46, 16, 2, 47, 17],
                                        [8, 132, 106, 4, 133, 107],
                                        [8, 75, 47, 13, 76, 48],
                                        [7, 54, 24, 22, 55, 25],
                                        [22, 45, 15, 13, 46, 16],
                                        [10, 142, 114, 2, 143, 115],
                                        [19, 74, 46, 4, 75, 47],
                                        [28, 50, 22, 6, 51, 23],
                                        [33, 46, 16, 4, 47, 17],
                                        [8, 152, 122, 4, 153, 123],
                                        [22, 73, 45, 3, 74, 46],
                                        [8, 53, 23, 26, 54, 24],
                                        [12, 45, 15, 28, 46, 16],
                                        [3, 147, 117, 10, 148, 118],
                                        [3, 73, 45, 23, 74, 46],
                                        [4, 54, 24, 31, 55, 25],
                                        [11, 45, 15, 31, 46, 16],
                                        [7, 146, 116, 7, 147, 117],
                                        [21, 73, 45, 7, 74, 46],
                                        [1, 53, 23, 37, 54, 24],
                                        [19, 45, 15, 26, 46, 16],
                                        [5, 145, 115, 10, 146, 116],
                                        [19, 75, 47, 10, 76, 48],
                                        [15, 54, 24, 25, 55, 25],
                                        [23, 45, 15, 25, 46, 16],
                                        [13, 145, 115, 3, 146, 116],
                                        [2, 74, 46, 29, 75, 47],
                                        [42, 54, 24, 1, 55, 25],
                                        [23, 45, 15, 28, 46, 16],
                                        [17, 145, 115],
                                        [10, 74, 46, 23, 75, 47],
                                        [10, 54, 24, 35, 55, 25],
                                        [19, 45, 15, 35, 46, 16],
                                        [17, 145, 115, 1, 146, 116],
                                        [14, 74, 46, 21, 75, 47],
                                        [29, 54, 24, 19, 55, 25],
                                        [11, 45, 15, 46, 46, 16],
                                        [13, 145, 115, 6, 146, 116],
                                        [14, 74, 46, 23, 75, 47],
                                        [44, 54, 24, 7, 55, 25],
                                        [59, 46, 16, 1, 47, 17],
                                        [12, 151, 121, 7, 152, 122],
                                        [12, 75, 47, 26, 76, 48],
                                        [39, 54, 24, 14, 55, 25],
                                        [22, 45, 15, 41, 46, 16],
                                        [6, 151, 121, 14, 152, 122],
                                        [6, 75, 47, 34, 76, 48],
                                        [46, 54, 24, 10, 55, 25],
                                        [2, 45, 15, 64, 46, 16],
                                        [17, 152, 122, 4, 153, 123],
                                        [29, 74, 46, 14, 75, 47],
                                        [49, 54, 24, 10, 55, 25],
                                        [24, 45, 15, 46, 46, 16],
                                        [4, 152, 122, 18, 153, 123],
                                        [13, 74, 46, 32, 75, 47],
                                        [48, 54, 24, 14, 55, 25],
                                        [42, 45, 15, 32, 46, 16],
                                        [20, 147, 117, 4, 148, 118],
                                        [40, 75, 47, 7, 76, 48],
                                        [43, 54, 24, 22, 55, 25],
                                        [10, 45, 15, 67, 46, 16],
                                        [19, 148, 118, 6, 149, 119],
                                        [18, 75, 47, 31, 76, 48],
                                        [34, 54, 24, 34, 55, 25],
                                        [20, 45, 15, 61, 46, 16]
                                    ],
                                    t = function(e, t) {
                                        var n = {};
                                        return n.totalCount = e, n.dataCount = t, n
                                    },
                                    r = {},
                                    o = function(t, r) {
                                        switch (r) {
                                            case n.L:
                                                return e[4 * (t - 1) + 0];
                                            case n.M:
                                                return e[4 * (t - 1) + 1];
                                            case n.Q:
                                                return e[4 * (t - 1) + 2];
                                            case n.H:
                                                return e[4 * (t - 1) + 3];
                                            default:
                                                return
                                        }
                                    };
                                return r.getRSBlocks = function(e, n) {
                                    var r = o(e, n);
                                    if ("undefined" == typeof r) throw "bad rs block @ typeNumber:" + e + "/errorCorrectionLevel:" + n;
                                    for (var i = r.length / 3, s = [], a = 0; a < i; a += 1)
                                        for (var c = r[3 * a + 0], u = r[3 * a + 1], l = r[3 * a + 2], d = 0; d < c; d += 1) s.push(t(u, l));
                                    return s
                                }, r
                            }(),
                            c = function() {
                                var e = [],
                                    t = 0,
                                    n = {
                                        getBuffer: function() {
                                            return e
                                        },
                                        getAt: function(t) {
                                            var n = Math.floor(t / 8);
                                            return 1 == (e[n] >>> 7 - t % 8 & 1)
                                        },
                                        put: function(e, t) {
                                            for (var r = 0; r < t; r += 1) n.putBit(1 == (e >>> t - r - 1 & 1))
                                        },
                                        getLengthInBits: function() {
                                            return t
                                        },
                                        putBit: function(n) {
                                            var r = Math.floor(t / 8);
                                            e.length <= r && e.push(0), n && (e[r] |= 128 >>> t % 8), t += 1
                                        }
                                    };
                                return n
                            },
                            u = function(e) {
                                var n = t.MODE_NUMBER,
                                    r = e,
                                    o = {
                                        getMode: function() {
                                            return n
                                        },
                                        getLength: function(e) {
                                            return r.length
                                        },
                                        write: function(e) {
                                            var t = r,
                                                n = 0;
                                            while (n + 2 < t.length) e.put(i(t.substring(n, n + 3)), 10), n += 3;
                                            n < t.length && (t.length - n == 1 ? e.put(i(t.substring(n, n + 1)), 4) : t.length - n == 2 && e.put(i(t.substring(n, n + 2)), 7))
                                        }
                                    },
                                    i = function(e) {
                                        for (var t = 0, n = 0; n < e.length; n += 1) t = 10 * t + s(e.charAt(n));
                                        return t
                                    },
                                    s = function(e) {
                                        if ("0" <= e && e <= "9") return e.charCodeAt(0) - "0".charCodeAt(0);
                                        throw "illegal char :" + e
                                    };
                                return o
                            },
                            l = function(e) {
                                var n = t.MODE_ALPHA_NUM,
                                    r = e,
                                    o = {
                                        getMode: function() {
                                            return n
                                        },
                                        getLength: function(e) {
                                            return r.length
                                        },
                                        write: function(e) {
                                            var t = r,
                                                n = 0;
                                            while (n + 1 < t.length) e.put(45 * i(t.charAt(n)) + i(t.charAt(n + 1)), 11), n += 2;
                                            n < t.length && e.put(i(t.charAt(n)), 6)
                                        }
                                    },
                                    i = function(e) {
                                        if ("0" <= e && e <= "9") return e.charCodeAt(0) - "0".charCodeAt(0);
                                        if ("A" <= e && e <= "Z") return e.charCodeAt(0) - "A".charCodeAt(0) + 10;
                                        switch (e) {
                                            case " ":
                                                return 36;
                                            case "$":
                                                return 37;
                                            case "%":
                                                return 38;
                                            case "*":
                                                return 39;
                                            case "+":
                                                return 40;
                                            case "-":
                                                return 41;
                                            case ".":
                                                return 42;
                                            case "/":
                                                return 43;
                                            case ":":
                                                return 44;
                                            default:
                                                throw "illegal char :" + e
                                        }
                                    };
                                return o
                            },
                            d = function(n) {
                                var r = t.MODE_8BIT_BYTE,
                                    o = e.stringToBytes(n),
                                    i = {
                                        getMode: function() {
                                            return r
                                        },
                                        getLength: function(e) {
                                            return o.length
                                        },
                                        write: function(e) {
                                            for (var t = 0; t < o.length; t += 1) e.put(o[t], 8)
                                        }
                                    };
                                return i
                            },
                            h = function(n) {
                                var r = t.MODE_KANJI,
                                    o = e.stringToBytesFuncs["SJIS"];
                                if (!o) throw "sjis not supported.";
                                ! function(e, t) {
                                    var n = o(e);
                                    if (2 != n.length || (n[0] << 8 | n[1]) != t) throw "sjis not supported."
                                }("", 38726);
                                var i = o(n),
                                    s = {
                                        getMode: function() {
                                            return r
                                        },
                                        getLength: function(e) {
                                            return ~~(i.length / 2)
                                        },
                                        write: function(e) {
                                            var t = i,
                                                n = 0;
                                            while (n + 1 < t.length) {
                                                var r = (255 & t[n]) << 8 | 255 & t[n + 1];
                                                if (33088 <= r && r <= 40956) r -= 33088;
                                                else {
                                                    if (!(57408 <= r && r <= 60351)) throw "illegal char at " + (n + 1) + "/" + r;
                                                    r -= 49472
                                                }
                                                r = 192 * (r >>> 8 & 255) + (255 & r), e.put(r, 13), n += 2
                                            }
                                            if (n < t.length) throw "illegal char at " + (n + 1)
                                        }
                                    };
                                return s
                            },
                            p = function() {
                                var e = [],
                                    t = {
                                        writeByte: function(t) {
                                            e.push(255 & t)
                                        },
                                        writeShort: function(e) {
                                            t.writeByte(e), t.writeByte(e >>> 8)
                                        },
                                        writeBytes: function(e, n, r) {
                                            n = n || 0, r = r || e.length;
                                            for (var o = 0; o < r; o += 1) t.writeByte(e[o + n])
                                        },
                                        writeString: function(e) {
                                            for (var n = 0; n < e.length; n += 1) t.writeByte(e.charCodeAt(n))
                                        },
                                        toByteArray: function() {
                                            return e
                                        },
                                        toString: function() {
                                            var t = "";
                                            t += "[";
                                            for (var n = 0; n < e.length; n += 1) n > 0 && (t += ","), t += e[n];
                                            return t += "]", t
                                        }
                                    };
                                return t
                            },
                            g = function() {
                                var e = 0,
                                    t = 0,
                                    n = 0,
                                    r = "",
                                    o = {},
                                    i = function(e) {
                                        r += String.fromCharCode(s(63 & e))
                                    },
                                    s = function(e) {
                                        if (e < 0);
                                        else {
                                            if (e < 26) return 65 + e;
                                            if (e < 52) return e - 26 + 97;
                                            if (e < 62) return e - 52 + 48;
                                            if (62 == e) return 43;
                                            if (63 == e) return 47
                                        }
                                        throw "n:" + e
                                    };
                                return o.writeByte = function(r) {
                                    e = e << 8 | 255 & r, t += 8, n += 1;
                                    while (t >= 6) i(e >>> t - 6), t -= 6
                                }, o.flush = function() {
                                    if (t > 0 && (i(e << 6 - t), e = 0, t = 0), n % 3 != 0)
                                        for (var o = 3 - n % 3, s = 0; s < o; s += 1) r += "="
                                }, o.toString = function() {
                                    return r
                                }, o
                            },
                            f = function(e) {
                                var t = e,
                                    n = 0,
                                    r = 0,
                                    o = 0,
                                    i = {
                                        read: function() {
                                            while (o < 8) {
                                                if (n >= t.length) {
                                                    if (0 == o) return -1;
                                                    throw "unexpected end of file./" + o
                                                }
                                                var e = t.charAt(n);
                                                if (n += 1, "=" == e) return o = 0, -1;
                                                e.match(/^\s$/) || (r = r << 6 | s(e.charCodeAt(0)), o += 6)
                                            }
                                            var i = r >>> o - 8 & 255;
                                            return o -= 8, i
                                        }
                                    },
                                    s = function(e) {
                                        if (65 <= e && e <= 90) return e - 65;
                                        if (97 <= e && e <= 122) return e - 97 + 26;
                                        if (48 <= e && e <= 57) return e - 48 + 52;
                                        if (43 == e) return 62;
                                        if (47 == e) return 63;
                                        throw "c:" + e
                                    };
                                return i
                            },
                            b = function(e, t) {
                                var n = e,
                                    r = t,
                                    o = new Array(e * t),
                                    i = {
                                        setPixel: function(e, t, r) {
                                            o[t * n + e] = r
                                        },
                                        write: function(e) {
                                            e.writeString("GIF87a"), e.writeShort(n), e.writeShort(r), e.writeByte(128), e.writeByte(0), e.writeByte(0), e.writeByte(0), e.writeByte(0), e.writeByte(0), e.writeByte(255), e.writeByte(255), e.writeByte(255), e.writeString(","), e.writeShort(0), e.writeShort(0), e.writeShort(n), e.writeShort(r), e.writeByte(0);
                                            var t = 2,
                                                o = a(t);
                                            e.writeByte(t);
                                            var i = 0;
                                            while (o.length - i > 255) e.writeByte(255), e.writeBytes(o, i, 255), i += 255;
                                            e.writeByte(o.length - i), e.writeBytes(o, i, o.length - i), e.writeByte(0), e.writeString(";")
                                        }
                                    },
                                    s = function(e) {
                                        var t = e,
                                            n = 0,
                                            r = 0,
                                            o = {
                                                write: function(e, o) {
                                                    if (e >>> o != 0) throw "length over";
                                                    while (n + o >= 8) t.writeByte(255 & (e << n | r)), o -= 8 - n, e >>>= 8 - n, r = 0, n = 0;
                                                    r |= e << n, n += o
                                                },
                                                flush: function() {
                                                    n > 0 && t.writeByte(r)
                                                }
                                            };
                                        return o
                                    },
                                    a = function(e) {
                                        for (var t = 1 << e, n = 1 + (1 << e), r = e + 1, i = c(), a = 0; a < t; a += 1) i.add(String.fromCharCode(a));
                                        i.add(String.fromCharCode(t)), i.add(String.fromCharCode(n));
                                        var u = p(),
                                            l = s(u);
                                        l.write(t, r);
                                        var d = 0,
                                            h = String.fromCharCode(o[d]);
                                        d += 1;
                                        while (d < o.length) {
                                            var g = String.fromCharCode(o[d]);
                                            d += 1, i.contains(h + g) ? h += g : (l.write(i.indexOf(h), r), i.size() < 4095 && (i.size() == 1 << r && (r += 1), i.add(h + g)), h = g)
                                        }
                                        return l.write(i.indexOf(h), r), l.write(n, r), l.flush(), u.toByteArray()
                                    },
                                    c = function() {
                                        var e = {},
                                            t = 0,
                                            n = {
                                                add: function(r) {
                                                    if (n.contains(r)) throw "dup key:" + r;
                                                    e[r] = t, t += 1
                                                },
                                                size: function() {
                                                    return t
                                                },
                                                indexOf: function(t) {
                                                    return e[t]
                                                },
                                                contains: function(t) {
                                                    return "undefined" != typeof e[t]
                                                }
                                            };
                                        return n
                                    };
                                return i
                            },
                            y = function(e, t, n) {
                                for (var r = b(e, t), o = 0; o < t; o += 1)
                                    for (var i = 0; i < e; i += 1) r.setPixel(i, o, n(i, o));
                                var s = p();
                                r.write(s);
                                for (var a = g(), c = s.toByteArray(), u = 0; u < c.length; u += 1) a.writeByte(c[u]);
                                return a.flush(), "data:image/gif;base64," + a
                            };
                        return e
                    }();
                    ! function() {
                        n.stringToBytesFuncs["UTF-8"] = function(e) {
                            function t(e) {
                                for (var t = [], n = 0; n < e.length; n++) {
                                    var r = e.charCodeAt(n);
                                    r < 128 ? t.push(r) : r < 2048 ? t.push(192 | r >> 6, 128 | 63 & r) : r < 55296 || r >= 57344 ? t.push(224 | r >> 12, 128 | r >> 6 & 63, 128 | 63 & r) : (n++, r = 65536 + ((1023 & r) << 10 | 1023 & e.charCodeAt(n)), t.push(240 | r >> 18, 128 | r >> 12 & 63, 128 | r >> 6 & 63, 128 | 63 & r))
                                }
                                return t
                            }
                            return t(e)
                        }
                    }(),
                    function(t) {
                        e.exports = t()
                    }((function() {
                        return n
                    }))
                })(ni);
                const ri = ni.exports;

                function oi(e) {
                    return _(this, null, (function*() {
                        try {
                            if (!(null == navigator ? void 0 : navigator.clipboard)) throw new Xt("Clipboard API not available");
                            return yield navigator.clipboard.writeText(e)
                        } catch (Ll) {}
                        ii(e)
                    }))
                }

                function ii(e) {
                    const t = document.createElement("textarea");
                    t.value = e, t.style.top = "0", t.style.left = "0", t.style.position = "fixed", document.body.appendChild(t), t.focus(), t.select();
                    try {
                        document.execCommand("copy")
                    } finally {
                        document.body.removeChild(t)
                    }
                }
                const si = Xe("<div></div>"),
                    ai = e => {
                        let t, n, r;
                        const [o, i] = G(!1), [s, a] = G(Go);
                        Z(() => {
                            const o = "L",
                                i = 4,
                                s = ri(0, o);
                            s.addData(e.sourceUrl), s.make(), t.innerHTML = s.createSvgTag(i, 0);
                            const c = t.firstElementChild.clientWidth,
                                u = Math.round(Vo / c * 1e5) / 1e5;
                            if (r) {
                                const e = Math.ceil(Fo / (u * i)) * i,
                                    t = Yt(Math.ceil((c - e) / (2 * i)) * i);
                                r.style.top = t, r.style.left = t, r.style.height = Yt(e), r.style.width = Yt(e), a(Math.round(Go / u))
                            }
                            n.style.transform = `scale(${u})`
                        });
                        let c = null;
                        const u = () => {
                            i(!0), oi(e.sourceUrl), null != c && clearTimeout(c), c = setTimeout(() => i(!1), 1500)
                        };
                        return Pe(Zo, {
                            get ["class"]() {
                                return e.class
                            },
                            onClick: u,
                            get children() {
                                return [Pe(Xo, {
                                    ref(e) {
                                        const t = n;
                                        "function" === typeof t ? t(e) : n = e
                                    },
                                    get children() {
                                        return [(() => {
                                            const e = si.cloneNode(!0),
                                                n = t;
                                            return "function" === typeof n ? at(n, e) : t = e, e
                                        })(), Pe(Me, {
                                            get when() {
                                                return e.imageUrl
                                            },
                                            get children() {
                                                return Pe(Qo, {
                                                    ref(e) {
                                                        const t = r;
                                                        "function" === typeof t ? t(e) : r = e
                                                    },
                                                    get children() {
                                                        return Pe(ei, {
                                                            get src() {
                                                                return e.imageUrl
                                                            },
                                                            alt: "",
                                                            get size() {
                                                                return s()
                                                            }
                                                        })
                                                    }
                                                })
                                            }
                                        })]
                                    }
                                }), Pe(io, {
                                    onBeforeEnter: e => {
                                        Po(e, [{
                                            opacity: 0,
                                            transform: "translate(-50%, 44px)"
                                        }, {
                                            opacity: 1,
                                            transform: "translate(-50%, 0)"
                                        }], {
                                            duration: 150,
                                            easing: "ease-out"
                                        })
                                    },
                                    onExit: (e, t) => {
                                        Po(e, [{
                                            opacity: 1,
                                            transform: "translate(-50%, 0)"
                                        }, {
                                            opacity: 0,
                                            transform: "translate(-50%, 44px)"
                                        }], {
                                            duration: 150,
                                            easing: "ease-out"
                                        }).finished.then(() => {
                                            t()
                                        })
                                    },
                                    get children() {
                                        return Pe(Me, {
                                            get when() {
                                                return o() && !e.disableCopy
                                            },
                                            get children() {
                                                return Pe(ti, {
                                                    get children() {
                                                        return [Pe(Ki, {
                                                            size: "xs"
                                                        }), Pe(gi, {
                                                            translationKey: "common.linkCopied",
                                                            children: "Link Copied"
                                                        })]
                                                    }
                                                })
                                            }
                                        })
                                    }
                                }), Pe(Me, {
                                    get when() {
                                        return !e.disableCopy
                                    },
                                    get children() {
                                        return Pe(Jo, {
                                            get children() {
                                                return Pe(vs, {})
                                            }
                                        })
                                    }
                                })]
                            }
                        })
                    };
                var ci = (e, t, n) => {
                        const r = t.trim().split(".").reduce((e, t) => e ? e[t] : void 0, e);
                        return void 0 !== r ? r : n
                    },
                    ui = (e, t, n = /{{(.*?)}}/g) => e.replace(n, (e, n) => ci(t, n, "")),
                    li = (e = {}, t = (navigator.language in e ? navigator.language : Object.keys(e)[0])) => {
                        const [n, r] = G(t), [o, i] = wr(e), s = (e, t, r) => {
                            const i = ci(o[n()], e, r || "");
                            return "function" === typeof i ? i(t) : "string" === typeof i ? ui(i, t || {}) : i
                        }, a = {
                            add(e, t) {
                                i(e, e => Object.assign(e || {}, t))
                            },
                            locale: e => e ? r(e) : n(),
                            dict: e => ci(o, e)
                        };
                        return [s, a]
                    },
                    di = ae({}),
                    hi = () => ce(di);
                const pi = zt.div `
    font-style: normal;
    font-weight: ${e=>e.fontWeight};
    font-size: ${e=>e.fontSize};
    line-height: ${e=>e.lineHeight};

    color: ${e=>e.color};
`,
                    gi = e => {
                        const t = Kt(),
                            [n] = hi();
                        let r;
                        const o = () => e.color || t.colors.text.primary,
                            i = Le({
                                fontSize: "14px",
                                fontWeight: "510",
                                lineHeight: "130%"
                            }, e);
                        return Z(() => {
                            r && "unset" !== i.cursor && "pointer" !== getComputedStyle(r).cursor && (r.style.cursor = "default")
                        }), Pe(pi, {
                            get fontSize() {
                                return i.fontSize
                            },
                            get fontWeight() {
                                return i.fontWeight
                            },
                            get lineHeight() {
                                return i.lineHeight
                            },
                            get color() {
                                return o()
                            },
                            get ["class"]() {
                                return i.class
                            },
                            ref(e) {
                                const t = r;
                                "function" === typeof t ? t(e) : r = e
                            },
                            "data-tc-text": "true",
                            get children() {
                                var e;
                                return X(() => !!i.translationKey)() ? n(i.translationKey, i.translationValues, null == (e = i.children) ? void 0 : e.toString()) : i.children
                            }
                        })
                    },
                    fi = zt.div `
    position: relative;

    &::after {
        content: '';
        display: block;
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        border: 0.5px solid rgba(0, 0, 0, 0.08);

        border-radius: inherit;
    }
`,
                    bi = zt(jr)
                `
    width: 100%;
    height: 100%;
    border-radius: inherit;
`, yi = e => Pe(fi, {
                    get ["class"]() {
                        return e.class
                    },
                    get children() {
                        return Pe(bi, {
                            get src() {
                                return e.src
                            }
                        })
                    }
                }), mi = {
                    m: "16px",
                    s: "12px",
                    none: "0"
                }, wi = {
                    m: "6px",
                    s: "6px",
                    none: "0"
                }, ki = zt.button `
    position: relative;
    cursor: pointer;
    border: none;
    background-color: unset;
    padding: 8px 4px;
    width: 92px;
    display: flex;
    flex-direction: column;
    align-items: center;

    transition: transform 0.125s ease-in-out;

    ${Xr} {
        &:hover {
            transform: scale(1.04);
        }
    }

    &:active {
        transform: scale(0.96);
    }

    ${Jr("mobile")} {
        padding: 8px 4px;
        width: 82px;
    }

    ${Zr} {
        &:active {
            transform: scale(0.92);
        }
    }
`, vi = zt(yi)
                `
    width: 60px;
    height: 60px;
    border-radius: ${e=>mi[e.theme.borderRadius]};

    margin-bottom: 8px;
`, Si = zt(jr)
                `
    position: absolute;
    right: 10px;
    top: 50px;
    width: 24px;
    height: 24px;
    border-radius: ${e=>wi[e.theme.borderRadius]};
    box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.08);
`, Ci = zt(gi)
                `
    max-width: 90px;
    font-weight: 590;
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;

    ${Jr("mobile")} {
        max-width: 80px;
    }
`, Ii = zt(gi)
                `
    font-weight: 510;
    max-width: 90px;
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;
    color: ${e=>e.colorPrimary?e.theme.colors.text.primary:e.theme.colors.text.secondary};

    ${Jr("mobile")} {
        max-width: 80px;
    }
`, Ai = e => Pe(ki, {
                    get ["class"]() {
                        return e.class
                    },
                    onClick: () => e.onClick(),
                    "data-tc-wallet-item": "true",
                    get children() {
                        return [X(() => X(() => "string" === typeof e.icon)() ? Pe(vi, {
                            get src() {
                                return e.icon
                            }
                        }) : e.icon), X(() => X(() => !!e.badgeUrl)() && Pe(Si, {
                            get src() {
                                return e.badgeUrl
                            }
                        })), Pe(Ci, {
                            get children() {
                                return e.name
                            }
                        }), X(() => X(() => !!e.secondLine)() && Pe(Ii, {
                            get colorPrimary() {
                                var t;
                                return null == (t = e.secondLineColorPrimary) || t
                            },
                            get children() {
                                return e.secondLine
                            }
                        }))]
                    }
                }), Oi = zt.h1 `
    font-style: normal;
    font-weight: 700;
    font-size: 20px;
    line-height: 28px;

    text-align: center;

    color: ${e=>e.theme.colors.text.primary};

    margin-top: 0;
    margin-bottom: 0;

    cursor: default;
`, xi = e => {
                    const [t] = hi();
                    return Pe(Oi, {
                        get ["class"]() {
                            return e.class
                        },
                        "data-tc-h1": "true",
                        get children() {
                            var n;
                            return X(() => !!e.translationKey)() ? t(e.translationKey, e.translationValues, null == (n = e.children) ? void 0 : n.toString()) : e.children
                        }
                    })
                }, _i = zt.h2 `
    font-style: normal;
    font-weight: 510;
    font-size: 16px;
    line-height: 22px;

    text-align: center;

    color: ${e=>e.theme.colors.text.secondary};

    margin-top: 0;
    margin-bottom: 32px;

    cursor: default;
`, Ei = e => {
                    const [t] = hi();
                    return Pe(_i, {
                        get ["class"]() {
                            return e.class
                        },
                        "data-tc-h2": "true",
                        get children() {
                            var n;
                            return X(() => !!e.translationKey)() ? t(e.translationKey, e.translationValues, null == (n = e.children) ? void 0 : n.toString()) : e.children
                        }
                    })
                }, Ti = zt.h3 `
    font-style: normal;
    font-weight: 590;
    font-size: 16px;
    line-height: 20px;

    color: ${e=>e.theme.colors.text.primary};

    margin-top: 0;
    margin-bottom: 0;

    cursor: default;
`, Pi = e => {
                    const [t] = hi();
                    return Pe(Ti, {
                        "data-tc-h3": "true",
                        get ["class"]() {
                            return e.class
                        },
                        get children() {
                            var n;
                            return X(() => !!e.translationKey)() ? t(e.translationKey, e.translationValues, null == (n = e.children) ? void 0 : n.toString()) : e.children
                        }
                    })
                }, Ri = Xe('<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28"><path fill-rule="evenodd" clip-rule="evenodd" d="M9.75 7.5C9.33579 7.5 9 7.16421 9 6.75C9 6.33579 9.33579 6 9.75 6H21.25C21.6642 6 22 6.33579 22 6.75V18.25C22 18.6642 21.6642 19 21.25 19C20.8358 19 20.5 18.6642 20.5 18.25V8.56066L6.28033 22.7803C5.98744 23.0732 5.51256 23.0732 5.21967 22.7803C4.92678 22.4874 4.92678 22.0126 5.21967 21.7197L19.4393 7.5H9.75Z"></path></svg>'), ji = e => {
                    const t = Kt(),
                        n = () => e.fill || t.colors.icon.secondary;
                    return (() => {
                        const e = Ri.cloneNode(!0),
                            t = e.firstChild;
                        return J(r => {
                            const o = n(),
                                i = n();
                            return o !== r._v$ && et(e, "fill", r._v$ = o), i !== r._v$2 && et(t, "fill", r._v$2 = i), r
                        }, {
                            _v$: void 0,
                            _v$2: void 0
                        }), e
                    })()
                }, Bi = Xe('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M14.1839 17.7069C13.6405 18.6507 13.3688 19.1226 13.0591 19.348C12.4278 19.8074 11.5723 19.8074 10.941 19.348C10.6312 19.1226 10.3595 18.6507 9.81613 17.7069L5.52066 10.2464C4.76864 8.94024 4.39263 8.28717 4.33762 7.75894C4.2255 6.68236 4.81894 5.65591 5.80788 5.21589C6.29309 5 7.04667 5 8.55383 5H15.4462C16.9534 5 17.7069 5 18.1922 5.21589C19.1811 5.65591 19.7745 6.68236 19.6624 7.75894C19.6074 8.28717 19.2314 8.94024 18.4794 10.2464L14.1839 17.7069ZM11.1 16.3412L6.56139 8.48002C6.31995 8.06185 6.19924 7.85276 6.18146 7.68365C6.14523 7.33896 6.33507 7.01015 6.65169 6.86919C6.80703 6.80002 7.04847 6.80002 7.53133 6.80002H7.53134L11.1 6.80002V16.3412ZM12.9 16.3412L17.4387 8.48002C17.6801 8.06185 17.8008 7.85276 17.8186 7.68365C17.8548 7.33896 17.665 7.01015 17.3484 6.86919C17.193 6.80002 16.9516 6.80002 16.4687 6.80002L12.9 6.80002V16.3412Z"></path></svg>'), Li = e => {
                    const t = Kt(),
                        n = () => e.fill || t.colors.icon.primary;
                    return (() => {
                        const e = Bi.cloneNode(!0),
                            t = e.firstChild;
                        return J(() => et(t, "fill", n())), e
                    })()
                }, Wi = Xe('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><g clip-path="url(#clip0_3783_2045)"><circle cx="8" cy="8.00098" r="8"></circle><path d="M4.75 8.50098L7 10.751L11.75 6.00098" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></g><defs><clipPath id="clip0_3783_2045"><rect width="16" height="16" fill="white" transform="translate(0 0.000976562)"></rect></clipPath></defs></svg>'), Ni = Xe('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="11"></circle><path d="M17.1364 9.6364C17.4879 9.28493 17.4879 8.71508 17.1364 8.36361C16.7849 8.01214 16.2151 8.01214 15.8636 8.36361L10 14.2272L8.1364 12.3636C7.78493 12.0121 7.21508 12.0121 6.86361 12.3636C6.51214 12.7151 6.51214 13.2849 6.86361 13.6364L9.36361 16.1364C9.71508 16.4879 10.2849 16.4879 10.6364 16.1364L17.1364 9.6364Z"></path></svg>'), Mi = Xe('<svg width="72" height="72" viewBox="0 0 72 72" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="36" cy="36" r="33"></circle><path d="M50.9142 28.4142C51.6953 27.6332 51.6953 26.3668 50.9142 25.5858C50.1332 24.8047 48.8668 24.8047 48.0858 25.5858L30 43.6716L23.9142 37.5858C23.1332 36.8047 21.8668 36.8047 21.0858 37.5858C20.3047 38.3668 20.3047 39.6332 21.0858 40.4142L28.5858 47.9142C29.3668 48.6953 30.6332 48.6953 31.4142 47.9142L50.9142 28.4142Z"></path></svg>'), Ki = e => {
                    const t = Kt(),
                        n = () => e.size || "s",
                        r = () => e.fill || t.colors.icon.success;
                    return X((() => {
                        const o = X(() => "xs" === n());
                        return () => o() ? (() => {
                            const n = Wi.cloneNode(!0),
                                o = n.firstChild,
                                i = o.firstChild,
                                s = i.nextSibling;
                            return J(o => {
                                const a = e.class,
                                    c = r(),
                                    u = t.colors.constant.white;
                                return a !== o._v$ && et(n, "class", o._v$ = a), c !== o._v$2 && et(i, "fill", o._v$2 = c), u !== o._v$3 && et(s, "stroke", o._v$3 = u), o
                            }, {
                                _v$: void 0,
                                _v$2: void 0,
                                _v$3: void 0
                            }), n
                        })() : (() => {
                            const o = X(() => "s" === n());
                            return () => o() ? (() => {
                                const n = Ni.cloneNode(!0),
                                    o = n.firstChild,
                                    i = o.nextSibling;
                                return J(s => {
                                    const a = e.class,
                                        c = r(),
                                        u = t.colors.constant.white;
                                    return a !== s._v$4 && et(n, "class", s._v$4 = a), c !== s._v$5 && et(o, "fill", s._v$5 = c), u !== s._v$6 && et(i, "fill", s._v$6 = u), s
                                }, {
                                    _v$4: void 0,
                                    _v$5: void 0,
                                    _v$6: void 0
                                }), n
                            })() : (() => {
                                const n = Mi.cloneNode(!0),
                                    o = n.firstChild,
                                    i = o.nextSibling;
                                return J(s => {
                                    const a = e.class,
                                        c = r(),
                                        u = t.colors.constant.white;
                                    return a !== s._v$7 && et(n, "class", s._v$7 = a), c !== s._v$8 && et(o, "fill", s._v$8 = c), u !== s._v$9 && et(i, "fill", s._v$9 = u), s
                                }, {
                                    _v$7: void 0,
                                    _v$8: void 0,
                                    _v$9: void 0
                                }), n
                            })()
                        })()
                    })())
                }, Ui = Xe('<svg width="72" height="72" viewBox="0 0 72 72" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="36" cy="36" r="33"></circle><path d="M24.0858 26.9142C23.3047 26.1332 23.3047 24.8668 24.0858 24.0858C24.8668 23.3047 26.1332 23.3047 26.9142 24.0858L36 33.1716L45.0858 24.0858C45.8668 23.3047 47.1332 23.3047 47.9142 24.0858C48.6953 24.8668 48.6953 26.1332 47.9142 26.9142L38.8284 36L47.9142 45.0858C48.6953 45.8668 48.6953 47.1332 47.9142 47.9142C47.1332 48.6953 45.8668 48.6953 45.0858 47.9142L36 38.8284L26.9142 47.9142C26.1332 48.6953 24.8668 48.6953 24.0858 47.9142C23.3047 47.1332 23.3047 45.8668 24.0858 45.0858L33.1716 36L24.0858 26.9142Z"></path></svg>'), zi = Xe('<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 48 48" fill="none"><circle cx="24" cy="24.001" r="22"></circle><path d="M24 24.001L31.5 16.501M24 24.001L16.5 16.501M24 24.001L16.5 31.501M24 24.001L31.5 31.501" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"></path></svg>'), Di = Xe('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="11"></circle><path d="M7.86361 9.1364C7.51214 8.78493 7.51214 8.21508 7.86361 7.86361C8.21508 7.51214 8.78493 7.51214 9.1364 7.86361L12 10.7272L14.8636 7.86361C15.2151 7.51214 15.7849 7.51214 16.1364 7.86361C16.4879 8.21508 16.4879 8.78493 16.1364 9.1364L13.2728 12L16.1364 14.8636C16.4879 15.2151 16.4879 15.7849 16.1364 16.1364C15.7849 16.4879 15.2151 16.4879 14.8636 16.1364L12 13.2728L9.1364 16.1364C8.78493 16.4879 8.21508 16.4879 7.86361 16.1364C7.51214 15.7849 7.51214 15.2151 7.86361 14.8636L10.7272 12L7.86361 9.1364Z"></path></svg>'), Hi = e => {
                    const t = Kt(),
                        n = () => e.size || "m",
                        r = () => e.fill || t.colors.icon.error;
                    return X((() => {
                        const o = X(() => "m" === n());
                        return () => o() ? (() => {
                            const n = Ui.cloneNode(!0),
                                o = n.firstChild,
                                i = o.nextSibling;
                            return J(s => {
                                const a = e.class,
                                    c = r(),
                                    u = t.colors.constant.white;
                                return a !== s._v$ && et(n, "class", s._v$ = a), c !== s._v$2 && et(o, "fill", s._v$2 = c), u !== s._v$3 && et(i, "fill", s._v$3 = u), s
                            }, {
                                _v$: void 0,
                                _v$2: void 0,
                                _v$3: void 0
                            }), n
                        })() : (() => {
                            const o = X(() => "s" === n());
                            return () => o() ? (() => {
                                const n = zi.cloneNode(!0),
                                    o = n.firstChild,
                                    i = o.nextSibling;
                                return J(s => {
                                    const a = e.class,
                                        c = r(),
                                        u = t.colors.constant.white;
                                    return a !== s._v$4 && et(n, "class", s._v$4 = a), c !== s._v$5 && et(o, "fill", s._v$5 = c), u !== s._v$6 && et(i, "stroke", s._v$6 = u), s
                                }, {
                                    _v$4: void 0,
                                    _v$5: void 0,
                                    _v$6: void 0
                                }), n
                            })() : (() => {
                                const n = Di.cloneNode(!0),
                                    o = n.firstChild,
                                    i = o.nextSibling;
                                return J(s => {
                                    const a = e.class,
                                        c = r(),
                                        u = t.colors.constant.white;
                                    return a !== s._v$7 && et(n, "class", s._v$7 = a), c !== s._v$8 && et(o, "fill", s._v$8 = c), u !== s._v$9 && et(i, "fill", s._v$9 = u), s
                                }, {
                                    _v$7: void 0,
                                    _v$8: void 0,
                                    _v$9: void 0
                                }), n
                            })()
                        })()
                    })())
                }, qi = Xe('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M15.55 5.85123C18.9459 7.81184 20.1094 12.1541 18.1488 15.55C16.1882 18.9459 11.8459 20.1094 8.44998 18.1488C8.01952 17.9003 7.46909 18.0478 7.22056 18.4782C6.97203 18.9087 7.11952 19.4591 7.54998 19.7076C11.8068 22.1653 17.2499 20.7068 19.7076 16.45C22.1653 12.1932 20.7068 6.75005 16.45 4.29239C12.1932 1.83472 6.75003 3.29321 4.29236 7.55001C4.04383 7.98047 4.19132 8.53091 4.62178 8.77943C5.05224 9.02796 5.60268 8.88048 5.8512 8.45001C7.81181 5.05413 12.1541 3.89062 15.55 5.85123Z"></path></svg>'), $i = Xe('<svg xmlns="http://www.w3.org/2000/svg" width="44" height="44" viewBox="0 0 44 44" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M22 2.99951C11.5066 2.99951 3 11.5061 3 21.9995C3 32.4929 11.5066 40.9995 22 40.9995C22.8284 40.9995 23.5 41.6711 23.5 42.4995C23.5 43.3279 22.8284 43.9995 22 43.9995C9.84974 43.9995 0 34.1498 0 21.9995C0 9.84925 9.84974 -0.000488281 22 -0.000488281C34.1503 -0.000488281 44 9.84925 44 21.9995C44 22.8279 43.3284 23.4995 42.5 23.4995C41.6716 23.4995 41 22.8279 41 21.9995C41 11.5061 32.4934 2.99951 22 2.99951Z"></path></svg>'), Vi = Xe('<svg width="72" height="72" viewBox="0 0 72 72" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M24 56.7846C35.479 63.412 50.1572 59.479 56.7846 47.9999C63.412 36.5209 59.479 21.8427 48 15.2153C36.521 8.58791 21.8428 12.5209 15.2154 23.9999" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"></path></svg>'), Fi = e => {
                    const t = Kt(),
                        n = () => e.size || "xs",
                        r = () => e.fill || t.colors.icon.tertiary,
                        o = Wt `
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
    `,
                        i = Lt `
        animation: ${o} 1s linear infinite;
    `;
                    return X((() => {
                        const t = X(() => "xs" === n());
                        return () => t() ? (() => {
                            const t = qi.cloneNode(!0),
                                n = t.firstChild;
                            return J(o => {
                                const s = y()(i, e.class),
                                    a = r();
                                return s !== o._v$ && et(t, "class", o._v$ = s), a !== o._v$2 && et(n, "fill", o._v$2 = a), o
                            }, {
                                _v$: void 0,
                                _v$2: void 0
                            }), t
                        })() : (() => {
                            const t = X(() => "s" === n());
                            return () => t() ? (() => {
                                const t = $i.cloneNode(!0),
                                    n = t.firstChild;
                                return J(o => {
                                    const s = y()(i, e.class),
                                        a = r();
                                    return s !== o._v$3 && et(t, "class", o._v$3 = s), a !== o._v$4 && et(n, "fill", o._v$4 = a), o
                                }, {
                                    _v$3: void 0,
                                    _v$4: void 0
                                }), t
                            })() : (() => {
                                const t = Vi.cloneNode(!0),
                                    n = t.firstChild;
                                return J(o => {
                                    const s = y()(i, e.class),
                                        a = r();
                                    return s !== o._v$5 && et(t, "class", o._v$5 = s), a !== o._v$6 && et(n, "stroke", o._v$6 = a), o
                                }, {
                                    _v$5: void 0,
                                    _v$6: void 0
                                }), t
                            })()
                        })()
                    })())
                }, Gi = Xe('<svg width="158" height="28" viewBox="0 0 158 28" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M28 14.001C28 21.733 21.732 28.001 14 28.001C6.26801 28.001 0 21.733 0 14.001C0 6.26899 6.26801 0.000976562 14 0.000976562C21.732 0.000976562 28 6.26899 28 14.001ZM9.21931 8.00098H18.7801H18.7813C20.538 8.00098 21.6522 9.89966 20.7691 11.4302L14.8672 21.6576C14.4822 22.3254 13.5172 22.3254 13.1322 21.6576L7.23158 11.4302C6.34721 9.89726 7.4614 8.00098 9.21931 8.00098ZM13.1262 18.5882V9.74806H9.21811C8.78976 9.74806 8.53708 10.2029 8.74163 10.5578L11.8423 16.1035L13.1262 18.5882ZM16.1559 16.1047L19.2554 10.5566C19.4599 10.2017 19.2073 9.74685 18.7789 9.74685H14.8709V18.5906L16.1559 16.1047Z" fill="#0098EA"></path><path d="M18.7802 8.00098H9.21936C7.46145 8.00098 6.34727 9.89726 7.23164 11.4302L13.1322 21.6576C13.5173 22.3254 14.4823 22.3254 14.8673 21.6576L20.7691 11.4302C21.6523 9.89966 20.5381 8.00098 18.7814 8.00098H18.7802ZM13.1274 18.5906L11.8424 16.1035L8.74168 10.5578C8.53714 10.2029 8.78981 9.74806 9.21816 9.74806H13.1262V18.5918L13.1274 18.5906ZM19.2555 10.5566L16.156 16.1047L14.8709 18.5906V9.74685H18.779C19.2073 9.74685 19.46 10.2017 19.2555 10.5566Z" fill="white"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M51.7483 22.1967C55.7182 22.1967 58.9609 18.954 58.9609 14.9841C58.9609 11.0142 55.7182 7.77148 51.7483 7.77148C47.7588 7.77148 44.5357 11.0142 44.5357 14.9841C44.5357 18.954 47.7588 22.1967 51.7483 22.1967ZM51.7483 19.1702C49.4686 19.1702 47.6802 17.2442 47.6802 14.9841C47.6802 12.724 49.4686 10.798 51.7483 10.798C54.0084 10.798 55.7968 12.724 55.7968 14.9841C55.7968 17.2442 54.0084 19.1702 51.7483 19.1702ZM37.0698 21.9609H40.2142V10.9946H44.2843V8.00732H33V10.9946H37.0698V21.9609ZM69.9379 8.00732H73.0823V21.9609H70.3899L63.59 13.3333V21.9609H60.4652V8.00732H63.1576L69.9379 16.6153V8.00732ZM79.2259 14.9887C79.2259 10.9202 82.351 7.77539 86.4982 7.77539C89.8592 7.77539 92.5519 9.95709 93.2202 12.6891H90.7437C90.154 11.0971 88.4637 9.9964 86.4982 9.9964C83.5893 9.9964 81.5452 12.1781 81.5452 14.9887C81.5452 17.7994 83.5893 19.9811 86.4982 19.9811C88.4637 19.9811 90.154 18.8804 90.7437 17.2884H93.2202C92.5519 20.0204 89.8592 22.2021 86.4982 22.2021C82.351 22.2021 79.2259 19.0573 79.2259 14.9887ZM104.584 17.0525C104.584 19.9025 102.343 22.1628 99.4342 22.1628C96.5253 22.1628 94.2846 19.9025 94.2846 17.0525C94.2846 14.2025 96.5253 11.9422 99.4342 11.9422C102.343 11.9422 104.584 14.2025 104.584 17.0525ZM96.4663 17.0525C96.4663 18.8018 97.6849 20.158 99.4342 20.158C101.164 20.158 102.382 18.8018 102.382 17.0525C102.382 15.3032 101.164 13.947 99.4342 13.947C97.6849 13.947 96.4663 15.3032 96.4663 17.0525ZM108.626 12.1388H106.463V21.9662H108.626V17.1311C108.626 15.0281 109.726 13.9077 111.161 13.9077C112.419 13.9077 113.205 14.8512 113.205 16.4039V21.9662H115.367V16.0501C115.367 13.5539 113.893 11.9422 111.613 11.9422C110.335 11.9422 109.215 12.4926 108.626 13.4753V12.1388ZM117.839 12.1388H120.001V13.4753C120.59 12.4926 121.711 11.9422 122.988 11.9422C125.268 11.9422 126.742 13.5539 126.742 16.0501V21.9662H124.58V16.4039C124.58 14.8512 123.794 13.9077 122.536 13.9077C121.101 13.9077 120.001 15.0281 120.001 17.1311V21.9662H117.839V12.1388ZM133.558 22.1628C136.054 22.1628 137.823 20.728 138.373 18.8804H136.113C135.661 19.8238 134.717 20.2563 133.636 20.2563C131.887 20.2563 130.747 19.077 130.668 17.5832H138.491C138.688 14.2419 136.585 11.9422 133.577 11.9422C130.551 11.9422 128.526 14.1436 128.526 17.0525C128.526 20.0007 130.629 22.1628 133.558 22.1628ZM130.747 16.0501C131.042 14.5367 132.162 13.7505 133.518 13.7505C134.717 13.7505 135.838 14.4581 136.172 16.0501H130.747ZM149.851 18.3694C149.32 20.5511 147.453 22.1628 144.859 22.1628C141.871 22.1628 139.709 19.8828 139.709 17.0525C139.709 14.2222 141.871 11.9422 144.859 11.9422C147.453 11.9422 149.32 13.5539 149.851 15.7356H147.571C147.178 14.6743 146.215 13.9077 144.859 13.9077C143.109 13.9077 141.91 15.2246 141.91 17.0525C141.91 18.8804 143.109 20.1973 144.859 20.1973C146.215 20.1973 147.178 19.4307 147.571 18.3694H149.851ZM155.75 22.0645C156.418 22.0645 156.929 21.9859 157.362 21.8483V19.9221C157.047 20.0401 156.615 20.1187 156.202 20.1187C155.082 20.1187 154.551 19.6666 154.551 18.448V14.065H157.362V12.1388H154.551V9.40675H152.389V12.1388H150.345V14.065H152.389V18.8018C152.389 21.0228 153.863 22.0645 155.75 22.0645Z"></path></svg>'), Yi = () => {
                    const e = Kt(),
                        t = () => e.theme === It.DARK ? e.colors.constant.white : e.colors.constant.black;
                    return (() => {
                        const e = Gi.cloneNode(!0),
                            n = e.firstChild,
                            r = n.nextSibling,
                            o = r.nextSibling;
                        return J(() => et(o, "fill", t())), e
                    })()
                }, Ji = Xe('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M5.56608 4.42584C5.82527 3.32158 6.8176 2.5 8.00001 2.5C9.38072 2.5 10.5 3.61929 10.5 5C10.5 5.63026 10.3391 6.0386 10.1264 6.34455C9.90018 6.66993 9.58561 6.92478 9.18864 7.20877C9.12579 7.25372 9.05873 7.30025 8.9887 7.34883C8.27392 7.84472 7.25001 8.55507 7.25001 10V10.25C7.25001 10.6642 7.5858 11 8.00001 11C8.41422 11 8.75001 10.6642 8.75001 10.25V10C8.75001 9.36502 9.10777 9.1096 9.94554 8.51149L10.0614 8.42873C10.4769 8.13147 10.9748 7.75194 11.358 7.20076C11.7547 6.63015 12 5.91973 12 5C12 2.79086 10.2091 1 8.00001 1C6.10564 1 4.5205 2.31615 4.10577 4.08308C4.01112 4.48634 4.26129 4.88997 4.66454 4.98462C5.0678 5.07927 5.47143 4.8291 5.56608 4.42584ZM8.00001 15C8.60752 15 9.10001 14.5075 9.10001 13.9C9.10001 13.2925 8.60752 12.8 8.00001 12.8C7.39249 12.8 6.90001 13.2925 6.90001 13.9C6.90001 14.5075 7.39249 15 8.00001 15Z"></path></svg>'), Zi = e => {
                    const t = Kt(),
                        n = () => e.fill || t.colors.icon.secondary;
                    return (() => {
                        const e = Ji.cloneNode(!0),
                            t = e.firstChild;
                        return J(() => et(t, "fill", n())), e
                    })()
                }, Xi = Xe('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M9.98156 8.75C9.84854 11.4328 9.01206 13.5 8 13.5C6.98794 13.5 6.15146 11.4328 6.01844 8.75H9.98156ZM11.4832 8.75C11.4217 10.1155 11.1929 11.3869 10.8239 12.4017C10.7734 12.5405 10.7188 12.6789 10.6595 12.8154C12.1454 11.993 13.2103 10.5029 13.4493 8.75H11.4832ZM13.4493 7.25H11.4832C11.4217 5.88453 11.1929 4.61314 10.8239 3.5983C10.7734 3.4595 10.7188 3.32111 10.6595 3.18459C12.1454 4.00697 13.2103 5.49709 13.4493 7.25ZM9.98156 7.25H6.01844C6.15144 4.56764 6.98769 2.50062 7.99955 2.5H8C9.01206 2.5 9.84854 4.56724 9.98156 7.25ZM4.51678 7.25C4.57826 5.88453 4.80706 4.61314 5.1761 3.5983C5.22657 3.4595 5.28124 3.32111 5.3405 3.18459C3.85463 4.00697 2.78972 5.49709 2.55071 7.25H4.51678ZM2.55071 8.75C2.78972 10.5029 3.85463 11.993 5.3405 12.8154C5.28124 12.6789 5.22657 12.5405 5.1761 12.4017C4.80706 11.3869 4.57826 10.1155 4.51678 8.75H2.55071ZM15 8C15 11.866 11.866 15 8 15C4.13401 15 1 11.866 1 8C1 4.13401 4.13401 1 8 1C11.866 1 15 4.13401 15 8Z"></path></svg>'), Qi = e => {
                    const t = Kt(),
                        n = () => e.fill || t.colors.icon.primary;
                    return (() => {
                        const e = Xi.cloneNode(!0),
                            t = e.firstChild;
                        return J(() => et(t, "fill", n())), e
                    })()
                }, es = Xe('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M2.5 4.8C2.5 3.11984 2.5 2.27976 2.82698 1.63803C3.1146 1.07354 3.57354 0.614601 4.13803 0.32698C4.77976 0 5.61984 0 7.3 0H8.7C10.3802 0 11.2202 0 11.862 0.32698C12.4265 0.614601 12.8854 1.07354 13.173 1.63803C13.5 2.27976 13.5 3.11984 13.5 4.8V11.2C13.5 12.8802 13.5 13.7202 13.173 14.362C12.8854 14.9265 12.4265 15.3854 11.862 15.673C11.2202 16 10.3802 16 8.7 16H7.3C5.61984 16 4.77976 16 4.13803 15.673C3.57354 15.3854 3.1146 14.9265 2.82698 14.362C2.5 13.7202 2.5 12.8802 2.5 11.2V4.8ZM4 3.9C4 3.05992 4 2.63988 4.16349 2.31901C4.3073 2.03677 4.53677 1.8073 4.81901 1.66349C5.13988 1.5 5.55992 1.5 6.4 1.5H9.6C10.4401 1.5 10.8601 1.5 11.181 1.66349C11.4632 1.8073 11.6927 2.03677 11.8365 2.31901C12 2.63988 12 3.05992 12 3.9V12.1C12 12.9401 12 13.3601 11.8365 13.681C11.6927 13.9632 11.4632 14.1927 11.181 14.3365C10.8601 14.5 10.4401 14.5 9.6 14.5H6.4C5.55992 14.5 5.13988 14.5 4.81901 14.3365C4.53677 14.1927 4.3073 13.9632 4.16349 13.681C4 13.3601 4 12.9401 4 12.1V3.9ZM7 2.5C6.58579 2.5 6.25 2.83579 6.25 3.25C6.25 3.66421 6.58579 4 7 4H9C9.41421 4 9.75 3.66421 9.75 3.25C9.75 2.83579 9.41421 2.5 9 2.5H7Z"></path></svg>'), ts = e => {
                    const t = Kt(),
                        n = () => e.fill || t.colors.icon.primary;
                    return (() => {
                        const e = es.cloneNode(!0),
                            t = e.firstChild;
                        return J(() => et(t, "fill", n())), e
                    })()
                }, ns = Xe('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 6.8C1.5 5.11984 1.5 4.27976 1.82698 3.63803C2.1146 3.07354 2.57354 2.6146 3.13803 2.32698C3.77976 2 4.61984 2 6.3 2H9.7C11.3802 2 12.2202 2 12.862 2.32698C13.4265 2.6146 13.8854 3.07354 14.173 3.63803C14.5 4.27976 14.5 5.11984 14.5 6.8V11.5H15.25C15.6642 11.5 16 11.8358 16 12.25C16 12.6642 15.6642 13 15.25 13H0.75C0.335786 13 0 12.6642 0 12.25C0 11.8358 0.335786 11.5 0.75 11.5H1.5V6.8ZM3 11.5H13V5.9C13 5.05992 13 4.63988 12.8365 4.31901C12.6927 4.03677 12.4632 3.8073 12.181 3.66349C11.8601 3.5 11.4401 3.5 10.6 3.5H5.4C4.55992 3.5 4.13988 3.5 3.81901 3.66349C3.53677 3.8073 3.3073 4.03677 3.16349 4.31901C3 4.63988 3 5.05992 3 5.9V11.5Z"></path></svg>'), rs = e => {
                    const t = Kt(),
                        n = () => e.fill || t.colors.icon.primary;
                    return (() => {
                        const e = ns.cloneNode(!0),
                            t = e.firstChild;
                        return J(() => et(t, "fill", n())), e
                    })()
                }, os = Xe('<svg xmlns="http://www.w3.org/2000/svg" width="17" height="16" viewBox="0 0 17 16" fill="none"><g clip-path="url(#clip0_3676_1603)"><path fill-rule="evenodd" clip-rule="evenodd" d="M15.5 1.25049C15.5 0.836275 15.1642 0.500488 14.75 0.500488C14.3358 0.500488 14 0.836275 14 1.25049V3.67012C12.7187 2.04487 10.7318 1.00049 8.5 1.00049C4.63401 1.00049 1.5 4.1345 1.5 8.00049C1.5 11.8665 4.63401 15.0005 8.5 15.0005C11.6844 15.0005 14.3703 12.8748 15.2199 9.96661C15.3361 9.56902 15.1079 9.15254 14.7103 9.03638C14.3127 8.92023 13.8962 9.14838 13.7801 9.54597C13.1123 11.8319 11 13.5005 8.5 13.5005C5.46243 13.5005 3 11.0381 3 8.00049C3 4.96292 5.46243 2.50049 8.5 2.50049C10.321 2.50049 11.9363 3.3855 12.9377 4.75049H10.5C10.0858 4.75049 9.75 5.08627 9.75 5.50049C9.75 5.9147 10.0858 6.25049 10.5 6.25049H14.75C15.1642 6.25049 15.5 5.9147 15.5 5.50049V1.25049Z"></path></g><defs><clipPath id="clip0_3676_1603"><rect width="16" height="16" fill="white" transform="translate(0.5 0.000488281)"></rect></clipPath></defs></svg>'), is = e => {
                    const t = Kt(),
                        n = () => e.fill || t.colors.accent;
                    return (() => {
                        const e = os.cloneNode(!0),
                            t = e.firstChild,
                            r = t.firstChild;
                        return J(() => et(r, "fill", n())), e
                    })()
                }, ss = Xe('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M13 4.06119V6.75053C13 7.16474 13.3358 7.50053 13.75 7.50053C14.1642 7.50053 14.5 7.16474 14.5 6.75053V2.75053L14.5 2.72807C14.5001 2.63191 14.5003 2.49627 14.4842 2.37627C14.4638 2.22503 14.4063 1.99261 14.2071 1.79342C14.0079 1.59423 13.7755 1.5367 13.6243 1.51637C13.5043 1.50023 13.3686 1.50039 13.2725 1.50051L13.25 1.50053H9.25C8.83579 1.50053 8.5 1.83631 8.5 2.25053C8.5 2.66474 8.83579 3.00053 9.25 3.00053H11.9393L7.21967 7.7202C6.92678 8.01309 6.92678 8.48796 7.21967 8.78086C7.51256 9.07375 7.98744 9.07375 8.28033 8.78086L13 4.06119ZM5.85 1.50053H5.81903H5.81899C5.21528 1.50052 4.71702 1.50051 4.31113 1.53367C3.88956 1.56812 3.50203 1.64204 3.13803 1.82751C2.57354 2.11513 2.1146 2.57407 1.82698 3.13856C1.64151 3.50256 1.56759 3.89009 1.53315 4.31166C1.49998 4.71755 1.49999 5.21581 1.5 5.81953V5.81955V5.85053V10.1505V10.1815V10.1815C1.49999 10.7852 1.49998 11.2835 1.53315 11.6894C1.56759 12.111 1.64151 12.4985 1.82698 12.8625C2.1146 13.427 2.57354 13.8859 3.13803 14.1735C3.50203 14.359 3.88956 14.4329 4.31113 14.4674C4.71702 14.5005 5.21527 14.5005 5.81897 14.5005H5.81901H5.85H10.15H10.181H10.181C10.7847 14.5005 11.283 14.5005 11.6889 14.4674C12.1104 14.4329 12.498 14.359 12.862 14.1735C13.4265 13.8859 13.8854 13.427 14.173 12.8625C14.3585 12.4985 14.4324 12.111 14.4669 11.6894C14.5 11.2835 14.5 10.7853 14.5 10.1816V10.1815V10.1505V9.75053C14.5 9.33631 14.1642 9.00053 13.75 9.00053C13.3358 9.00053 13 9.33631 13 9.75053V10.1505C13 10.793 12.9994 11.2297 12.9718 11.5672C12.945 11.8961 12.8963 12.0642 12.8365 12.1815C12.6927 12.4638 12.4632 12.6932 12.181 12.837C12.0637 12.8968 11.8955 12.9455 11.5667 12.9724C11.2292 12.9999 10.7924 13.0005 10.15 13.0005H5.85C5.20757 13.0005 4.77085 12.9999 4.43328 12.9724C4.10447 12.9455 3.93632 12.8968 3.81902 12.837C3.53677 12.6932 3.3073 12.4638 3.16349 12.1815C3.10372 12.0642 3.05503 11.8961 3.02816 11.5672C3.00058 11.2297 3 10.793 3 10.1505V5.85053C3 5.20809 3.00058 4.77137 3.02816 4.43381C3.05503 4.10499 3.10372 3.93684 3.16349 3.81954C3.3073 3.5373 3.53677 3.30783 3.81902 3.16402C3.93632 3.10425 4.10447 3.05556 4.43328 3.02869C4.77085 3.00111 5.20757 3.00053 5.85 3.00053H6.25C6.66422 3.00053 7 2.66474 7 2.25053C7 1.83631 6.66422 1.50053 6.25 1.50053H5.85Z"></path></svg>'), as = e => {
                    const t = Kt(),
                        n = () => e.fill || t.colors.accent;
                    return (() => {
                        const e = ss.cloneNode(!0),
                            t = e.firstChild;
                        return J(() => et(t, "fill", n())), e
                    })()
                }, cs = Xe('<svg xmlns="http://www.w3.org/2000/svg" width="17" height="16" viewBox="0 0 17 16" fill="none"><g clip-path="url(#clip0_3676_1274)"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.82698 2.63901C1.5 3.28074 1.5 4.12082 1.5 5.80098V8.80098V9.00098V10.201C1.5 11.8811 1.5 12.7212 1.82698 13.3629C2.1146 13.9274 2.57354 14.3864 3.13803 14.674C3.77976 15.001 4.61984 15.001 6.3 15.001H11.7C13.3802 15.001 14.2202 15.001 14.862 14.674C15.4265 14.3864 15.8854 13.9274 16.173 13.3629C16.5 12.7212 16.5 11.8811 16.5 10.201V8.80098C16.5 7.12082 16.5 6.28074 16.173 5.63901C15.8854 5.07452 15.4265 4.61558 14.862 4.32796C14.743 4.26733 14.6172 4.21795 14.4805 4.17772C14.4501 3.49449 14.3722 3.02994 14.173 2.63901C13.8854 2.07452 13.4265 1.61558 12.862 1.32796C12.2202 1.00098 11.3802 1.00098 9.7 1.00098H6.3C4.61984 1.00098 3.77976 1.00098 3.13803 1.32796C2.57354 1.61558 2.1146 2.07452 1.82698 2.63901ZM12.9861 4.00942C12.9684 3.7108 12.9281 3.49982 12.8365 3.31999C12.6927 3.03775 12.4632 2.80828 12.181 2.66447C11.8601 2.50098 11.4401 2.50098 10.6 2.50098H5.4C4.55992 2.50098 4.13988 2.50098 3.81901 2.66447C3.53677 2.80828 3.3073 3.03775 3.16349 3.31999C3.03615 3.56991 3.00799 3.88 3.00177 4.40188C3.04646 4.37612 3.09189 4.35146 3.13803 4.32796C3.77976 4.00098 4.61984 4.00098 6.3 4.00098H11.7C12.1966 4.00098 12.6197 4.00098 12.9861 4.00942ZM3 7.90098V8.10098C3 8.47468 3 8.76527 3.01439 9.00098H3V11.101C3 11.9411 3 12.3611 3.16349 12.682C3.3073 12.9642 3.53677 13.1937 3.81901 13.3375C4.13988 13.501 4.55992 13.501 5.4 13.501H12.6C13.4401 13.501 13.8601 13.501 14.181 13.3375C14.4632 13.1937 14.6927 12.9642 14.8365 12.682C15 12.3611 15 11.9411 15 11.101V7.90098C15 7.0609 15 6.64086 14.8365 6.31999C14.6927 6.03775 14.4632 5.80828 14.181 5.66447C13.8601 5.50098 13.4401 5.50098 12.6 5.50098H5.4C4.55992 5.50098 4.13988 5.50098 3.81901 5.66447C3.53677 5.80828 3.3073 6.03775 3.16349 6.31999C3 6.64086 3 7.0609 3 7.90098ZM10.5 9.75098C10.5 9.33676 10.8358 9.00098 11.25 9.00098H12.75C13.1642 9.00098 13.5 9.33676 13.5 9.75098C13.5 10.1652 13.1642 10.501 12.75 10.501H11.25C10.8358 10.501 10.5 10.1652 10.5 9.75098Z"></path></g><defs><clipPath id="clip0_3676_1274"><rect width="16" height="16" fill="white" transform="translate(0.5 0.000976562)"></rect></clipPath></defs></svg>'), us = e => {
                    const t = Kt(),
                        n = () => e.fill || t.colors.accent;
                    return (() => {
                        const e = cs.cloneNode(!0),
                            t = e.firstChild,
                            r = t.firstChild;
                        return J(() => et(r, "fill", n())), e
                    })()
                }, ls = Xe('<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 48 48" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M39.6319 16.8719C38.3212 16.2041 36.7002 16.0478 34 16.0112V11C34 5.47715 29.5228 1 24 1C18.4772 1 14 5.47715 14 11V16.0112C11.2998 16.0478 9.6788 16.2041 8.36808 16.8719C6.86278 17.6389 5.63893 18.8628 4.87195 20.3681C4 22.0794 4 24.3196 4 28.8V32.2C4 36.6804 4 38.9206 4.87195 40.6319C5.63893 42.1372 6.86278 43.3611 8.36808 44.1281C10.0794 45 12.3196 45 16.8 45H31.2C35.6804 45 37.9206 45 39.6319 44.1281C41.1372 43.3611 42.3611 42.1372 43.1281 40.6319C44 38.9206 44 36.6804 44 32.2V28.8C44 24.3196 44 22.0794 43.1281 20.3681C42.3611 18.8628 41.1372 17.6389 39.6319 16.8719ZM31 11V16H17V11C17 7.13401 20.134 4 24 4C27.866 4 31 7.13401 31 11ZM7.54497 21.73C7 22.7996 7 24.1997 7 27V34C7 36.8003 7 38.2004 7.54497 39.27C8.02433 40.2108 8.78924 40.9757 9.73005 41.455C10.7996 42 12.1997 42 15 42H33C35.8003 42 37.2004 42 38.27 41.455C39.2108 40.9757 39.9757 40.2108 40.455 39.27C41 38.2004 41 36.8003 41 34V27C41 24.1997 41 22.7996 40.455 21.73C39.9757 20.7892 39.2108 20.0243 38.27 19.545C37.2004 19 35.8003 19 33 19H15C12.1997 19 10.7996 19 9.73005 19.545C8.78924 20.0243 8.02433 20.7892 7.54497 21.73ZM24 24C23.1716 24 22.5 24.6716 22.5 25.5V29.5C22.5 30.3284 23.1716 31 24 31C24.8284 31 25.5 30.3284 25.5 29.5V25.5C25.5 24.6716 24.8284 24 24 24Z"></path></svg>'), ds = e => {
                    const t = Kt(),
                        n = () => e.fill || t.colors.icon.secondary;
                    return (() => {
                        const t = ls.cloneNode(!0),
                            r = t.firstChild;
                        return J(o => {
                            const i = e.class,
                                s = n();
                            return i !== o._v$ && et(t, "class", o._v$ = i), s !== o._v$2 && et(r, "fill", o._v$2 = s), o
                        }, {
                            _v$: void 0,
                            _v$2: void 0
                        }), t
                    })()
                }, hs = Xe('<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 48 48" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M37.485 37.3849C40.894 33.9506 43 29.2212 43 24C43 13.5066 34.4934 5 24 5C13.5066 5 5 13.5066 5 24C5 29.2213 7.1061 33.9507 10.5151 37.385C13.3583 32.9438 18.3354 30 24.0001 30C29.6647 30 34.6418 32.9437 37.485 37.3849ZM35.1809 39.3635C32.9143 35.5532 28.7554 33 24.0001 33C19.2448 33 15.0858 35.5533 12.8193 39.3636C15.9564 41.6506 19.8206 43 24 43C28.1795 43 32.0437 41.6505 35.1809 39.3635ZM24 46C36.1503 46 46 36.1503 46 24C46 11.8497 36.1503 2 24 2C11.8497 2 2 11.8497 2 24C2 36.1503 11.8497 46 24 46ZM24 24C26.7614 24 29 21.7614 29 19C29 16.2386 26.7614 14 24 14C21.2386 14 19 16.2386 19 19C19 21.7614 21.2386 24 24 24ZM24 27C28.4183 27 32 23.4183 32 19C32 14.5817 28.4183 11 24 11C19.5817 11 16 14.5817 16 19C16 23.4183 19.5817 27 24 27Z"></path></svg>'), ps = e => {
                    const t = Kt(),
                        n = () => e.fill || t.colors.icon.secondary;
                    return (() => {
                        const t = hs.cloneNode(!0),
                            r = t.firstChild;
                        return J(o => {
                            const i = e.class,
                                s = n();
                            return i !== o._v$ && et(t, "class", o._v$ = i), s !== o._v$2 && et(r, "fill", o._v$2 = s), o
                        }, {
                            _v$: void 0,
                            _v$2: void 0
                        }), t
                    })()
                }, gs = Xe('<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 48 48" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M34.5607 4.43934C33.9749 3.85355 33.0251 3.85355 32.4393 4.43934C31.8536 5.02513 31.8536 5.97487 32.4393 6.56066L37.8787 12H10.5C9.67157 12 9 12.6716 9 13.5C9 14.3284 9.67157 15 10.5 15H37.8787L32.4393 20.4393C31.8536 21.0251 31.8536 21.9749 32.4393 22.5607C33.0251 23.1464 33.9749 23.1464 34.5607 22.5607L42.5607 14.5607C43.1464 13.9749 43.1464 13.0251 42.5607 12.4393L34.5607 4.43934ZM13.4393 25.4393C14.0251 24.8536 14.9749 24.8536 15.5607 25.4393C16.1464 26.0251 16.1464 26.9749 15.5607 27.5607L10.1213 33H37.5C38.3284 33 39 33.6716 39 34.5C39 35.3284 38.3284 36 37.5 36H10.1213L15.5607 41.4393C16.1464 42.0251 16.1464 42.9749 15.5607 43.5607C14.9749 44.1464 14.0251 44.1464 13.4393 43.5607L5.43934 35.5607C4.85355 34.9749 4.85355 34.0251 5.43934 33.4393L13.4393 25.4393Z"></path></svg>'), fs = e => {
                    const t = Kt(),
                        n = () => e.fill || t.colors.icon.secondary;
                    return (() => {
                        const t = gs.cloneNode(!0),
                            r = t.firstChild;
                        return J(o => {
                            const i = e.class,
                                s = n();
                            return i !== o._v$ && et(t, "class", o._v$ = i), s !== o._v$2 && et(r, "fill", o._v$2 = s), o
                        }, {
                            _v$: void 0,
                            _v$2: void 0
                        }), t
                    })()
                }, bs = Xe('<svg xmlns="http://www.w3.org/2000/svg" width="28" height="29" viewBox="0 0 28 29" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.75 12.002C1.75 9.20169 1.75 7.80156 2.29497 6.732C2.77433 5.79119 3.53924 5.02629 4.48005 4.54692C5.54961 4.00195 6.94974 4.00195 9.75 4.00195H17.25C20.0503 4.00195 21.4504 4.00195 22.52 4.54692C23.4608 5.02629 24.2257 5.79119 24.705 6.732C24.8256 6.96861 24.9195 7.2214 24.9926 7.50195H21.5C19.6377 7.50195 18.7065 7.50195 17.9609 7.77334C16.711 8.22828 15.7263 9.21291 15.2714 10.4629C15 11.2085 15 12.1396 15 14.002C15 15.8643 15 16.7954 15.2714 17.541C15.7263 18.791 16.711 19.7756 17.9609 20.2306C18.7065 20.502 19.6377 20.502 21.5 20.502H24.9926C24.9195 20.7825 24.8256 21.0353 24.705 21.2719C24.2257 22.2127 23.4608 22.9776 22.52 23.457C21.4504 24.002 20.0503 24.002 17.25 24.002H9.75C6.94974 24.002 5.54961 24.002 4.48005 23.457C3.53924 22.9776 2.77433 22.2127 2.29497 21.2719C1.75 20.2023 1.75 18.8022 1.75 16.002V12.002ZM16.4999 13.802C16.4999 12.1218 16.4999 11.2817 16.8269 10.64C17.1145 10.0755 17.5735 9.61656 18.138 9.32894C18.7797 9.00196 19.6198 9.00196 21.2999 9.00196H23.1999C24.8801 9.00196 25.7202 9.00196 26.3619 9.32894C26.9264 9.61656 27.3853 10.0755 27.673 10.64C27.9999 11.2817 27.9999 12.1218 27.9999 13.802V14.202C27.9999 15.8821 27.9999 16.7222 27.673 17.3639C27.3853 17.9284 26.9264 18.3874 26.3619 18.675C25.7202 19.002 24.8801 19.002 23.1999 19.002H21.2999C19.6198 19.002 18.7797 19.002 18.138 18.675C17.5735 18.3874 17.1145 17.9284 16.8269 17.3639C16.4999 16.7222 16.4999 15.8821 16.4999 14.202V13.802ZM22.4999 14.002C22.4999 14.9685 21.7164 15.752 20.7499 15.752C19.7834 15.752 18.9999 14.9685 18.9999 14.002C18.9999 13.0355 19.7834 12.252 20.7499 12.252C21.7164 12.252 22.4999 13.0355 22.4999 14.002Z"></path></svg>'), ys = e => {
                    const t = Kt(),
                        n = () => e.fill || t.colors.constant.white;
                    return (() => {
                        const t = bs.cloneNode(!0),
                            r = t.firstChild;
                        return J(o => {
                            const i = e.class,
                                s = n();
                            return i !== o._v$ && et(t, "class", o._v$ = i), s !== o._v$2 && et(r, "fill", o._v$2 = s), o
                        }, {
                            _v$: void 0,
                            _v$2: void 0
                        }), t
                    })()
                }, ms = Xe('<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M24.7803 7.21967C25.0732 7.51256 25.0732 7.98744 24.7803 8.28033L11.5303 21.5303C11.2374 21.8232 10.7626 21.8232 10.4697 21.5303L4.21967 15.2803C3.92678 14.9874 3.92678 14.5126 4.21967 14.2197C4.51256 13.9268 4.98744 13.9268 5.28033 14.2197L11 19.9393L23.7197 7.21967C24.0126 6.92678 24.4874 6.92678 24.7803 7.21967Z"></path></svg>'), ws = e => {
                    const t = Kt(),
                        n = () => e.fill || t.colors.icon.secondary;
                    return (() => {
                        const t = ms.cloneNode(!0),
                            r = t.firstChild;
                        return J(o => {
                            const i = e.class,
                                s = n();
                            return i !== o._v$ && et(t, "class", o._v$ = i), s !== o._v$2 && et(r, "fill", o._v$2 = s), o
                        }, {
                            _v$: void 0,
                            _v$2: void 0
                        }), t
                    })()
                }, ks = Xe('<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.0001 10.0001C10.0016 8.02333 10.0267 6.98719 10.436 6.18404C10.8195 5.43139 11.4314 4.81947 12.184 4.43597C13.0397 4 14.1598 4 16.4 4H17.6C19.8402 4 20.9603 4 21.816 4.43597C22.5686 4.81947 23.1805 5.43139 23.564 6.18404C24 7.03969 24 8.15979 24 10.4V11.6C24 13.8402 24 14.9603 23.564 15.816C23.1805 16.5686 22.5686 17.1805 21.816 17.564C21.0128 17.9733 19.9767 17.9984 17.9999 17.9999C17.9984 19.9767 17.9733 21.0128 17.564 21.816C17.1805 22.5686 16.5686 23.1805 15.816 23.564C14.9603 24 13.8402 24 11.6 24H10.4C8.15979 24 7.03969 24 6.18404 23.564C5.43139 23.1805 4.81947 22.5686 4.43597 21.816C4 20.9603 4 19.8402 4 17.6V16.4C4 14.1598 4 13.0397 4.43597 12.184C4.81947 11.4314 5.43139 10.8195 6.18404 10.436C6.98719 10.0267 8.02333 10.0016 10.0001 10.0001ZM10 11.5H9.5C8.09987 11.5 7.3998 11.5 6.86502 11.7725C6.39462 12.0122 6.01217 12.3946 5.77248 12.865C5.5 13.3998 5.5 14.0999 5.5 15.5V18.5C5.5 19.9001 5.5 20.6002 5.77248 21.135C6.01217 21.6054 6.39462 21.9878 6.86502 22.2275C7.3998 22.5 8.09987 22.5 9.5 22.5H12.5C13.9001 22.5 14.6002 22.5 15.135 22.2275C15.6054 21.9878 15.9878 21.6054 16.2275 21.135C16.5 20.6002 16.5 19.9001 16.5 18.5V18H16.4C14.1598 18 13.0397 18 12.184 17.564C11.4314 17.1805 10.8195 16.5686 10.436 15.816C10 14.9603 10 13.8402 10 11.6V11.5ZM11.5 9.5C11.5 8.09987 11.5 7.3998 11.7725 6.86502C12.0122 6.39462 12.3946 6.01217 12.865 5.77248C13.3998 5.5 14.0999 5.5 15.5 5.5H18.5C19.9001 5.5 20.6002 5.5 21.135 5.77248C21.6054 6.01217 21.9878 6.39462 22.2275 6.86502C22.5 7.3998 22.5 8.09987 22.5 9.5V12.5C22.5 13.9001 22.5 14.6002 22.2275 15.135C21.9878 15.6054 21.6054 15.9878 21.135 16.2275C20.6002 16.5 19.9001 16.5 18.5 16.5H15.5C14.0999 16.5 13.3998 16.5 12.865 16.2275C12.3946 15.9878 12.0122 15.6054 11.7725 15.135C11.5 14.6002 11.5 13.9001 11.5 12.5V9.5Z"></path></svg>'), vs = e => {
                    const t = Kt(),
                        n = () => e.fill || t.colors.icon.secondary;
                    return (() => {
                        const e = ks.cloneNode(!0),
                            t = e.firstChild;
                        return J(r => {
                            const o = n(),
                                i = n();
                            return o !== r._v$ && et(e, "fill", r._v$ = o), i !== r._v$2 && et(t, "fill", r._v$2 = i), r
                        }, {
                            _v$: void 0,
                            _v$2: void 0
                        }), e
                    })()
                }, Ss = Xe('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="17" viewBox="0 0 16 17" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 4.12695C1 3.07754 1 2.55284 1.19202 2.14684C1.38986 1.72856 1.7266 1.39181 2.14489 1.19397C2.55088 1.00195 3.07559 1.00195 4.125 1.00195C5.17441 1.00195 5.69912 1.00195 6.10511 1.19397C6.5234 1.39181 6.86014 1.72856 7.05798 2.14684C7.25 2.55284 7.25 3.07754 7.25 4.12695C7.25 5.17636 7.25 5.70107 7.05798 6.10706C6.86014 6.52535 6.5234 6.8621 6.10511 7.05993C5.69912 7.25195 5.17441 7.25195 4.125 7.25195C3.07559 7.25195 2.55088 7.25195 2.14489 7.05993C1.7266 6.8621 1.38986 6.52535 1.19202 6.10706C1 5.70107 1 5.17636 1 4.12695ZM2.5 3.30195C2.5 3.02193 2.5 2.88191 2.5545 2.77496C2.60243 2.68088 2.67892 2.60439 2.773 2.55645C2.87996 2.50195 3.01997 2.50195 3.3 2.50195H4.95C5.23003 2.50195 5.37004 2.50195 5.477 2.55645C5.57108 2.60439 5.64757 2.68088 5.6955 2.77496C5.75 2.88191 5.75 3.02193 5.75 3.30195V4.95195C5.75 5.23198 5.75 5.37199 5.6955 5.47895C5.64757 5.57303 5.57108 5.64952 5.477 5.69746C5.37004 5.75195 5.23003 5.75195 4.95 5.75195H3.3C3.01997 5.75195 2.87996 5.75195 2.773 5.69746C2.67892 5.64952 2.60243 5.57303 2.5545 5.47895C2.5 5.37199 2.5 5.23198 2.5 4.95195V3.30195ZM1 11.877C1 10.8275 1 10.3028 1.19202 9.89684C1.38986 9.47856 1.7266 9.14181 2.14489 8.94397C2.55088 8.75195 3.07559 8.75195 4.125 8.75195C5.17441 8.75195 5.69912 8.75195 6.10511 8.94397C6.5234 9.14181 6.86014 9.47856 7.05798 9.89684C7.25 10.3028 7.25 10.8275 7.25 11.877C7.25 12.9264 7.25 13.4511 7.05798 13.8571C6.86014 14.2753 6.5234 14.6121 6.10511 14.8099C5.69912 15.002 5.17441 15.002 4.125 15.002C3.07559 15.002 2.55088 15.002 2.14489 14.8099C1.7266 14.6121 1.38986 14.2753 1.19202 13.8571C1 13.4511 1 12.9264 1 11.877ZM2.5 11.052C2.5 10.7719 2.5 10.6319 2.5545 10.525C2.60243 10.4309 2.67892 10.3544 2.773 10.3064C2.87996 10.252 3.01997 10.252 3.3 10.252H4.95C5.23003 10.252 5.37004 10.252 5.477 10.3064C5.57108 10.3544 5.64757 10.4309 5.6955 10.525C5.75 10.6319 5.75 10.7719 5.75 11.052V12.702C5.75 12.982 5.75 13.122 5.6955 13.2289C5.64757 13.323 5.57108 13.3995 5.477 13.4475C5.37004 13.502 5.23003 13.502 4.95 13.502H3.3C3.01997 13.502 2.87996 13.502 2.773 13.4475C2.67892 13.3995 2.60243 13.323 2.5545 13.2289C2.5 13.122 2.5 12.982 2.5 12.702V11.052ZM8.94202 2.14684C8.75 2.55284 8.75 3.07754 8.75 4.12695C8.75 5.17636 8.75 5.70107 8.94202 6.10706C9.13986 6.52535 9.4766 6.8621 9.89489 7.05993C10.3009 7.25195 10.8256 7.25195 11.875 7.25195C12.9244 7.25195 13.4491 7.25195 13.8551 7.05993C14.2734 6.8621 14.6101 6.52535 14.808 6.10706C15 5.70107 15 5.17636 15 4.12695C15 3.07754 15 2.55284 14.808 2.14684C14.6101 1.72856 14.2734 1.39181 13.8551 1.19397C13.4491 1.00195 12.9244 1.00195 11.875 1.00195C10.8256 1.00195 10.3009 1.00195 9.89489 1.19397C9.4766 1.39181 9.13986 1.72856 8.94202 2.14684ZM10.3045 2.77496C10.25 2.88191 10.25 3.02193 10.25 3.30195V4.95195C10.25 5.23198 10.25 5.37199 10.3045 5.47895C10.3524 5.57303 10.4289 5.64952 10.523 5.69746C10.63 5.75195 10.77 5.75195 11.05 5.75195H12.7C12.98 5.75195 13.12 5.75195 13.227 5.69746C13.3211 5.64952 13.3976 5.57303 13.4455 5.47895C13.5 5.37199 13.5 5.23198 13.5 4.95195V3.30195C13.5 3.02193 13.5 2.88191 13.4455 2.77496C13.3976 2.68088 13.3211 2.60439 13.227 2.55645C13.12 2.50195 12.98 2.50195 12.7 2.50195H11.05C10.77 2.50195 10.63 2.50195 10.523 2.55645C10.4289 2.60439 10.3524 2.68088 10.3045 2.77496ZM8.80727 9.13518C8.75 9.26242 8.75 9.4256 8.75 9.75195C8.75 10.0783 8.75 10.2415 8.80727 10.3687C8.87245 10.5136 8.9884 10.6295 9.13323 10.6947C9.26047 10.752 9.42365 10.752 9.75 10.752C10.0764 10.752 10.2395 10.752 10.3668 10.6947C10.5116 10.6295 10.6276 10.5136 10.6927 10.3687C10.75 10.2415 10.75 10.0783 10.75 9.75195C10.75 9.4256 10.75 9.26242 10.6927 9.13518C10.6276 8.99035 10.5116 8.8744 10.3668 8.80922C10.2395 8.75195 10.0764 8.75195 9.75 8.75195C9.42365 8.75195 9.26047 8.75195 9.13323 8.80922C8.9884 8.8744 8.87245 8.99035 8.80727 9.13518ZM10.87 11.8771C10.87 11.546 10.87 11.3805 10.9289 11.2517C10.9938 11.1098 11.1077 10.9959 11.2497 10.931C11.3784 10.8721 11.5439 10.8721 11.875 10.8721C12.2061 10.8721 12.3716 10.8721 12.5003 10.931C12.6423 10.9959 12.7562 11.1098 12.8211 11.2517C12.88 11.3805 12.88 11.546 12.88 11.8771C12.88 12.2081 12.88 12.3737 12.8211 12.5024C12.7562 12.6444 12.6423 12.7583 12.5003 12.8232C12.3716 12.8821 12.2061 12.8821 11.875 12.8821C11.5439 12.8821 11.3784 12.8821 11.2497 12.8232C11.1077 12.7583 10.9938 12.6444 10.9289 12.5024C10.87 12.3737 10.87 12.2081 10.87 11.8771ZM8.80727 13.3852C8.75 13.5124 8.75 13.6756 8.75 14.002C8.75 14.3283 8.75 14.4915 8.80727 14.6187C8.87245 14.7636 8.9884 14.8795 9.13323 14.9447C9.26047 15.002 9.42365 15.002 9.75 15.002C10.0764 15.002 10.2395 15.002 10.3668 14.9447C10.5116 14.8795 10.6276 14.7636 10.6927 14.6187C10.75 14.4915 10.75 14.3283 10.75 14.002C10.75 13.6756 10.75 13.5124 10.6927 13.3852C10.6276 13.2404 10.5116 13.1244 10.3668 13.0592C10.2395 13.002 10.0764 13.002 9.75 13.002C9.42365 13.002 9.26047 13.002 9.13323 13.0592C8.9884 13.1244 8.87245 13.2404 8.80727 13.3852ZM13 9.75195C13 9.4256 13 9.26242 13.0573 9.13518C13.1224 8.99035 13.2384 8.8744 13.3832 8.80922C13.5105 8.75195 13.6736 8.75195 14 8.75195C14.3264 8.75195 14.4895 8.75195 14.6168 8.80922C14.7616 8.8744 14.8776 8.99035 14.9427 9.13518C15 9.26242 15 9.4256 15 9.75195C15 10.0783 15 10.2415 14.9427 10.3687C14.8776 10.5136 14.7616 10.6295 14.6168 10.6947C14.4895 10.752 14.3264 10.752 14 10.752C13.6736 10.752 13.5105 10.752 13.3832 10.6947C13.2384 10.6295 13.1224 10.5136 13.0573 10.3687C13 10.2415 13 10.0783 13 9.75195ZM13.0573 13.3852C13 13.5124 13 13.6756 13 14.002C13 14.3283 13 14.4915 13.0573 14.6187C13.1224 14.7636 13.2384 14.8795 13.3832 14.9447C13.5105 15.002 13.6736 15.002 14 15.002C14.3264 15.002 14.4895 15.002 14.6168 14.9447C14.7616 14.8795 14.8776 14.7636 14.9427 14.6187C15 14.4915 15 14.3283 15 14.002C15 13.6756 15 13.5124 14.9427 13.3852C14.8776 13.2404 14.7616 13.1244 14.6168 13.0592C14.4895 13.002 14.3264 13.002 14 13.002C13.6736 13.002 13.5105 13.002 13.3832 13.0592C13.2384 13.1244 13.1224 13.2404 13.0573 13.3852Z"></path></svg>'), Cs = e => {
                    const t = Kt(),
                        n = () => e.fill || t.colors.icon.secondary;
                    return (() => {
                        const e = Ss.cloneNode(!0),
                            t = e.firstChild;
                        return J(() => et(t, "fill", n())), e
                    })()
                }, Is = {
                    m: "16px",
                    s: "12px",
                    none: "0"
                }, As = {
                    m: "6px",
                    s: "6px",
                    none: "0"
                }, Os = zt.div `
    width: 60px;
    height: 60px;
    padding: 8px;
    margin-bottom: 8px;
    border-radius: ${e=>Is[e.theme.borderRadius]};
    background-color: ${e=>e.theme.colors.background.tint};
    display: grid;
    grid-template: 1fr 1fr / 1fr 1fr;
    gap: 4px;
`, xs = zt(yi)
                `
    width: 20px;
    height: 20px;
    border-radius: ${e=>As[e.theme.borderRadius]};
`, _s = e => Pe(Ai, {
                    get name() {
                        return e.labelLine1
                    },
                    get secondLine() {
                        return e.labelLine2
                    },
                    get icon() {
                        return Pe(Os, {
                            get children() {
                                return Pe(Ne, {
                                    each: [0, 1, 2, 3],
                                    children: t => Pe(xs, {
                                        get src() {
                                            return e.images[t]
                                        }
                                    })
                                })
                            }
                        })
                    },
                    onClick: () => e.onClick()
                }), Es = "telegram-wallet", Ts = {
                    TON: "https://raw.githubusercontent.com/ton-connect/sdk/main/assets/ton-icon-48.png",
                    TG: "https://raw.githubusercontent.com/ton-connect/sdk/main/assets/tg.png"
                }, Ps = e => {
                    const [t] = hi(), n = () => {
                        if (e.wallet.appName !== Es) return "isPreferred" in e.wallet && e.wallet.isPreferred ? t("walletItem.recent", {}, "Recent") : Object(d["isWalletInfoCurrentlyInjected"])(e.wallet) ? t("walletItem.installed", {}, "Installed") : "Tonkeeper" === e.wallet.name ? t("walletItem.popular", {}, "Popular") : void 0
                    };
                    return X((() => {
                        const r = X(() => e.wallet.appName === Es);
                        return () => r() ? Pe(Ai, {
                            get icon() {
                                return e.wallet.imageUrl
                            },
                            get name() {
                                return t("walletItem.walletOn", {}, "Wallet On")
                            },
                            secondLine: "Telegram",
                            get badgeUrl() {
                                return Ts.TG
                            },
                            onClick: () => e.onClick()
                        }) : Pe(Ai, {
                            get icon() {
                                return e.wallet.imageUrl
                            },
                            get name() {
                                return e.wallet.name
                            },
                            get secondLine() {
                                return n()
                            },
                            secondLineColorPrimary: !1,
                            onClick: () => e.onClick()
                        })
                    })())
                }, Rs = zt.div `
    width: 100%;
    overflow-y: auto;
    max-height: ${e=>e.maxHeight};

    scrollbar-width: none;
    &&::-webkit-scrollbar {
        display: none;
    }

    &&::-webkit-scrollbar-track {
        background: transparent;
    }

    &&::-webkit-scrollbar-thumb {
        display: none;
    }
`, js = zt.div `
    height: 1px;
    margin: 0 -24px;
    width: calc(100% + 48px);
    opacity: 0.08;
    background: ${e=>e.isShown?e.theme.colors.icon.secondary:"transparent"};
    transition: background 0.15s ease-in-out;

    ${Jr("mobile")} {
        width: 100%;
        margin: 0;
    }
`, [Bs, Ls] = G((null == (l = fn()) ? void 0 : l.innerHeight) || 0);
                fn() && window.addEventListener("resize", () => Ls(window.innerHeight));
                const [Ws, Ns] = G(Yr("mobile")), Ms = () => Ns(Yr("mobile"));
                fn() && (window.addEventListener("resize", () => Ms()), window.addEventListener("load", () => Ms(), {
                    once: !0
                }));
                const Ks = e => {
                        const [t, n] = G(!1), r = e => {
                            n(e.target.scrollTop > 0)
                        }, o = () => Ws() ? 150 : 200, i = () => void 0 !== e.maxHeight ? e.maxHeight + "px" : Bs() - o() + "px";
                        return [Pe(js, {
                            get isShown() {
                                return t()
                            }
                        }), Pe(Rs, {
                            get maxHeight() {
                                return i()
                            },
                            onScroll: r,
                            get ["class"]() {
                                return e.class
                            },
                            get children() {
                                return e.children
                            }
                        })]
                    },
                    Us = zt.a `
    display: block;
    text-decoration: unset;
`,
                    zs = e => {
                        const t = () => e.blank ? {
                            rel: "noreferrer noopener"
                        } : {};
                        return Pe(Us, Le({
                            get href() {
                                return e.href
                            },
                            get target() {
                                return e.blank ? "_blank" : "_self"
                            },
                            get ["class"]() {
                                return e.class
                            }
                        }, t, {
                            get children() {
                                return e.children
                            }
                        }))
                    },
                    Ds = ae(),
                    Hs = Xe('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M7.76228 2.09998H10.2378C11.0458 2.09997 11.7067 2.09996 12.2438 2.14384C12.7997 2.18926 13.3017 2.28614 13.7706 2.52505C14.5045 2.89896 15.1011 3.49558 15.475 4.22941C15.7139 4.6983 15.8108 5.20038 15.8562 5.75629C15.9001 6.29337 15.9001 6.95422 15.9001 7.76227V8.1H16.2377C17.0457 8.09999 17.7066 8.09998 18.2437 8.14386C18.7996 8.18928 19.3017 8.28616 19.7705 8.52507C20.5044 8.89898 21.101 9.4956 21.4749 10.2294C21.7138 10.6983 21.8107 11.2004 21.8561 11.7563C21.9 12.2934 21.9 12.9542 21.9 13.7623V16.2377C21.9 17.0458 21.9 17.7066 21.8561 18.2437C21.8107 18.7996 21.7138 19.3017 21.4749 19.7706C21.101 20.5044 20.5044 21.101 19.7705 21.4749C19.3017 21.7138 18.7996 21.8107 18.2437 21.8561C17.7066 21.9 17.0458 21.9 16.2378 21.9H13.7623C12.9543 21.9 12.2934 21.9 11.7563 21.8561C11.2004 21.8107 10.6983 21.7138 10.2294 21.4749C9.49561 21.101 8.89898 20.5044 8.52508 19.7706C8.28616 19.3017 8.18928 18.7996 8.14386 18.2437C8.09998 17.7066 8.09999 17.0458 8.1 16.2377V15.9H7.76227C6.95426 15.9 6.29335 15.9 5.75629 15.8561C5.20038 15.8107 4.6983 15.7138 4.22941 15.4749C3.49558 15.101 2.89896 14.5044 2.52505 13.7705C2.28614 13.3017 2.18926 12.7996 2.14384 12.2437C2.09996 11.7066 2.09997 11.0458 2.09998 10.2377V7.76228C2.09997 6.95424 2.09996 6.29336 2.14384 5.75629C2.18926 5.20038 2.28614 4.6983 2.52505 4.22941C2.89896 3.49558 3.49558 2.89896 4.22941 2.52505C4.6983 2.28614 5.20038 2.18926 5.75629 2.14384C6.29336 2.09996 6.95425 2.09997 7.76228 2.09998ZM8.1 14.1V13.7623C8.09999 12.9542 8.09998 12.2934 8.14386 11.7563C8.18928 11.2004 8.28616 10.6983 8.52508 10.2294C8.89898 9.4956 9.49561 8.89898 10.2294 8.52507C10.6983 8.28616 11.2004 8.18928 11.7563 8.14386C12.2934 8.09998 12.9542 8.09999 13.7623 8.1H14.1001V7.79998C14.1001 6.94505 14.0994 6.35798 14.0622 5.90287C14.0259 5.45827 13.9593 5.21944 13.8712 5.0466C13.6699 4.65146 13.3486 4.3302 12.9535 4.12886C12.7806 4.04079 12.5418 3.97419 12.0972 3.93786C11.6421 3.90068 11.055 3.89998 10.2001 3.89998H7.79998C6.94505 3.89998 6.35798 3.90068 5.90287 3.93786C5.45827 3.97419 5.21944 4.04079 5.0466 4.12886C4.65146 4.3302 4.3302 4.65146 4.12886 5.0466C4.04079 5.21944 3.97419 5.45827 3.93786 5.90287C3.90068 6.35798 3.89998 6.94505 3.89998 7.79998V10.2C3.89998 11.0549 3.90068 11.642 3.93786 12.0971C3.97419 12.5417 4.04079 12.7805 4.12886 12.9534C4.3302 13.3485 4.65146 13.6698 5.0466 13.8711C5.21944 13.9592 5.45827 14.0258 5.90287 14.0621C6.35798 14.0993 6.94505 14.1 7.79998 14.1H8.1ZM11.0466 10.1289C11.2195 10.0408 11.4583 9.97421 11.9029 9.93788C12.358 9.9007 12.9451 9.9 13.8 9.9H16.2C17.0549 9.9 17.642 9.9007 18.0971 9.93788C18.5417 9.97421 18.7805 10.0408 18.9534 10.1289C19.3485 10.3302 19.6698 10.6515 19.8711 11.0466C19.9592 11.2195 20.0258 11.4583 20.0621 11.9029C20.0993 12.358 20.1 12.9451 20.1 13.8V16.2C20.1 17.0549 20.0993 17.642 20.0621 18.0971C20.0258 18.5417 19.9592 18.7805 19.8711 18.9534C19.6698 19.3485 19.3485 19.6698 18.9534 19.8711C18.7805 19.9592 18.5417 20.0258 18.0971 20.0621C17.642 20.0993 17.0549 20.1 16.2 20.1H13.8C12.9451 20.1 12.358 20.0993 11.9029 20.0621C11.4583 20.0258 11.2195 19.9592 11.0466 19.8711C10.6515 19.6698 10.3302 19.3485 10.1289 18.9534C10.0408 18.7805 9.97421 18.5417 9.93788 18.0971C9.9007 17.642 9.9 17.0549 9.9 16.2V13.8C9.9 12.9451 9.9007 12.358 9.93788 11.9029C9.97421 11.4583 10.0408 11.2195 10.1289 11.0466C10.3302 10.6515 10.6515 10.3302 11.0466 10.1289Z"></path></svg>'),
                    qs = e => {
                        const t = Kt(),
                            n = () => e.fill || t.colors.icon.primary;
                        return (() => {
                            const t = Hs.cloneNode(!0),
                                r = t.firstChild;
                            return J(o => {
                                const i = e.class,
                                    s = n();
                                return i !== o._v$ && et(t, "class", o._v$ = i), s !== o._v$2 && et(r, "fill", o._v$2 = s), o
                            }, {
                                _v$: void 0,
                                _v$2: void 0
                            }), t
                        })()
                    },
                    $s = Xe('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.7624 3.10001C7.95435 3.1 7.29349 3.09999 6.75642 3.14387C6.2005 3.18929 5.69842 3.28617 5.22954 3.52508C4.4957 3.89899 3.89908 4.49561 3.52517 5.22944C3.28626 5.69833 3.18938 6.20041 3.14396 6.75632C3.10008 7.2934 3.10009 7.95424 3.1001 8.76229V15.2377C3.10009 16.0458 3.10008 16.7066 3.14396 17.2437C3.18938 17.7996 3.28626 18.3017 3.52517 18.7706C3.89908 19.5044 4.4957 20.101 5.22954 20.4749C5.69842 20.7138 6.2005 20.8107 6.75642 20.8561C7.29349 20.9 7.95434 20.9 8.76239 20.9H12.0001C12.4972 20.9 12.9001 20.4971 12.9001 20C12.9001 19.503 12.4972 19.1 12.0001 19.1H8.8001C7.94517 19.1 7.3581 19.0993 6.90299 19.0621C6.45839 19.0258 6.21956 18.9592 6.04672 18.8711C5.65158 18.6698 5.33032 18.3485 5.12898 17.9534C5.04092 17.7805 4.97431 17.5417 4.93798 17.0971C4.9008 16.642 4.9001 16.0549 4.9001 15.2V8.80001C4.9001 7.94508 4.9008 7.35801 4.93798 6.9029C4.97431 6.4583 5.04092 6.21947 5.12898 6.04663C5.33032 5.65149 5.65158 5.33023 6.04672 5.12889C6.21956 5.04082 6.45839 4.97422 6.90299 4.93789C7.3581 4.90071 7.94517 4.90001 8.8001 4.90001H12.0001C12.4972 4.90001 12.9001 4.49706 12.9001 4.00001C12.9001 3.50295 12.4972 3.10001 12.0001 3.10001H8.7624Z"></path><path d="M17.6364 7.3636C17.2849 7.01212 16.7151 7.01212 16.3636 7.3636C16.0121 7.71507 16.0121 8.28492 16.3636 8.63639L18.8272 11.1H9.00001C8.50295 11.1 8.10001 11.5029 8.10001 12C8.10001 12.497 8.50295 12.9 9.00001 12.9H18.8272L16.3636 15.3636C16.0121 15.7151 16.0121 16.2849 16.3636 16.6364C16.7151 16.9879 17.2849 16.9879 17.6364 16.6364L21.6364 12.6364C21.9879 12.2849 21.9879 11.7151 21.6364 11.3636L17.6364 7.3636Z"></path></svg>'),
                    Vs = e => {
                        const t = Kt(),
                            n = () => e.fill || t.colors.icon.primary;
                        return (() => {
                            const e = $s.cloneNode(!0),
                                t = e.firstChild,
                                r = t.nextSibling;
                            return J(e => {
                                const o = n(),
                                    i = n();
                                return o !== e._v$ && et(t, "fill", e._v$ = o), i !== e._v$2 && et(r, "fill", e._v$2 = i), e
                            }, {
                                _v$: void 0,
                                _v$2: void 0
                            }), e
                        })()
                    },
                    Fs = {
                        m: "8px",
                        s: "4px",
                        none: "0"
                    },
                    Gs = {
                        m: "16px",
                        s: "8px",
                        none: "0"
                    },
                    Ys = zt.div `
    width: 256px;
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.16);
    border-radius: ${e=>Gs[e.theme.borderRadius]};

    background-color: ${e=>e.theme.colors.background.primary}
           
    color: ${e=>e.theme.colors.text.primary}
`,
                    Js = zt.ul `
    background-color: ${e=>e.theme.colors.background.primary};
    padding: 8px;
`,
                    Zs = zt.button `
    display: flex;
    align-items: center;
    gap: 8px;
    height: 40px;
    padding-left: 8px;
    width: 100%;

    background-color: ${e=>e.theme.colors.background.primary};
    border: none;
    border-radius: ${e=>Fs[e.theme.borderRadius]};
    cursor: pointer;

    transition: background-color, transform 0.1s ease-in-out;

    &:hover {
        background-color: ${e=>e.theme.colors.background.secondary};
    }

    &:active {
        transform: scale(0.96);
    }
`,
                    Xs = Xe("<li></li>"),
                    Qs = e => Pe(gi, {
                        get translationKey() {
                            return e.translationKey
                        },
                        fontSize: "15px",
                        fontWeight: "590",
                        get children() {
                            return e.children
                        }
                    }),
                    ea = e => {
                        const t = ce(Ds),
                            [n, r] = G(!1),
                            o = () => _(void 0, null, (function*() {
                                const e = Object(d["toUserFriendlyAddress"])(t.account.address, t.account.chain === d["CHAIN"].TESTNET);
                                yield oi(e), r(!0), setTimeout(() => r(!1), 1e3)
                            })),
                            i = () => {
                                t.disconnect(), e.onClose()
                            };
                        return Pe(Ys, {
                            ref(t) {
                                const n = e.ref;
                                "function" === typeof n ? n(t) : e.ref = t
                            },
                            get ["class"]() {
                                return e.class
                            },
                            "data-tc-dropdown": "true",
                            get children() {
                                return Pe(Js, {
                                    get children() {
                                        return [(() => {
                                            const e = Xs.cloneNode(!0);
                                            return ct(e, Pe(Zs, {
                                                onClick: () => o(),
                                                get children() {
                                                    return [Pe(qs, {}), Pe(Me, {
                                                        get when() {
                                                            return !n()
                                                        },
                                                        get children() {
                                                            return Pe(Qs, {
                                                                translationKey: "button.dropdown.copy",
                                                                children: "Copy address"
                                                            })
                                                        }
                                                    }), Pe(Me, {
                                                        get when() {
                                                            return n()
                                                        },
                                                        get children() {
                                                            return Pe(Qs, {
                                                                translationKey: "button.dropdown.copied",
                                                                children: "Address copied!"
                                                            })
                                                        }
                                                    })]
                                                }
                                            })), e
                                        })(), (() => {
                                            const e = Xs.cloneNode(!0);
                                            return ct(e, Pe(Zs, {
                                                onClick: () => i(),
                                                get children() {
                                                    return [Pe(Vs, {}), Pe(Qs, {
                                                        translationKey: "button.dropdown.disconnect",
                                                        children: "Disconnect"
                                                    })]
                                                }
                                            })), e
                                        })()]
                                    }
                                })
                            }
                        })
                    },
                    ta = {
                        m: "16px",
                        s: "8px",
                        none: "0"
                    },
                    na = zt.div `
    width: 256px;
    padding: 12px 16px;
    display: flex;
    gap: 9px;

    background-color: ${e=>e.theme.colors.background.primary};
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.16);
    border-radius: ${e=>ta[e.theme.borderRadius]};
`,
                    ra = zt.div `
    width: 192px;

    > h3 {
        font-size: 15px;
    }
`,
                    oa = zt(gi)
                `
    margin-top: 4px;
    color: ${e=>e.theme.colors.text.secondary};
`, ia = e => {
                    const t = no(e);
                    return Pe(na, Le({
                        get ["class"]() {
                            return e.class
                        },
                        "data-tc-notification": "true"
                    }, t, {
                        get children() {
                            return [Pe(ra, {
                                get children() {
                                    return [Pe(Pi, {
                                        get translationKey() {
                                            return e.header.translationKey
                                        },
                                        get translationValues() {
                                            return e.header.translationValues
                                        },
                                        get children() {
                                            return e.children
                                        }
                                    }), Pe(Me, {
                                        get when() {
                                            return e.text
                                        },
                                        get children() {
                                            return Pe(oa, {
                                                get translationKey() {
                                                    return e.text.translationKey
                                                },
                                                get translationValues() {
                                                    return e.text.translationValues
                                                }
                                            })
                                        }
                                    })]
                                }
                            }), X(() => e.icon)]
                        }
                    }))
                }, sa = zt(Fi)
                `
    align-self: center;
`, aa = e => {
                    const t = ce(Ds),
                        [n] = hi(),
                        r = () => t.wallet && "name" in t.wallet ? t.wallet.name : n("common.yourWallet", {}, "Your wallet");
                    return Pe(ia, {
                        get header() {
                            return {
                                translationKey: "notifications.confirm.header",
                                translationValues: {
                                    name: r()
                                }
                            }
                        },
                        get ["class"]() {
                            return e.class
                        },
                        get icon() {
                            return Pe(sa, {})
                        },
                        "data-tc-notification-confirm": "true",
                        children: "Confirm operation in your wallet"
                    })
                }, ca = zt(Hi)
                `
    margin-top: 2px;
`, ua = e => Pe(ia, {
                    header: {
                        translationKey: "notifications.transactionCanceled.header"
                    },
                    text: {
                        translationKey: "notifications.transactionCanceled.text"
                    },
                    get icon() {
                        return Pe(ca, {
                            size: "xs"
                        })
                    },
                    get ["class"]() {
                        return e.class
                    },
                    "data-tc-notification-tx-cancelled": "true",
                    children: "Transaction cancelled"
                }), la = zt(Ki)
                `
    margin-top: 2px;
`, da = e => Pe(ia, {
                    header: {
                        translationKey: "notifications.transactionSent.header"
                    },
                    text: {
                        translationKey: "notifications.transactionSent.text"
                    },
                    get icon() {
                        return Pe(la, {})
                    },
                    get ["class"]() {
                        return e.class
                    },
                    "data-tc-notification-tx-sent": "true",
                    children: "Transaction sent"
                }), ha = Lt `
    transform: translateY(-8px);
    margin-bottom: 12px;
`, pa = {
                    timeout: 4500
                }, [ga, fa] = G(null);

                function ba(e) {
                    const {
                        timeout: t
                    } = A(A({}, pa), e), [n, r] = G([]), [o, i] = G([]);
                    return Z(ne(Nn, e => {
                        var n;
                        if (!e || !e.showNotification) return;
                        if (ga() === e) return;
                        if ("confirm-transaction" === (null == (n = ga()) ? void 0 : n.name) && "confirm-transaction" === e.name) return;
                        fa(e), r(e => e.filter(e => "confirm-transaction" !== e.action));
                        const o = {
                            action: e.name
                        };
                        r(e => [...e, o]);
                        const s = setTimeout(() => {
                            r(e => e.filter(e => e !== o)), i(e => e.filter(e => e !== s))
                        }, t);
                        i(e => [...e, s])
                    })), oe(() => {
                        o().forEach(e => clearTimeout(e))
                    }), n
                }
                const ya = Xe('<div data-tc-list-notifications="true"></div>'),
                    ma = e => {
                        const t = ba();
                        return (() => {
                            const n = ya.cloneNode(!0);
                            return ct(n, Pe(ao, {
                                onBeforeEnter: e => {
                                    Po(e, [{
                                        opacity: 0,
                                        transform: "translateY(0)"
                                    }, {
                                        opacity: 1,
                                        transform: "translateY(-8px)"
                                    }], {
                                        duration: 200
                                    })
                                },
                                onExit: (e, t) => {
                                    const n = Po(e, [{
                                        opacity: 1,
                                        transform: "translateY(-8px)"
                                    }, {
                                        opacity: 0,
                                        transform: "translateY(-30px)"
                                    }], {
                                        duration: 200
                                    });
                                    n.finished.then(t)
                                },
                                get children() {
                                    return Pe(Ne, {
                                        get each() {
                                            return t()
                                        },
                                        children: e => Pe(Ke, {
                                            get children() {
                                                return [Pe(Ue, {
                                                    get when() {
                                                        return "transaction-sent" === e.action
                                                    },
                                                    get children() {
                                                        return Pe(da, {
                                                            class: ha
                                                        })
                                                    }
                                                }), Pe(Ue, {
                                                    get when() {
                                                        return "transaction-canceled" === e.action
                                                    },
                                                    get children() {
                                                        return Pe(ua, {
                                                            class: ha
                                                        })
                                                    }
                                                }), Pe(Ue, {
                                                    get when() {
                                                        return "confirm-transaction" === e.action
                                                    },
                                                    get children() {
                                                        return Pe(aa, {
                                                            class: ha
                                                        })
                                                    }
                                                })]
                                            }
                                        })
                                    })
                                }
                            })), J(() => nt(n, e.class)), n
                        })()
                    },
                    wa = zt(ro)
                `
    background-color: ${e=>e.theme.colors.connectButton.background};
    color: ${e=>e.theme.colors.connectButton.foreground};
    box-shadow: ${e=>"0 4px 24px "+Gt(e.theme.colors.constant.black,.16)};
    padding: 8px 16px 8px 12px;

    display: flex;
    align-items: center;
    gap: 4px;
    height: 40px;
`, ka = zt(wa)
                `
    padding: 12px 16px;
    min-width: 148px;
    justify-content: center;
    background-color: ${e=>e.theme.colors.background.primary};
`, va = zt(ro)
                `
    min-width: 148px;
    height: 40px;

    background-color: ${e=>e.theme.colors.background.primary};
    color: ${e=>e.theme.colors.connectButton.foreground};
    box-shadow: ${e=>"0 4px 24px "+Gt(e.theme.colors.constant.black,.16)};

    display: flex;
    align-items: center;
    justify-content: center;
`, Sa = zt(Fi)
                `
    height: 18px;
    width: 18px;
`, Ca = zt.div `
    width: fit-content;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
`, Ia = zt(ea)
                `
    box-sizing: border-box;
    overflow: hidden;
    margin-top: 12px;
`, Aa = zt(ma)
                `
    > div:first-child {
        margin-top: 20px;
    }
`;

                function Oa(e) {
                    return e.split("-")[0]
                }

                function xa(e) {
                    return e.split("-")[1]
                }

                function _a(e) {
                    return ["top", "bottom"].includes(Oa(e)) ? "x" : "y"
                }

                function Ea(e) {
                    return "y" === e ? "height" : "width"
                }

                function Ta(e, t, n) {
                    let {
                        reference: r,
                        floating: o
                    } = e;
                    const i = r.x + r.width / 2 - o.width / 2,
                        s = r.y + r.height / 2 - o.height / 2,
                        a = _a(t),
                        c = Ea(a),
                        u = r[c] / 2 - o[c] / 2,
                        l = Oa(t),
                        d = "x" === a;
                    let h;
                    switch (l) {
                        case "top":
                            h = {
                                x: i,
                                y: r.y - o.height
                            };
                            break;
                        case "bottom":
                            h = {
                                x: i,
                                y: r.y + r.height
                            };
                            break;
                        case "right":
                            h = {
                                x: r.x + r.width,
                                y: s
                            };
                            break;
                        case "left":
                            h = {
                                x: r.x - o.width,
                                y: s
                            };
                            break;
                        default:
                            h = {
                                x: r.x,
                                y: r.y
                            }
                    }
                    switch (xa(t)) {
                        case "start":
                            h[a] -= u * (n && d ? -1 : 1);
                            break;
                        case "end":
                            h[a] += u * (n && d ? -1 : 1);
                            break
                    }
                    return h
                }
                const Pa = (e, t, n) => _(void 0, null, (function*() {
                    const {
                        placement: r = "bottom",
                        strategy: o = "absolute",
                        middleware: i = [],
                        platform: s
                    } = n, a = i.filter(Boolean), c = yield null == s.isRTL ? void 0 : s.isRTL(t);
                    let u = yield s.getElementRects({
                        reference: e,
                        floating: t,
                        strategy: o
                    }), {
                        x: l,
                        y: d
                    } = Ta(u, r, c), h = r, p = {}, g = 0;
                    for (let n = 0; n < a.length; n++) {
                        const {
                            name: i,
                            fn: f
                        } = a[n], {
                            x: b,
                            y: y,
                            data: m,
                            reset: w
                        } = yield f({
                            x: l,
                            y: d,
                            initialPlacement: r,
                            placement: h,
                            strategy: o,
                            middlewareData: p,
                            rects: u,
                            platform: s,
                            elements: {
                                reference: e,
                                floating: t
                            }
                        });
                        l = null != b ? b : l, d = null != y ? y : d, p = O(A({}, p), {
                            [i]: A(A({}, p[i]), m)
                        }), w && g <= 50 && (g++, "object" === typeof w && (w.placement && (h = w.placement), w.rects && (u = !0 === w.rects ? yield s.getElementRects({
                            reference: e,
                            floating: t,
                            strategy: o
                        }): w.rects), ({
                            x: l,
                            y: d
                        } = Ta(u, h, c))), n = -1)
                    }
                    return {
                        x: l,
                        y: d,
                        placement: h,
                        strategy: o,
                        middlewareData: p
                    }
                }));

                function Ra(e) {
                    return O(A({}, e), {
                        top: e.y,
                        left: e.x,
                        right: e.x + e.width,
                        bottom: e.y + e.height
                    })
                }

                function ja(e) {
                    var t;
                    return (null == (t = e.ownerDocument) ? void 0 : t.defaultView) || window
                }

                function Ba(e) {
                    return ja(e).getComputedStyle(e)
                }

                function La(e) {
                    return Ua(e) ? (e.nodeName || "").toLowerCase() : ""
                }
                let Wa;

                function Na() {
                    if (Wa) return Wa;
                    const e = navigator.userAgentData;
                    return e && Array.isArray(e.brands) ? (Wa = e.brands.map(e => e.brand + "/" + e.version).join(" "), Wa) : navigator.userAgent
                }

                function Ma(e) {
                    return e instanceof ja(e).HTMLElement
                }

                function Ka(e) {
                    return e instanceof ja(e).Element
                }

                function Ua(e) {
                    return e instanceof ja(e).Node
                }

                function za(e) {
                    if ("undefined" === typeof ShadowRoot) return !1;
                    const t = ja(e).ShadowRoot;
                    return e instanceof t || e instanceof ShadowRoot
                }

                function Da(e) {
                    const {
                        overflow: t,
                        overflowX: n,
                        overflowY: r,
                        display: o
                    } = Ba(e);
                    return /auto|scroll|overlay|hidden/.test(t + r + n) && !["inline", "contents"].includes(o)
                }

                function Ha(e) {
                    return ["table", "td", "th"].includes(La(e))
                }

                function qa(e) {
                    const t = /firefox/i.test(Na()),
                        n = Ba(e),
                        r = n.backdropFilter || n.WebkitBackdropFilter;
                    return "none" !== n.transform || "none" !== n.perspective || !!r && "none" !== r || t && "filter" === n.willChange || t && !!n.filter && "none" !== n.filter || ["transform", "perspective"].some(e => n.willChange.includes(e)) || ["paint", "layout", "strict", "content"].some(e => {
                        const t = n.contain;
                        return null != t && t.includes(e)
                    })
                }

                function $a() {
                    return !/^((?!chrome|android).)*safari/i.test(Na())
                }

                function Va(e) {
                    return ["html", "body", "#document"].includes(La(e))
                }
                const Fa = Math.min,
                    Ga = Math.max,
                    Ya = Math.round,
                    Ja = {
                        x: 1,
                        y: 1
                    };

                function Za(e) {
                    const t = !Ka(e) && e.contextElement ? e.contextElement : Ka(e) ? e : null;
                    if (!t) return Ja;
                    const n = t.getBoundingClientRect(),
                        r = Ba(t);
                    if ("border-box" !== r.boxSizing) return Ma(t) ? {
                        x: t.offsetWidth > 0 && Ya(n.width) / t.offsetWidth || 1,
                        y: t.offsetHeight > 0 && Ya(n.height) / t.offsetHeight || 1
                    } : Ja;
                    let o = n.width / parseFloat(r.width),
                        i = n.height / parseFloat(r.height);
                    return o && Number.isFinite(o) || (o = 1), i && Number.isFinite(i) || (i = 1), {
                        x: o,
                        y: i
                    }
                }

                function Xa(e, t, n, r) {
                    var o, i, s, a;
                    void 0 === t && (t = !1), void 0 === n && (n = !1);
                    const c = e.getBoundingClientRect();
                    let u = Ja;
                    t && (r ? Ka(r) && (u = Za(r)) : u = Za(e));
                    const l = Ka(e) ? ja(e) : window,
                        d = !$a() && n,
                        h = (c.left + (d && null != (o = null == (i = l.visualViewport) ? void 0 : i.offsetLeft) ? o : 0)) / u.x,
                        p = (c.top + (d && null != (s = null == (a = l.visualViewport) ? void 0 : a.offsetTop) ? s : 0)) / u.y,
                        g = c.width / u.x,
                        f = c.height / u.y;
                    return {
                        width: g,
                        height: f,
                        top: p,
                        right: h + g,
                        bottom: p + f,
                        left: h,
                        x: h,
                        y: p
                    }
                }

                function Qa(e) {
                    return ((Ua(e) ? e.ownerDocument : e.document) || window.document).documentElement
                }

                function ec(e) {
                    return Ka(e) ? {
                        scrollLeft: e.scrollLeft,
                        scrollTop: e.scrollTop
                    } : {
                        scrollLeft: e.pageXOffset,
                        scrollTop: e.pageYOffset
                    }
                }

                function tc(e) {
                    return Xa(Qa(e)).left + ec(e).scrollLeft
                }

                function nc(e, t, n) {
                    const r = Ma(t),
                        o = Qa(t),
                        i = Xa(e, !0, "fixed" === n, t);
                    let s = {
                        scrollLeft: 0,
                        scrollTop: 0
                    };
                    const a = {
                        x: 0,
                        y: 0
                    };
                    if (r || !r && "fixed" !== n)
                        if (("body" !== La(t) || Da(o)) && (s = ec(t)), Ma(t)) {
                            const e = Xa(t, !0);
                            a.x = e.x + t.clientLeft, a.y = e.y + t.clientTop
                        } else o && (a.x = tc(o));
                    return {
                        x: i.left + s.scrollLeft - a.x,
                        y: i.top + s.scrollTop - a.y,
                        width: i.width,
                        height: i.height
                    }
                }

                function rc(e) {
                    if ("html" === La(e)) return e;
                    const t = e.assignedSlot || e.parentNode || (za(e) ? e.host : null) || Qa(e);
                    return za(t) ? t.host : t
                }

                function oc(e) {
                    return Ma(e) && "fixed" !== Ba(e).position ? e.offsetParent : null
                }

                function ic(e) {
                    let t = rc(e);
                    while (Ma(t) && !Va(t)) {
                        if (qa(t)) return t;
                        t = rc(t)
                    }
                    return null
                }

                function sc(e) {
                    const t = ja(e);
                    let n = oc(e);
                    while (n && Ha(n) && "static" === Ba(n).position) n = oc(n);
                    return n && ("html" === La(n) || "body" === La(n) && "static" === Ba(n).position && !qa(n)) ? t : n || ic(e) || t
                }

                function ac(e) {
                    if (Ma(e)) return {
                        width: e.offsetWidth,
                        height: e.offsetHeight
                    };
                    const t = Xa(e);
                    return {
                        width: t.width,
                        height: t.height
                    }
                }

                function cc(e) {
                    let {
                        rect: t,
                        offsetParent: n,
                        strategy: r
                    } = e;
                    const o = Ma(n),
                        i = Qa(n);
                    if (n === i) return t;
                    let s = {
                            scrollLeft: 0,
                            scrollTop: 0
                        },
                        a = {
                            x: 1,
                            y: 1
                        };
                    const c = {
                        x: 0,
                        y: 0
                    };
                    if ((o || !o && "fixed" !== r) && (("body" !== La(n) || Da(i)) && (s = ec(n)), Ma(n))) {
                        const e = Xa(n);
                        a = Za(n), c.x = e.x + n.clientLeft, c.y = e.y + n.clientTop
                    }
                    return {
                        width: t.width * a.x,
                        height: t.height * a.y,
                        x: t.x * a.x - s.scrollLeft * a.x + c.x,
                        y: t.y * a.y - s.scrollTop * a.y + c.y
                    }
                }

                function uc(e, t) {
                    const n = ja(e),
                        r = Qa(e),
                        o = n.visualViewport;
                    let i = r.clientWidth,
                        s = r.clientHeight,
                        a = 0,
                        c = 0;
                    if (o) {
                        i = o.width, s = o.height;
                        const e = $a();
                        (e || !e && "fixed" === t) && (a = o.offsetLeft, c = o.offsetTop)
                    }
                    return {
                        width: i,
                        height: s,
                        x: a,
                        y: c
                    }
                }

                function lc(e) {
                    var t;
                    const n = Qa(e),
                        r = ec(e),
                        o = null == (t = e.ownerDocument) ? void 0 : t.body,
                        i = Ga(n.scrollWidth, n.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0),
                        s = Ga(n.scrollHeight, n.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0);
                    let a = -r.scrollLeft + tc(e);
                    const c = -r.scrollTop;
                    return "rtl" === Ba(o || n).direction && (a += Ga(n.clientWidth, o ? o.clientWidth : 0) - i), {
                        width: i,
                        height: s,
                        x: a,
                        y: c
                    }
                }

                function dc(e) {
                    const t = rc(e);
                    return Va(t) ? e.ownerDocument.body : Ma(t) && Da(t) ? t : dc(t)
                }

                function hc(e, t) {
                    var n;
                    void 0 === t && (t = []);
                    const r = dc(e),
                        o = r === (null == (n = e.ownerDocument) ? void 0 : n.body),
                        i = ja(r);
                    return o ? t.concat(i, i.visualViewport || [], Da(r) ? r : []) : t.concat(r, hc(r))
                }

                function pc(e, t) {
                    const n = Xa(e, !0, "fixed" === t),
                        r = n.top + e.clientTop,
                        o = n.left + e.clientLeft,
                        i = Ma(e) ? Za(e) : {
                            x: 1,
                            y: 1
                        },
                        s = e.clientWidth * i.x,
                        a = e.clientHeight * i.y,
                        c = o * i.x,
                        u = r * i.y;
                    return {
                        top: u,
                        left: c,
                        right: c + s,
                        bottom: u + a,
                        x: c,
                        y: u,
                        width: s,
                        height: a
                    }
                }

                function gc(e, t, n) {
                    return "viewport" === t ? Ra(uc(e, n)) : Ka(t) ? pc(t, n) : Ra(lc(Qa(e)))
                }

                function fc(e, t) {
                    const n = t.get(e);
                    if (n) return n;
                    let r = hc(e).filter(e => Ka(e) && "body" !== La(e)),
                        o = null;
                    const i = "fixed" === Ba(e).position;
                    let s = i ? rc(e) : e;
                    while (Ka(s) && !Va(s)) {
                        const e = Ba(s),
                            t = qa(s),
                            n = i ? !t && !o : !t && "static" === e.position && !!o && ["absolute", "fixed"].includes(o.position);
                        n ? r = r.filter(e => e !== s) : o = e, s = rc(s)
                    }
                    return t.set(e, r), r
                }

                function bc(e) {
                    let {
                        element: t,
                        boundary: n,
                        rootBoundary: r,
                        strategy: o
                    } = e;
                    const i = "clippingAncestors" === n ? fc(t, this._c) : [].concat(n),
                        s = [...i, r],
                        a = s[0],
                        c = s.reduce((e, n) => {
                            const r = gc(t, n, o);
                            return e.top = Ga(r.top, e.top), e.right = Fa(r.right, e.right), e.bottom = Fa(r.bottom, e.bottom), e.left = Ga(r.left, e.left), e
                        }, gc(t, a, o));
                    return {
                        width: c.right - c.left,
                        height: c.bottom - c.top,
                        x: c.left,
                        y: c.top
                    }
                }
                const yc = {
                    getClippingRect: bc,
                    convertOffsetParentRelativeRectToViewportRelativeRect: cc,
                    isElement: Ka,
                    getDimensions: ac,
                    getOffsetParent: sc,
                    getDocumentElement: Qa,
                    getScale: Za,
                    getElementRects(e) {
                        return _(this, null, (function*() {
                            let {
                                reference: t,
                                floating: n,
                                strategy: r
                            } = e;
                            const o = this.getOffsetParent || sc,
                                i = this.getDimensions;
                            return {
                                reference: nc(t, yield o(n), r),
                                floating: A({
                                    x: 0,
                                    y: 0
                                }, yield i(n))
                            }
                        }))
                    },
                    getClientRects: e => Array.from(e.getClientRects()),
                    isRTL: e => "rtl" === Ba(e).direction
                };

                function mc(e, t, n, r) {
                    void 0 === r && (r = {});
                    const {
                        ancestorScroll: o = !0,
                        ancestorResize: i = !0,
                        elementResize: s = !0,
                        animationFrame: a = !1
                    } = r, c = o && !a, u = c || i ? [...Ka(e) ? hc(e) : e.contextElement ? hc(e.contextElement) : [], ...hc(t)] : [];
                    u.forEach(e => {
                        c && e.addEventListener("scroll", n, {
                            passive: !0
                        }), i && e.addEventListener("resize", n)
                    });
                    let l, d = null;
                    if (s) {
                        let r = !0;
                        d = new ResizeObserver(() => {
                            r || n(), r = !1
                        }), Ka(e) && !a && d.observe(e), Ka(e) || !e.contextElement || a || d.observe(e.contextElement), d.observe(t)
                    }
                    let h = a ? Xa(e) : null;

                    function p() {
                        const t = Xa(e);
                        !h || t.x === h.x && t.y === h.y && t.width === h.width && t.height === h.height || n(), h = t, l = requestAnimationFrame(p)
                    }
                    return a && p(), n(), () => {
                        var e;
                        u.forEach(e => {
                            c && e.removeEventListener("scroll", n), i && e.removeEventListener("resize", n)
                        }), null == (e = d) || e.disconnect(), d = null, a && cancelAnimationFrame(l)
                    }
                }
                const wc = (e, t, n) => {
                    const r = new Map,
                        o = A({
                            platform: yc
                        }, n),
                        i = O(A({}, o.platform), {
                            _c: r
                        });
                    return Pa(e, t, O(A({}, o), {
                        platform: i
                    }))
                };

                function kc(e, t, n) {
                    let r = () => {
                            var e;
                            return null != (e = null == n ? void 0 : n.placement) ? e : "bottom"
                        },
                        o = () => {
                            var e;
                            return null != (e = null == n ? void 0 : n.strategy) ? e : "absolute"
                        },
                        [i, s] = G({
                            x: null,
                            y: null,
                            placement: r(),
                            strategy: o(),
                            middlewareData: {}
                        }),
                        [a, c] = G();
                    Z(() => {
                        let e = a();
                        if (e) throw e.value
                    });
                    let u = X(() => (e(), t(), {}));

                    function l() {
                        let i = e(),
                            a = t();
                        if (i && a) {
                            let e = u();
                            wc(i, a, {
                                middleware: null == n ? void 0 : n.middleware,
                                placement: r(),
                                strategy: o()
                            }).then(t => {
                                e === u() && s(t)
                            }, e => {
                                c(e)
                            })
                        }
                    }
                    return Z(() => {
                        let i = e(),
                            s = t();
                        if (null == n || n.middleware, r(), o(), i && s)
                            if (null != n && n.whileElementsMounted) {
                                let e = n.whileElementsMounted(i, s, l);
                                e && oe(e)
                            } else l()
                    }), {
                        get x() {
                            return i().x
                        },
                        get y() {
                            return i().y
                        },
                        get placement() {
                            return i().placement
                        },
                        get strategy() {
                            return i().strategy
                        },
                        get middlewareData() {
                            return i().middlewareData
                        },
                        update: l
                    }
                }
                const vc = Xe('<tc-root data-tc-dropdown-container="true"></tc-root>'),
                    Sc = () => {
                        const e = Kt(),
                            t = ce(tr),
                            n = ce(Ds),
                            [r, o] = G(!1),
                            [i, s] = G(t.account),
                            [a, c] = G(!t.account);
                        let u;
                        const [l, h] = G(), [p, g] = G(), f = kc(p, l, {
                            whileElementsMounted: mc,
                            placement: "bottom-end"
                        }), b = () => {
                            const e = i();
                            if (e) {
                                const t = Object(d["toUserFriendlyAddress"])(e.address, e.chain === d["CHAIN"].TESTNET);
                                return t.slice(0, 4) + "" + t.slice(-4)
                            }
                            return ""
                        };
                        n.connectionRestored.then(() => c(!1));
                        const y = t.onStatusChange(e => {
                                if (!e) return o(!1), s(null), void c(!1);
                                s(e.account), c(!1)
                            }),
                            m = e => {
                                if (!i() || !r()) return;
                                const t = p().contains(e.target),
                                    n = u.contains(e.target);
                                t || n || o(!1)
                            };
                        return re(() => {
                            document.body.addEventListener("click", m)
                        }), oe(() => {
                            document.body.removeEventListener("click", m), y()
                        }), Pe(Ct, {
                            component: Ht,
                            get children() {
                                return [Pe(Me, {
                                    get when() {
                                        return a()
                                    },
                                    get children() {
                                        return Pe(va, {
                                            disabled: !0,
                                            "data-tc-connect-button-loading": "true",
                                            get children() {
                                                return Pe(Sa, {})
                                            }
                                        })
                                    }
                                }), Pe(Me, {
                                    get when() {
                                        return !a()
                                    },
                                    get children() {
                                        return [Pe(Me, {
                                            get when() {
                                                return !i()
                                            },
                                            get children() {
                                                return Pe(wa, {
                                                    onClick: () => n.openModal(),
                                                    "data-tc-connect-button": "true",
                                                    scale: "s",
                                                    get children() {
                                                        return [Pe(Li, {
                                                            get fill() {
                                                                return e.colors.connectButton.foreground
                                                            }
                                                        }), Pe(gi, {
                                                            translationKey: "button.connectWallet",
                                                            fontSize: "15px",
                                                            lineHeight: "18px",
                                                            fontWeight: "590",
                                                            get color() {
                                                                return e.colors.connectButton.foreground
                                                            },
                                                            children: "Connect wallet"
                                                        })]
                                                    }
                                                })
                                            }
                                        }), Pe(Me, {
                                            get when() {
                                                return i()
                                            },
                                            get children() {
                                                return Pe(Ca, {
                                                    get children() {
                                                        return [Pe(ka, {
                                                            onClick: () => o(e => !e),
                                                            ref: g,
                                                            "data-tc-dropdown-button": "true",
                                                            scale: "s",
                                                            get children() {
                                                                return [Pe(gi, {
                                                                    fontSize: "15px",
                                                                    fontWeight: "590",
                                                                    lineHeight: "18px",
                                                                    get children() {
                                                                        return b()
                                                                    }
                                                                }), Pe(bo, {
                                                                    direction: "bottom"
                                                                })]
                                                            }
                                                        }), Pe(St, {
                                                            get children() {
                                                                const e = te(() => document.importNode(vc, !0));
                                                                return at(h, e), e.style.setProperty("z-index", "999"), e._$owner = se(), ct(e, Pe(io, {
                                                                    onBeforeEnter: e => {
                                                                        Po(e, [{
                                                                            opacity: 0,
                                                                            transform: "translateY(-8px)"
                                                                        }, {
                                                                            opacity: 1,
                                                                            transform: "translateY(0)"
                                                                        }], {
                                                                            duration: 150
                                                                        })
                                                                    },
                                                                    onExit: (e, t) => {
                                                                        const n = Po(e, [{
                                                                            opacity: 1,
                                                                            transform: "translateY(0)"
                                                                        }, {
                                                                            opacity: 0,
                                                                            transform: "translateY(-8px)"
                                                                        }], {
                                                                            duration: 150
                                                                        });
                                                                        n.finished.then(t)
                                                                    },
                                                                    get children() {
                                                                        return Pe(Me, {
                                                                            get when() {
                                                                                return r()
                                                                            },
                                                                            get children() {
                                                                                return Pe(Ia, {
                                                                                    get hidden() {
                                                                                        return !r()
                                                                                    },
                                                                                    onClose: () => o(!1),
                                                                                    ref(e) {
                                                                                        const t = u;
                                                                                        "function" === typeof t ? t(e) : u = e
                                                                                    }
                                                                                })
                                                                            }
                                                                        })
                                                                    }
                                                                }), null), ct(e, Pe(Aa, {}), null), J(t => {
                                                                    var n, r;
                                                                    const o = f.strategy,
                                                                        i = (null != (n = f.y) ? n : 0) + "px",
                                                                        s = (null != (r = f.x) ? r : 0) + "px";
                                                                    return o !== t._v$ && e.style.setProperty("position", t._v$ = o), i !== t._v$2 && e.style.setProperty("top", t._v$2 = i), s !== t._v$3 && e.style.setProperty("left", t._v$3 = s), t
                                                                }, {
                                                                    _v$: void 0,
                                                                    _v$2: void 0,
                                                                    _v$3: void 0
                                                                }), e
                                                            }
                                                        })]
                                                    }
                                                })
                                            }
                                        })]
                                    }
                                })]
                            }
                        })
                    },
                    Cc = zt(Wo)
                `
    padding-left: 24px;
    padding-right: 24px;
    padding-top: 18px;
    padding-bottom: 0;

    ${Jr("mobile")} {
        padding-left: 0;
        padding-right: 0;

        min-height: 364px;
    }
`, Ic = zt(xi)
                `
    margin-top: 12px;

    ${Jr("mobile")} {
        padding: 0 10px;
    }
`, Ac = zt.div `
    margin: 30px 0;
    width: 100%;
    display: flex;
    justify-content: center;

    ${Jr("mobile")} {
        height: 160px;
        align-items: center;
    }
`;
                zt(gi)
                `
    min-width: 84px;
    text-align: center;
    font-weight: 590;
`, zt(Ho)
                `
    margin: 0 auto 22px;
`;
                const [Oc, xc] = wr({
                    buttonRootId: null,
                    language: "en",
                    returnStrategy: "back",
                    twaReturnUrl: void 0,
                    walletsListConfiguration: {},
                    enableAndroidBackHandler: !0
                });

                function _c(e) {
                    return [...new Set(e)]
                }

                function Ec(e, t, n) {
                    return t.map(t => {
                        const r = n.find(n => n[e] === t[e]);
                        return n = n.filter(n => n[e] !== t[e]), void 0 === r ? t : r
                    }).concat(n)
                }

                function Tc(e) {
                    return "jsBridgeKey" in e ? O(A({}, e), {
                        injected: d["TonConnect"].isWalletInjected(e.jsBridgeKey),
                        embedded: d["TonConnect"].isInsideWalletBrowser(e.jsBridgeKey)
                    }) : e
                }

                function Pc(e, t) {
                    var n;
                    return t ? ((null == (n = t.includeWallets) ? void 0 : n.length) && (e = Ec("name", e, t.includeWallets.map(Tc))), e) : e
                }

                function Rc(e) {
                    return e.platforms.some(e => ["macos", "linux", "windows"].includes(e))
                }

                function jc(e) {
                    return e.platforms.some(e => ["ios", "android"].includes(e))
                }

                function Bc(e) {
                    return e.platforms.some(e => ["chrome", "firefox", "safari"].includes(e))
                }

                function Lc(e, t) {
                    return !!t && (e.name.toLowerCase() === t.toLowerCase() || e.appName.toLowerCase() === t.toLowerCase())
                }
                const Wc = zt.div `
    display: flex;
    flex-direction: column;
    align-items: center;
`,
                    Nc = zt(xi)
                `
    margin-bottom: 18px;
`;
                zt.div `
    height: 1px;
    margin: 0 -24px;
    width: calc(100% + 48px);
    opacity: 0.12;
    background: ${e=>e.isShown?e.theme.colors.icon.secondary:"transparent"};
    transition: background 0.15s ease-in-out;

    ${Jr("mobile")} {
        width: 100%;
    }
`;
                const Mc = zt.ul `
    display: grid;
    grid-template-columns: repeat(auto-fit, 92px);
    grid-template-rows: auto;
    align-content: flex-start;
    justify-content: center;
    row-gap: 8px;
    width: 100%;
    padding: 0 0 16px;
    align-self: flex-start;
    max-width: 400px;
    margin: 0 auto;

    > li {
        display: block;
        height: fit-content;
    }

    ${Jr("mobile")} {
        grid-template-columns: repeat(auto-fit, 82px);
    }
`;
                zt(ro)
                `
    display: block;
    margin: 0 auto 1px;
    font-size: 15px;
`;
                const Kc = zt(ko)
                `
    position: absolute;
    top: 16px;
    left: 16px;
`, Uc = zt(Ps)
                `
    height: 100%;
`, zc = Xe("<li></li>"), Dc = e => {
                    const t = () => Ws() ? void 0 : 510,
                        n = () => Ws() ? e.walletsList.filter(jc) : e.walletsList;
                    return Pe(Wc, {
                        "data-tc-wallets-modal-list": "true",
                        get children() {
                            return [Pe(Kc, {
                                icon: "arrow",
                                onClick: () => e.onBack()
                            }), Pe(Nc, {
                                translationKey: "walletModal.wallets",
                                children: "Wallets"
                            }), Pe(Ks, {
                                get maxHeight() {
                                    return t()
                                },
                                get children() {
                                    return Pe(Mc, {
                                        get children() {
                                            return Pe(Ne, {
                                                get each() {
                                                    return n()
                                                },
                                                children: t => (() => {
                                                    const n = zc.cloneNode(!0);
                                                    return ct(n, Pe(Uc, {
                                                        wallet: t,
                                                        onClick: () => e.onSelect(t)
                                                    })), n
                                                })()
                                            })
                                        }
                                    })
                                }
                            })]
                        }
                    })
                }, Hc = {
                    m: "16px",
                    s: "12px",
                    none: "0"
                }, qc = {
                    m: "6px",
                    s: "6px",
                    none: "0"
                }, $c = zt.div `
    display: flex;
    flex-direction: column;
`, Vc = zt.div `
    flex: 1;
    margin-top: ${e=>e.qr?"0":"18px"};
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 232px;
`, Fc = zt(ai)
                `
    margin-bottom: 24px;
`, Gc = zt(xi)
                `
    max-width: 288px;
    margin: 0 auto 2px;
`, Yc = zt(Ei)
                `
    max-width: 288px;
    text-align: center;
    margin: 0 auto 20px;
`, Jc = zt(ko)
                `
    position: absolute;
    top: 16px;
    left: 16px;
`, Zc = zt.div `
    display: flex;
    justify-content: center;
    gap: 8px;
    padding-bottom: 16px;
`, Xc = zt(Zc)
                `
    padding-bottom: 0;
`, Qc = zt(ro)
                `
    margin-bottom: 24px;
`, eu = zt(Fi)
                `
    margin-bottom: 18px;
    margin-top: 2px;
`, tu = zt(Hi)
                `
    margin-bottom: 16px;
`, nu = zt(Ei)
                `
    color: ${e=>e.theme.colors.text.secondary};
    text-align: center;
    margin-bottom: 20px;
`, ru = zt(ro)
                `
    margin-top: -8px;
    margin-bottom: 24px;
    width: 100%;
    padding: 12px 12px 12px 20px;
    border-radius: ${e=>Hc[e.theme.borderRadius]};
    font-size: 16px;
    line-height: 20px;
`, ou = zt(jr)
                `
    width: 32px;
    height: 32px;
    border-radius: ${e=>qc[e.theme.borderRadius]};
`, iu = e => {
                    const [t] = hi();
                    return X(() => {
                        var n;
                        return t(e.translationKey, e.translationValues, null == (n = e.children) ? void 0 : n.toString())
                    })
                };

                function su(e, t) {
                    let n;
                    n = "string" === typeof t ? t : Mr() ? t.twaReturnUrl || t.returnStrategy : "none";
                    const r = uu(e, "ret", n);
                    if (!Object(d["isTelegramUrl"])(e)) return r;
                    const o = r.slice(r.lastIndexOf("&") + 1);
                    return r.slice(0, r.lastIndexOf("&")) + "-" + Object(d["encodeTelegramUrlParameters"])(o)
                }

                function au(e, t) {
                    t = A({}, t);
                    const n = lu(e),
                        r = new URL(n);
                    if (r.searchParams.has("startapp") || r.searchParams.append("startapp", "tonconnect"), Mr()) Nr("ios", "android", "macos") ? (t.returnStrategy = "back", t.twaReturnUrl = void 0, Ur(su(r.toString(), t))) : Nr("tdesktop") || Nr("weba") ? Ur(su(r.toString(), t)) : Nr("web") ? (t.returnStrategy = "back", t.twaReturnUrl = void 0, Ur(su(r.toString(), t))) : rn(su(r.toString(), t));
                    else if (kn("ios")) {
                        "back" === t.returnStrategy && (vn("safari") ? t.returnStrategy = "back" : vn("chrome") ? t.returnStrategy = "googlechrome://" : vn("firefox") ? t.returnStrategy = "firefox://" : vn("opera") ? t.returnStrategy = "opera-http://" : t.returnStrategy = location.href);
                        const e = vn("chrome"),
                            n = vn("firefox"),
                            o = (e || n) && !t.forceRedirect;
                        if (o) {
                            const e = su(r.toString(), t.returnStrategy),
                                n = du(e);
                            on(n, () => rn(e))
                        } else {
                            const e = su(r.toString(), t.returnStrategy);
                            rn(e)
                        }
                    } else if (kn("android")) {
                        t.returnStrategy = "none";
                        const e = vn("chrome"),
                            n = vn("firefox"),
                            o = (e || n) && !t.forceRedirect;
                        if (o) {
                            const e = su(r.toString(), t.returnStrategy),
                                n = du(e);
                            on(n, () => rn(e))
                        } else {
                            const e = su(r.toString(), t.returnStrategy);
                            rn(e)
                        }
                    } else if (kn("ipad")) {
                        "back" === t.returnStrategy && (vn("safari") ? t.returnStrategy = "back" : vn("chrome") ? t.returnStrategy = "googlechrome://" : vn("firefox") ? t.returnStrategy = "firefox://" : vn("opera") ? t.returnStrategy = "opera-http://" : t.returnStrategy = location.href);
                        const e = vn("chrome"),
                            n = vn("firefox"),
                            o = (e || n) && !t.forceRedirect;
                        if (o) {
                            const e = su(r.toString(), t.returnStrategy),
                                n = du(e);
                            on(n, () => rn(e))
                        } else {
                            const e = su(r.toString(), t.returnStrategy);
                            rn(e)
                        }
                    } else if (kn("macos", "windows", "linux"))
                        if (t.returnStrategy = "none", t.twaReturnUrl = void 0, t.forceRedirect) rn(su(r.toString(), t));
                        else {
                            const e = su(r.toString(), t),
                                n = du(e);
                            on(n, () => rn(e))
                        }
                    else rn(su(r.toString(), t))
                }

                function cu(e, t, n, r) {
                    if (n = A({}, n), Mr())
                        if (Nr("ios", "android")) {
                            "back" === n.returnStrategy && (n.returnStrategy = "tg://resolve"), r("universal-link");
                            const t = su(e, n.returnStrategy);
                            Ur(t, () => {
                                r("universal-link"), rn(t)
                            })
                        } else if (Nr("macos", "tdesktop")) {
                        "back" === n.returnStrategy && (n.returnStrategy = "tg://resolve");
                        const o = su(e, n.returnStrategy),
                            i = !!t && !n.forceRedirect;
                        i ? (r("custom-deeplink"), on(Sn(o, t), () => {
                            r("universal-link"), rn(o)
                        })) : (r("universal-link"), rn(o))
                    } else if (Nr("weba")) {
                        "back" === n.returnStrategy && (vn("safari") ? n.returnStrategy = location.href : vn("chrome") ? n.returnStrategy = "googlechrome://" : vn("firefox") ? n.returnStrategy = "firefox://" : vn("opera") ? n.returnStrategy = "opera-http://" : n.returnStrategy = location.href);
                        const o = su(e, n.returnStrategy),
                            i = !!t && !n.forceRedirect;
                        i ? (r("custom-deeplink"), on(Sn(o, t), () => {
                            r("universal-link"), rn(o)
                        })) : (r("universal-link"), rn(o))
                    } else if (Nr("web")) {
                        "back" === n.returnStrategy && (vn("safari") ? n.returnStrategy = location.href : vn("chrome") ? n.returnStrategy = "googlechrome://" : vn("firefox") ? n.returnStrategy = "firefox://" : vn("opera") ? n.returnStrategy = "opera-http://" : n.returnStrategy = location.href);
                        const o = su(e, n.returnStrategy),
                            i = !!t && !n.forceRedirect;
                        i ? (r("custom-deeplink"), on(Sn(o, t), () => {
                            r("universal-link"), rn(o)
                        })) : (r("universal-link"), rn(o))
                    } else {
                        r("universal-link");
                        const t = su(e, n.returnStrategy);
                        rn(t)
                    } else if (kn("ios")) "back" === n.returnStrategy && (vn("safari") ? n.returnStrategy = "none" : vn("chrome") ? n.returnStrategy = "googlechrome://" : vn("firefox") ? n.returnStrategy = "firefox://" : vn("opera") ? n.returnStrategy = "opera-http://" : n.returnStrategy = location.href), vn("chrome") ? (r("universal-link"), nn(su(e, n.returnStrategy), "_self")) : (r("universal-link"), rn(su(e, n.returnStrategy)));
                    else if (kn("android")) "back" === n.returnStrategy && (vn("chrome") ? n.returnStrategy = "googlechrome://" : vn("firefox") ? n.returnStrategy = "firefox://" : vn("opera") ? n.returnStrategy = "opera-http://" : n.returnStrategy = location.href), r("universal-link"), rn(su(e, n.returnStrategy));
                    else if (kn("ipad")) "back" === n.returnStrategy && (vn("safari") ? n.returnStrategy = "none" : vn("chrome") ? n.returnStrategy = "googlechrome://" : vn("firefox") ? n.returnStrategy = "firefox://" : vn("opera") ? n.returnStrategy = "opera-http://" : n.returnStrategy = location.href), vn("chrome") ? (r("universal-link"), nn(su(e, n.returnStrategy), "_self")) : (r("universal-link"), rn(su(e, n.returnStrategy)));
                    else if (kn("macos", "windows", "linux")) {
                        "back" === n.returnStrategy && (vn("safari") ? n.returnStrategy = "none" : vn("chrome") ? n.returnStrategy = "googlechrome://" : vn("firefox") ? n.returnStrategy = "firefox://" : vn("opera") ? n.returnStrategy = "opera-http://" : n.returnStrategy = "none");
                        const o = su(e, n.returnStrategy),
                            i = !!t && !n.forceRedirect;
                        i ? (r("custom-deeplink"), on(Sn(o, t), () => {
                            r("universal-link"), rn(o)
                        })) : (r("universal-link"), rn(o))
                    } else r("universal-link"), rn(su(e, n.returnStrategy))
                }

                function uu(e, t, n) {
                    const r = new URL(e);
                    return r.searchParams.append(t, n), r.toString()
                }

                function lu(e) {
                    const t = new URL(e);
                    return t.searchParams.has("attach") && (t.searchParams.delete("attach"), t.pathname += "/start"), t.toString()
                }

                function du(e) {
                    const t = new URL(e),
                        [, n, r] = t.pathname.split("/"),
                        o = t.searchParams.get("startapp");
                    return `tg://resolve?domain=${n}&appname=${r}&startapp=${o}`
                }
                const hu = e => {
                        const [t, n] = G("mobile"), [r, o] = G(!1), [i, s] = G(), [a, c] = G(!0), u = ce(tr), l = u.onStatusChange(() => {}, () => {
                            e.wallet.appName !== Es && o(!0)
                        });
                        oe(l);
                        const h = () => {
                            try {
                                const t = u.connect({
                                    universalLink: e.wallet.universalLink,
                                    bridgeUrl: e.wallet.bridgeUrl
                                }, e.additionalRequest);
                                s(t)
                            } catch (Ll) {}
                        };
                        Z(() => {
                            "extension" !== te(t) && (jc(e.wallet) || Rc(e.wallet)) && h()
                        });
                        const p = () => {
                                o(!1), "extension" === t() && h(), n("mobile"), Wn(O(A({}, e.wallet), {
                                    openMethod: "qrcode"
                                }))
                            },
                            g = () => {
                                o(!1), "extension" === t() && h(), n("desktop");
                                const r = !a();
                                c(!1), cu(i(), e.wallet.deepLink, {
                                    returnStrategy: Oc.returnStrategy,
                                    forceRedirect: r
                                }, t => {
                                    Wn(O(A({}, e.wallet), {
                                        openMethod: t
                                    }))
                                })
                            },
                            f = () => {
                                const t = !a();
                                c(!1), Wn(O(A({}, e.wallet), {
                                    openMethod: "universal-link"
                                })), au(i(), {
                                    returnStrategy: Oc.returnStrategy,
                                    twaReturnUrl: Oc.twaReturnUrl,
                                    forceRedirect: t
                                })
                            },
                            b = () => {
                                o(!1), n("extension"), Object(d["isWalletInfoCurrentlyInjected"])(e.wallet) && (Wn(e.wallet), u.connect({
                                    jsBridgeKey: e.wallet.jsBridgeKey
                                }, e.additionalRequest))
                            };
                        return jc(e.wallet) ? p() : Bc(e.wallet) ? b() : g(), Pe($c, {
                            "data-tc-wallets-modal-connection-desktop": "true",
                            get children() {
                                return [Pe(Me, {
                                    get when() {
                                        return !e.backDisabled
                                    },
                                    get children() {
                                        return Pe(Jc, {
                                            icon: "arrow",
                                            onClick: () => e.onBackClick()
                                        })
                                    }
                                }), Pe(Gc, {
                                    get children() {
                                        return e.wallet.name
                                    }
                                }), Pe(Me, {
                                    get when() {
                                        return "mobile" === t()
                                    },
                                    get children() {
                                        return Pe(Yc, {
                                            translationKey: "walletModal.desktopConnectionModal.scanQR",
                                            get translationValues() {
                                                return {
                                                    name: e.wallet.name
                                                }
                                            },
                                            get children() {
                                                return ["Scan the QR code below with your phones or ", X(() => e.wallet.name), "s camera"]
                                            }
                                        })
                                    }
                                }), Pe(Vc, {
                                    get qr() {
                                        return "mobile" === t()
                                    },
                                    get children() {
                                        return Pe(Ke, {
                                            get children() {
                                                return [Pe(Ue, {
                                                    get when() {
                                                        return "mobile" === t()
                                                    },
                                                    get children() {
                                                        return Pe(Fc, {
                                                            disableCopy: !1,
                                                            get sourceUrl() {
                                                                return su(i(), "none")
                                                            },
                                                            get imageUrl() {
                                                                return e.wallet.imageUrl
                                                            }
                                                        })
                                                    }
                                                }), Pe(Ue, {
                                                    get when() {
                                                        return r()
                                                    },
                                                    get children() {
                                                        return [Pe(tu, {
                                                            size: "s"
                                                        }), Pe(nu, {
                                                            translationKey: "walletModal.desktopConnectionModal.connectionDeclined",
                                                            children: "Connection declined"
                                                        }), Pe(Zc, {
                                                            get children() {
                                                                return Pe(ro, {
                                                                    get leftIcon() {
                                                                        return Pe(is, {})
                                                                    },
                                                                    get onClick() {
                                                                        return "extension" === t() ? b : g
                                                                    },
                                                                    get children() {
                                                                        return Pe(iu, {
                                                                            translationKey: "common.retry",
                                                                            children: "Retry"
                                                                        })
                                                                    }
                                                                })
                                                            }
                                                        })]
                                                    }
                                                }), Pe(Ue, {
                                                    get when() {
                                                        return "extension" === t()
                                                    },
                                                    get children() {
                                                        return [Pe(Me, {
                                                            get when() {
                                                                return Object(d["isWalletInfoCurrentlyInjected"])(e.wallet)
                                                            },
                                                            get children() {
                                                                return [Pe(eu, {
                                                                    size: "s"
                                                                }), Pe(nu, {
                                                                    translationKey: "walletModal.desktopConnectionModal.continueInExtension",
                                                                    get translationValues() {
                                                                        return {
                                                                            name: e.wallet.name
                                                                        }
                                                                    },
                                                                    get children() {
                                                                        return ["Continue in ", X(() => e.wallet.name), " browser extension"]
                                                                    }
                                                                }), Pe(Zc, {
                                                                    get children() {
                                                                        return Pe(ro, {
                                                                            get leftIcon() {
                                                                                return Pe(is, {})
                                                                            },
                                                                            onClick: b,
                                                                            get children() {
                                                                                return Pe(iu, {
                                                                                    translationKey: "common.retry",
                                                                                    children: "Retry"
                                                                                })
                                                                            }
                                                                        })
                                                                    }
                                                                })]
                                                            }
                                                        }), Pe(Me, {
                                                            get when() {
                                                                return !Object(d["isWalletInfoCurrentlyInjected"])(e.wallet)
                                                            },
                                                            get children() {
                                                                return [Pe(nu, {
                                                                    translationKey: "walletModal.desktopConnectionModal.dontHaveExtension",
                                                                    get translationValues() {
                                                                        return {
                                                                            name: e.wallet.name
                                                                        }
                                                                    },
                                                                    get children() {
                                                                        return ["Seems you don't have installed ", X(() => e.wallet.name), " browser extension"]
                                                                    }
                                                                }), Pe(Zc, {
                                                                    get children() {
                                                                        return Pe(zs, {
                                                                            get href() {
                                                                                return e.wallet.aboutUrl
                                                                            },
                                                                            blank: !0,
                                                                            get children() {
                                                                                return Pe(ro, {
                                                                                    get rightIcon() {
                                                                                        return Pe(as, {})
                                                                                    },
                                                                                    onClick: b,
                                                                                    get children() {
                                                                                        return Pe(iu, {
                                                                                            translationKey: "walletModal.desktopConnectionModal.getWallet",
                                                                                            get translationValues() {
                                                                                                return {
                                                                                                    name: e.wallet.name
                                                                                                }
                                                                                            },
                                                                                            get children() {
                                                                                                return ["Get ", X(() => e.wallet.name)]
                                                                                            }
                                                                                        })
                                                                                    }
                                                                                })
                                                                            }
                                                                        })
                                                                    }
                                                                })]
                                                            }
                                                        })]
                                                    }
                                                }), Pe(Ue, {
                                                    get when() {
                                                        return "desktop" === t()
                                                    },
                                                    get children() {
                                                        return [Pe(Fi, {
                                                            size: "m"
                                                        }), Pe(nu, {
                                                            translationKey: "walletModal.desktopConnectionModal.continueOnDesktop",
                                                            get translationValues() {
                                                                return {
                                                                    name: e.wallet.name
                                                                }
                                                            },
                                                            get children() {
                                                                return ["Continue in ", X(() => e.wallet.name), " on desktop"]
                                                            }
                                                        }), Pe(Zc, {
                                                            get children() {
                                                                return [Pe(ro, {
                                                                    get leftIcon() {
                                                                        return Pe(is, {})
                                                                    },
                                                                    onClick: g,
                                                                    get children() {
                                                                        return Pe(iu, {
                                                                            translationKey: "common.retry",
                                                                            children: "Retry"
                                                                        })
                                                                    }
                                                                }), Pe(zs, {
                                                                    get href() {
                                                                        return e.wallet.aboutUrl
                                                                    },
                                                                    blank: !0,
                                                                    get children() {
                                                                        return Pe(ro, {
                                                                            get rightIcon() {
                                                                                return Pe(as, {})
                                                                            },
                                                                            get children() {
                                                                                return Pe(iu, {
                                                                                    translationKey: "walletModal.desktopConnectionModal.getWallet",
                                                                                    get translationValues() {
                                                                                        return {
                                                                                            name: e.wallet.name
                                                                                        }
                                                                                    },
                                                                                    get children() {
                                                                                        return ["Get ", X(() => e.wallet.name)]
                                                                                    }
                                                                                })
                                                                            }
                                                                        })
                                                                    }
                                                                })]
                                                            }
                                                        })]
                                                    }
                                                })]
                                            }
                                        })
                                    }
                                }), Pe(Me, {
                                    get when() {
                                        return e.wallet.appName === Es
                                    },
                                    get children() {
                                        return Pe(ru, {
                                            get rightIcon() {
                                                return Pe(ou, {
                                                    get src() {
                                                        return Ts.TG
                                                    }
                                                })
                                            },
                                            scale: "s",
                                            onClick: f,
                                            get children() {
                                                return Pe(iu, {
                                                    translationKey: "walletModal.desktopConnectionModal.openWalletOnTelegram",
                                                    children: "Open Wallet in Telegram on desktop"
                                                })
                                            }
                                        })
                                    }
                                }), Pe(Me, {
                                    get when() {
                                        return e.wallet.appName !== Es
                                    },
                                    get children() {
                                        return Pe(Xc, {
                                            get children() {
                                                return [Pe(Me, {
                                                    get when() {
                                                        return X(() => "mobile" !== t())() && jc(e.wallet)
                                                    },
                                                    get children() {
                                                        return Pe(Qc, {
                                                            appearance: "secondary",
                                                            get leftIcon() {
                                                                return Pe(ts, {})
                                                            },
                                                            onClick: p,
                                                            get children() {
                                                                return Pe(iu, {
                                                                    translationKey: "common.mobile",
                                                                    children: "Mobile"
                                                                })
                                                            }
                                                        })
                                                    }
                                                }), Pe(Me, {
                                                    get when() {
                                                        return X(() => "extension" !== t())() && Bc(e.wallet)
                                                    },
                                                    get children() {
                                                        return Pe(Qc, {
                                                            appearance: "secondary",
                                                            get leftIcon() {
                                                                return Pe(Qi, {})
                                                            },
                                                            onClick: b,
                                                            get children() {
                                                                return Pe(iu, {
                                                                    translationKey: "common.browserExtension",
                                                                    children: "Browser Extension"
                                                                })
                                                            }
                                                        })
                                                    }
                                                }), Pe(Me, {
                                                    get when() {
                                                        return X(() => "desktop" !== t())() && Rc(e.wallet)
                                                    },
                                                    get children() {
                                                        return Pe(Qc, {
                                                            appearance: "secondary",
                                                            get leftIcon() {
                                                                return Pe(rs, {})
                                                            },
                                                            onClick: g,
                                                            get children() {
                                                                return Pe(iu, {
                                                                    translationKey: "common.desktop",
                                                                    children: "Desktop"
                                                                })
                                                            }
                                                        })
                                                    }
                                                })]
                                            }
                                        })
                                    }
                                })]
                            }
                        })
                    },
                    pu = zt.div ``,
                    gu = zt(ko)
                `
    position: absolute;
    top: 16px;
    left: 16px;
`, fu = zt(xi)
                `
    margin-bottom: 18px;
`, bu = zt.div `
    padding: 16px 0;
    display: flex;
    flex-direction: column;
    align-items: center;
`, yu = Lt `
    margin-bottom: 12px;
`, mu = zt(Pi)
                `
    text-align: center;
    margin-bottom: 4px;
`, wu = zt(gi)
                `
    text-align: center;
    max-width: 352px;
    color: ${e=>e.theme.colors.text.secondary};
`, ku = zt.div `
    padding: 16px 24px 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
`, vu = {
                    GET_A_WALLET: "https://ton.org/wallets?filters[wallet_features][slug][$in]=dapp-auth&pagination[limit]=-1"
                }, Su = e => Pe(pu, {
                    "data-tc-wallets-modal-info": "true",
                    get children() {
                        return [Pe(gu, {
                            icon: "arrow",
                            onClick: () => e.onBackClick()
                        }), Pe(fu, {
                            translationKey: "walletModal.infoModal.whatIsAWallet",
                            children: "What is a wallet"
                        }), Pe(Ks, {
                            get children() {
                                return [Pe(bu, {
                                    get children() {
                                        return [Pe(ds, {
                                            class: yu
                                        }), Pe(mu, {
                                            translationKey: "walletModal.infoModal.secureDigitalAssets",
                                            children: "Secure digital assets storage"
                                        }), Pe(wu, {
                                            translationKey: "walletModal.infoModal.walletProtects",
                                            children: "A wallet protects and manages your digital assets including TON, tokens and collectables."
                                        })]
                                    }
                                }), Pe(bu, {
                                    get children() {
                                        return [Pe(ps, {
                                            class: yu
                                        }), Pe(mu, {
                                            translationKey: "walletModal.infoModal.controlIdentity",
                                            children: "Control your Web3 identity"
                                        }), Pe(wu, {
                                            translationKey: "walletModal.infoModal.manageIdentity",
                                            children: "Manage your digital identity and access decentralized applications with ease. Maintain control over your data and engage securely in the blockchain ecosystem."
                                        })]
                                    }
                                }), Pe(bu, {
                                    get children() {
                                        return [Pe(fs, {
                                            class: yu
                                        }), Pe(mu, {
                                            translationKey: "walletModal.infoModal.effortlessCryptoTransactions",
                                            children: "Effortless crypto transactions"
                                        }), Pe(wu, {
                                            translationKey: "walletModal.infoModal.easilySend",
                                            children: "Easily send, receive, monitor your cryptocurrencies. Streamline your operations with decentralized applications."
                                        })]
                                    }
                                }), Pe(ku, {
                                    get children() {
                                        return Pe(zs, {
                                            get href() {
                                                return vu.GET_A_WALLET
                                            },
                                            blank: !0,
                                            get children() {
                                                return Pe(ro, {
                                                    get rightIcon() {
                                                        return Pe(us, {})
                                                    },
                                                    get children() {
                                                        return Pe(iu, {
                                                            translationKey: "walletModal.infoModal.getAWallet",
                                                            children: "Get a Wallet"
                                                        })
                                                    }
                                                })
                                            }
                                        })
                                    }
                                })]
                            }
                        })]
                    }
                }), Cu = zt.div ``, Iu = zt.div `
    flex: 1;
    margin-top: 18px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 232px;
`, Au = zt(xi)
                `
    max-width: 262px;
    margin: 0 auto 8px;
`, Ou = zt(ko)
                `
    position: absolute;
    top: 16px;
    left: 16px;
`, xu = zt.div `
    padding: 16px;
    display: flex;
    align-items: center;
    gap: 12px;
    border-top: 0.5px solid ${e=>Gt(e.theme.colors.icon.secondary,.2)};
`, _u = zt(jr)
                `
    width: 36px;
    height: 36px;
    border-radius: 10px;
`, Eu = zt(zs)
                `
    margin-left: auto;
`, Tu = zt(Fi)
                `
    margin-bottom: 18px;
    margin-top: 2px;
`, Pu = zt(Hi)
                `
    margin-bottom: 16px;
`, Ru = zt(Ei)
                `
    color: ${e=>e.theme.colors.text.secondary};
    text-align: center;
    margin-bottom: 20px;
`, ju = zt.div `
    display: flex;
    justify-content: center;
    gap: 8px;
    padding-bottom: 16px;
`, Bu = zt(xi)
                `
    margin-bottom: 2px;
    padding: 0 64px;
`, Lu = zt(Ei)
                `
    margin-bottom: 20px;
    padding: 0 64px;
    min-height: 44px;
`, Wu = zt.div `
    padding: 0 24px 24px;
`, Nu = e => [Pe(Bu, {
                    get children() {
                        return e.walletInfo.name
                    }
                }), Pe(Lu, {
                    translationKey: "walletModal.mobileConnectionModal.scanQR",
                    get translationValues() {
                        return {
                            name: e.walletInfo.name
                        }
                    },
                    get children() {
                        return ["Scan the QR code below with your phones or ", X(() => e.walletInfo.name), "s camera"]
                    }
                }), Pe(Wu, {
                    get children() {
                        return Pe(ai, {
                            get imageUrl() {
                                return e.walletInfo.imageUrl
                            },
                            get sourceUrl() {
                                return su(e.universalLink, "none")
                            },
                            disableCopy: !0
                        })
                    }
                })], Mu = e => {
                    const t = Kt(),
                        [n, r] = G(!0),
                        [o, i] = G(!1),
                        [s, a] = G(!1),
                        c = ce(tr),
                        u = c.onStatusChange(() => {}, () => {
                            a(!0)
                        }),
                        l = X(() => c.connect({
                            universalLink: e.wallet.universalLink,
                            bridgeUrl: e.wallet.bridgeUrl
                        }, e.additionalRequest)),
                        h = () => {
                            const t = !0;
                            Wn(O(A({}, e.wallet), {
                                openMethod: "universal-link"
                            })), au(l(), {
                                returnStrategy: Oc.returnStrategy,
                                twaReturnUrl: Oc.twaReturnUrl,
                                forceRedirect: t
                            })
                        },
                        p = () => {
                            const t = l();
                            if (Object(d["isTelegramUrl"])(t)) return h();
                            a(!1);
                            const o = !n();
                            r(!1), cu(l(), e.wallet.deepLink, {
                                returnStrategy: Oc.returnStrategy,
                                forceRedirect: o
                            }, t => {
                                Wn(O(A({}, e.wallet), {
                                    openMethod: t
                                }))
                            })
                        },
                        g = () => {
                            a(!1), i(!0), Wn(O(A({}, e.wallet), {
                                openMethod: "qrcode"
                            }))
                        },
                        f = () => {
                            i(!1), Wn(O(A({}, e.wallet), {
                                openMethod: "universal-link"
                            }))
                        },
                        b = () => {
                            o() ? f() : e.onBackClick()
                        };
                    return oe(u), p(), Pe(Cu, {
                        "data-tc-wallets-modal-connection-mobile": "true",
                        get children() {
                            return [Pe(Me, {
                                get when() {
                                    return !e.backDisabled || o()
                                },
                                get children() {
                                    return Pe(Ou, {
                                        icon: "arrow",
                                        onClick: b
                                    })
                                }
                            }), Pe(Me, {
                                get when() {
                                    return o()
                                },
                                get children() {
                                    return Pe(Nu, {
                                        get universalLink() {
                                            return l()
                                        },
                                        get walletInfo() {
                                            return e.wallet
                                        }
                                    })
                                }
                            }), Pe(Me, {
                                get when() {
                                    return !o()
                                },
                                get children() {
                                    return [Pe(Au, {
                                        get children() {
                                            return e.wallet.name
                                        }
                                    }), Pe(Iu, {
                                        get children() {
                                            return [Pe(Me, {
                                                get when() {
                                                    return s()
                                                },
                                                get children() {
                                                    return [Pe(Pu, {
                                                        size: "s"
                                                    }), Pe(Ru, {
                                                        translationKey: "walletModal.mobileConnectionModal.connectionDeclined",
                                                        children: "Connection declined"
                                                    }), Pe(ju, {
                                                        get children() {
                                                            return [Pe(ro, {
                                                                get leftIcon() {
                                                                    return Pe(is, {})
                                                                },
                                                                onClick: p,
                                                                get children() {
                                                                    return Pe(iu, {
                                                                        translationKey: "common.retry",
                                                                        children: "Retry"
                                                                    })
                                                                }
                                                            }), Pe(ro, {
                                                                get leftIcon() {
                                                                    return Pe(Cs, {
                                                                        get fill() {
                                                                            return t.colors.accent
                                                                        }
                                                                    })
                                                                },
                                                                onClick: g,
                                                                get children() {
                                                                    return Pe(iu, {
                                                                        translationKey: "walletModal.mobileConnectionModal.showQR",
                                                                        children: "Show QR Code"
                                                                    })
                                                                }
                                                            })]
                                                        }
                                                    })]
                                                }
                                            }), Pe(Me, {
                                                get when() {
                                                    return !s()
                                                },
                                                get children() {
                                                    return [Pe(Tu, {
                                                        size: "s"
                                                    }), Pe(Ru, {
                                                        translationKey: "walletModal.mobileConnectionModal.continueIn",
                                                        get translationValues() {
                                                            return {
                                                                name: e.wallet.name
                                                            }
                                                        },
                                                        get children() {
                                                            return ["Continue in ", X(() => e.wallet.name), ""]
                                                        }
                                                    }), Pe(ju, {
                                                        get children() {
                                                            return [Pe(ro, {
                                                                get leftIcon() {
                                                                    return Pe(is, {})
                                                                },
                                                                onClick: p,
                                                                get children() {
                                                                    return Pe(iu, {
                                                                        translationKey: "common.retry",
                                                                        children: "Retry"
                                                                    })
                                                                }
                                                            }), Pe(ro, {
                                                                get leftIcon() {
                                                                    return Pe(Cs, {
                                                                        get fill() {
                                                                            return t.colors.accent
                                                                        }
                                                                    })
                                                                },
                                                                onClick: g,
                                                                get children() {
                                                                    return Pe(iu, {
                                                                        translationKey: "walletModal.mobileConnectionModal.showQR",
                                                                        children: "Show QR Code"
                                                                    })
                                                                }
                                                            })]
                                                        }
                                                    })]
                                                }
                                            })]
                                        }
                                    }), Pe(xu, {
                                        get children() {
                                            return [Pe(_u, {
                                                get src() {
                                                    return e.wallet.imageUrl
                                                }
                                            }), Pe(Pi, {
                                                get children() {
                                                    return e.wallet.name
                                                }
                                            }), Pe(Eu, {
                                                get href() {
                                                    return e.wallet.aboutUrl
                                                },
                                                blank: !0,
                                                get children() {
                                                    return Pe(ro, {
                                                        get children() {
                                                            return Pe(iu, {
                                                                translationKey: "common.get",
                                                                children: "GET"
                                                            })
                                                        }
                                                    })
                                                }
                                            })]
                                        }
                                    })]
                                }
                            })]
                        }
                    })
                }, Ku = {
                    m: "16px",
                    s: "12px",
                    none: "0"
                }, Uu = {
                    m: "6px",
                    s: "6px",
                    none: "0"
                }, zu = zt.ul `
    display: flex;
    justify-content: space-between;
    margin: 0 auto;
    width: fit-content;
    max-width: 100%;
    min-width: 100%;
    height: fit-content;
    overflow-x: auto;
    overflow-y: hidden;
    padding: 0 13px 24px;

    &&::-webkit-scrollbar {
        display: none;
    }

    -ms-overflow-style: none;
    scrollbar-width: none;

    > li {
        height: fit-content;
    }
`, Du = zt.li `
    width: 82px;
    min-width: 82px;
    height: 124px;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 8px 4px;

    text-align: center;
    cursor: pointer;

    transition: transform 0.1s ease-in-out;

    ${Xr} {
        &:hover {
            transform: scale(1.04);
        }
    }

    &:active {
        transform: scale(0.96);
    }

    ${Zr} {
        &:active {
            transform: scale(0.92);
        }
    }
`, Hu = zt.div `
    width: 1px;
    margin: 0 10px;
    height: 24px;
    position: relative;
    top: 26px;

    background-color: ${e=>e.theme.colors.icon.secondary};
    opacity: 0.2;
`, qu = zt.div `
    width: 60px;
    height: 60px;
    border-radius: ${e=>Ku[e.theme.borderRadius]};
    display: flex;
    align-items: center;
    justify-content: center;

    background-color: ${e=>e.theme.colors.background.tint};
    margin-bottom: 8px;
`, $u = zt(xi)
                `
    margin-top: 38px;
    margin-bottom: 4px;
    padding: 0 24px;
`, Vu = zt(Ei)
                `
    margin-bottom: 24px;
    padding: 0 24px;
    min-height: 44px;
`;
                zt(ro)
                `
    display: block;
    margin: 0 auto;
`;
                const Fu = zt(ro)
                `
    margin: 0 24px 24px;
    width: calc(100% - 48px);
    border-radius: ${e=>Ku[e.theme.borderRadius]};
    padding: 14px 16px 14px 14px;
    background-color: ${e=>e.theme.colors.telegramButton};

    color: ${e=>e.theme.colors.constant.white};
    font-weight: 590;
    font-size: 16px;
    line-height: 20px;
`, Gu = zt(jr)
                `
    border-radius: ${e=>Uu[e.theme.borderRadius]};
    width: 24px;
    height: 24px;
`, Yu = zt(ko)
                `
    position: absolute;
    top: 16px;
    left: 16px;
`, Ju = zt(xi)
                `
    margin-bottom: 2px;
    padding: 0 64px;
`, Zu = zt(Ei)
                `
    margin-bottom: 20px;
    padding: 0 64px;
`, Xu = zt.div `
    padding: 0 24px 24px;
`, Qu = e => [Pe(Ju, {
                    translationKey: "walletModal.mobileUniversalModal.connectYourWallet",
                    children: "Connect your wallet"
                }), Pe(Zu, {
                    translationKey: "walletModal.mobileUniversalModal.scan",
                    children: "Scan with your mobile wallet"
                }), Pe(Xu, {
                    get children() {
                        return Pe(ai, {
                            get imageUrl() {
                                return Ts.TON
                            },
                            get sourceUrl() {
                                return su(e.universalLink, "none")
                            },
                            disableCopy: !0
                        })
                    }
                })];

                function el(e) {
                    const t = new Set(e.filter(d["isWalletInfoRemote"]).map(e => e.bridgeUrl));
                    return Array.from(t).map(e => ({
                        bridgeUrl: e
                    }))
                }

                function tl(e, t) {
                    const n = new Set(null == e ? void 0 : e.map(e => e.bridgeUrl)),
                        r = new Set(null == t ? void 0 : t.map(e => e.bridgeUrl));
                    return n.size === r.size && [...n].every(e => r.has(e))
                }
                const nl = Xe("<li></li>"),
                    rl = Xe('<div data-tc-wallets-modal-universal-mobile="true"></div>'),
                    ol = e => {
                        const [t, n] = G(!1), [r, o] = G(!0), [i, s] = G(null), a = Oc.connector, c = () => e.walletsList.filter(e => jc(e) && e.appName !== Es), u = () => c().length > 7, l = X(() => el(e.walletsList), null, {
                            equals: tl
                        }), h = () => (i() || s(a.connect(l(), e.additionalRequest)), i());
                        Wn({
                            openMethod: "universal-link"
                        });
                        const [p, g] = G(void 0), f = () => _(void 0, null, (function*() {
                            void 0 !== p() && clearTimeout(p()), yield oi(h());
                            const e = setTimeout(() => g(void 0), 1500);
                            g(e)
                        })), b = () => {
                            const e = !r();
                            o(!1), cu(h(), void 0, {
                                returnStrategy: Oc.returnStrategy,
                                forceRedirect: e
                            }, e => {
                                Wn({
                                    openMethod: e
                                })
                            })
                        }, y = () => {
                            s(null);
                            const t = e.walletsList.find(e => e.appName === Es);
                            if (!t || !Object(d["isWalletInfoRemote"])(t)) throw new Xt("@wallet bot not found in the wallets list");
                            const n = a.connect({
                                    bridgeUrl: t.bridgeUrl,
                                    universalLink: t.universalLink
                                }, e.additionalRequest),
                                i = !r();
                            o(!1), au(n, {
                                returnStrategy: Oc.returnStrategy,
                                twaReturnUrl: Oc.twaReturnUrl,
                                forceRedirect: i
                            })
                        }, m = () => {
                            n(!0), Wn({
                                openMethod: "qrcode"
                            })
                        }, w = () => {
                            n(!1), Wn({
                                openMethod: "universal-link"
                            })
                        };
                        return (() => {
                            const n = rl.cloneNode(!0);
                            return ct(n, Pe(Me, {
                                get when() {
                                    return t()
                                },
                                get children() {
                                    return [Pe(Yu, {
                                        icon: "arrow",
                                        onClick: w
                                    }), Pe(Qu, {
                                        get universalLink() {
                                            return h()
                                        }
                                    })]
                                }
                            }), null), ct(n, Pe(Me, {
                                get when() {
                                    return !t()
                                },
                                get children() {
                                    return [Pe(Yu, {
                                        get icon() {
                                            return Pe(Cs, {})
                                        },
                                        onClick: m
                                    }), Pe($u, {
                                        translationKey: "walletModal.mobileUniversalModal.connectYourWallet",
                                        children: "Connect your wallet"
                                    }), Pe(Vu, {
                                        translationKey: "walletModal.mobileUniversalModal.openWalletOnTelegramOrSelect",
                                        children: "Open Wallet in Telegram or select your wallet to connect"
                                    }), Pe(Fu, {
                                        get leftIcon() {
                                            return Pe(ys, {})
                                        },
                                        get rightIcon() {
                                            return Pe(Gu, {
                                                get src() {
                                                    return Ts.TG
                                                }
                                            })
                                        },
                                        onClick: y,
                                        scale: "s",
                                        get children() {
                                            return Pe(iu, {
                                                translationKey: "walletModal.mobileUniversalModal.openWalletOnTelegram",
                                                children: "Open Wallet in Telegram"
                                            })
                                        }
                                    }), Pe(zu, {
                                        get children() {
                                            return [Pe(Ne, {
                                                get each() {
                                                    return X(() => !!u())() ? c().slice(0, 4) : c()
                                                },
                                                children: t => (() => {
                                                    const n = nl.cloneNode(!0);
                                                    return ct(n, Pe(Ai, {
                                                        get icon() {
                                                            return t.imageUrl
                                                        },
                                                        get name() {
                                                            return t.name
                                                        },
                                                        onClick: () => e.onSelect(t)
                                                    })), n
                                                })()
                                            }), Pe(Me, {
                                                get when() {
                                                    return u()
                                                },
                                                get children() {
                                                    const t = nl.cloneNode(!0);
                                                    return ct(t, Pe(_s, {
                                                        labelLine1: "View all",
                                                        labelLine2: "wallets",
                                                        get images() {
                                                            return c().slice(3, 7).map(e => e.imageUrl)
                                                        },
                                                        onClick: () => e.onSelectAllWallets()
                                                    })), t
                                                }
                                            }), Pe(Hu, {
                                                children: ""
                                            }), Pe(Du, {
                                                onClick: b,
                                                get children() {
                                                    return [Pe(qu, {
                                                        get children() {
                                                            return Pe(ji, {})
                                                        }
                                                    }), Pe(gi, {
                                                        fontWeight: 590,
                                                        translationKey: "walletModal.mobileUniversalModal.openLink",
                                                        children: "Open Link"
                                                    })]
                                                }
                                            }), Pe(Du, {
                                                onClick: f,
                                                get children() {
                                                    return [Pe(qu, {
                                                        get children() {
                                                            return X(() => void 0 !== p())() ? Pe(ws, {}) : Pe(vs, {})
                                                        }
                                                    }), Pe(gi, {
                                                        fontWeight: 590,
                                                        get translationKey() {
                                                            return void 0 !== p() ? "common.copied" : "common.copyLink"
                                                        },
                                                        get children() {
                                                            return void 0 !== p() ? "Copied" : "Copy Link"
                                                        }
                                                    })]
                                                }
                                            })]
                                        }
                                    })]
                                }
                            }), null), n
                        })()
                    },
                    il = {
                        m: "16px",
                        s: "8px",
                        none: "0"
                    },
                    sl = {
                        m: "8px",
                        s: "4px",
                        none: "0"
                    },
                    al = zt.div `
    display: flex;
    flex-direction: column;
    align-items: center;
    padding-bottom: 16px;
`,
                    cl = zt(Ei)
                `
    max-width: 320px;
    margin-top: 2px;
    margin-bottom: 20px;
`, ul = zt(Ei)
                `
    margin-bottom: 16px;
`, ll = zt(ai)
                `
    margin-bottom: 24px;
`, dl = zt.ul `
    display: flex;
`;
                zt.div `
    display: flex;
    gap: 16px;
    width: 100%;
`, zt(ro)
                `
    position: relative;
    font-size: 16px;
    line-height: 20px;
    width: 100%;
    padding: 0 16px;
    height: 56px;
    border-radius: ${e=>il[e.theme.borderRadius]};

    &:hover {
        ${e=>e.disableEventsAnimation?"transform: unset;":""}
    }

    &:active {
        ${e=>e.disableEventsAnimation?"transform: unset;":""}
    }
`, zt.ul `
    position: absolute;
    bottom: 100%;
    left: 0;
    margin: 0;
    padding: 8px;
    width: 188px;
    transform: translateY(-16px);

    background-color: ${e=>e.theme.colors.background.primary};
    border-radius: ${e=>il[e.theme.borderRadius]};
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.16);
`, zt.li `
    padding: 8px;

    display: flex;
    align-items: center;
    gap: 8px;

    cursor: pointer;
    border-radius: ${e=>sl[e.theme.borderRadius]};

    transition: background-color, transform 0.1s ease-in-out;

    &:hover {
        background-color: ${e=>e.theme.colors.background.secondary};
    }

    &:active {
        transform: scale(0.96);
    }
`, zt(jr)
                `
    width: 24px;
    height: 24px;

    border-radius: 6px;
`, zt.div `
    margin-top: 23px;
    margin-bottom: 1px;
    width: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
`, zt(gi)
                `
    color: ${e=>e.theme.colors.text.secondary};
    font-size: 16px;
`;
                const hl = Xe("<li></li>"),
                    pl = e => {
                        const [t, n] = G(!1), r = Oc.connector, o = X(() => el(e.walletsList), null, {
                            equals: tl
                        });
                        Wn({
                            openMethod: "qrcode"
                        });
                        const i = X(() => r.connect(o(), e.additionalRequest));
                        return Pe(al, {
                            onClick: () => n(!1),
                            "data-tc-wallets-modal-universal-desktop": "true",
                            get children() {
                                return [Pe(xi, {
                                    translationKey: "walletModal.desktopUniversalModal.connectYourWallet",
                                    children: "Connect your wallet"
                                }), Pe(cl, {
                                    translationKey: "walletModal.desktopUniversalModal.scan",
                                    children: "Scan with your mobile wallet"
                                }), Pe(ll, {
                                    get sourceUrl() {
                                        return su(i(), "none")
                                    },
                                    get disableCopy() {
                                        return t()
                                    },
                                    get imageUrl() {
                                        return Ts.TON
                                    }
                                }), Pe(ul, {
                                    translationKey: "walletModal.desktopUniversalModal.availableWallets",
                                    children: "Available wallets"
                                }), Pe(dl, {
                                    get children() {
                                        return [Pe(Ne, {
                                            get each() {
                                                return e.walletsList.slice(0, 3)
                                            },
                                            children: t => (() => {
                                                const n = hl.cloneNode(!0);
                                                return ct(n, Pe(Ps, {
                                                    wallet: t,
                                                    onClick: () => e.onSelect(t)
                                                })), n
                                            })()
                                        }), Pe(_s, {
                                            labelLine1: "View all",
                                            labelLine2: "wallets",
                                            get images() {
                                                return e.walletsList.slice(3, 7).map(e => e.imageUrl)
                                            },
                                            onClick: () => e.onSelectAllWallets()
                                        })]
                                    }
                                })]
                            }
                        })
                    },
                    gl = () => {
                        const {
                            locale: e
                        } = hi()[1];
                        Z(() => e(Oc.language)), Z(() => {
                            _n() ? Ms() : (i(null), a("universal"), u(!1))
                        });
                        const t = ce(tr),
                            n = ce(Ds),
                            [r] = Q(() => n.getWallets()),
                            [o, i] = G(null),
                            [s, a] = G("universal"),
                            [c, u] = G(!1),
                            l = X(() => {
                                if ("ready" !== r.state) return null;
                                let e = Pc(r(), Oc.walletsListConfiguration);
                                const t = e.filter(d["isWalletInfoCurrentlyInjected"]),
                                    n = e.filter(e => !Object(d["isWalletInfoCurrentlyInjected"])(e));
                                e = (t || []).concat(n);
                                const o = Oc.preferredWalletAppName,
                                    i = e.find(e => Lc(e, o)),
                                    s = e.filter(e => Lc(e, o)).length >= 2;
                                o && i && !s && (e = [O(A({}, i), {
                                    isPreferred: !0
                                })].concat(e.filter(e => !Lc(e, o))));
                                const a = e.find(e => Lc(e, Es));
                                return a && (e = [a].concat(e.filter(e => !Lc(e, Es)))), e
                            }),
                            h = () => {
                                var e;
                                return "loading" === (null == (e = Oc.connectRequestParameters) ? void 0 : e.state)
                            },
                            p = X(() => {
                                var e;
                                if (!h()) return null == (e = Oc.connectRequestParameters) ? void 0 : e.value
                            }),
                            g = e => {
                                n.closeModal(e)
                            },
                            f = t.onStatusChange(e => {
                                e && g("wallet-selected")
                            }),
                            b = () => {
                                a("all-wallets")
                            },
                            y = () => {
                                a("universal")
                            },
                            m = () => {
                                i(null)
                            };
                        return oe(() => {
                            i(null), u(!1)
                        }), oe(f), Pe(Cc, {
                            get opened() {
                                return _n()
                            },
                            get enableAndroidBackHandler() {
                                return Oc.enableAndroidBackHandler
                            },
                            onClose: () => g("action-cancelled"),
                            onClickQuestion: () => u(e => !e),
                            "data-tc-wallets-modal-container": "true",
                            get children() {
                                return [Pe(Me, {
                                    get when() {
                                        return c()
                                    },
                                    get children() {
                                        return Pe(Su, {
                                            onBackClick: () => u(!1)
                                        })
                                    }
                                }), Pe(Me, {
                                    get when() {
                                        return !c()
                                    },
                                    get children() {
                                        return [Pe(Me, {
                                            get when() {
                                                return h() || !l()
                                            },
                                            get children() {
                                                return [Pe(Ic, {
                                                    translationKey: "walletModal.loading",
                                                    children: "Wallets list is loading"
                                                }), Pe(Ac, {
                                                    get children() {
                                                        return Pe(Fi, {
                                                            size: "m"
                                                        })
                                                    }
                                                })]
                                            }
                                        }), Pe(Me, {
                                            get when() {
                                                return X(() => !h())() && l()
                                            },
                                            get children() {
                                                return Pe(Ke, {
                                                    get children() {
                                                        return [Pe(Ue, {
                                                            get when() {
                                                                return o()
                                                            },
                                                            get children() {
                                                                return Pe(Ct, {
                                                                    get component() {
                                                                        return Ws() ? Mu : hu
                                                                    },
                                                                    get wallet() {
                                                                        return o()
                                                                    },
                                                                    get additionalRequest() {
                                                                        return p()
                                                                    },
                                                                    onBackClick: m
                                                                })
                                                            }
                                                        }), Pe(Ue, {
                                                            get when() {
                                                                return "universal" === s()
                                                            },
                                                            get children() {
                                                                return Pe(Ct, {
                                                                    get component() {
                                                                        return Ws() ? ol : pl
                                                                    },
                                                                    onSelect: i,
                                                                    get walletsList() {
                                                                        return l()
                                                                    },
                                                                    get additionalRequest() {
                                                                        return p()
                                                                    },
                                                                    onSelectAllWallets: b
                                                                })
                                                            }
                                                        }), Pe(Ue, {
                                                            get when() {
                                                                return "all-wallets" === s()
                                                            },
                                                            get children() {
                                                                return Pe(Dc, {
                                                                    get walletsList() {
                                                                        return l()
                                                                    },
                                                                    onBack: y,
                                                                    onSelect: i
                                                                })
                                                            }
                                                        })]
                                                    }
                                                })
                                            }
                                        })]
                                    }
                                })]
                            }
                        })
                    },
                    fl = zt.div `
    display: flex;
    flex-direction: column;
    align-items: center;
    padding-bottom: 8px;
`,
                    bl = zt(xi)
                `
    margin-top: 16px;
`, yl = zt(gi)
                `
    font-weight: 510;
    font-size: 16px;
    line-height: 20px;
    text-align: center;
    max-width: 250px;

    color: ${e=>e.theme.colors.text.secondary};
`, ml = zt(ro)
                `
    min-width: 112px;
    margin-top: 32px;
`, wl = zt(Fi)
                `
    height: 16px;
    width: 16px;
`, kl = zt(ro)
                `
    margin-top: 32px;
`, vl = e => {
                    const t = no(e),
                        n = ce(Ds),
                        [r, o] = G(!0),
                        [i, s] = G(!1);
                    let a, c;
                    Z(() => {
                        const e = Nn();
                        s(!!e && "sent" in e && e.sent)
                    }), (null == n ? void 0 : n.wallet) && "universalLink" in n.wallet && ("universal-link" === n.wallet.openMethod || Object(d["isTelegramUrl"])(n.wallet.universalLink) && Mr()) && (a = n.wallet.universalLink), (null == n ? void 0 : n.wallet) && "deepLink" in n.wallet && ("custom-deeplink" === n.wallet.openMethod || Object(d["isTelegramUrl"])(n.wallet.deepLink) && Mr()) && (c = n.wallet.deepLink);
                    const u = () => {
                        const e = Nn(),
                            t = "returnStrategy" in e ? e.returnStrategy : Oc.returnStrategy,
                            n = !r();
                        o(!1), Object(d["isTelegramUrl"])(a) ? au(a, {
                            returnStrategy: t,
                            twaReturnUrl: "twaReturnUrl" in e ? e.twaReturnUrl : Oc.twaReturnUrl,
                            forceRedirect: n
                        }) : cu(a, c, {
                            returnStrategy: t,
                            forceRedirect: n
                        }, () => {})
                    };
                    return Pe(fl, Le(t, {
                        get children() {
                            return [X(() => e.icon), Pe(bl, {
                                get translationKey() {
                                    return e.headerTranslationKey
                                },
                                get translationValues() {
                                    return e.headerTranslationValues
                                }
                            }), Pe(yl, {
                                get translationKey() {
                                    return e.textTranslationKey
                                },
                                get translationValues() {
                                    return e.textTranslationValues
                                }
                            }), Pe(Me, {
                                get when() {
                                    return !i() && ("open-wallet" === e.showButton && a || "open-wallet" !== e.showButton)
                                },
                                get children() {
                                    return Pe(ml, {
                                        disabled: !0,
                                        "data-tc-connect-button-loading": "true",
                                        get children() {
                                            return Pe(wl, {})
                                        }
                                    })
                                }
                            }), Pe(Me, {
                                get when() {
                                    return i()
                                },
                                get children() {
                                    return [Pe(Me, {
                                        get when() {
                                            return "open-wallet" !== e.showButton
                                        },
                                        get children() {
                                            return Pe(kl, {
                                                onClick: () => e.onClose(),
                                                get children() {
                                                    return Pe(iu, {
                                                        translationKey: "common.close",
                                                        children: "Close"
                                                    })
                                                }
                                            })
                                        }
                                    }), Pe(Me, {
                                        get when() {
                                            return "open-wallet" === e.showButton && a
                                        },
                                        get children() {
                                            return Pe(kl, {
                                                onClick: u,
                                                get children() {
                                                    return Pe(iu, {
                                                        translationKey: "common.openWallet",
                                                        children: "Open wallet"
                                                    })
                                                }
                                            })
                                        }
                                    })]
                                }
                            })]
                        }
                    }))
                }, Sl = e => {
                    const t = ce(Ds),
                        [n] = hi(),
                        r = () => t.wallet && "name" in t.wallet ? t.wallet.name : n("common.yourWallet", {}, "Your wallet");
                    return Pe(vl, {
                        headerTranslationKey: "actionModal.confirmTransaction.header",
                        get headerTranslationValues() {
                            return {
                                name: r()
                            }
                        },
                        textTranslationKey: "actionModal.confirmTransaction.text",
                        get icon() {
                            return Pe(Fi, {
                                size: "m"
                            })
                        },
                        onClose: () => e.onClose(),
                        showButton: "open-wallet",
                        "data-tc-confirm-modal": "true"
                    })
                }, Cl = e => Pe(vl, {
                    headerTranslationKey: "actionModal.transactionCanceled.header",
                    textTranslationKey: "actionModal.transactionCanceled.text",
                    get icon() {
                        return Pe(Hi, {
                            size: "m"
                        })
                    },
                    onClose: () => e.onClose(),
                    "data-tc-transaction-canceled-modal": "true"
                }), Il = e => Pe(vl, {
                    headerTranslationKey: "actionModal.transactionSent.header",
                    textTranslationKey: "actionModal.transactionSent.text",
                    get icon() {
                        return Pe(Ki, {
                            size: "m"
                        })
                    },
                    onClose: () => e.onClose(),
                    "data-tc-transaction-sent-modal": "true"
                }), Al = () => Pe(Wo, {
                    get opened() {
                        var e;
                        return X(() => null !== Nn())() && !0 === (null == (e = Nn()) ? void 0 : e.openModal)
                    },
                    get enableAndroidBackHandler() {
                        return Oc.enableAndroidBackHandler
                    },
                    onClose: () => Mn(null),
                    "data-tc-actions-modal-container": "true",
                    get children() {
                        return Pe(Ke, {
                            get children() {
                                return [Pe(Ue, {
                                    get when() {
                                        return "transaction-sent" === Nn().name
                                    },
                                    get children() {
                                        return Pe(Il, {
                                            onClose: () => Mn(null)
                                        })
                                    }
                                }), Pe(Ue, {
                                    get when() {
                                        return "transaction-canceled" === Nn().name
                                    },
                                    get children() {
                                        return Pe(Cl, {
                                            onClose: () => Mn(null)
                                        })
                                    }
                                }), Pe(Ue, {
                                    get when() {
                                        return "confirm-transaction" === Nn().name
                                    },
                                    get children() {
                                        return Pe(Sl, {
                                            onClose: () => Mn(null)
                                        })
                                    }
                                })]
                            }
                        })
                    }
                }), Ol = () => {
                    const {
                        locale: e
                    } = hi()[1];
                    Z(() => e(Oc.language)), Z(() => {
                        Pn() && Ms()
                    });
                    const t = ce(tr),
                        n = ce(Ds),
                        [r, o] = G(!1),
                        i = () => {
                            var e;
                            return "loading" === (null == (e = Oc.connectRequestParameters) ? void 0 : e.state)
                        },
                        s = X(() => {
                            var e;
                            if (!i()) return null == (e = Oc.connectRequestParameters) ? void 0 : e.value
                        }),
                        a = e => {
                            n.closeSingleWalletModal(e)
                        },
                        c = t.onStatusChange(e => {
                            e && a("wallet-selected")
                        });
                    return oe(c), oe(() => {
                        o(!1)
                    }), Pe(Cc, {
                        get opened() {
                            return Pn()
                        },
                        get enableAndroidBackHandler() {
                            return Oc.enableAndroidBackHandler
                        },
                        onClose: () => a("action-cancelled"),
                        onClickQuestion: () => o(e => !e),
                        "data-tc-wallets-modal-container": "true",
                        get children() {
                            return [Pe(Me, {
                                get when() {
                                    return r()
                                },
                                get children() {
                                    return Pe(Su, {
                                        onBackClick: () => o(!1)
                                    })
                                }
                            }), Pe(Me, {
                                get when() {
                                    return !r()
                                },
                                get children() {
                                    return [Pe(Me, {
                                        get when() {
                                            return i()
                                        },
                                        get children() {
                                            return [Pe(Ic, {
                                                translationKey: "walletModal.loading",
                                                children: "Wallets list is loading"
                                            }), Pe(Ac, {
                                                get children() {
                                                    return Pe(Fi, {
                                                        size: "m"
                                                    })
                                                }
                                            })]
                                        }
                                    }), Pe(Me, {
                                        get when() {
                                            return !i()
                                        },
                                        get children() {
                                            return Pe(Ct, {
                                                get component() {
                                                    return Ws() ? Mu : hu
                                                },
                                                get wallet() {
                                                    return Rn()
                                                },
                                                get additionalRequest() {
                                                    return s()
                                                },
                                                onBackClick: () => {},
                                                backDisabled: !0
                                            })
                                        }
                                    })]
                                }
                            })]
                        }
                    })
                }, xl = e => {
                    const t = li(Qn, Oc.language);
                    return dn(), ln(), Pe(di.Provider, {
                        value: t,
                        get children() {
                            return Pe(Ds.Provider, {
                                get value() {
                                    return e.tonConnectUI
                                },
                                get children() {
                                    return Pe(tr.Provider, {
                                        get value() {
                                            return Oc.connector
                                        },
                                        get children() {
                                            return [Pe(Vt, {}), Pe(Mt, {
                                                theme: Ar,
                                                get children() {
                                                    return [Pe(Me, {
                                                        get when() {
                                                            return Oc.buttonRootId
                                                        },
                                                        get children() {
                                                            return Pe(St, {
                                                                get mount() {
                                                                    return document.getElementById(Oc.buttonRootId)
                                                                },
                                                                get children() {
                                                                    return Pe(Sc, {})
                                                                }
                                                            })
                                                        }
                                                    }), Pe(Ct, {
                                                        component: Ht,
                                                        get children() {
                                                            return [Pe(gl, {}), Pe(Ol, {}), Pe(Al, {})]
                                                        }
                                                    })]
                                                }
                                            })]
                                        }
                                    })
                                }
                            })
                        }
                    })
                }, _l = {
                    openWalletsModal: () => {
                        setTimeout(() => xn({
                            status: "opened",
                            closeReason: null
                        }))
                    },
                    closeWalletsModal: e => {
                        setTimeout(() => xn({
                            status: "closed",
                            closeReason: e
                        }))
                    },
                    openSingleWalletModal: e => {
                        setTimeout(() => Tn({
                            status: "opened",
                            closeReason: null,
                            walletInfo: e
                        }))
                    },
                    closeSingleWalletModal: e => {
                        setTimeout(() => Tn({
                            status: "closed",
                            closeReason: e
                        }))
                    },
                    setAction: e => {
                        setTimeout(() => Mn(e))
                    },
                    clearAction: () => {
                        setTimeout(() => Mn(null))
                    },
                    getSelectedWalletInfo: () => Bn(),
                    removeSelectedWalletInfo: () => Wn(null),
                    renderApp: (e, t) => Ze(() => Pe(xl, {
                        tonConnectUI: t
                    }), document.getElementById(e))
                };
                class El {
                    constructor(e) {
                        x(this, "connector"), x(this, "setConnectRequestParametersCallback"), x(this, "consumers", []), x(this, "tracker"), x(this, "state", On()), this.connector = e.connector, this.tracker = e.tracker, this.setConnectRequestParametersCallback = e.setConnectRequestParametersCallback, Z(() => {
                            const e = On();
                            this.state = e, this.consumers.forEach(t => t(e))
                        })
                    }
                    open() {
                        return _(this, null, (function*() {
                            this.tracker.trackConnectionStarted();
                            const e = yield this.connector.getWallets(), t = e.find(d["isWalletInfoCurrentlyEmbedded"]);
                            return t ? this.connectEmbeddedWallet(t) : this.openWalletsModal()
                        }))
                    }
                    close(e = "action-cancelled") {
                        "action-cancelled" === e && this.tracker.trackConnectionError("Connection was cancelled"), _l.closeWalletsModal(e)
                    }
                    onStateChange(e) {
                        return this.consumers.push(e), () => {
                            this.consumers = this.consumers.filter(t => t !== e)
                        }
                    }
                    connectEmbeddedWallet(e) {
                        const t = t => {
                                Wn(e), this.connector.connect({
                                    jsBridgeKey: e.jsBridgeKey
                                }, t)
                            },
                            n = Oc.connectRequestParameters;
                        "loading" === (null == n ? void 0 : n.state) ? this.setConnectRequestParametersCallback(t): t(null == n ? void 0 : n.value)
                    }
                    openWalletsModal() {
                        return _(this, null, (function*() {
                            return Mr() && Kr(), _l.openWalletsModal(), new Promise(e => {
                                const t = this.onStateChange(n => {
                                    const {
                                        status: r
                                    } = n;
                                    "opened" === r && (t(), e())
                                })
                            })
                        }))
                    }
                }
                class Tl {
                    constructor(e) {
                        x(this, "connector"), x(this, "consumers", []), this.connector = e.connector, Z(() => {
                            const e = Nn();
                            this.consumers.forEach(t => t(e))
                        })
                    }
                    onStateChange(e) {
                        return this.consumers.push(e), () => {
                            this.consumers = this.consumers.filter(t => t !== e)
                        }
                    }
                }
                class Pl {
                    constructor(e) {
                        x(this, "connector"), x(this, "setConnectRequestParametersCallback"), x(this, "consumers", []), x(this, "tracker"), x(this, "state", En()), this.connector = e.connector, this.tracker = e.tracker, this.setConnectRequestParametersCallback = e.setConnectRequestParametersCallback, Z(() => {
                            const e = En();
                            this.state = e, this.consumers.forEach(t => t(e))
                        })
                    }
                    open(e) {
                        return _(this, null, (function*() {
                            this.tracker.trackConnectionStarted();
                            const t = yield this.connector.getWallets(), n = Pc(t, Oc.walletsListConfiguration), r = n.find(d["isWalletInfoCurrentlyEmbedded"]), o = !!r;
                            if (o) return this.connectEmbeddedWallet(r);
                            const i = n.filter(d["isWalletInfoRemote"]),
                                s = i.find(t => Lc(t, e)),
                                a = !!s;
                            if (a) return this.openSingleWalletModal(s);
                            const c = `Trying to open modal window with unknown wallet "${e}".`;
                            throw this.tracker.trackConnectionError(c), new Xt(c)
                        }))
                    }
                    close(e = "action-cancelled") {
                        "action-cancelled" === e && this.tracker.trackConnectionError("Connection was cancelled"), _l.closeSingleWalletModal("action-cancelled")
                    }
                    onStateChange(e) {
                        return this.consumers.push(e), () => {
                            this.consumers = this.consumers.filter(t => t !== e)
                        }
                    }
                    connectEmbeddedWallet(e) {
                        const t = t => {
                                Wn(e), this.connector.connect({
                                    jsBridgeKey: e.jsBridgeKey
                                }, t)
                            },
                            n = Oc.connectRequestParameters;
                        "loading" === (null == n ? void 0 : n.state) ? this.setConnectRequestParametersCallback(t): t(null == n ? void 0 : n.value)
                    }
                    openSingleWalletModal(e) {
                        return _(this, null, (function*() {
                            return Mr() && Kr(), _l.openSingleWalletModal(e), new Promise(e => {
                                const t = this.onStateChange(n => {
                                    const {
                                        status: r
                                    } = n;
                                    "opened" === r && (t(), e())
                                })
                            })
                        }))
                    }
                }
                class Rl {
                    constructor(e) {
                        var t;
                        x(this, "eventPrefix", "ton-connect-ui-"), x(this, "tonConnectUiVersion"), x(this, "tonConnectSdkVersion", null), x(this, "eventDispatcher"), this.eventDispatcher = null != (t = null == e ? void 0 : e.eventDispatcher) ? t : new d["BrowserEventDispatcher"], this.tonConnectUiVersion = e.tonConnectUiVersion, this.init().catch()
                    }
                    get version() {
                        return Object(d["createVersionInfo"])({
                            ton_connect_sdk_lib: this.tonConnectSdkVersion,
                            ton_connect_ui_lib: this.tonConnectUiVersion
                        })
                    }
                    init() {
                        return _(this, null, (function*() {
                            try {
                                yield this.setRequestVersionHandler(), this.tonConnectSdkVersion = yield this.requestTonConnectSdkVersion()
                            } catch (Ll) {}
                        }))
                    }
                    setRequestVersionHandler() {
                        return _(this, null, (function*() {
                            yield this.eventDispatcher.addEventListener("ton-connect-ui-request-version", () => _(this, null, (function*() {
                                yield this.eventDispatcher.dispatchEvent("ton-connect-ui-response-version", Object(d["createResponseVersionEvent"])(this.tonConnectUiVersion))
                            })))
                        }))
                    }
                    requestTonConnectSdkVersion() {
                        return _(this, null, (function*() {
                            return new Promise((e, t) => _(this, null, (function*() {
                                try {
                                    yield this.eventDispatcher.addEventListener("ton-connect-response-version", t => {
                                        e(t.detail.version)
                                    }, {
                                        once: !0
                                    }), yield this.eventDispatcher.dispatchEvent("ton-connect-request-version", Object(d["createRequestVersionEvent"])())
                                } catch (Ll) {
                                    t(Ll)
                                }
                            })))
                        }))
                    }
                    dispatchUserActionEvent(e) {
                        var t;
                        try {
                            null == (t = this.eventDispatcher) || t.dispatchEvent(`${this.eventPrefix}${e.type}`, e).catch()
                        } catch (Ll) {}
                    }
                    trackConnectionStarted(...e) {
                        try {
                            const t = Object(d["createConnectionStartedEvent"])(this.version, ...e);
                            this.dispatchUserActionEvent(t)
                        } catch (Ll) {}
                    }
                    trackConnectionCompleted(...e) {
                        try {
                            const t = Object(d["createConnectionCompletedEvent"])(this.version, ...e);
                            this.dispatchUserActionEvent(t)
                        } catch (Ll) {}
                    }
                    trackConnectionError(...e) {
                        try {
                            const t = Object(d["createConnectionErrorEvent"])(this.version, ...e);
                            this.dispatchUserActionEvent(t)
                        } catch (Ll) {}
                    }
                    trackConnectionRestoringStarted(...e) {
                        try {
                            const t = Object(d["createConnectionRestoringStartedEvent"])(this.version, ...e);
                            this.dispatchUserActionEvent(t)
                        } catch (Ll) {}
                    }
                    trackConnectionRestoringCompleted(...e) {
                        try {
                            const t = Object(d["createConnectionRestoringCompletedEvent"])(this.version, ...e);
                            this.dispatchUserActionEvent(t)
                        } catch (Ll) {}
                    }
                    trackConnectionRestoringError(...e) {
                        try {
                            const t = Object(d["createConnectionRestoringErrorEvent"])(this.version, ...e);
                            this.dispatchUserActionEvent(t)
                        } catch (Ll) {}
                    }
                    trackDisconnection(...e) {
                        try {
                            const t = Object(d["createDisconnectionEvent"])(this.version, ...e);
                            this.dispatchUserActionEvent(t)
                        } catch (Ll) {}
                    }
                    trackTransactionSentForSignature(...e) {
                        try {
                            const t = Object(d["createTransactionSentForSignatureEvent"])(this.version, ...e);
                            this.dispatchUserActionEvent(t)
                        } catch (Ll) {}
                    }
                    trackTransactionSigned(...e) {
                        try {
                            const t = Object(d["createTransactionSignedEvent"])(this.version, ...e);
                            this.dispatchUserActionEvent(t)
                        } catch (Ll) {}
                    }
                    trackTransactionSigningFailed(...e) {
                        try {
                            const t = Object(d["createTransactionSigningFailedEvent"])(this.version, ...e);
                            this.dispatchUserActionEvent(t)
                        } catch (Ll) {}
                    }
                }
                const jl = "2.0.5";
                class Bl {
                    constructor(e) {
                        if (x(this, "walletInfoStorage", new Cn), x(this, "preferredWalletStorage", new In), x(this, "tracker"), x(this, "walletInfo", null), x(this, "systemThemeChangeUnsubscribe", null), x(this, "actionsConfiguration"), x(this, "walletsList"), x(this, "connectRequestParametersCallback"), x(this, "connector"), x(this, "modal"), x(this, "singleWalletModal"), x(this, "transactionModal"), x(this, "connectionRestored", Promise.resolve(!1)), e && "connector" in e && e.connector) this.connector = e.connector;
                        else {
                            if (!(e && "manifestUrl" in e && e.manifestUrl)) throw new Xt("You have to specify a `manifestUrl` or a `connector` in the options.");
                            this.connector = new d["TonConnect"]({
                                manifestUrl: e.manifestUrl,
                                eventDispatcher: null == e ? void 0 : e.eventDispatcher
                            })
                        }
                        this.tracker = new Rl({
                            eventDispatcher: null == e ? void 0 : e.eventDispatcher,
                            tonConnectUiVersion: jl
                        }), this.modal = new El({
                            connector: this.connector,
                            tracker: this.tracker,
                            setConnectRequestParametersCallback: e => {
                                this.connectRequestParametersCallback = e
                            }
                        }), this.singleWalletModal = new Pl({
                            connector: this.connector,
                            tracker: this.tracker,
                            setConnectRequestParametersCallback: e => {
                                this.connectRequestParametersCallback = e
                            }
                        }), this.transactionModal = new Tl({
                            connector: this.connector
                        }), this.walletsList = this.getWallets(), this.walletsList.then(e => gn(_c(e.map(e => e.imageUrl))));
                        const t = this.normalizeWidgetRoot(null == e ? void 0 : e.widgetRootId);
                        this.subscribeToWalletChange(), !1 !== (null == e ? void 0 : e.restoreConnection) && (this.connectionRestored = pn(() => _(this, null, (function*() {
                            return this.tracker.trackConnectionRestoringStarted(), yield this.connector.restoreConnection(), this.connector.connected ? this.tracker.trackConnectionRestoringCompleted(this.wallet) : (this.tracker.trackConnectionRestoringError("Connection was not restored"), this.walletInfoStorage.removeWalletInfo()), this.connector.connected
                        })))), this.uiOptions = Ir(e, {
                            uiPreferences: {
                                theme: "SYSTEM"
                            }
                        });
                        const n = this.preferredWalletStorage.getPreferredWalletAppName();
                        xc({
                            connector: this.connector,
                            preferredWalletAppName: n
                        }), _l.renderApp(t, this)
                    }
                    static getWallets() {
                        return d["TonConnect"].getWallets()
                    }
                    get connected() {
                        return this.connector.connected
                    }
                    get account() {
                        return this.connector.account
                    }
                    get wallet() {
                        return this.connector.wallet ? A(A({}, this.connector.wallet), this.walletInfo) : null
                    }
                    set uiOptions(e) {
                        var t, n, r, o, i;
                        this.checkButtonRootExist(e.buttonRootId), this.actionsConfiguration = e.actionsConfiguration, (null == (t = e.uiPreferences) ? void 0 : t.theme) ? "SYSTEM" !== (null == (n = e.uiPreferences) ? void 0 : n.theme) ? (null == (r = this.systemThemeChangeUnsubscribe) || r.call(this), Er(e.uiPreferences.theme, e.uiPreferences.colorsSet)) : (Er(sn(), e.uiPreferences.colorsSet), this.systemThemeChangeUnsubscribe || (this.systemThemeChangeUnsubscribe = an(Er))) : (null == (o = e.uiPreferences) ? void 0 : o.colorsSet) && Pr(e.uiPreferences.colorsSet), (null == (i = e.uiPreferences) ? void 0 : i.borderRadius) && Tr(e.uiPreferences.borderRadius), xc(t => {
                            var n, r;
                            const o = Ir(A(A(A(A({}, e.language && {
                                language: e.language
                            }), !!(null == (n = e.actionsConfiguration) ? void 0 : n.returnStrategy) && {
                                returnStrategy: e.actionsConfiguration.returnStrategy
                            }), !!(null == (r = e.actionsConfiguration) ? void 0 : r.twaReturnUrl) && {
                                twaReturnUrl: e.actionsConfiguration.twaReturnUrl
                            }), !!e.walletsListConfiguration && {
                                walletsListConfiguration: e.walletsListConfiguration
                            }), ar(t));
                            return void 0 !== e.buttonRootId && (o.buttonRootId = e.buttonRootId), void 0 !== e.enableAndroidBackHandler && (o.enableAndroidBackHandler = e.enableAndroidBackHandler), o
                        })
                    }
                    setConnectRequestParameters(e) {
                        var t;
                        xc({
                            connectRequestParameters: e
                        }), "ready" !== (null == e ? void 0 : e.state) && e || null == (t = this.connectRequestParametersCallback) || t.call(this, null == e ? void 0 : e.value)
                    }
                    getWallets() {
                        return _(this, null, (function*() {
                            return this.connector.getWallets()
                        }))
                    }
                    onStatusChange(e, t) {
                        return this.connector.onStatusChange(t => _(this, null, (function*() {
                            if (t) {
                                const n = yield this.getSelectedWalletInfo(t);
                                e(A(A({}, t), n || this.walletInfoStorage.getWalletInfo()))
                            } else e(t)
                        })), t)
                    }
                    openModal() {
                        return _(this, null, (function*() {
                            return this.modal.open()
                        }))
                    }
                    closeModal(e) {
                        this.modal.close(e)
                    }
                    onModalStateChange(e) {
                        return this.modal.onStateChange(e)
                    }
                    get modalState() {
                        return this.modal.state
                    }
                    openSingleWalletModal(e) {
                        return _(this, null, (function*() {
                            return this.singleWalletModal.open(e)
                        }))
                    }
                    closeSingleWalletModal(e) {
                        this.singleWalletModal.close(e)
                    }
                    onSingleWalletModalStateChange(e) {
                        return this.singleWalletModal.onStateChange(e)
                    }
                    get singleWalletModalState() {
                        return this.singleWalletModal.state
                    }
                    connectWallet() {
                        return _(this, null, (function*() {
                            const e = yield this.getWallets(), t = e.find(d["isWalletInfoCurrentlyEmbedded"]);
                            return t ? yield this.connectEmbeddedWallet(t): yield this.connectExternalWallet()
                        }))
                    }
                    disconnect() {
                        return this.tracker.trackDisconnection(this.wallet, "dapp"), _l.clearAction(), _l.removeSelectedWalletInfo(), this.walletInfoStorage.removeWalletInfo(), this.connector.disconnect()
                    }
                    sendTransaction(e, t) {
                        return _(this, null, (function*() {
                            if (this.tracker.trackTransactionSentForSignature(this.wallet, e), !this.connected) throw this.tracker.trackTransactionSigningFailed(this.wallet, e, "Wallet was not connected"), new Xt("Connect wallet to send a transaction.");
                            Mr() && Kr();
                            const {
                                notifications: n,
                                modals: r,
                                returnStrategy: o,
                                twaReturnUrl: i,
                                skipRedirectToWallet: s
                            } = this.getModalsAndNotificationsConfiguration(t);
                            _l.setAction({
                                name: "confirm-transaction",
                                showNotification: n.includes("before"),
                                openModal: r.includes("before"),
                                sent: !1
                            });
                            const a = () => {
                                    c.signal.aborted || (_l.setAction({
                                        name: "confirm-transaction",
                                        showNotification: n.includes("before"),
                                        openModal: r.includes("before"),
                                        sent: !0
                                    }), this.walletInfo && "universalLink" in this.walletInfo && ("universal-link" === this.walletInfo.openMethod || "custom-deeplink" === this.walletInfo.openMethod) && (Object(d["isTelegramUrl"])(this.walletInfo.universalLink) ? au(this.walletInfo.universalLink, {
                                        returnStrategy: o,
                                        twaReturnUrl: i || Oc.twaReturnUrl,
                                        forceRedirect: !1
                                    }) : cu(this.walletInfo.universalLink, this.walletInfo.deepLink, {
                                        returnStrategy: o,
                                        forceRedirect: !1
                                    }, () => {})))
                                },
                                c = new AbortController,
                                u = this.onTransactionModalStateChange(e => {
                                    (null == e ? void 0 : e.openModal) || (u(), e || c.abort())
                                });
                            try {
                                const t = yield this.waitForSendTransaction({
                                    transaction: e,
                                    signal: c.signal
                                }, a);
                                return this.tracker.trackTransactionSigned(this.wallet, e, t), _l.setAction({
                                    name: "transaction-sent",
                                    showNotification: n.includes("success"),
                                    openModal: r.includes("success")
                                }), t
                            } catch (Ll) {
                                throw _l.setAction({
                                    name: "transaction-canceled",
                                    showNotification: n.includes("error"),
                                    openModal: r.includes("error")
                                }), Ll instanceof d["TonConnectError"] ? Ll : (console.error(Ll), new Xt("Unhandled error:" + Ll))
                            } finally {
                                u()
                            }
                        }))
                    }
                    connectEmbeddedWallet(e) {
                        return _(this, null, (function*() {
                            const t = t => {
                                    Wn(e), this.connector.connect({
                                        jsBridgeKey: e.jsBridgeKey
                                    }, t)
                                },
                                n = Oc.connectRequestParameters;
                            return "loading" === (null == n ? void 0 : n.state) ? this.connectRequestParametersCallback = t : t(null == n ? void 0 : n.value), yield this.waitForWalletConnection({
                                ignoreErrors: !1
                            })
                        }))
                    }
                    connectExternalWallet() {
                        return _(this, null, (function*() {
                            const e = new AbortController;
                            _l.openWalletsModal();
                            const t = this.onModalStateChange(n => {
                                const {
                                    status: r,
                                    closeReason: o
                                } = n;
                                "opened" !== r && (t(), "action-cancelled" === o && e.abort())
                            });
                            return yield this.waitForWalletConnection({
                                ignoreErrors: !0,
                                signal: e.signal
                            })
                        }))
                    }
                    waitForWalletConnection(e) {
                        return _(this, null, (function*() {
                            return new Promise((t, n) => {
                                this.tracker.trackConnectionStarted();
                                const {
                                    ignoreErrors: r = !1,
                                    signal: o = null
                                } = e;
                                if (o && o.aborted) return this.tracker.trackConnectionError("Connection was cancelled"), n(new Xt("Wallet was not connected"));
                                const i = e => _(this, null, (function*() {
                                        if (e) this.tracker.trackConnectionCompleted(e), a(), t(e);
                                        else {
                                            if (this.tracker.trackConnectionError("Connection was cancelled"), r) return;
                                            a(), n(new Xt("Wallet was not connected"))
                                        }
                                    })),
                                    s = e => {
                                        this.tracker.trackConnectionError(e.message), r || (a(), n(e))
                                    },
                                    a = this.onStatusChange(e => i(e), e => s(e));
                                o && o.addEventListener("abort", () => {
                                    a(), n(new Xt("Wallet was not connected"))
                                }, {
                                    once: !0
                                })
                            })
                        }))
                    }
                    waitForSendTransaction(e, t) {
                        return _(this, null, (function*() {
                            return new Promise((n, r) => {
                                const {
                                    transaction: o,
                                    signal: i
                                } = e;
                                if (i.aborted) return this.tracker.trackTransactionSigningFailed(this.wallet, o, "Transaction was cancelled"), r(new Xt("Transaction was not sent"));
                                const s = e => _(this, null, (function*() {
                                        n(e)
                                    })),
                                    a = e => {
                                        r(e)
                                    },
                                    c = () => {
                                        this.tracker.trackTransactionSigningFailed(this.wallet, o, "Transaction was cancelled"), r(new Xt("Transaction was not sent"))
                                    };
                                i.addEventListener("abort", c, {
                                    once: !0
                                }), this.connector.sendTransaction(o, {
                                    onRequestSent: t,
                                    signal: i
                                }).then(e => (i.removeEventListener("abort", c), s(e))).catch(e => (i.removeEventListener("abort", c), a(e)))
                            })
                        }))
                    }
                    onTransactionModalStateChange(e) {
                        return this.transactionModal.onStateChange(e)
                    }
                    subscribeToWalletChange() {
                        this.connector.onStatusChange(e => _(this, null, (function*() {
                            var t;
                            e ? (yield this.updateWalletInfo(e), this.setPreferredWalletAppName((null == (t = this.walletInfo) ? void 0 : t.appName) || e.device.appName)) : this.walletInfoStorage.removeWalletInfo()
                        })))
                    }
                    setPreferredWalletAppName(e) {
                        this.preferredWalletStorage.setPreferredWalletAppName(e), xc({
                            preferredWalletAppName: e
                        })
                    }
                    getSelectedWalletInfo(e) {
                        return _(this, null, (function*() {
                            let t, n = _l.getSelectedWalletInfo();
                            if (!n) return null;
                            if ("name" in n) t = n;
                            else {
                                const r = Pc(yield this.walletsList, Oc.walletsListConfiguration),
                                    o = r.find(t => Lc(t, e.device.appName));
                                if (!o) throw new Xt(`Cannot find WalletInfo for the '${e.device.appName}' wallet`);
                                t = A(A({}, o), n)
                            }
                            return t
                        }))
                    }
                    updateWalletInfo(e) {
                        return _(this, null, (function*() {
                            const t = yield this.getSelectedWalletInfo(e);
                            if (t) return this.walletInfo = t, void this.walletInfoStorage.setWalletInfo(t);
                            const n = this.walletInfoStorage.getWalletInfo();
                            this.walletInfo = n || ((yield this.walletsList).find(t => Lc(t, e.device.appName)) || null)
                        }))
                    }
                    normalizeWidgetRoot(e) {
                        if (!e || !document.getElementById(e)) {
                            e = "tc-widget-root";
                            const t = document.createElement("div");
                            t.id = e, document.body.appendChild(t)
                        }
                        return e
                    }
                    checkButtonRootExist(e) {
                        if (null != e && !document.getElementById(e)) throw new Xt(e + " element not found in the document.")
                    }
                    getModalsAndNotificationsConfiguration(e) {
                        var t, n, r, o, i, s;
                        const a = ["before", "success", "error"];
                        let c = a;
                        (null == (t = this.actionsConfiguration) ? void 0 : t.notifications) && "all" !== (null == (n = this.actionsConfiguration) ? void 0 : n.notifications) && (c = this.actionsConfiguration.notifications), (null == e ? void 0 : e.notifications) && (c = "all" === e.notifications ? a : e.notifications);
                        let u = ["before"];
                        (null == (r = this.actionsConfiguration) ? void 0 : r.modals) && (u = "all" === this.actionsConfiguration.modals ? a : this.actionsConfiguration.modals), (null == e ? void 0 : e.modals) && (u = "all" === e.modals ? a : e.modals);
                        const l = (null == e ? void 0 : e.returnStrategy) || (null == (o = this.actionsConfiguration) ? void 0 : o.returnStrategy) || "back",
                            d = (null == e ? void 0 : e.twaReturnUrl) || (null == (i = this.actionsConfiguration) ? void 0 : i.twaReturnUrl);
                        let h = (null == e ? void 0 : e.skipRedirectToWallet) || (null == (s = this.actionsConfiguration) ? void 0 : s.skipRedirectToWallet) || "ios";
                        return Mr() && (h = "never"), {
                            notifications: c,
                            modals: u,
                            returnStrategy: l,
                            twaReturnUrl: d,
                            skipRedirectToWallet: h
                        }
                    }
                }
            }).call(this, n("4362"))
        },
        c4fe: function(e, t, n) {
            "use strict";
            (function(e) {
                n.d(t, "a", (function() {
                    return l
                })), n.d(t, "b", (function() {
                    return d
                })), n.d(t, "c", (function() {
                    return h
                })), n.d(t, "d", (function() {
                    return p
                }));
                var r = n("8df2"),
                    o = n("1c54"),
                    i = n("0276"),
                    s = n("4ae8"),
                    a = n("a15d"),
                    c = n("0609"),
                    u = n("5762");
                const l = Object(r["struct"])([Object(r["u8"])("instruction"), Object(o["u64"])("amount")]);

                function d(t, n, r, o, a = [], d = s["c"]) {
                    const h = Object(c["a"])([{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: n,
                            isSigner: !1,
                            isWritable: !0
                        }], r, a),
                        p = e.alloc(l.span);
                    return l.encode({
                        instruction: u["a"].Burn,
                        amount: BigInt(o)
                    }, p), new i["TransactionInstruction"]({
                        keys: h,
                        programId: d,
                        data: p
                    })
                }

                function h(e, t = s["c"]) {
                    if (!e.programId.equals(t)) throw new a["g"];
                    if (e.data.length !== l.span) throw new a["e"];
                    const {
                        keys: {
                            account: n,
                            mint: r,
                            owner: o,
                            multiSigners: i
                        },
                        data: c
                    } = p(e);
                    if (c.instruction !== u["a"].Burn) throw new a["h"];
                    if (!n || !r || !o) throw new a["f"];
                    return {
                        programId: t,
                        keys: {
                            account: n,
                            mint: r,
                            owner: o,
                            multiSigners: i
                        },
                        data: c
                    }
                }

                function p({
                    programId: e,
                    keys: [t, n, r, ...o],
                    data: i
                }) {
                    return {
                        programId: e,
                        keys: {
                            account: t,
                            mint: n,
                            owner: r,
                            multiSigners: o
                        },
                        data: l.decode(i)
                    }
                }
            }).call(this, n("b639").Buffer)
        },
        ce55: function(e, t, n) {
            "use strict";
            (function(e) {
                n.d(t, "a", (function() {
                    return l
                })), n.d(t, "b", (function() {
                    return d
                })), n.d(t, "c", (function() {
                    return h
                })), n.d(t, "d", (function() {
                    return p
                }));
                var r = n("8df2"),
                    o = n("1c54"),
                    i = n("0276"),
                    s = n("4ae8"),
                    a = n("a15d"),
                    c = n("0609"),
                    u = n("5762");
                const l = Object(r["struct"])([Object(r["u8"])("instruction"), Object(o["u64"])("amount"), Object(r["u8"])("decimals")]);

                function d(t, n, r, o, a, d = [], h = s["c"]) {
                    const p = Object(c["a"])([{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: n,
                            isSigner: !1,
                            isWritable: !0
                        }], r, d),
                        g = e.alloc(l.span);
                    return l.encode({
                        instruction: u["a"].BurnChecked,
                        amount: BigInt(o),
                        decimals: a
                    }, g), new i["TransactionInstruction"]({
                        keys: p,
                        programId: h,
                        data: g
                    })
                }

                function h(e, t = s["c"]) {
                    if (!e.programId.equals(t)) throw new a["g"];
                    if (e.data.length !== l.span) throw new a["e"];
                    const {
                        keys: {
                            account: n,
                            mint: r,
                            owner: o,
                            multiSigners: i
                        },
                        data: c
                    } = p(e);
                    if (c.instruction !== u["a"].BurnChecked) throw new a["h"];
                    if (!n || !r || !o) throw new a["f"];
                    return {
                        programId: t,
                        keys: {
                            account: n,
                            mint: r,
                            owner: o,
                            multiSigners: i
                        },
                        data: c
                    }
                }

                function p({
                    programId: e,
                    keys: [t, n, r, ...o],
                    data: i
                }) {
                    return {
                        programId: e,
                        keys: {
                            account: t,
                            mint: n,
                            owner: r,
                            multiSigners: o
                        },
                        data: l.decode(i)
                    }
                }
            }).call(this, n("b639").Buffer)
        },
        d845: function(e, t, n) {
            "use strict";
            var r = function(e) {
                return o(e) && !i(e)
            };

            function o(e) {
                return !!e && "object" === typeof e
            }

            function i(e) {
                var t = Object.prototype.toString.call(e);
                return "[object RegExp]" === t || "[object Date]" === t || c(e)
            }
            var s = "function" === typeof Symbol && Symbol.for,
                a = s ? Symbol.for("react.element") : 60103;

            function c(e) {
                return e.$$typeof === a
            }

            function u(e) {
                return Array.isArray(e) ? [] : {}
            }

            function l(e, t) {
                return !1 !== t.clone && t.isMergeableObject(e) ? m(u(e), e, t) : e
            }

            function d(e, t, n) {
                return e.concat(t).map((function(e) {
                    return l(e, n)
                }))
            }

            function h(e, t) {
                if (!t.customMerge) return m;
                var n = t.customMerge(e);
                return "function" === typeof n ? n : m
            }

            function p(e) {
                return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(e).filter((function(t) {
                    return Object.propertyIsEnumerable.call(e, t)
                })) : []
            }

            function g(e) {
                return Object.keys(e).concat(p(e))
            }

            function f(e, t) {
                try {
                    return t in e
                } catch (n) {
                    return !1
                }
            }

            function b(e, t) {
                return f(e, t) && !(Object.hasOwnProperty.call(e, t) && Object.propertyIsEnumerable.call(e, t))
            }

            function y(e, t, n) {
                var r = {};
                return n.isMergeableObject(e) && g(e).forEach((function(t) {
                    r[t] = l(e[t], n)
                })), g(t).forEach((function(o) {
                    b(e, o) || (f(e, o) && n.isMergeableObject(t[o]) ? r[o] = h(o, n)(e[o], t[o], n) : r[o] = l(t[o], n))
                })), r
            }

            function m(e, t, n) {
                n = n || {}, n.arrayMerge = n.arrayMerge || d, n.isMergeableObject = n.isMergeableObject || r, n.cloneUnlessOtherwiseSpecified = l;
                var o = Array.isArray(t),
                    i = Array.isArray(e),
                    s = o === i;
                return s ? o ? n.arrayMerge(e, t, n) : y(e, t, n) : l(t, n)
            }
            m.all = function(e, t) {
                if (!Array.isArray(e)) throw new Error("first argument should be an array");
                return e.reduce((function(e, n) {
                    return m(e, n, t)
                }), {})
            };
            var w = m;
            e.exports = w
        },
        e093: function(e, t, n) {
            "use strict";
            (function(e) {
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.u256be = t.u256 = t.u192be = t.u192 = t.u128be = t.u128 = t.u64be = t.u64 = t.bigIntBE = t.bigInt = void 0;
                const r = n("8df2"),
                    o = n("9ea2"),
                    i = n("ee73"),
                    s = t => n => {
                        const s = (0, r.blob)(t, n),
                            {
                                encode: a,
                                decode: c
                            } = (0, i.encodeDecode)(s),
                            u = s;
                        return u.decode = (t, n) => {
                            const r = c(t, n);
                            return (0, o.toBigIntLE)(e.from(r))
                        }, u.encode = (e, n, r) => {
                            const i = (0, o.toBufferLE)(e, t);
                            return a(i, n, r)
                        }, u
                    };
                t.bigInt = s;
                const a = t => n => {
                    const s = (0, r.blob)(t, n),
                        {
                            encode: a,
                            decode: c
                        } = (0, i.encodeDecode)(s),
                        u = s;
                    return u.decode = (t, n) => {
                        const r = c(t, n);
                        return (0, o.toBigIntBE)(e.from(r))
                    }, u.encode = (e, n, r) => {
                        const i = (0, o.toBufferBE)(e, t);
                        return a(i, n, r)
                    }, u
                };
                t.bigIntBE = a, t.u64 = (0, t.bigInt)(8), t.u64be = (0, t.bigIntBE)(8), t.u128 = (0, t.bigInt)(16), t.u128be = (0, t.bigIntBE)(16), t.u192 = (0, t.bigInt)(24), t.u192be = (0, t.bigIntBE)(24), t.u256 = (0, t.bigInt)(32), t.u256be = (0, t.bigIntBE)(32)
            }).call(this, n("b639").Buffer)
        },
        e4cc: function(e, t) {},
        ee73: function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.encodeDecode = void 0;
            const r = e => {
                const t = e.decode.bind(e),
                    n = e.encode.bind(e);
                return {
                    decode: t,
                    encode: n
                }
            };
            t.encodeDecode = r
        },
        f0f6: function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.sha384 = t.sha512_256 = t.sha512_224 = t.sha512 = t.SHA512 = void 0;
            const r = n("9d51"),
                o = n("6b27"),
                i = n("1700"),
                [s, a] = (() => o.default.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(e => BigInt(e))))(),
                c = new Uint32Array(80),
                u = new Uint32Array(80);
            class l extends r.HashMD {
                constructor() {
                    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209
                }
                get() {
                    const {
                        Ah: e,
                        Al: t,
                        Bh: n,
                        Bl: r,
                        Ch: o,
                        Cl: i,
                        Dh: s,
                        Dl: a,
                        Eh: c,
                        El: u,
                        Fh: l,
                        Fl: d,
                        Gh: h,
                        Gl: p,
                        Hh: g,
                        Hl: f
                    } = this;
                    return [e, t, n, r, o, i, s, a, c, u, l, d, h, p, g, f]
                }
                set(e, t, n, r, o, i, s, a, c, u, l, d, h, p, g, f) {
                    this.Ah = 0 | e, this.Al = 0 | t, this.Bh = 0 | n, this.Bl = 0 | r, this.Ch = 0 | o, this.Cl = 0 | i, this.Dh = 0 | s, this.Dl = 0 | a, this.Eh = 0 | c, this.El = 0 | u, this.Fh = 0 | l, this.Fl = 0 | d, this.Gh = 0 | h, this.Gl = 0 | p, this.Hh = 0 | g, this.Hl = 0 | f
                }
                process(e, t) {
                    for (let o = 0; o < 16; o++, t += 4) c[o] = e.getUint32(t), u[o] = e.getUint32(t += 4);
                    for (let s = 16; s < 80; s++) {
                        const e = 0 | c[s - 15],
                            t = 0 | u[s - 15],
                            n = o.default.rotrSH(e, t, 1) ^ o.default.rotrSH(e, t, 8) ^ o.default.shrSH(e, t, 7),
                            r = o.default.rotrSL(e, t, 1) ^ o.default.rotrSL(e, t, 8) ^ o.default.shrSL(e, t, 7),
                            i = 0 | c[s - 2],
                            a = 0 | u[s - 2],
                            l = o.default.rotrSH(i, a, 19) ^ o.default.rotrBH(i, a, 61) ^ o.default.shrSH(i, a, 6),
                            d = o.default.rotrSL(i, a, 19) ^ o.default.rotrBL(i, a, 61) ^ o.default.shrSL(i, a, 6),
                            h = o.default.add4L(r, d, u[s - 7], u[s - 16]),
                            p = o.default.add4H(h, n, l, c[s - 7], c[s - 16]);
                        c[s] = 0 | p, u[s] = 0 | h
                    }
                    let {
                        Ah: n,
                        Al: r,
                        Bh: i,
                        Bl: l,
                        Ch: d,
                        Cl: h,
                        Dh: p,
                        Dl: g,
                        Eh: f,
                        El: b,
                        Fh: y,
                        Fl: m,
                        Gh: w,
                        Gl: k,
                        Hh: v,
                        Hl: S
                    } = this;
                    for (let C = 0; C < 80; C++) {
                        const e = o.default.rotrSH(f, b, 14) ^ o.default.rotrSH(f, b, 18) ^ o.default.rotrBH(f, b, 41),
                            t = o.default.rotrSL(f, b, 14) ^ o.default.rotrSL(f, b, 18) ^ o.default.rotrBL(f, b, 41),
                            I = f & y ^ ~f & w,
                            A = b & m ^ ~b & k,
                            O = o.default.add5L(S, t, A, a[C], u[C]),
                            x = o.default.add5H(O, v, e, I, s[C], c[C]),
                            _ = 0 | O,
                            E = o.default.rotrSH(n, r, 28) ^ o.default.rotrBH(n, r, 34) ^ o.default.rotrBH(n, r, 39),
                            T = o.default.rotrSL(n, r, 28) ^ o.default.rotrBL(n, r, 34) ^ o.default.rotrBL(n, r, 39),
                            P = n & i ^ n & d ^ i & d,
                            R = r & l ^ r & h ^ l & h;
                        v = 0 | w, S = 0 | k, w = 0 | y, k = 0 | m, y = 0 | f, m = 0 | b, ({
                            h: f,
                            l: b
                        } = o.default.add(0 | p, 0 | g, 0 | x, 0 | _)), p = 0 | d, g = 0 | h, d = 0 | i, h = 0 | l, i = 0 | n, l = 0 | r;
                        const j = o.default.add3L(_, T, R);
                        n = o.default.add3H(j, x, E, P), r = 0 | j
                    }({
                        h: n,
                        l: r
                    } = o.default.add(0 | this.Ah, 0 | this.Al, 0 | n, 0 | r)), ({
                        h: i,
                        l: l
                    } = o.default.add(0 | this.Bh, 0 | this.Bl, 0 | i, 0 | l)), ({
                        h: d,
                        l: h
                    } = o.default.add(0 | this.Ch, 0 | this.Cl, 0 | d, 0 | h)), ({
                        h: p,
                        l: g
                    } = o.default.add(0 | this.Dh, 0 | this.Dl, 0 | p, 0 | g)), ({
                        h: f,
                        l: b
                    } = o.default.add(0 | this.Eh, 0 | this.El, 0 | f, 0 | b)), ({
                        h: y,
                        l: m
                    } = o.default.add(0 | this.Fh, 0 | this.Fl, 0 | y, 0 | m)), ({
                        h: w,
                        l: k
                    } = o.default.add(0 | this.Gh, 0 | this.Gl, 0 | w, 0 | k)), ({
                        h: v,
                        l: S
                    } = o.default.add(0 | this.Hh, 0 | this.Hl, 0 | v, 0 | S)), this.set(n, r, i, l, d, h, p, g, f, b, y, m, w, k, v, S)
                }
                roundClean() {
                    c.fill(0), u.fill(0)
                }
                destroy() {
                    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
                }
            }
            t.SHA512 = l;
            class d extends l {
                constructor() {
                    super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28
                }
            }
            class h extends l {
                constructor() {
                    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32
                }
            }
            class p extends l {
                constructor() {
                    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48
                }
            }
            t.sha512 = (0, i.wrapConstructor)(() => new l), t.sha512_224 = (0, i.wrapConstructor)(() => new d), t.sha512_256 = (0, i.wrapConstructor)(() => new h), t.sha384 = (0, i.wrapConstructor)(() => new p)
        },
        f632: function(e, t) {}
    }
]);